(function(ns){
// Enqueue class
var enqueue = function(fn) {
	var queue = [], locked = 1, working = 0, fn = fn,
		instance = function(){
			queue.push([this, arguments]);
			if (!locked) instance.execute();
		};
		instance.execute = function(){
			if (working) return;
			working = 1; locked = 0;
			var q; while(q = queue.shift()) { fn.apply(q[0], q[1]) };
			working = 0;
		};
		instance.lock = function(){
			locked = 0;
		};
	return instance;
};

// Private variables
var $, options, components = {}, initialized = 0, installers = [];

var self = window[ns] = {

	setup: function(o) {
		options = o; // Keep a copy of the options
		self.init(); // Try to initialize.
	},

	jquery: function(jquery) {
		if ($) return; // If jquery is already available, stop.
		$ = jquery; // Set self.$ to jquery object
		self.init(); // Try to initialize.
	},

	init: function() {
		if (initialized) {
			return; // If initialized, stop.
		}

		if ($ && options) { // If options & jquery is available,
			self.$ = $.initialize(options); // Initialize jquery
			self.plugin.execute(); // Execute any pending plugins
			initialized = 1;
		}
	},

	plugin: enqueue(function(name, factory) {
		factory.apply(self, [$]);
	}),

	module: enqueue(function(name, factory) {
		$.module(name, factory);
	}),

	installer: function(recipient, name, factory) {
		if (!installers[recipient]) installers[recipient] = []; // Create package array if this is the first time
		if (!name) return installers[recipient];
		var component = components[recipient]; // Get component
		if (component.registered) return component.install(name, factory); // If component exist, install straight away
		installers[recipient].push([name, factory]); // Keep the package to install later
	},

	component: function(name, options) {

		// Getter
		if (!name) {
			return components; // return list of components
		}

		if (!options) {
			return components[name]; // return component
		}

		// Registering
		if (typeof options === "function") {
			var component = options;
			component.registered = true;
			return components[name] = component;
		}

		// Setter
		var queue = [];

		var abstractQueue = function(method, context, args) {
			return {method: method, context: this, args: args};
		};

		var abstractMethod = function(method, parent, chain) {
			return function(){
				(chain || queue).push(abstractQueue(method, this, arguments));
				return parent;
			};
		};

		var abstractInstance = function(instance, methods, chain) {
			var i = 0;
			for (; i < methods.length; i++) {
				var method = methods[i];
				instance[method] = abstractMethod(method, instance, chain);
			};
			return instance;
		};

		var abstractChain = function(name, methods) {
			return function(){
				var chain = [abstractQueue(name, this, arguments)];
					queue.push(chain);
				return abstractInstance({}, methods, chain);
			};
		};

		queue.execute = function(){
			var component = components[name], i = 0;
			for (; i < queue.length; i++) {
				var fn = queue[i];
				if (Object.prototype.toString.call(fn)==='[object Array]') {
					var chain = fn, context = component, j = 0;
					for (; j < chain.length; j++) {
						context = context[chain[j].method].apply(context, chain[j].args);
					}
				} else {
					component[fn.method].apply(component, fn.args)
				}
			}
		};

		// Create abstract component
		var component = abstractInstance(
				function(){component.run.apply(this.arguments)},
				["run","ready","template","dialog"]
			);

			// Set reference to options & queue
			component.className = name;
			component.options = options;
			component.queue = queue;

			// Create abstract module method
			component.module = abstractChain(
				"module",
				["done","always","fail","progress"]
			);

			// Create abstract require method
			component.require = abstractChain(
				"require",
				["library","script","stylesheet","language","template","app","view","done","always","fail","progress"]
			);

		// Register component in global namespace
		window[name] = components[name] = component;

		if (initialized) {
			$.Component.register(component);
		}

		return component;
	}
};

})("FD40");

// Setup foundry
FD40.setup({
	"environment": window.es.environment,
	"source": "local",
	"mode": window.es.environment == "production" ? "compressed" : "uncompressed",
	"path": window.es.rootUrl + "/media/com_easysocial/scripts/vendors",
	"cdn": "",
	"extension":".js",
	"cdnPath": "",
	"rootPath": window.es.rootUrl,
	"basePath": window.es.rootUrl,
	"indexUrl": window.es.rootUrl + '/index.php',
	"token": window.es.token,
	"joomla":{
		"appendTitle": window.es.appendTitle,
		"sitename": window.es.siteName
	},
	"locale":{
		"lang": window.es.locale
	}
});

FD40.component("EasySocial", {
	"environment": window.es.environment,
	"source":"local",
	"mode": window.es.environment == "production" ? "compressed" : "uncompressed",
	"mode": "compressed",
	"baseUrl": window.es.baseUrl,
	"version":"2.0",
	"momentLang": window.es.momentLang,
	"ajaxUrl": window.es.ajaxUrl
});

!function(a){var x,b=" ",c="width",d="height",e="replace",f="classList",g="className",h="parentNode",i="fit-width",j="fit-height",k="fit-both",l="fit-small",m=i+b+j+b+k+b+l,n=function(a,b){return a.getAttribute("data-"+b)},o=function(a,b){return a["natural"+b[0].toUpperCase()+b.slice(1)]},p=function(a,b){return parseInt(n(a,b)||o(a,b)||a[b])},q=function(a,c){a[f]?a[f].add(c):a[g]+=b+c},r=function(a,c){a[g]=a[g][e](new RegExp("\\b("+c[e](/\s+/g,"|")+")\\b","g"),b)[e](/\s+/g,b)[e](/^\s+|\s+$/g,"")},s=function(a,b,c){a.style[b]=c+"px"},u=function(a,b,e,f,g,t,v,x,y,z){return!n(a,c)&&0===o(a,c)&&(a._retry||(a._retry=0))<=25?setTimeout(function(){a._retry++,u(a)},200):(b=a[h],e=b[h],f=e[h],g=n(b,"mode"),t=n(b,"threshold"),v=p(a,c),x=p(a,d),y=b.offsetWidth,z=b.offsetHeight,r(f,m),q(f,t>v&&t>x?function(){return s(a,c,v),s(a,d,x),l}():"cover"==g?function(b,c,d){return 1>y||1>z?(w.push(a),k):(b=y/z,c=y/v,d=z/x,1>b?z>x*c?j:i:b>1?y>v*d?i:j:1==b?1>=v/x?i:j:void 0)}():function(){return w.push(a),a.style.maxHeight="none",s(a,"maxHeight",b.offsetHeight),k}()),a.removeAttribute("onload"),void 0)},v=function(a,b){for(b=w,w=[];a=b.shift();)a[h]&&u(a)},w=[],y=function(){clearTimeout(x),x=setTimeout(v,500)},z=a.ESImageList||[];for(a.ESImage=u,a.ESImageRefresh=v,a.addEventListener?a.addEventListener("resize",y,!1):a.attachEvent("resize",y);z.length;)u(z.shift())}(window);

jQuery.version = "4.0";
jQuery.long_version = "4.0.37";


// duplicate from media/com_easydiscuss/scripts/vendors/edjquery.js
var support = {};
(function() {
    // Minified: var b,c,d,e,f,g, h,i
    var div, style, a, pixelPositionVal, boxSizingReliableVal,
        reliableHiddenOffsetsVal, reliableMarginRightVal;

    // Setup
    div = document.createElement( "div" );
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName( "a" )[ 0 ];
    style = a && a.style;

    // Finish early in limited (non-browser) environments
    if ( !style ) {
        return;
    }

    style.cssText = "float:left;opacity:.5";

    // Support: IE<9
    // Make sure that element opacity exists (as opposed to filter)
    support.opacity = style.opacity === "0.5";

    // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)
    support.cssFloat = !!style.cssFloat;

    div.style.backgroundClip = "content-box";
    div.cloneNode( true ).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";

    // Support: Firefox<29, Android 2.3
    // Vendor-prefix box-sizing
    support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" ||
        style.WebkitBoxSizing === "";

    jQuery.extend(support, {
        reliableHiddenOffsets: function() {
            if ( reliableHiddenOffsetsVal == null ) {
                computeStyleTests();
            }
            return reliableHiddenOffsetsVal;
        },

        boxSizingReliable: function() {
            if ( boxSizingReliableVal == null ) {
                computeStyleTests();
            }
            return boxSizingReliableVal;
        },

        pixelPosition: function() {
            if ( pixelPositionVal == null ) {
                computeStyleTests();
            }
            return pixelPositionVal;
        },

        // Support: Android 2.3
        reliableMarginRight: function() {
            if ( reliableMarginRightVal == null ) {
                computeStyleTests();
            }
            return reliableMarginRightVal;
        }
    });

    function computeStyleTests() {
        // Minified: var b,c,d,j
        var div, body, container, contents;

        body = document.getElementsByTagName( "body" )[ 0 ];
        if ( !body || !body.style ) {
            // Test fired too early or in an unsupported environment, exit.
            return;
        }

        // Setup
        div = document.createElement( "div" );
        container = document.createElement( "div" );
        container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
        body.appendChild( container ).appendChild( div );

        div.style.cssText =
            // Support: Firefox<29, Android 2.3
            // Vendor-prefix box-sizing
            "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
            "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
            "border:1px;padding:1px;width:4px;position:absolute";

        // Support: IE<9
        // Assume reasonable values in the absence of getComputedStyle
        pixelPositionVal = boxSizingReliableVal = false;
        reliableMarginRightVal = true;

        // Check for getComputedStyle so that this code is not run in IE<9.
        if ( window.getComputedStyle ) {
            pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
            boxSizingReliableVal =
                ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

            // Support: Android 2.3
            // Div with explicit width and no margin-right incorrectly
            // gets computed margin-right based on width of container (#3333)
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            contents = div.appendChild( document.createElement( "div" ) );

            // Reset CSS: box-sizing; display; margin; border; padding
            contents.style.cssText = div.style.cssText =
                // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
            contents.style.marginRight = contents.style.width = "0";
            div.style.width = "1px";

            reliableMarginRightVal =
                !parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );

            div.removeChild( contents );
        }

        // Support: IE8
        // Check if table cells still have offsetWidth/Height when they are set
        // to display:none and there are still other visible table cells in a
        // table row; if so, offsetWidth/Height are not reliable for use when
        // determining if an element has been hidden directly using
        // display:none (it is still safe to use offsets if a parent element is
        // hidden; don safety goggles and see bug #4512 for more information).
        div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
        contents = div.getElementsByTagName( "td" );
        contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
        reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
        if ( reliableHiddenOffsetsVal ) {
            contents[ 0 ].style.display = "";
            contents[ 1 ].style.display = "none";
            reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
        }

        body.removeChild( container );
    }

})();

// duplicate variables from media/com_easydiscuss/scripts/vendors/edjquery.js
var strundefined = typeof undefined;
var rcheckableType = (/^(?:checkbox|radio)$/i);
var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video";
var rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g;
var rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i");
var rleadingWhitespace = /^\s+/;
var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
var rtagName = /<([\w:]+)/;
var rtbody = /<tbody/i;
var rhtml = /<|&#?\w+;/;
var rnoInnerhtml = /<(?:script|style|link)/i;
var rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i;
var rscriptType = /^$|\/(?:java|ecma)script/i;
var rscriptTypeMasked = /^true\/(.*)/;
var rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
// We have to close these tags to support XHTML (#13200)
var wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

        // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
        // unless wrapped in a div with non-breaking characters in front of it.
        _default: [ 0, "", "" ]
    };
var safeFragment = createSafeFragment( document );
var fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


// duplicate createSafeFragment from media/com_easydiscuss/scripts/vendors/edjquery.js
function createSafeFragment( document ) {
    var list = nodeNames.split( "|" ),
        safeFrag = document.createDocumentFragment();

    if ( safeFrag.createElement ) {
        while ( list.length ) {
            safeFrag.createElement(
                list.pop()
            );
        }
    }
    return safeFrag;
};

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
    if ( rcheckableType.test( elem.type ) ) {
        elem.defaultChecked = elem.checked;
    }
}

// duplicate getAll from media/com_easydiscuss/scripts/vendors/edjquery.js
function getAll( context, tag ) {
    var elems, elem,
        i = 0,
        found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
            typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
            undefined;

    if ( !found ) {
        for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
            if ( !tag || jQuery.nodeName( elem, tag ) ) {
                found.push( elem );
            } else {
                jQuery.merge( found, getAll( elem, tag ) );
            }
        }
    }

    return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
        jQuery.merge( [ context ], found ) :
        found;
};

// duplicate setGlobalEval from media/com_easydiscuss/scripts/vendors/edjquery.js
function setGlobalEval( elems, refElements ) {
    var elem,
        i = 0;
    for ( ; (elem = elems[i]) != null; i++ ) {
        jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
    }
};


jQuery.uid = function(p,s) {
	return ((p) ? p : "") + Math.random().toString().replace(".","") + ((s) ? s : "");
};

jQuery.globalNamespace = jQuery.uid("Komento");

window[jQuery.globalNamespace] = jQuery;

jQuery.run = function(command) {
	return (jQuery.isFunction(command)) ? command(jQuery) : null;
};

jQuery.initialize = function(options) {
	if (jQuery.initialized) {
		return;
	}

    // duplicate buildFragment from media/com_easydiscuss/scripts/vendors/edjquery.js
    jQuery.buildFragment = function( elems, context, scripts, selection ) {
        var j, elem, contains,
            tmp, tag, tbody, wrap,
            l = elems.length,

            // Ensure a safe fragment
            safe = createSafeFragment( context ),

            nodes = [],
            i = 0;

        for ( ; i < l; i++ ) {
            elem = elems[ i ];

            if ( elem || elem === 0 ) {

                // Add nodes directly
                if ( jQuery.type( elem ) === "object" ) {
                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                // Convert non-html into a text node
                } else if ( !rhtml.test( elem ) ) {
                    nodes.push( context.createTextNode( elem ) );

                // Convert html into DOM nodes
                } else {
                    tmp = tmp || safe.appendChild( context.createElement("div") );

                    // Deserialize a standard representation
                    tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
                    wrap = wrapMap[ tag ] || wrapMap._default;

                    tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while ( j-- ) {
                        tmp = tmp.lastChild;
                    }

                    // Manually add leading whitespace removed by IE
                    if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                        nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
                    }

                    // Remove IE's autoinserted <tbody> from table fragments
                    if ( !support.tbody ) {

                        // String was a <table>, *may* have spurious <tbody>
                        elem = tag === "table" && !rtbody.test( elem ) ?
                            tmp.firstChild :

                            // String was a bare <thead> or <tfoot>
                            wrap[1] === "<table>" && !rtbody.test( elem ) ?
                                tmp :
                                0;

                        j = elem && elem.childNodes.length;
                        while ( j-- ) {
                            if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
                                elem.removeChild( tbody );
                            }
                        }
                    }

                    jQuery.merge( nodes, tmp.childNodes );

                    // Fix #12392 for WebKit and IE > 9
                    tmp.textContent = "";

                    // Fix #12392 for oldIE
                    while ( tmp.firstChild ) {
                        tmp.removeChild( tmp.firstChild );
                    }

                    // Remember the top-level container for proper cleanup
                    tmp = safe.lastChild;
                }
            }
        }

        // Fix #11356: Clear elements from fragment
        if ( tmp ) {
            safe.removeChild( tmp );
        }

        // Reset defaultChecked for any radios and checkboxes
        // about to be appended to the DOM in IE 6/7 (#8060)
        if ( !support.appendChecked ) {
            jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
        }

        i = 0;
        while ( (elem = nodes[ i++ ]) ) {

            // #4087 - If origin and destination elements are the same, and this is
            // that element, do not do anything
            if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
                continue;
            }

            contains = jQuery.contains( elem.ownerDocument, elem );

            // Append to fragment
            tmp = getAll( safe.appendChild( elem ), "script" );

            // Preserve script evaluation history
            if ( contains ) {
                setGlobalEval( tmp );
            }

            // Capture executables
            if ( scripts ) {
                j = 0;
                while ( (elem = tmp[ j++ ]) ) {
                    if ( rscriptType.test( elem.type || "" ) ) {
                        scripts.push( elem );
                    }
                }
            }
        }

        tmp = null;

        return safe;
    };

	jQuery.extend(jQuery, options);

	if (jQuery.environment=="development") {
		window.F = jQuery;
	}

	jQuery.initialized = true;

	// Execute any pending modules
	FD40.module.execute();
}

// Register jquery into bootloader
FD40.jquery(jQuery);

// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.
if (typeof define === "function" && define.amd) {
	define("jquery", [], function() {
		return jQuery;
	});
}FD40.plugin("lodash", function($) {

/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      // hack: Add ability to reset memoized values
      memoized.reset = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        if (hasOwnProperty.call(cache, key)) {
          delete cache[key];
        }
      }
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = $._ = runInContext();

  // expose Lo-Dash methods to jQuery
  $.each(_, function(prop, func){
    if (!Object.hasOwnProperty.call(_, prop) || /VERSION/.test(name)) return;
    if (!$[prop]) $[prop] = func;
  });

});FD40.plugin("bootstrap3", function($) {

var jQuery = $;
/*!
 * Bootstrap v3.0.3 (http://getbootstrap.com)
 * Copyright 2015 Twitter, Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0s
 */

// if (window["Foundry/Bootstrap"]) { return } else { window["Foundry/Bootstrap"] = { version: "3.0.3", foundry: jQuery } }

// Since ES require this version of modified bootstrap the most, we must allow ES bootstrap to always loaded. #2606
if (window["Foundry/Bootstrap"] == undefined) {
  window["Foundry/Bootstrap"] = { version: "3.0.3", foundry: jQuery }
}

/* ========================================================================
 * Bootstrap: transition.js v3.0.3
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
	var el = document.createElement('bootstrap')

	var transEndEventNames = {
	  'WebkitTransition' : 'webkitTransitionEnd'
	, 'MozTransition'    : 'transitionend'
	, 'OTransition'      : 'oTransitionEnd otransitionend'
	, 'transition'       : 'transitionend'
	}

	for (var name in transEndEventNames) {
	  if (el.style[name] !== undefined) {
		return { end: transEndEventNames[name] }
	  }
	}
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
	var called = false, $el = this
	$(this).one($.support.transition.end, function () { called = true })
	var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
	setTimeout(callback, duration)
	return this
  }

  $(function () {
	$.support.transition = transitionEnd()
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.0.3
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-bs-dismiss="alert"]'
  var Alert   = function (el) {
	$(el).on('click', dismiss, this.close)
  }

  Alert.prototype.close = function (e) {
	var $this    = $(this)
	var selector = $this.attr('data-target')

	if (!selector) {
	  selector = $this.attr('href')
	  selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	}

	var $parent = $(selector)

	if (e) e.preventDefault()

	if (!$parent.length) {
	  $parent = $this.hasClass('alert') ? $this : $this.parent()
	}

	$parent.trigger(e = $.Event('close.bs.alert'))

	if (e.isDefaultPrevented()) return

	$parent.removeClass('in')

	function removeElement() {
	  $parent.trigger('closed.bs.alert').remove()
	}

	$.support.transition && $parent.hasClass('fade') ?
	  $parent
		.one($.support.transition.end, removeElement)
		.emulateTransitionEnd(150) :
	  removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  var old = $.fn.alert

  $.fn.alert = function (option) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data('bs.alert')

	  if (!data) $this.data('bs.alert', (data = new Alert(this)))
	  if (typeof option == 'string') data[option].call($this)
	})
  }

  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
	$.fn.alert = old
	return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.0.3
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
	this.$element = $(element)
	this.options  = $.extend({}, Button.DEFAULTS, options)
  }

  Button.DEFAULTS = {
	loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
	var d    = 'disabled'
	var $el  = this.$element
	var val  = $el.is('input') ? 'val' : 'html'
	var data = $el.data()

	state = state + 'Text'

	if (!data.resetText) $el.data('resetText', $el[val]())

	$el[val](data[state] || this.options[state])

	// push to event loop to allow forms to submit
	setTimeout(function () {
	  state == 'loadingText' ?
		$el.addClass(d).attr(d, d) :
		$el.removeClass(d).removeAttr(d);
	}, 0)
  }

  Button.prototype.toggle = function () {
	var $parent = this.$element.closest('[data-bs-toggle="buttons"]')
	var changed = true

	if ($parent.length) {
	  var $input = this.$element.find('input')
	  if ($input.prop('type') === 'radio') {
		// see if clicking on current one
		if ($input.prop('checked') && this.$element.hasClass('active'))
		  changed = false
		else
		  $parent.find('.active').removeClass('active')
	  }
	  if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
	}

	if (changed) this.$element.toggleClass('active')
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  var old = $.fn.button

  $.fn.button = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.button')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.button', (data = new Button(this, options)))

	  if (option == 'toggle') data.toggle()
	  else if (option) data.setState(option)
	})
  }

  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
	$.fn.button = old
	return this
  }


  // BUTTON DATA-API
  // ===============

  $(document).on('click.bs.button.data-api', '[data-bs-toggle^=button]', function (e) {
	var $btn = $(e.target)
	if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
	$btn.button('toggle')
	e.preventDefault()
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.0.3
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
	this.$element    = $(element)
	this.$indicators = this.$element.find('.carousel-indicators')
	this.options     = options
	this.paused      =
	this.sliding     =
	this.interval    =
	this.$active     =
	this.$items      = null

	this.options.pause == 'hover' && this.$element
	  .on('mouseenter', $.proxy(this.pause, this))
	  .on('mouseleave', $.proxy(this.cycle, this))
  }

  Carousel.DEFAULTS = {
	interval: 5000
  , pause: 'hover'
  , wrap: true
  }

  Carousel.prototype.cycle =  function (e) {
	e || (this.paused = false)

	this.interval && clearInterval(this.interval)

	this.options.interval
	  && !this.paused
	  && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

	return this
  }

  Carousel.prototype.getActiveIndex = function () {
	this.$active = this.$element.find('.item.active')
	this.$items  = this.$active.parent().children()

	return this.$items.index(this.$active)
  }

  Carousel.prototype.to = function (pos) {
	var that        = this
	var activeIndex = this.getActiveIndex()

	if (pos > (this.$items.length - 1) || pos < 0) return

	if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) })
	if (activeIndex == pos) return this.pause().cycle()

	return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]))
  }

  Carousel.prototype.pause = function (e) {
	e || (this.paused = true)

	if (this.$element.find('.next, .prev').length && $.support.transition.end) {
	  this.$element.trigger($.support.transition.end)
	  this.cycle(true)
	}

	this.interval = clearInterval(this.interval)

	return this
  }

  Carousel.prototype.next = function () {
	if (this.sliding) return
	return this.slide('next')
  }

  Carousel.prototype.prev = function () {
	if (this.sliding) return
	return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
	var $active   = this.$element.find('.item.active')
	var $next     = next || $active[type]()
	var isCycling = this.interval
	var direction = type == 'next' ? 'left' : 'right'
	var fallback  = type == 'next' ? 'first' : 'last'
	var that      = this

	if (!$next.length) {
	  if (!this.options.wrap) return
	  $next = this.$element.find('.item')[fallback]()
	}

	this.sliding = true

	isCycling && this.pause()

	var e = $.Event('slide.bs.carousel', { relatedTarget: $next[0], direction: direction })

	if ($next.hasClass('active')) return

	if (this.$indicators.length) {
	  this.$indicators.find('.active').removeClass('active')
	  this.$element.one('slid.bs.carousel', function () {
		var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()])
		$nextIndicator && $nextIndicator.addClass('active')
	  })
	}

	if ($.support.transition && this.$element.hasClass('slide')) {
	  this.$element.trigger(e)
	  if (e.isDefaultPrevented()) return
	  $next.addClass(type)
	  $next[0].offsetWidth // force reflow
	  $active.addClass(direction)
	  $next.addClass(direction)
	  $active
		.one($.support.transition.end, function () {
		  $next.removeClass([type, direction].join(' ')).addClass('active')
		  $active.removeClass(['active', direction].join(' '))
		  that.sliding = false
		  setTimeout(function () { that.$element.trigger('slid.bs.carousel') }, 0)
		})
		.emulateTransitionEnd(600)
	} else {
	  this.$element.trigger(e)
	  if (e.isDefaultPrevented()) return
	  $active.removeClass('active')
	  $next.addClass('active')
	  this.sliding = false
	  this.$element.trigger('slid.bs.carousel')
	}

	isCycling && this.cycle()

	return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  var old = $.fn.carousel

  $.fn.carousel = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.carousel')
	  var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
	  var action  = typeof option == 'string' ? option : options.slide

	  if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
	  if (typeof option == 'number') data.to(option)
	  else if (action) data[action]()
	  else if (options.interval) data.pause().cycle()
	})
  }

  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
	$.fn.carousel = old
	return this
  }


  // CAROUSEL DATA-API
  // =================

  $(document).on('click.bs.carousel.data-api', '[data-bs-slide], [data-bs-slide-to]', function (e) {
	var $this   = $(this), href
	var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
	var options = $.extend({}, $target.data(), $this.data())
	var slideIndex = $this.attr('data-bs-slide-to')
	if (slideIndex) options.interval = false

	$target.carousel(options)

	if (slideIndex = $this.attr('data-bs-slide-to')) {
	  $target.data('bs.carousel').to(slideIndex)
	}

	e.preventDefault()
  })

  $(window).on('load', function () {
	$('[data-bs-ride="carousel"]').each(function () {
	  var $carousel = $(this)
	  $carousel.carousel($carousel.data())
	})
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.0.3
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
	this.$element      = $(element)
	this.options       = $.extend({}, Collapse.DEFAULTS, options)
	this.transitioning = null

	if (this.options.parent) this.$parent = $(this.options.parent)
	if (this.options.toggle) this.toggle()
  }

  Collapse.DEFAULTS = {
	toggle: true
  }

  Collapse.prototype.dimension = function () {
	var hasWidth = this.$element.hasClass('width')
	return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
	if (this.transitioning || this.$element.hasClass('in')) return

	var startEvent = $.Event('show.bs.collapse')
	this.$element.triggerHandler(startEvent)
	if (startEvent.isDefaultPrevented()) return

	var actives = this.$parent && this.$parent.find('> .panel > .in')

	if (actives && actives.length) {
	  var hasData = actives.data('bs.collapse')
	  if (hasData && hasData.transitioning) return
	  actives.collapse('hide')
	  hasData || actives.data('bs.collapse', null)
	}

	var dimension = this.dimension()

	this.$element
	  .removeClass('collapse')
	  .addClass('collapsing')
	  [dimension](0)

	this.transitioning = 1

	var complete = function () {
	  this.$element
		.removeClass('collapsing')
		.addClass('in')
		[dimension]('auto')
	  this.transitioning = 0
	  this.$element.trigger('shown.bs.collapse')
	}

	if (!$.support.transition) return complete.call(this)

	var scrollSize = $.camelCase(['scroll', dimension].join('-'))

	this.$element
	  .one($.support.transition.end, $.proxy(complete, this))
	  .emulateTransitionEnd(350)
	  [dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
	if (this.transitioning || !this.$element.hasClass('in')) return

	var startEvent = $.Event('hide.bs.collapse')
	this.$element.triggerHandler(startEvent)
	if (startEvent.isDefaultPrevented()) return

	var dimension = this.dimension()

	this.$element
	  [dimension](this.$element[dimension]())
	  [0].offsetHeight

	this.$element
	  .addClass('collapsing')
	  .removeClass('collapse')
	  .removeClass('in')

	this.transitioning = 1

	var complete = function () {
	  this.transitioning = 0
	  this.$element
		.trigger('hidden.bs.collapse')
		.removeClass('collapsing')
		.addClass('collapse')
	}

	if (!$.support.transition) return complete.call(this)

	this.$element
	  [dimension](0)
	  .one($.support.transition.end, $.proxy(complete, this))
	  .emulateTransitionEnd(350)
  }

  Collapse.prototype.toggle = function () {
	this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  var old = $.fn.collapse

  $.fn.collapse = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.collapse')
	  var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

	  if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
	$.fn.collapse = old
	return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-bs-toggle=collapse]', function (e) {
	var $this   = $(this), href
	var target  = $this.attr('data-target')
		|| e.preventDefault()
		|| (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
	var $target = $(target)
	var data    = $target.data('bs.collapse')
	var option  = data ? 'toggle' : $this.data()
	var parent  = $this.attr('data-parent')
	var $parent = parent && $(parent)

	if (!data || !data.transitioning) {
	  if ($parent) $parent.find('[data-bs-toggle=collapse][data-parent="' + parent + '"]').not($this).addClass('collapsed')
	  $this[$target.hasClass('in') ? 'addClass' : 'removeClass']('collapsed')
	}

	$target.collapse(option)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.4.0
 * https://getbootstrap.com/docs/3.4/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2018 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-bs-toggle="dropdown"]'
  var Dropdown = function (element) {
	$(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.4.0'

  function getParent($this) {
	var selector = $this.attr('data-target')

	if (!selector) {
	  selector = $this.attr('href')
	  selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	}

	var $parent = selector && $(document).find(selector)

	return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
	if (e && e.which === 3) return
	$(backdrop).remove()
	$(toggle).each(function () {
	  var $this         = $(this)
	  var $parent       = getParent($this)
	  var relatedTarget = { relatedTarget: this }

	  if (!$parent.hasClass('open')) return

	  if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

	  $parent.triggerHandler(e = $.Event('hide.bs.dropdown'))

	  if (e.isDefaultPrevented()) return

	  $this.attr('aria-expanded', 'false')
	  $parent.removeClass('open').trigger('hidden.bs.dropdown')
	})
  }

  Dropdown.prototype.toggle = function (e) {
	var $this = $(this)

	if ($this.is('.disabled, :disabled')) return

	var $parent  = getParent($this)
	var isActive = $parent.hasClass('open')

	// Clear out any dropdown menu that already open
	clearMenus()

	if (!isActive) {
		if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {

			var backdropTarget = $(this);

			// if mobile we use a backdrop because click events don't delegate
			setTimeout(function() {
				$(document.createElement('div'))
				.addClass('dropdown-backdrop')
				.insertAfter(backdropTarget)
				.on('click', clearMenus)
			}, 4);
		}

		var relatedTarget = { relatedTarget: this }
		$parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

		if (e.isDefaultPrevented()) return

		setTimeout(function() {
			$this
			.trigger('focus')
			.attr('aria-expanded', 'true')

			$parent
			.toggleClass('open')
			.trigger($.Event('shown.bs.dropdown', relatedTarget))
		}, 4);
	}

	// Returning false will somehow causing other trigger to not working correctly. #2967
	// return false
  }

  Dropdown.prototype.keydown = function (e) {
	if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

	var $this = $(this)

	e.preventDefault()
	e.stopPropagation()

	if ($this.is('.disabled, :disabled')) return

	var $parent  = getParent($this)
	var isActive = $parent.hasClass('open')

	if (!isActive && e.which != 27 || isActive && e.which == 27) {
	  if (e.which == 27) $parent.find(toggle).trigger('focus')
	  return $this.trigger('click')
	}

	var desc = ' li:not(.disabled):visible a'
	var $items = $parent.find('.dropdown-menu' + desc)

	if (!$items.length) return

	var index = $items.index(e.target)

	if (e.which == 38 && index > 0)                 index--         // up
	if (e.which == 40 && index < $items.length - 1) index++         // down
	if (!~index)                                    index = 0

	$items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data('bs.dropdown')

	  if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
	  if (typeof option == 'string') data[option].call($this)
	})
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
	$.fn.dropdown = old
	return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
	.on('click.bs.dropdown.data-api', clearMenus)
	.on('click.bs.dropdown.data-api', '.dropdown_ form, .dropdown-static', function (e) { e.stopPropagation() })
	.on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
	.on('keydown.bs.dropdown.data-api', toggle + ', [role=menu]', Dropdown.prototype.keydown)
	.on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.0.3
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
	this.options   = options
	this.$element  = $(element)
	this.$backdrop =
	this.isShown   = null

	if (this.options.remote) this.$element.load(this.options.remote)
  }

  Modal.DEFAULTS = {
	  backdrop: true
	, keyboard: true
	, show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
	return this[!this.isShown ? 'show' : 'hide'](_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
	var that = this
	var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

	this.$element.triggerHandler(e)

	if (this.isShown || e.isDefaultPrevented()) return

	this.isShown = true

	this.escape()

	this.$element.on('click.dismiss.modal', '[data-bs-dismiss="modal"]', $.proxy(this.hide, this))

	this.backdrop(function () {
	  var transition = $.support.transition && that.$element.hasClass('fade')

	  if (!that.$element.parent().length) {
		that.$element.appendTo(document.body) // don't move modals dom position
	  }

	  that.$element.show()

	  if (transition) {
		that.$element[0].offsetWidth // force reflow
	  }

	  that.$element
		.addClass('in')
		.attr('aria-hidden', false)

	  that.enforceFocus()

	  var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

	  transition ?
		that.$element.find('.modal-dialog') // wait for modal to slide in
		  .one($.support.transition.end, function () {
			that.$element.focus().trigger(e)
		  })
		  .emulateTransitionEnd(300) :
		that.$element.focus().trigger(e)
	})
  }

  Modal.prototype.hide = function (e) {
	if (e) e.preventDefault()

	e = $.Event('hide.bs.modal')

	this.$element.triggerHandler(e)

	if (!this.isShown || e.isDefaultPrevented()) return

	this.isShown = false

	this.escape()

	$(document).off('focusin.bs.modal')

	this.$element
	  .removeClass('in')
	  .attr('aria-hidden', true)
	  .off('click.dismiss.modal')

	$.support.transition && this.$element.hasClass('fade') ?
	  this.$element
		.one($.support.transition.end, $.proxy(this.hideModal, this))
		.emulateTransitionEnd(300) :
	  this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
	$(document)
	  .off('focusin.bs.modal') // guard against infinite focus loop
	  .on('focusin.bs.modal', $.proxy(function (e) {
		if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
		  this.$element.focus()
		}
	  }, this))
  }

  Modal.prototype.escape = function () {
	if (this.isShown && this.options.keyboard) {
	  this.$element.on('keyup.dismiss.bs.modal', $.proxy(function (e) {
		e.which == 27 && this.hide()
	  }, this))
	} else if (!this.isShown) {
	  this.$element.off('keyup.dismiss.bs.modal')
	}
  }

  Modal.prototype.hideModal = function () {
	var that = this
	this.$element.hide()
	this.backdrop(function () {
	  that.removeBackdrop()
	  that.$element.trigger('hidden.bs.modal')
	})
  }

  Modal.prototype.removeBackdrop = function () {
	this.$backdrop && this.$backdrop.remove()
	this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
	var that    = this
	var animate = this.$element.hasClass('fade') ? 'fade' : ''

	if (this.isShown && this.options.backdrop) {
	  var doAnimate = $.support.transition && animate

	  this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
		.appendTo(document.body)

	  this.$element.on('click.dismiss.modal', $.proxy(function (e) {
		if (e.target !== e.currentTarget) return
		this.options.backdrop == 'static'
		  ? this.$element[0].focus.call(this.$element[0])
		  : this.hide.call(this)
	  }, this))

	  if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

	  this.$backdrop.addClass('in')

	  if (!callback) return

	  doAnimate ?
		this.$backdrop
		  .one($.support.transition.end, callback)
		  .emulateTransitionEnd(150) :
		callback()

	} else if (!this.isShown && this.$backdrop) {
	  this.$backdrop.removeClass('in')

	  $.support.transition && this.$element.hasClass('fade')?
		this.$backdrop
		  .one($.support.transition.end, callback)
		  .emulateTransitionEnd(150) :
		callback()

	} else if (callback) {
	  callback()
	}
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  var old = $.fn.modal

  $.fn.modal = function (option, _relatedTarget) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.modal')
	  var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

	  if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
	  if (typeof option == 'string') data[option](_relatedTarget)
	  else if (options.show) data.show(_relatedTarget)
	})
  }

  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
	$.fn.modal = old
	return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-bs-toggle="modal"]', function (e) {
	var $this   = $(this)
	var href    = $this.attr('href')
	var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
	var option  = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

	e.preventDefault()

	$target
	  .modal(option, this)
	  .one('hide', function () {
		$this.is(':visible') && $this.focus()
	  })
  })

  $(document)
	.on('show.bs.modal',  '.modal.bs', function () { $(document.body).addClass('modal-open') })
	.on('hidden.bs.modal', '.modal.bs', function () { $(document.body).removeClass('modal-open') })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.0.3
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
	this.type       =
	this.options    =
	this.enabled    =
	this.timeout    =
	this.hoverState =
	this.$element   = null

	this.init('tooltip', element, options)
  }

  Tooltip.DEFAULTS = {
	animation: true
  , placement: 'top'
  , selector: false
  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
  , trigger: 'hover focus'
  , title: ''
  , delay: 0
  , html: false
  , container: false
  }

  Tooltip.prototype.init = function (type, element, options) {
	this.enabled  = true
	this.type     = type
	this.$element = $(element)
	this.options  = this.getOptions(options)

	var triggers = this.options.trigger.split(' ')

	for (var i = triggers.length; i--;) {
	  var trigger = triggers[i]

	  if (trigger == 'click') {
		this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
	  } else if (trigger != 'manual') {
		var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focus'
		var eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'

		this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
		this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
	  }
	}

	this.options.selector ?
	  (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
	  this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
	return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
	options = $.extend({}, this.getDefaults(), this.$element.data(), options)

	if (options.delay && typeof options.delay == 'number') {
	  options.delay = {
		show: options.delay
	  , hide: options.delay
	  }
	}

	return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
	var options  = {}
	var defaults = this.getDefaults()

	this._options && $.each(this._options, function (key, value) {
	  if (defaults[key] != value) options[key] = value
	})

	return options
  }

  Tooltip.prototype.enter = function (obj) {
	var self = obj instanceof this.constructor ?
	  obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

	clearTimeout(self.timeout)

	self.hoverState = 'in'

	if (!self.options.delay || !self.options.delay.show) return self.show()

	self.timeout = setTimeout(function () {
	  if (self.hoverState == 'in') self.show()
	}, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {

	var self = obj instanceof this.constructor ?
	  obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

	clearTimeout(self.timeout)

	self.hoverState = 'out'

	if (!self.options.delay || !self.options.delay.hide) return self.hide()

	self.timeout = setTimeout(function () {
	  if (self.hoverState == 'out') self.hide()
	}, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
	var e = $.Event('show.bs.'+ this.type)

	if (this.hasContent() && this.enabled) {
	  this.$element.triggerHandler(e)

	  if (e.isDefaultPrevented()) return

	  var $tip = this.tip()

	  this.setContent()

	  if (this.options.animation) $tip.addClass('fade')

	  var placement = typeof this.options.placement == 'function' ?
		this.options.placement.call(this, $tip[0], this.$element[0]) :
		this.options.placement

	  var autoToken = /\s?auto?\s?/i
	  var autoPlace = autoToken.test(placement)
	  if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

	  $tip
		.detach()
		.css({ top: 0, left: 0, display: 'block' })
		.addClass(placement.split('-')[0]);

	  this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

	  var pos          = this.getPosition()
	  var actualWidth  = $tip[0].offsetWidth
	  var actualHeight = $tip[0].offsetHeight

	  if (autoPlace) {
		var $parent = this.$element.parent()

		var orgPlacement = placement
		var docScroll    = document.documentElement.scrollTop || document.body.scrollTop
		var parentWidth  = this.options.container == 'body' ? window.innerWidth  : $parent.outerWidth()
		var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight()
		var parentLeft   = this.options.container == 'body' ? 0 : $parent.offset().left

		placement = placement == 'bottom' && pos.top   + pos.height  + actualHeight - docScroll > parentHeight  ? 'top'    :
					placement == 'top'    && pos.top   - docScroll   - actualHeight < 0                         ? 'bottom' :
					placement == 'right'  && pos.right + actualWidth > parentWidth                              ? 'left'   :
					placement == 'left'   && pos.left  - actualWidth < parentLeft                               ? 'right'  :
					placement

		$tip
		  .removeClass(orgPlacement)
		  .addClass(placement)
	  }

	  var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

	  this.applyPlacement(calculatedOffset, placement)
	  this.$element.trigger('shown.bs.' + this.type)
	}
  }

  Tooltip.prototype.applyPlacement = function(offset, placement) {
	var replace
	var $tip   = this.tip()
	var width  = $tip[0].offsetWidth
	var height = $tip[0].offsetHeight

	// manually read margins because getBoundingClientRect includes difference
	var marginTop = parseInt($tip.css('margin-top'), 10)
	var marginLeft = parseInt($tip.css('margin-left'), 10)

	// we must check for NaN for ie 8/9
	if (isNaN(marginTop))  marginTop  = 0
	if (isNaN(marginLeft)) marginLeft = 0

	offset.top  = offset.top  + marginTop
	offset.left = offset.left + marginLeft

	$tip
	  .offset(offset)
	  .addClass('in')

	// Add cursor to the background. #3393
	if (window.es.mobile && this.type == 'popover') {
		$('body').css('cursor', 'pointer');
	}

	// check to see if placing tip in new offset caused the tip to resize itself
	var actualWidth  = $tip[0].offsetWidth
	var actualHeight = $tip[0].offsetHeight

	if (placement == 'top' && actualHeight != height) {
	  replace = true
	  offset.top = offset.top + height - actualHeight
	}

	if (['top', 'bottom'].indexOf(placement.split('-')[0]) === 0) {
	  var delta = 0

	  if (offset.left < 0) {
		delta       = offset.left * -2
		offset.left = 0

		$tip.offset(offset)

		actualWidth  = $tip[0].offsetWidth
		actualHeight = $tip[0].offsetHeight
	  }

	  this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
	}

	if (['left', 'right'].indexOf(placement.split('-')[0]) === 0) {
	  this.replaceArrow(actualHeight - height, actualHeight, 'top')
	}

	if (replace) $tip.offset(offset)
  }

  Tooltip.prototype.replaceArrow = function(delta, dimension, position) {
	this.arrow().css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
  }

  Tooltip.prototype.setContent = function () {
	var $tip  = this.tip()
	var title = this.getTitle()

	$tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
	$tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function () {
	var that = this
	var $tip = this.tip()
	var e    = $.Event('hide.bs.' + this.type)

	function complete() {
	  if (that.hoverState != 'in') $tip.detach()
	}

	this.$element.triggerHandler(e)

	if (e.isDefaultPrevented()) return

	$tip.removeClass('in')

	$.support.transition && this.$tip.hasClass('fade') ?
	  $tip
		.one($.support.transition.end, complete)
		.emulateTransitionEnd(150) :
	  complete()

	// Remove cursor from the background. #3393
	if (window.es.mobile && this.type == 'popover') {
		$('body').css('cursor', '');
	}

	this.$element.trigger('hidden.bs.' + this.type)

	return this
  }

  Tooltip.prototype.fixTitle = function () {
	var $e = this.$element
	if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
	  $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
	}
  }

  Tooltip.prototype.hasContent = function () {
	return this.getTitle()
  }

  Tooltip.prototype.getPosition = function () {
	var el = this.$element[0]
	return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
	  width: el.offsetWidth
	, height: el.offsetHeight
	}, this.$element.offset())
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {

	return placement == 'left-top'     ? { top: pos.top, left: pos.left - actualWidth } :
		   placement == 'left-bottom'  ? { top: pos.top + pos.height - actualHeight, left: pos.left - actualWidth } :
		   placement == 'right-top'    ? { top: pos.top, left: pos.left + pos.width } :
		   placement == 'right-bottom' ? { top: pos.top + pos.height - actualHeight, left: pos.left + pos.width } :
		   placement == 'top-left'     ? { top: pos.top - actualHeight, left: pos.left } :
		   placement == 'top-right'    ? { top: pos.top - actualHeight, left: pos.left + pos.width - actualWidth } :
		   placement == 'bottom-left'  ? { top: pos.top + pos.height, left: pos.left } :
		   placement == 'bottom-right' ? { top: pos.top + pos.height, left: pos.left + pos.width - actualWidth } :
		   placement == 'bottom'       ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
		   placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
		   placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
		/* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }
  }

  Tooltip.prototype.getTitle = function () {
	var title
	var $e = this.$element
	var o  = this.options

	title = $e.attr('data-original-title')
	  || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

	return title
  }

  Tooltip.prototype.tip = function () {
	return this.$tip = this.$tip || $(this.options.template)
  }

  Tooltip.prototype.arrow = function () {
	return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow')
  }

  Tooltip.prototype.validate = function () {
	if (!this.$element[0].parentNode) {
	  this.hide()
	  this.$element = null
	  this.options  = null
	}
  }

  Tooltip.prototype.enable = function () {
	this.enabled = true
  }

  Tooltip.prototype.disable = function () {
	this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
	this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
	var self = e ? $(e.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type) : this
	self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
	this.hide().$element.off('.' + this.type).removeData('bs.' + this.type)
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  var old = $.fn.tooltip

  $.fn.tooltip = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.tooltip')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
	$.fn.tooltip = old
	return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.0.3
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
	this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.DEFAULTS = $.extend({} , $.fn.tooltip.Constructor.DEFAULTS, {
	placement: 'right'
  , trigger: 'click'
  , content: ''
  , template: '<div id="es" class="o-popover--es"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
	return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
	var $tip    = this.tip()
	var title   = this.getTitle()
	var content = this.getContent()

	$tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
	$tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)

	$tip.removeClass('fade top bottom left right in')

	// IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
	// this manually by checking the contents.
	if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
	return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
	var $e = this.$element
	var o  = this.options

	return $e.attr('data-content')
	  || (typeof o.content == 'function' ?
			o.content.call($e[0]) :
			o.content)
  }

  Popover.prototype.arrow = function () {
	return this.$arrow = this.$arrow || this.tip().find('.arrow')
  }

  Popover.prototype.tip = function () {
	if (!this.$tip) this.$tip = $(this.options.template)
	return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  var old = $.fn.popover

  $.fn.popover = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.popover')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
	$.fn.popover = old
	return this
  }

// It seems like Tooltips is still referring to popover?
// To solve the Tooltip issue, we need to create another instance and
// keep the original popover. #1444

  $.fn.popoverES = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.popover')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.popoverES.Constructor = Popover


}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.0.3
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
	var href
	var process  = $.proxy(this.process, this)

	this.$element       = $(element).is('body') ? $(window) : $(element)
	this.$body          = $('body')
	this.$scrollElement = this.$element.on('scroll.bs.scroll-spy.data-api', process)
	this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
	this.selector       = (this.options.target
	  || ((href = $(element).attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
	  || '') + ' .nav li > a'
	this.offsets        = $([])
	this.targets        = $([])
	this.activeTarget   = null

	this.refresh()
	this.process()
  }

  ScrollSpy.DEFAULTS = {
	offset: 10
  }

  ScrollSpy.prototype.refresh = function () {
	var offsetMethod = this.$element[0] == window ? 'offset' : 'position'

	this.offsets = $([])
	this.targets = $([])

	var self     = this
	var $targets = this.$body
	  .find(this.selector)
	  .map(function () {
		var $el   = $(this)
		var href  = $el.data('target') || $el.attr('href')
		var $href = /^#\w/.test(href) && $(href)

		return ($href
		  && $href.length
		  && [[ $href[offsetMethod]().top + (!$.isWindow(self.$scrollElement.get(0)) && self.$scrollElement.scrollTop()), href ]]) || null
	  })
	  .sort(function (a, b) { return a[0] - b[0] })
	  .each(function () {
		self.offsets.push(this[0])
		self.targets.push(this[1])
	  })
  }

  ScrollSpy.prototype.process = function () {
	var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
	var scrollHeight = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight
	var maxScroll    = scrollHeight - this.$scrollElement.height()
	var offsets      = this.offsets
	var targets      = this.targets
	var activeTarget = this.activeTarget
	var i

	if (scrollTop >= maxScroll) {
	  return activeTarget != (i = targets.last()[0]) && this.activate(i)
	}

	for (i = offsets.length; i--;) {
	  activeTarget != targets[i]
		&& scrollTop >= offsets[i]
		&& (!offsets[i + 1] || scrollTop <= offsets[i + 1])
		&& this.activate( targets[i] )
	}
  }

  ScrollSpy.prototype.activate = function (target) {
	this.activeTarget = target

	$(this.selector)
	  .parents('.active')
	  .removeClass('active')

	var selector = this.selector
	  + '[data-target="' + target + '"],'
	  + this.selector + '[href="' + target + '"]'

	var active = $(selector)
	  .parents('li')
	  .addClass('active')

	if (active.parent('.dropdown-menu').length)  {
	  active = active
		.closest('li.dropdown')
		.addClass('active')
	}

	active.trigger('activate.bs.scrollspy')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  var old = $.fn.scrollspy

  $.fn.scrollspy = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.scrollspy')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
	$.fn.scrollspy = old
	return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load', function () {
	$('[data-bs-spy="scroll"]').each(function () {
	  var $spy = $(this)
	  $spy.scrollspy($spy.data())
	})
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.0.3
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
	this.element = $(element)
  }

  Tab.prototype.show = function () {
	var $this    = this.element
	var $ul      = $this.closest('ul:not(.dropdown-menu)')
	var selector = $this.data('target')

	if (!selector) {
	  selector = $this.attr('href')
	  selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
	}

	if ($this.parent('li').hasClass('active')) return

	var previous = $ul.find('.active:last a')[0]
	var e        = $.Event('show.bs.tab', {
	  relatedTarget: previous
	})

	$this.triggerHandler(e)

	if (e.isDefaultPrevented()) return

	var $target = $(selector)

	this.activate($this.parent('li'), $ul)
	this.activate($target, $target.parent(), function () {
	  $this.trigger({
		type: 'shown.bs.tab'
	  , relatedTarget: previous
	  })
	})
  }

  Tab.prototype.activate = function (element, container, callback) {
	var $active    = container.find('> .active')
	var transition = callback
	  && $.support.transition
	  && $active.hasClass('fade')

	function next() {
	  $active
		.removeClass('active')
		.find('> .dropdown-menu > .active')
		.removeClass('active')

	  element.addClass('active')

	  if (transition) {
		element[0].offsetWidth // reflow for transition
		element.addClass('in')
	  } else {
		element.removeClass('fade')
	  }

	  if (element.parent('.dropdown-menu')) {
		element.closest('li.dropdown').addClass('active')
	  }

	  callback && callback()
	}

	transition ?
	  $active
		.one($.support.transition.end, next)
		.emulateTransitionEnd(150) :
	  next()

	$active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  var old = $.fn.tab

  $.fn.tab = function ( option ) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data('bs.tab')

	  if (!data) $this.data('bs.tab', (data = new Tab(this)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
	$.fn.tab = old
	return this
  }


  // TAB DATA-API
  // ============

  $(document).on('click.bs.tab.data-api', '[data-bs-toggle="tab"], [data-bs-toggle="pill"]', function (e) {
	e.preventDefault()
	$(this).tab('show')
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.0.3
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
	this.options = $.extend({}, Affix.DEFAULTS, options)
	this.$window = $(window)
	  .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
	  .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

	this.$element = $(element)
	this.affixed  =
	this.unpin    = null

	this.checkPosition()
  }

  Affix.RESET = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
	offset: 0
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
	setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
	if (!this.$element.is(':visible')) return

	var scrollHeight = $(document).height()
	var scrollTop    = this.$window.scrollTop()
	var position     = this.$element.offset()
	var offset       = this.options.offset
	var offsetTop    = offset.top
	var offsetBottom = offset.bottom

	if (typeof offset != 'object')         offsetBottom = offsetTop = offset
	if (typeof offsetTop == 'function')    offsetTop    = offset.top()
	if (typeof offsetBottom == 'function') offsetBottom = offset.bottom()

	var affix = this.unpin   != null && (scrollTop + this.unpin <= position.top) ? false :
				offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ? 'bottom' :
				offsetTop    != null && (scrollTop <= offsetTop) ? 'top' : false

	if (this.affixed === affix) return
	if (this.unpin) this.$element.css('top', '')

	this.affixed = affix
	this.unpin   = affix == 'bottom' ? position.top - scrollTop : null

	this.$element.removeClass(Affix.RESET).addClass('affix' + (affix ? '-' + affix : ''))

	if (affix == 'bottom') {
	  this.$element.offset({ top: document.body.offsetHeight - offsetBottom - this.$element.height() })
	}
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  var old = $.fn.affix

  $.fn.affix = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.affix')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
	$.fn.affix = old
	return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
	$('[data-bs-spy="affix"]').each(function () {
	  var $spy = $(this)
	  var data = $spy.data()

	  data.offset = data.offset || {}

	  if (data.offsetBottom) data.offset.bottom = data.offsetBottom
	  if (data.offsetTop)    data.offset.top    = data.offsetTop

	  $spy.affix(data)
	})
  })

}(jQuery);
/**
 * bootstrap-notify.js v1.0
 * --
 * http://twitter.com/nijikokun
 * Copyright 2012 Nijiko Yonskai, Goodybag
 * --
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

!function ($) {
  var Notification = function (element, options) {
	// Element collection
	this.$element = $(element);
	this.$note    = $('<div class="alert"></div>');
	this.options  = $.extend(true, $.fn.notify.defaults, options);

	// Setup from options
	if(this.options.transition)
	  if(this.options.transition == 'fade')
		this.$note.addClass('in').addClass(this.options.transition);
	  else this.$note.addClass(this.options.transition);
	else this.$note.addClass('fade').addClass('in');

	if(this.options.type)
	  this.$note.addClass('alert-' + this.options.type);
	else this.$note.addClass('alert-success');

	if(!this.options.message && this.$element.data("message") !== '') // dom text
	  this.$note.html(this.$element.data("message"));
	else
	  if(typeof this.options.message === 'object')
		if(this.options.message.html)
		  this.$note.html(this.options.message.html);
		else if(this.options.message.text)
		  this.$note.text(this.options.message.text);
	  else
		this.$note.html(this.options.message);

	if(this.options.closable)
	  var link = $('<a class="close pull-right" href="javascript: void(0);">&times;</a>');
	  $(link).on('click', $.proxy(onClose, this));
	  this.$note.prepend(link);

	return this;
  };

  onClose = function() {
	this.options.onClose();
	$(this.$note).remove();
	this.options.onClosed();
  };

  Notification.prototype.show = function () {
	if(this.options.fadeOut.enabled)
	  this.$note.delay(this.options.fadeOut.delay || 3000).fadeOut('slow', $.proxy(onClose, this));

	this.$element.append(this.$note);
	this.$note.alert();
  };

  Notification.prototype.hide = function () {
	if(this.options.fadeOut.enabled)
	  this.$note.delay(this.options.fadeOut.delay || 3000).fadeOut('slow', $.proxy(onClose, this));
	else onClose.call(this);
  };

  $.fn.notify = function (options) {
	return new Notification(this, options);
  };

  $.fn.notify.defaults = {
	type: 'success',
	closable: true,
	transition: 'fade',
	fadeOut: {
	  enabled: true,
	  delay: 3000
	},
	message: null,
	onClose: function () {},
	onClosed: function () {}
  }
}($);

});
FD40.plugin("utils", function($) {

/**
 * jquery.Bloop
 * Binary loop helper.
 * https://github.com/jstonne/jquery.Bloop
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne & Jason Rey
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

	var Bloop = function(items) {

		this.items = items;
		this.start = 0;
		this.end = items.length - 1;
		this.node = null;
		this.stopped = false;
	};

	$.extend(Bloop.prototype, {

		isLooping: function() {

			if (this.stopped) return false;

			if (Math.abs(this.start - this.end) > 1) {
				this.node = Math.floor((this.start + this.end) / 2);
				return true;
			}

			return false;
		},

		flip: function(flip) {

			if (flip) {
				this.end = this.node - 1;
			} else {
				this.start = this.node + 1;
			}
		},

		stop: function() {
			this.stop = true;
		}
	});


	$.Bloop = function(items){

		return new Bloop(items);
	}

})();
;/*!
 * jquery.Chunk
 * Utility to handle large arrays by processing
 * them in smaller manageable chunks.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.Chunk = function(array, options) {

	if ($.isArray(array)) {
		array = [];
	}

	var options = $.extend({},
		{
			size: 256,
			every: 1000
		},
		options
	);

	var self = $.extend($.Deferred(), {

		size: options.size,

		every: options.every,

		from: 0,

		to: array.length,

		process: function(callback) {

			self.process.fn = callback;

			return self;
		},

		chunkStart: function(callback) {

			self.chunkStart.fn = callback;

			return self;
		},

		chunkEnd: function(callback) {

			self.chunkEnd.fn = callback;

			return self;
		},

		start: function() {

			self.stopped = false;

			self.iterate();

			return self;
		},

		iterate: function() {

			if (self.stopped) return;

			var iterator = self.process.fn;

			if (!iterator) return;

			self.to = from.size + self.size;

			var max = array.length;

			if (self.to > max) {

				self.to = max;
			}

			var range = {from: self.from, to: self.to};

			// Trigger chunkStart event
			self.chunkStart.fn && self.chunkStart.fn.call(self, range.from, range.to);

			while (self.from < self.to) {

				if (self.stopped) break;

				iterator.call(self, array[self.from]);

				self.from++;
			}

			// Trigger chunkEnd event
			self.chunkEnd.fn && self.chunkEnd.fn.call(self, range.from, range.to);

			// Always get the latest array length because
			// it may change through iteration
			self.completed = (self.from >= array.length - 1);

			if (self.completed) {

				self.resolveWith(self);

			} else {

				self.nextIteration = setTimeout(self.iterate, self.every);
			}

			return self;
		},

		pause: function() {

			self.stopped = true;

			clearTimeout(self.nextIteration);

			return self;
		},

		restart: function() {

			if (self.state()==="rejected") return self;

			self.from = 0;

			self.start();

			return self;
		},

		stop: function() {

			self.pause();

			self.rejectWith(self, [self.from]);

			return self;
		}
	});

	return self;
};
;/**
 * jquery.Enqueue
 * Execute only the last added callback.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne & Jason Rey
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(isFunction) {

	var Enqueue = function() {
		this.lastId = 0;
	};

	Enqueue.prototype.queue = function(filter) {

		var self = this,
			id = $.uid();
			self.lastId = id;

		return function() {

			if (self.lastId===id) {

				var args = arguments,
					args = (isFunction(filter)) ? filter.apply(this, args) : args;

				return (isFunction(self.fn)) ? self.fn.apply(this, args) : args;
			}
		}
	};

	$.Enqueue = function(fn) {

		var self = new Enqueue();

		if (isFunction(fn)) self.fn = fn;

		var func = $.proxy(self.queue, self);

		func.reset = function() {
			self.lastId = 0;
		};

		return func;
	};
})($.isFunction);
;/**
 * jquery.Exception
 * Standardized exception object.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){
	var consoleMethod = {
		error: "error",
		warning: "warn",
		success: "log",
		info: "info"
	};

	// $.Exception("message");
	// $.Exception("success", "message");
	// $.Exception("error", "message", data);
	// $.Exception({type: "info", message: "message", foo: "bar", key: "val"});
	$.Exception = function(exception) {

		// Normalize arguments
		var args = arguments,
			simple = args.length==1,
			hasData = args.length==3;

		exception = $.isPlainObject(exception) ?
			exception :
			{
				type   : simple ? "error" : args[0],
				message: simple ? args[0] : args[1]
			}

		hasData && $.extend(exception, args[2]);

		if ($.environment=="development") {
			console[consoleMethod[exception.type]](exception.message, exception);
		}

		return exception;
	}
})();;/**
 * jquery.IE
 * Returns the current IE version.
 *
 * Based on Padolsey's IE detection script.
 * https://gist.github.com/padolsey/527683
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.IE = (function(){

	// It seems Padolsey's IE detection script
	// doesn't work on IE10 and 11.
	var ua = navigator.userAgent;
	if (ua.match(/MSIE 9/)) return 9;
	if (ua.match(/MSIE 10/)) return 10;
	if (ua.match(/rv:11/i)) return 11;

	var undef,
		v = 3,
		div = document.createElement('div'),
		all = div.getElementsByTagName('i');

	while (
		v++,
		div.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->',
		all[0]
	);

	return v > 4 ? v : undef;

}());;/**
 * jquery.Task
 * Task runner utility.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.Task = function(props) {

	var task = $.extend(
		$.Deferred(),
		{
			data: {},
			list: [],
			add: function(name) {

				var item = $.extend(
					$.Deferred(),
					{
						name: name,
						item: item
					}
				);

				task.list.push(item);

				return item;
			},
			process: function() {

				if (!task._promise) {

					task._promise =
						$.when.apply($, task.list)
							.then(
								task.resolve,
								task.reject,
								task.progress
							);
				}

				return task;
			}
		},
		props
	);

	return task;
};;/**
 * jquery.Threads
 * A manager that controls threads a.k.a. execution of function simultaneously.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne & Jason Rey
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function() {

	var Threads = function(options) {
		this.threads = [];
		this.threadCount = 0;
		this.threadLimit = options.threadLimit || 1;
		this.threadDelay = options.threadDelay || 0;
	}

	$.extend(Threads.prototype, {

		add: function(thread, type) {

			if (!$.isFunction(thread)) return;

			thread.type = type || "normal";

			if (type=="deferred") {
				thread.deferred = $.Deferred().always($.proxy(this.next, this));
			}

			this.threads.push(thread);

			this.run();
		},

		addDeferred: function(thread) {

			return this.add(thread, "deferred");
		},

		next: function() {

			// Reduce thread count
			this.threadCount--;

			// And see if there's anymore task to run
			this.run();
		},

		run: function() {

			var self = this;

			setTimeout(function(){

				if (self.threads.length < 1) return;

				if (self.threadCount < self.threadLimit) {

					self.threadCount++;

					var thread = self.threads.shift();

					// Wrap in a try catch in case if the thread
					// throws an error it doesn't break our chain.
					try { thread.call(thread, thread.deferred); }
					catch(e) { console.error(e); }

					!thread.deferred && self.next();
				}

			}, self.threadDelay);
		}
	});

	$.Threads = function(options) {

		return new Threads(options);
	};

})();
;/**
 * jquery.callback
 * Creates a global callback function that gets
 * removed from the window object after it has executed.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.callback = function(func, persist){

	// Create callback
	if ($.isFunction(func)) {

		var funcName = $.uid("cb");

		window[funcName] = function(){

			// Destroy itself after callback has been called
			if (!persist) {
				delete window[funcName];
			}

			return func.apply(null, arguments);
		}

		return funcName;
	}

	// Callback method
	if ($.isString(func)) {
		switch (func) {
			case "destroy":
				var funcName = persist;
				delete window[funcName];
				break;
		}
	}
};/**
 * jquery.fn.checkList.
 * Multiple checkbox handler.
 *
 * $(e).checkList({
 *    check  : function(){},   // callback when an input is checked
 *    uncheck: function(){},   // callback when an input is unchecked
 *
 *    // returns checked elements & unchecked elements in separate arguments
 *    change : function(checked, unchecked){}
 * })
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.checkList = function(options) {

	var defaultOptions = {
		checkbox: ".checkbox",
		masterCheckbox: ".master-checkbox",
		check: function() {},
		uncheck: function() {},
		change: function() {}
	}

	var options = $.extend({}, defaultOptions, options),
		checkList       = this,
		checkboxes      = checkList.find(options.checkbox),
		masterCheckbox  = checkList.find(options.masterCheckbox),
		disableChangeEvent = false;

	var change = function() {

		if (!disableChangeEvent) {

			var checked = checkboxes.filter(':checked'),
				unchecked = checkboxes.not(':checked');

			if (checked.length < 1) {
				masterCheckbox.removeAttr("checked");
			}

			if (checked.length == checkboxes.length) {
				masterCheckbox.prop("checked", true);
			}

			options.change.call(checkList, checked, unchecked);
		}
	}

	checkboxes.checked(

		// checked
		function() {
			options.check.apply(checkList);
			change();
		},

		// unchecked
		function() {
			options.uncheck.apply(checkList);
			change();
		}
	);

	masterCheckbox.checked(

		// checked
		function() {
			disableChangeEvent = true;
			checkboxes.checked(true);
			disableChangeEvent = false;
			change();
		},

		// unchecked
		function() {
			disableChangeEvent = true;
			checkboxes.checked(false);
			disableChangeEvent = false;
			change();
		}
	);

	change();

	return this;
};;/**
 * jquery.classManip
 * Utilities to manipulate classnames.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * $.fn.switchClass
 * Swaps a classname for another classname that bears identical prefix.
 *
 * $("div").switchClass("state-busy")l;
 *
 * Before:
 * <div class="state-idle"></div>
 *
 * After:
 * <div class="state-busy"></div>
 */
$.fn.switchClass = function(classname, delimiter){

	var delimiter = delimiter || "-",
		prefix = classname.split(delimiter)[0] + delimiter,
		length = prefix.length;

	return this.each(function(){

		var $el = $(this),
			classnames =
				$.map(($el.attr("class") || "").split(" "), function(classname){
					return (classname.slice(0, length)==prefix || classname=="") ? null : classname;
				});
			classnames.push(classname);

		$el.attr("class", classnames.join(" "));
	});
};

/**
 * $.fn.activateClass
 * Add classname on current set of elements and
 * remove classname on previous set of elements.
 *
 * $(".item").find("[data-id=64]").activateClass("active");
 *
 * Before:
 * <div class="item active" data-id="62"></div>
 * <div class="item" data-id="63"></div>
 * <div class="item" data-id="64"></div>
 *
 * After:
 * <div class="item" data-id="62"></div>
 * <div class="item" data-id="63"></div>
 * <div class="item active" data-id="64"></div>
 */
$.fn.activateClass = function(className) {
	this.prevObject.removeClass(className);
	return $(this).addClass(className);
};;/**
 * jquery.color
 * Color helpers.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */
(function(){

var hexToRgb = function(hex) {
	var hex = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
	return {r: hex >> 16, g: (hex & 0x00FF00) >> 8, b: (hex & 0x0000FF)};
};

var hexToHsb = function(hex) {
	return rgbToHsb(hexToRgb(hex));
};

var rgbToHsb = function(rgb) {
	var hsb = {h: 0, s: 0, b: 0};
	var min = Math.min(rgb.r, rgb.g, rgb.b);
	var max = Math.max(rgb.r, rgb.g, rgb.b);
	var delta = max - min;
	hsb.b = max;
	hsb.s = max != 0 ? 255 * delta / max : 0;
	if (hsb.s != 0) {
		if (rgb.r == max) hsb.h = (rgb.g - rgb.b) / delta;
		else if (rgb.g == max) hsb.h = 2 + (rgb.b - rgb.r) / delta;
		else hsb.h = 4 + (rgb.r - rgb.g) / delta;
		hsb.h *= 60;
	} else hsb.h = 360;
	if (hsb.h < 0) hsb.h += 360;
	hsb.s *= 100/255;
	hsb.b *= 100/255;
	return hsb;
};

var hsbToRgb = function(hsb) {
	var rgb = {};
	var h = hsb.h;
	var s = hsb.s*255/100;
	var v = hsb.b*255/100;
	if(s == 0) {
		rgb.r = rgb.g = rgb.b = v;
	} else {
		var t1 = v;
		var t2 = (255-s)*v/255;
		var t3 = (t1-t2)*(h%60)/60;
		if(h==360) h = 0;
		if(h<60) {rgb.r=t1; rgb.b=t2; rgb.g=t2+t3}
		else if(h<120) {rgb.g=t1; rgb.b=t2; rgb.r=t1-t3}
		else if(h<180) {rgb.g=t1; rgb.r=t2; rgb.b=t2+t3}
		else if(h<240) {rgb.b=t1; rgb.r=t2; rgb.g=t1-t3}
		else if(h<300) {rgb.b=t1; rgb.g=t2; rgb.r=t2+t3}
		else if(h<360) {rgb.r=t1; rgb.g=t2; rgb.b=t1-t3}
		else {rgb.r=0; rgb.g=0; rgb.b=0}
	}
	return {r:Math.round(rgb.r), g:Math.round(rgb.g), b:Math.round(rgb.b)};
};

var rgbToHex = function(rgb) {
	var hex = [
		rgb.r.toString(16),
		rgb.g.toString(16),
		rgb.b.toString(16)
	];
	$.each(hex, function (nr, val) {
		if (val.length == 1) {
			hex[nr] = '0' + val;
		}
	});
	return hex.join('');
};

var hsbToHex = function (hsb) {
	return rgbToHex(hsbToRgb(hsb));
};

var fixHsb = function (hsb) {
	return {
		h: Math.min(360, Math.max(0, hsb.h)),
		s: Math.min(100, Math.max(0, hsb.s)),
		b: Math.min(100, Math.max(0, hsb.b))
	};
};

var fixRgb = function (rgb) {
	return {
		r: Math.min(255, Math.max(0, rgb.r)),
		g: Math.min(255, Math.max(0, rgb.g)),
		b: Math.min(255, Math.max(0, rgb.b))
	};
};

var fixHex = function (hex) {
	var len = 6 - hex.length;

	if (len == 3) {
		var chars = hex.split(""), chr, hex = "";
		while (chr = chars.shift()) hex += chr + chr;
	} else {
		while (len--) hex = "0" + hex;
	}

	hex.replace(/[^A-Fa-f0-9]/g, "0");

	return hex;
};

$.extend($, {
	hexToRgb: hexToRgb,
	hexToHsb: hexToHsb,
	rgbToHsb: rgbToHsb,
	hsbToRgb: hsbToRgb,
	rgbToHex: rgbToHex,
	hsbToHex: hsbToHex,
	fixHsb: fixHsb,
	fixRgb: fixRgb,
	fixHex: fixHex
});

})();;;/**
 * jquery.fn.htmlData
 * Utilities to handle data within jQuery elements.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * jquery.fn.htmlData
 * Converts inline data attributes into objects.
 */
$.fn.htmlData = function(prefix, nested) {

	var nested = nested===undefined ? true : nested,
		re = new RegExp("^" + "data-" + (prefix ? prefix + "-" : "") + "(.*)", "i"),
		parts,
		data = {};

	if (this.length <= 0) {
		return {};
	}

	// Extract options from data attributes
	$.each(this[0].attributes, function(i, attr){

		if (attr.specified && (parts = attr.name.match(re)) && parts[1]) {
			if (nested) {
				var props = parts[1].split("-"),
					i, prop, obj = data; max = props.length - 1;

				for (i=0; i<=max; i++) {
					prop = props[i];
					if (i==max) {
						obj[prop] = attr.value;
					} else {
						!obj[prop] && (obj[prop] = {});
						obj = obj[prop];
					}
				}
			} else {
				data[parts[1]] = attr.value;
			}
		}
	});

	return data;
};

/**
 * jquery.fn.defineData
 * Creates persistent data that cannot be changed.
 */
$.fn.defineData = function(name, value) {

	if (this.data(name)===undefined) {
		this.data(name, value);
	}

	return this;
};/**
 * jquery.deletes
 * Remove properties from objects.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.deletes = function(obj, props) {
	$.each(props, function(i, prop){
		delete obj[prop];
	});
};
;/**
 * jquery.fn.disabled
 * jquery.fn.enabled
 *
 * Determine if an element is disabled.
 * Also lets you disable or enable an element.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */


$.fn.disabled = function(state) {
	return (state===undefined) ?
				(this.is(":disabled") || this.hasClass('disabled')) :
				this.prop('disabled', !!state).toggleClass("disabled", !!state);
};

$.fn.enabled = function(state) {
	return (state===undefined) ? !this.disabled() : this.disabled(!state);
};
;/**
 * jquery.distinct
 * Enhanced version of jQuery.unique that also removes
 * removes object/string/integer duplicates within an array.
 * https://github.com/jstonne/jquery.distinct
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.distinct = function(items) {

	var uniqueElements = $.unique;

	if (items.length < 1) {
		return;
	};

	// If item is an array of DOM elements
	if (items[0].nodeType) {

		return uniqueElements.apply(this, arguments);
	};

	// If item is an array of objects
	if (typeof items[0]=='object') {

		var unique = Math.random(),
			uniqueObjects = [];

		$.each(items, function(i) {

			if (!items[i][unique]) {

				uniqueObjects.push(items[i]);

				items[i][unique] = true;
			}
		});

		$.each(uniqueObjects, function(i) {

			delete uniqueObjects[i][unique];
		});

		return uniqueObjects;
	};

	// Anything else (can be combination of string, integers and boolean)
	return $.grep(items, function(item, i) {

		return $.inArray(item, items) === i;
	});

};
;/**
 * jquery.fn.domManip
 * Shorthands for common DOM operations.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.tagName = function(){
	return (this[0] || {}).tagName;
};

$.create = function(tagName) {
	return $(document.createElement(tagName));
};

$.fn.editable = function(editable) {
	if ($.isUndefined(editable)) return this.prop("contenteditable")==="true";
	this.prop("contenteditable", editable);
	editable===false && this.removeAttr("contenteditable");
	return this;
};/**
 * jquery.download
 * Simulate a download programatically.
 *
 * The download url should return the correct
 * Content-Type in the response headers to work.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.download = function(src) {
	return $("<iframe>").hide().appendTo("body").bind("load", function(){$(this).remove()}).attr("src", src);
};;/**
 * jquery.eventManip
 * Utilities to handle events in jQuery.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * jquery.ns
 * Adds namespace to events.
 * $(el).on($.ns("mousedown keyup keydown", ".foobar"), function(){});
 */
$.ns = function(event, ns) {
	return event.split(" ").join(ns + " ") + ns;
};


/**
 * jquery.getPointerPosition
 * Get pointer position whether it came from mouse or touch events.
 */
$.getPointerPosition = function(event) {

	return event.type.match("touch") ?
		{
			x: event.originalEvent.changedTouches[0].pageX,
			y: event.originalEvent.changedTouches[0].pageY
		} :
		{
			x: event.pageX,
			y: event.pageY
		};
};;/**
 * jquery.eventable
 * Extend objects with simple event system.
 *
 * Requires jquery.deletes.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function() {

	var instance = "___eventable",
		publicMethods = ["on", "off", "fire"],
		getEventName = function(name){
			return name.split(".")[0];
		};

	var Eventable = function(mode) {
		this.fnList = {};
		this.events = {};
		this.mode = mode;
	}

	$.extend(
		Eventable.prototype,
		{
			createEvent: function(name) {

				return this.events[name] = $.Callbacks(this.mode);
			},

			on: function(name, fn) {

				if (!name || !$.isFunction(fn)) return this;

				var fnList = this.fnList;

				(fnList[name] || (fnList[name] = [])).push(fn);

				// Translate into base event name
				var basename = getEventName(name);

				// Add the event
				(this.events[basename] || this.createEvent(basename)).add(fn);

				return this;
			},

			off: function(name) {

				if (!name) return this;

				var basename = getEventName(name),
					event = this.events[basename];

				if (!event) return this;

				var removeCallbacks = function(fnList) {

					$.each(fnList, function(i, fn) {
						event.remove(fn);
					});
				}

				if (basename!==name) {

					$.each(this.fnList, function(name, fnList) {

						if (name.indexOf(basename) > -1) {

							removeCallbacks(fnList);
						}
					});

				} else {

					removeCallbacks(this.fnList[name]);
				}

				return this;
			},

			fire: function(name) {

				var event = this.events[name];

				if (!event) return;

				event.fire.apply(event, $.makeArray(arguments).slice(1));

				return this;
			},

			destroy: function() {
				for (name in this.events) {
					this.events[name].disable();
				}
			}
		}
	);

	$.eventable = function(obj, mode) {

		var eventable = obj[instance];

		if (eventable && mode==="destroy") {
			eventable.destroy();
			$.deletes(obj, publicMethods);
			return delete obj[instance];
		}

		eventable = obj[instance] = new Eventable(mode);

		obj.on = $.proxy(eventable.on, eventable);
		obj.off = $.proxy(eventable.off, eventable);
		obj.fire = $.proxy(eventable.fire, eventable);

		return obj;
	}

})();
;/**
 * jquery.fn.checkList.
 * Multiple checkbox handler.
 *
 * $(e).checkList({
 *    check  : function(){},   // callback when an input is checked
 *    uncheck: function(){},   // callback when an input is unchecked
 *
 *    // returns checked elements & unchecked elements in separate arguments
 *    change : function(checked, unchecked){}
 * })
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.checkList = function(options) {

	var defaultOptions = {
		checkbox: ".checkbox",
		masterCheckbox: ".master-checkbox",
		check: function() {},
		uncheck: function() {},
		change: function() {}
	}

	var options = $.extend({}, defaultOptions, options),
		checkList       = this,
		checkboxes      = checkList.find(options.checkbox),
		masterCheckbox  = checkList.find(options.masterCheckbox),
		disableChangeEvent = false;

	var change = function() {

		if (!disableChangeEvent) {

			var checked = checkboxes.filter(':checked'),
				unchecked = checkboxes.not(':checked');

			if (checked.length < 1) {
				masterCheckbox.removeAttr("checked");
			}

			if (checked.length == checkboxes.length) {
				masterCheckbox.prop("checked", true);
			}

			options.change.call(checkList, checked, unchecked);
		}
	}

	checkboxes.checked(

		// checked
		function() {
			options.check.apply(checkList);
			change();
		},

		// unchecked
		function() {
			options.uncheck.apply(checkList);
			change();
		}
	);

	masterCheckbox.checked(

		// checked
		function() {
			disableChangeEvent = true;
			checkboxes.checked(true);
			disableChangeEvent = false;
			change();
		},

		// unchecked
		function() {
			disableChangeEvent = true;
			checkboxes.checked(false);
			disableChangeEvent = false;
			change();
		}
	);

	change();

	return this;
};/**
 * jquery.fn.checked
 * Checked/unchecked event handler for checkbox & radio button.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.checked = function(checked, unchecked) {

	// Return checked value if no arguments are given;
	if (arguments.length < 1)
		return this.is(':checked');

	this.each(function(i) {

		var input = $(this);

		if (typeof checked == "boolean") {
			input.attr('checked', checked).trigger('change');
			return;
		}

		if (input.is('input[type=checkbox]') || input.is('input[type=radio]')) {
			input
				.off('change.checked')
				.on('change.checked', function() {
					try {
						return (input.is(':checked')) ? checked.apply(input) : unchecked.apply(input);
					} catch(e) {};
				});
		}
	});

	return this;
};
;/**
 * jquery.fn.locate
 * Locate a related child element based on data attribute.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.locate = function(key) {

	var prefix = "data";

	$.each(this[0].attributes, function(i, attr){
		if (attr.specified && attr.value==="$") {
			prefix = attr.name;
			return false;
		}
	});

	return this.find("[" + prefix + "-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + "]");
};
;/**
 * jquery.fn.noscroll
 * Disable scrollbar on elements
 * with the ability to restore it.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

	var props = ["overflow", "overflow-x", "overflow-y"];

	$.fn.noscroll = function(lock) {

		if (lock===undefined) lock = true;

		return this.each(function(){

			var el = $(this),
				overflow = el.data("noscroll");

			// No original overflow values was stored before
			if (!overflow && lock) {

				// Get the original overflow values
				overflow = {};
				$.each(props, function(i, prop){
					overflow[prop] = el.css(prop);
				});

				// Store original values
				el.data("noscroll", overflow);
			}

			if (lock) {
				$.each(props, function(i, prop){
					el.css(prop, "hidden");
				});
			} else {
				overflow && el.css(overflow);
			}
		});
	};

})();
;/**
* Copyright 2012, Digital Fusion
* Licensed under the MIT license.
* http://teamdf.com/jquery-plugins/license/
*
* @author Sam Sehnert
* @desc A small plugin that checks whether elements are within
* the user visible viewport of a web browser.
* only accounts for vertical position, not horizontal.
*/

$.fn.visible = function(partial) {

	var $t = $(this),
		$w = $(window);

	if ($t.length < 1) return;

	var viewTop      = $w.scrollTop(),
		viewBottom   = viewTop + $w.height(),
		_top         = $t.offset().top,
		_bottom      = _top + $t.height(),
		compareTop    = partial === true ? _bottom : _top,
		compareBottom = partial === true ? _top : _bottom;

	return ((compareBottom <= viewBottom) && (compareTop >= viewTop));
};;/**
 * jquery.fn.where
 * Filter jQuery elements by data attributes.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.where = $.fn.filterBy = function(key, val, operator) {

	var operator = operator || "=",
		selector = "[data-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + operator + "'" + val + "']";

	return this.filter(selector);
};
;/**
 * jquery.formManip
 * Utilities to manipulate form elements.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

// For checkboxes and radio buttons
$.fn.checked = function(checked, unchecked) {

	// Return checked value if no arguments are given;
	if (arguments.length < 1)
		return this.is(':checked');

	this.each(function(i) {

		var input = $(this);

		if (typeof checked == "boolean") {
			input.attr('checked', checked).trigger('change');
			return;
		}

		if (input.is('input[type=checkbox]') || input.is('input[type=radio]')) {
			input
				.off('change.checked')
				.on('change.checked', function() {
					try {
						return (input.is(':checked')) ? checked.apply(input) : unchecked.apply(input);
					} catch(e) {};
				});
		}
	});

	return this;
};

// For select boxes
$.fn.selectAll = function() {
	return this.each(function(){this.select()});
};

$.fn.unselect = function() {
	return this.each(function(){
		var input = this,
			value = input.value;
			input.value += " ";
			input.value = value;
	});
};;/**
 * jquery.formSerializers
 * Serializes form values to Object or JSON.
 * Utilities to manipulate html content.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.toObject = $.fn.serializeObject = function() {

	var obj = {};

	$.each($(this).serializeArray(), function(i, prop) {
		if (obj.hasOwnProperty(prop.name)) {
			// Convert it into an array
			if (!$.isArray(obj[prop.name])) {
				obj[prop.name] = [obj[prop.name]];
			}
			obj[prop.name].push(prop.value);
		} else {
			obj[prop.name] = prop.value;
		}
	});

	return obj;
};

$.fn.toJSON = $.fn.serializeJSON = function() {

	return JSON.stringify($(this).serializeObject());
};
;/**
 * jquery.htmlManip
 * Utilities to manipulate html content.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.sanitizeHTML = function(html) {
	return $($.parseHTML(html, document, true)).toHTML();
};

// This also encodes html entities.
$.toHTML = function(str) {
	return $("<div>").html(str).html();
};

$.fn.toHTML = function() {
	return $.toHTML(this.clone());
};

// Based on http://stackoverflow.com/questions/1231770/innerhtml-removes-attribute-quotes-in-internet-explorer
$.toXHTML = function(obj, maintainUppercaseTag) {

	var zz = obj.innerHTML ? String(obj.innerHTML) : obj,
		z  = zz.match(/(<.+[^>])/g);

	if (z) {
		for (var i=0; i<z.length; (i=i+1)) {

			var y,
				zSaved = z[i],
				attrRE = /\=[a-zA-Z\.\:\[\]_\(\)\&\$\%#\@\!0-9\/]+[?\s+|?>]/g;

			z[i] =
				z[i].replace(/([<|<\/].+?\w+).+[^>]/, function(a){
					return a;
				});

			y = z[i].match(attrRE);

			if (y) {
				var j = 0,
					len = y.length;

				while (j < len) {

					var replaceRE = /(\=)([a-zA-Z\.\:\[\]_\(\)\&\$\%#\@\!0-9\/]+)?([\s+|?>])/g,
						replacer = function() {
							var args = Array.prototype.slice.call(arguments);
							return '="' + (maintainUppercaseTag ? args[2] : args[2].toLowerCase()) + '"' + args[3];
						};

					z[i] = z[i].replace(y[j], y[j].replace(replaceRE,replacer));
					j += 1;
				}
			}

			zz = zz.replace(zSaved,z[i]);
		}
	}

	return zz;
};

$.fn.xhtml = function() {
	return $.IE ? $.toXHTML(this[0]) : this.html();
};

/**
 * jquery.buildHTML
 * Converts html string into jQuery element where
 * script tags within it gets removed after it is
 * inserted into the DOM.
 *
 * Using $.buildHTML(html) over $(html) also circumvents
 * CloudFlare from modifying the execution behaviour of
 * script elements.
 */

$.buildHTML = function(html, keepScripts) {

	// If a jquery element was passed in, return as it is.
	if (html instanceof $) return html;

	var doc = document;

	// If CloudFlare exists, use document from iframe
	// because CloudFlare Rocketscript overrides native methods.
	if (window["CloudFlare"]) {

		var iframe = $.buildHTML.iframe;

		// If iframe wasn't created, or iframe was removed or detached,
		// create the iframe element again;
		if (!iframe || !iframe.contentDocument) {

			// Create iframe
			var iframe =
				$.buildHTML.iframe =
				document.createElement("iframe");

			// Hide iframe
			iframe.style.display = "none";

			// Append iframe to body
			document.body.appendChild(iframe);
		}

		doc = iframe.contentDocument;
	}

	// Trim out any whitespace so no unusable text nodes are introduced.
	var html = $.trim(html),

		// Build html fragment while keeping a separate reference to the script
		scripts = [],
		fragment = $.buildFragment([html], doc, scripts),

		// Convert childNodes into a proper array
		nodes = $.merge([], fragment.childNodes);

	// If we want to remove the script after
	// it is appended to the DOM & executed
	if (!keepScripts && scripts.length > 0) {

		// Create script remover
		var script = doc.createElement("script");
			// This is wrapped in try..catch because Cloudflare's
			// proxy node executes this twice for some reason.
			// The second time this executes, the callback has been removed,
			// so let it fail silently.
			script.text = "try{" + $.callback(function(){$(scripts).remove();}) + "();}catch(e){}";

		// Go through nodes in reverse
		var i = nodes.length-1, node, inserted;

		while (node = nodes[i--]) {

			// If a script node is found first, we'll just append
			// script remover next to it to ensure this last script
			// executes before any script removal happens.
			if (node.nodeName==="SCRIPT") {
				inserted = nodes.push(script);
			} else if (node.nodeType===1) {
				inserted = node.appendChild(script);
			}

			if (inserted) break;
		}

		// If script remover was not inserted,
		// then just add it to the array of nodes
		if (!inserted) nodes.push(script);

		// Add script remover itself to the
		// array of scripts to be removed.
		scripts.push(script);
	}

	// Convert nodes into jquery instance and return
	return $(nodes);
};;/**
 * jquery.intersects
 * jquery.fn.intersectsWith
 *
 * Determines if an area intersects with another area.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.intersects = function(a, b) {

	if ($.isArray(b)) {
	   b = {top: b.y, left: b.x, bottom: b.y, right: b.x}
	}

	return (
	   b.left <= a.right  &&
	   a.left <= b.right  &&
	   b.top  <= a.bottom &&
	   a.top  <= b.bottom
	);
};

$.fn.intersectsWith = function(top, left, width, height) {

	// TODO: intersectsWith(element)

	var offset = this.offset(),

	   reference = {
			top   : offset.top,
			left  : offset.left,
			bottom: offset.top  + (sourceHeight = this.height()),
			right : offset.left + (sourceWidth  = this.width()),
			width : sourceWidth,
			height: sourceHeight
	   },

	   subject = {
			top   : top,
			left  : left,
			bottom: top  + (height || (height = 0)),
			right : left + (width  || (width  = 0)),
			width : width,
			height: height
	   };

	return ($.intersects(reference, subject)) ? {reference: reference, subject: subject} : false;
};;/**
 * jquery.isDeferred
 * Test if an object is a jQuery Deferred object.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.isDeferred = function(obj) {
	return obj && $.isFunction(obj.always);
};
;/**
 * jquery.number
 * Utilities to deal with numbers.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.isNumeric = function(n) {
	// http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
	return !isNaN(parseFloat(n)) && isFinite(n);
};

$.rotateNumber = function(n, min, max, offset) {

	if (offset===undefined) {
		offset = 0;
	}

	n += offset;

	if (n < min) {
		n += max + 1;
	} else if (n > max) {
		n -= max + 1;
	}

	return n;
};;/**
 * jquery.regExpEscape
 * Makes string regex safe.
 * http://stackoverflow.com/questions/2593637/how-to-escape-regular-expression-in-javascript
 */

$.regExpEscape = function(str) {
	return str.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
}
;/**
 * jquery.remap
 * Utility for remapping properties of an object selectively from another object.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.remap = function(to, from, props) {
	$.each(props, function(i, prop){
		to[prop] = from[prop];
	});
	return obj;
};
;/**
 * jquery.throttledAjax
 * jQuery AJAX with throttling.
 *
 * Requires jquery.Threads.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

var self = $.Ajax = function(options) {

	// Start ajax manually
	options.autostart = false;

	var ajax = $.ajax(options);

	if ('function' == typeof ajax.send) {
		self.queue
			.addDeferred(function(queue){

				// Start ajax now
				ajax.send();

				// Mark this queue as resolved
				setTimeout(queue.resolve, self.interval);
			});
	}

	return ajax;
}

self.queue    = $.Threads({threadLimit: 1});
self.interval = 1200;

self.interval = 0;

})();

/*!
 * jquery.transitionClass.
 * jQuery functions to invoke classnames that has CSS3 transitions.
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

// addTransitoryClass
$.fn.addTransitoryClass = function(classname, duration) {
	var elem = this.addClass(classname);
	setTimeout(function(){elem.removeClass(classname)}, duration || 1);
	return this;
};

// addClassAfter
// removeClassAfter
var classAfter = function(operation, classname, timer) {
	var elem = this;
	setTimeout(function(){elem[operation+"Class"](classname)}, timer || 50);
	return this;
};

$.fn.addClassAfter = function(classname, timer) {
	return classAfter.call(this, "add", classname, timer);
};

$.fn.removeClassAfter = function(classname, timer) {
	return classAfter.call(this, "remove", classname, timer);
};

// addTransitionClass
// removeTransitionClass
var transitionClass = function(toggle, classname, duration, callback) {
	var suffix = toggle ? "-in" : "-out";
	this.addTransitoryClass(classname.replace(/ /g, suffix + " ") + suffix, duration || 1000)
		[(toggle ? "add" : "remove") + "ClassAfter"](classname);
	callback && setTimeout(callback, duration);
	return this;
};

$.fn.addTransitionClass = function(classname, duration, callback) {
	return transitionClass.call(this, true, classname, duration, callback);
};

$.fn.removeTransitionClass = function(classname, duration, callback) {
	return transitionClass.call(this, false, classname, duration, callback);
};

})();;/**
 * jquery.trimSeparators
 * Trims whitespace and separators.
 *
 * Turns this: ",df        ,,,  ,,,abc, sdasd sdfsdf    ,   asdsad, ,, , "
 * into this : "df,abc,sdasd sdfsdf,asdsad"
 *
 * Requires jquery.distinct
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.trimSeparators = function(keyword, separator, removeDuplicates) {

	var s = separator;

	keyword = keyword
		.replace(new RegExp('^['+s+'\\s]+|['+s+',\\s]+$','g'), '') // /^[,\s]+|[,\s]+$/g
		.replace(new RegExp(s+'['+s+'\\s]*'+s,'g'), s)             // /,[,\s]*,/g
		.replace(new RegExp('[\\s]+'+s,'g'), s)                    // /[\s]+,/g
		.replace(new RegExp(s+'[\\s]+','g'), s);                   // /,[\s]+/g

	if (removeDuplicates) {
		keyword = $.distinct(keyword.split(s)).join(s);
	}

	return keyword;
};
;/**
 * jquery.uid
 * Generates a unique id with optional prefix/suffix.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.uid = function(p,s) {
	return ((p) ? p : '') + Math.random().toString().replace('.','') + ((s) ? s : '');
};

});
FD40.plugin("uri", function($) {

$.isUrl = function(s)
{
	var regexp = /^(http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
	return regexp.test(s);
};


var Query = function (queryString) {

    // query string parsing, parameter manipulation and stringification

    'use strict';

    var // parseQuery(q) parses the uri query string and returns a multi-dimensional array of the components
        parseQuery = function (q) {
            var arr = [], i, ps, p, kvp, k, v;

            if (typeof (q) === 'undefined' || q === null || q === '') {
                return arr;
            }

            if (q.indexOf('?') === 0) {
                q = q.substring(1);
            }

            ps = q.toString().split(/[&;]/);

            for (i = 0; i < ps.length; i++) {
                p = ps[i];
                kvp = p.split('=');
                k = kvp[0];
                v = p.indexOf('=') === -1 ? null : (kvp[1] === null ? '' : kvp[1]);
                arr.push([k, v]);
            }

            return arr;
        },

        params = parseQuery(queryString),

        // toString() returns a string representation of the internal state of the object
        toString = function () {
            var s = '', i, param;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (s.length > 0) {
                    s += '&';
                }
                if (param[1] === null) {
                  s += param[0];
                }
                else {
                  s += param.join('=');
                }
            }
            return s.length > 0 ? '?' + s : s;
        },

        decode = function (s) {
            s = decodeURIComponent(s);
            s = s.replace('+', ' ');
            return s;
        },

        // getParamValues(key) returns the first query param value found for the key 'key'
        getParamValue = function (key) {
            var param, i;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (decode(key) === decode(param[0])) {
                    return param[1];
                }
            }
        },

        // getParamValues(key) returns an array of query param values for the key 'key'
        getParamValues = function (key) {
            var arr = [], i, param;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (decode(key) === decode(param[0])) {
                    arr.push(param[1]);
                }
            }
            return arr;
        },

        // deleteParam(key) removes all instances of parameters named (key)
        // deleteParam(key, val) removes all instances where the value matches (val)
        deleteParam = function (key, val) {

            var arr = [], i, param, keyMatchesFilter, valMatchesFilter;

            for (i = 0; i < params.length; i++) {

                param = params[i];
                keyMatchesFilter = decode(param[0]) === decode(key);
                valMatchesFilter = decode(param[1]) === decode(val);

                if ((arguments.length === 1 && !keyMatchesFilter) || (arguments.length === 2 && !keyMatchesFilter && !valMatchesFilter)) {
                    arr.push(param);
                }
            }

            params = arr;

            return this;
        },

        // addParam(key, val) Adds an element to the end of the list of query parameters
        // addParam(key, val, index) adds the param at the specified position (index)
        addParam = function (key, val, index) {

            if (arguments.length === 3 && index !== -1) {
                index = Math.min(index, params.length);
                params.splice(index, 0, [key, val]);
            } else if (arguments.length > 0) {
                params.push([key, val]);
            }
            return this;
        },

        // replaceParam(key, newVal) deletes all instances of params named (key) and replaces them with the new single value
        // replaceParam(key, newVal, oldVal) deletes only instances of params named (key) with the value (val) and replaces them with the new single value
        // this function attempts to preserve query param ordering
        replaceParam = function (key, newVal, oldVal) {

            var index = -1, i, param;

            if (arguments.length === 3) {
                for (i = 0; i < params.length; i++) {
                    param = params[i];
                    if (decode(param[0]) === decode(key) && decodeURIComponent(param[1]) === decode(oldVal)) {
                        index = i;
                        break;
                    }
                }
                deleteParam(key, oldVal).addParam(key, newVal, index);
            } else {
                for (i = 0; i < params.length; i++) {
                    param = params[i];
                    if (decode(param[0]) === decode(key)) {
                        index = i;
                        break;
                    }
                }
                deleteParam(key);
                addParam(key, newVal, index);
            }
            return this;
        };

    // public api
    return {
        getParamValue: getParamValue,
        getParamValues: getParamValues,
        deleteParam: deleteParam,
        addParam: addParam,
        replaceParam: replaceParam,

        toString: toString
    };
};
var Uri = function (uriString) {

    // uri string parsing, attribute manipulation and stringification

    'use strict';

    /*global Query: true */
    /*jslint regexp: false, plusplus: false */

    var strictMode = false,

        urlExtractor = /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&\/\/=]*)?/gi,

        // parseUri(str) parses the supplied uri and returns an object containing its components
        parseUri = function (str) {

            /*jslint unparam: true */
            var parsers = {
                    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
                },
                keys = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                q = {
                    name: "queryKey",
                    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                },
                m = parsers[strictMode ? "strict" : "loose"].exec(str),
                uri = {},
                i = 14;

            while (i--) {
                uri[keys[i]] = m[i] || "";
            }

            uri[q.name] = {};
            uri[keys[12]].replace(q.parser, function ($0, $1, $2) {
                if ($1) {
                    uri[q.name][$1] = $2;
                }
            });

            return uri;
        },

        uriParts = parseUri(uriString || ''),

        queryObj = new Query(uriParts.query),


        /*
            Basic get/set functions for all properties
        */

        protocol = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.protocol = val;
            }
            return uriParts.protocol;
        },

        hasAuthorityPrefixUserPref = null,

        // hasAuthorityPrefix: if there is no protocol, the leading // can be enabled or disabled
        hasAuthorityPrefix = function (val) {

            if (typeof val !== 'undefined') {
                hasAuthorityPrefixUserPref = val;
            }

            if (hasAuthorityPrefixUserPref === null) {
                return (uriParts.source.indexOf('//') !== -1);
            } else {
                return hasAuthorityPrefixUserPref;
            }
        },

        userInfo = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.userInfo = val;
            }
            return uriParts.userInfo;
        },

        host = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.host = val;
            }
            return uriParts.host;
        },

        port = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.port = val;
            }
            return uriParts.port;
        },

        path = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.path = val;
            }
            return uriParts.path;
        },

        query = function (val) {
            if (typeof val !== 'undefined') {
                queryObj = new Query(val);
            }
            return queryObj;
        },

        anchor = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.anchor = val;
            }
            return uriParts.anchor;
        },


        /*
            Fluent setters for Uri uri properties
        */

        setProtocol = function (val) {
            protocol(val);
            return this;
        },

        setHasAuthorityPrefix = function (val) {
            hasAuthorityPrefix(val);
            return this;
        },

        setUserInfo = function (val) {
            userInfo(val);
            return this;
        },

        setHost = function (val) {
            host(val);
            return this;
        },

        setPort = function (val) {
            port(val);
            return this;
        },

        setPath = function (val) {
            path(val);
            return this;
        },

        setQuery = function (val) {
            query(val);
            return this;
        },

        setAnchor = function (val) {
            anchor(val);
            return this;
        },

        /*
            Query method wrappers
        */
        getQueryParamValue = function (key) {
            return query().getParamValue(key);
        },

        getQueryParamValues = function (key) {
            return query().getParamValues(key);
        },

        deleteQueryParam = function (key, val) {
            if (arguments.length === 2) {
                query().deleteParam(key, val);
            } else {
                query().deleteParam(key);
            }

            return this;
        },

        addQueryParam = function (key, val, index) {
            if (arguments.length === 3) {
                query().addParam(key, val, index);
            } else {
                query().addParam(key, val);
            }
            return this;
        },

        replaceQueryParam = function (key, newVal, oldVal) {
            if (arguments.length === 3) {
                query().replaceParam(key, newVal, oldVal);
            } else {
                query().replaceParam(key, newVal);
            }

            return this;
        },

        /*
            Converters
        */

        // toPath() converts a relative path into its absolute path, e.g.
        //
        // Current path:  /foo/bar/today
        // Relative path: ../tomorrow
        // Result:        /foo/bar/tomorrow

        toPath = function (val) {
            if (val===undefined) {
                return uriParts.path;
            }

            // If relative path starts with '/'
            if (val.substring(0,1)=='/') {
                return uriParts.path = val;
            }

            var base_path = uriParts.path.split('/'),
                rel_path = val.split('/');

            if (base_path.slice(-1)[0]==='') {
                base_path.pop();
            }

            var part;
            while (part = rel_path.shift()) {
                switch (part) {
                    case '..':
                        if (base_path.length > 1) {
                            base_path.pop();
                        }
                        break;

                    case '.':
                        // skip
                        break;

                    default:
                        base_path.push(part);
                }
            }

            uriParts.path = base_path.join('/');

            return this;
        },

        /*
            Serialization
        */

        // toString() stringifies the current state of the uri
        toString = function () {

            var s = '',
                is = function (s) {
                    return (s !== null && s !== '');
                };

            if (is(protocol())) {
                s += protocol();
                if (protocol().indexOf(':') !== protocol().length - 1) {
                    s += ':';
                }
                s += '//';
            } else {
                if (hasAuthorityPrefix() && is(host())) {
                    s += '//';
                }
            }

            if (is(userInfo()) && is(host())) {
                s += userInfo();
                if (userInfo().indexOf('@') !== userInfo().length - 1) {
                    s += '@';
                }
            }

            if (is(host())) {
                s += host();
                if (is(port())) {
                    s += ':' + port();
                }
            }

            if (is(path())) {
                s += path();
            } else {
                if (is(host()) && (is(query().toString()) || is(anchor()))) {
                    s += '/';
                }
            }
            if (is(query().toString())) {
                if (query().toString().indexOf('?') !== 0) {
                    s += '?';
                }
                s += query().toString();
            }

            if (is(anchor())) {
                if (anchor().indexOf('#') !== 0) {
                    s += '#';
                }
                s += anchor();
            }

            return s;
        },

        extract = function(i) {
            var urls = uriString.match(urlExtractor) || [];
            return (i===undefined) ? urls : (urls[i] || "");
        },

        /*
            Cloning
        */

        // clone() returns a new, identical Uri instance
        clone = function () {
            return new Uri(toString());
        };

    // public api
    return {

        protocol: protocol,
        hasAuthorityPrefix: hasAuthorityPrefix,
        userInfo: userInfo,
        host: host,
        port: port,
        path: path,
        query: query,
        anchor: anchor,

        setProtocol: setProtocol,
        setHasAuthorityPrefix: setHasAuthorityPrefix,
        setUserInfo: setUserInfo,
        setHost: setHost,
        setPort: setPort,
        setPath: setPath,
        setQuery: setQuery,
        setAnchor: setAnchor,

        getQueryParamValue: getQueryParamValue,
        getQueryParamValues: getQueryParamValues,
        deleteQueryParam: deleteQueryParam,
        addQueryParam: addQueryParam,
        replaceQueryParam: replaceQueryParam,
        extract: extract,

        toPath: toPath,

        toString: toString,
        clone: clone
    };
};
$.uri = function (s) {
    return new Uri(s);
}

});FD40.plugin("mvc", function($) {

(function(){
    // Several of the methods in this plugin use code adapated from Prototype
    //  Prototype JavaScript framework, version 1.6.0.1
    //  (c) 2005-2007 Sam Stephenson
    var regs = {
        undHash: /_|-/,
        colons: /::/,
        words: /([A-Z]+)([A-Z][a-z])/g,
        lowUp: /([a-z\d])([A-Z])/g,
        dash: /([a-z\d])([A-Z])/g,
        replacer: /\{([^\}]+)\}/g,
        dot: /\./
    },
        // gets the nextPart property from current
        // add - if true and nextPart doesnt exist, create it as an empty object
        getNext = function(current, nextPart, add){
            return current[nextPart] !== undefined ? current[nextPart] : ( add && (current[nextPart] = {}) );
        },
        // returns true if the object can have properties (no nulls)
        isContainer = function(current){
            var type = typeof current;
            return current && ( type == 'function' || type == 'object' );
        },
        // a reference
        getObject,
        /**
         * @class jQuery.String
         * @parent jquerymx.lang
         *
         * A collection of useful string helpers. Available helpers are:
         * <ul>
         *   <li>[jQuery.String.capitalize|capitalize]: Capitalizes a string (some_string &raquo; Some_string)</li>
         *   <li>[jQuery.String.camelize|camelize]: Capitalizes a string from something undercored
         *       (some_string &raquo; someString, some-string &raquo; someString)</li>
         *   <li>[jQuery.String.classize|classize]: Like [jQuery.String.camelize|camelize],
         *       but the first part is also capitalized (some_string &raquo; SomeString)</li>
         *   <li>[jQuery.String.niceName|niceName]: Like [jQuery.String.classize|classize], but a space separates each 'word' (some_string &raquo; Some String)</li>
         *   <li>[jQuery.String.underscore|underscore]: Underscores a string (SomeString &raquo; some_string)</li>
         *   <li>[jQuery.String.sub|sub]: Returns a string with {param} replaced values from data.
         *       <code><pre>
         *       $.String.sub("foo {bar}",{bar: "far"})
         *       //-> "foo far"</pre></code>
         *   </li>
         * </ul>
         *
         */

        str = $.String = $.extend($.String || {} , {


            /**
             * @function getObject
             * Gets an object from a string.  It can also modify objects on the
             * 'object path' by removing or adding properties.
             *
             *     Foo = {Bar: {Zar: {"Ted"}}}
             *     $.String.getObject("Foo.Bar.Zar") //-> "Ted"
             *
             * @param {String} name the name of the object to look for
             * @param {Array} [roots] an array of root objects to look for the
             *   name.  If roots is not provided, the window is used.
             * @param {Boolean} [add] true to add missing objects to
             *  the path. false to remove found properties. undefined to
             *  not modify the root object
             * @return {Object} The object.
             */
            getObject : getObject = function( name, roots, add ) {

                // the parts of the name we are looking up
                // ['App','Models','Recipe']
                var parts = name ? name.split(regs.dot) : [],
                    length =  parts.length,
                    current,
                    ret,
                    i,
                    r = 0,
                    type;

                // make sure roots is an array
                roots = $.isArray(roots) ? roots : [roots || window];

                if(length == 0){
                    return roots[0];
                }
                // for each root, mark it as current
                while( current = roots[r++] ) {
                    // walk current to the 2nd to last object
                    // or until there is not a container
                    for (i =0; i < length - 1 && isContainer(current); i++ ) {
                        current = getNext(current, parts[i], add);
                    }
                    // if we can get a property from the 2nd to last object
                    if( isContainer(current) ) {

                        // get (and possibly set) the property
                        ret = getNext(current, parts[i], add);

                        // if there is a value, we exit
                        if( ret !== undefined ) {
                            // if add is false, delete the property
                            if ( add === false ) {
                                delete current[parts[i]];
                            }
                            return ret;

                        }
                    }
                }
            },
            /**
             * Capitalizes a string
             * @param {String} s the string.
             * @return {String} a string with the first character capitalized.
             */
            capitalize: function( s, cache ) {
                return s.charAt(0).toUpperCase() + s.substr(1);
            },
            /**
             * Capitalizes a string from something undercored. Examples:
             * @codestart
             * jQuery.String.camelize("one_two") //-> "oneTwo"
             * "three-four".camelize() //-> threeFour
             * @codeend
             * @param {String} s
             * @return {String} a the camelized string
             */
            camelize: function( s ) {
                s = str.classize(s);
                return s.charAt(0).toLowerCase() + s.substr(1);
            },
            /**
             * Like [jQuery.String.camelize|camelize], but the first part is also capitalized
             * @param {String} s
             * @return {String} the classized string
             */
            classize: function( s , join) {
                var parts = s.split(regs.undHash),
                    i = 0;
                for (; i < parts.length; i++ ) {
                    parts[i] = str.capitalize(parts[i]);
                }

                return parts.join(join || '');
            },
            /**
             * Like [jQuery.String.classize|classize], but a space separates each 'word'
             * @codestart
             * jQuery.String.niceName("one_two") //-> "One Two"
             * @codeend
             * @param {String} s
             * @return {String} the niceName
             */
            niceName: function( s ) {
                return str.classize(s,' ');
            },

            /**
             * Underscores a string.
             * @codestart
             * jQuery.String.underscore("OneTwo") //-> "one_two"
             * @codeend
             * @param {String} s
             * @return {String} the underscored string
             */
            underscore: function( s ) {
                return s.replace(regs.colons, '/').replace(regs.words, '$1_$2').replace(regs.lowUp, '$1_$2').replace(regs.dash, '_').toLowerCase();
            },
            /**
             * Returns a string with {param} replaced values from data.
             *
             *     $.String.sub("foo {bar}",{bar: "far"})
             *     //-> "foo far"
             *
             * @param {String} s The string to replace
             * @param {Object} data The data to be used to look for properties.  If it's an array, multiple
             * objects can be used.
             * @param {Boolean} [remove] if a match is found, remove the property from the object
             */
            sub: function( s, data, remove ) {
                var obs = [];
                obs.push(s.replace(regs.replacer, function( whole, inside ) {

                    // !-- FOUNDRY HACK --! //
                    // Prefer {foobar} over foobar

                    //convert inside to type
                    var ob = getObject(whole, data, typeof remove == 'boolean' ? !remove : remove) ||
                             getObject(inside, data, typeof remove == 'boolean' ? !remove : remove),
                        type = typeof ob;

                    if ((type === 'object' || type === 'function') && type !== null) {
                        obs.push(ob);
                        return "";
                    } else {
                        return ""+ob;
                    }
                }));
                return obs.length <= 1 ? obs[0] : obs;
            },
            _regs : regs
        });

    // !-- FOUNDRY HACK --! //
    // Expose string methods to $.
    $.extend($, str);
})();(function(){
    /**
     * @add jQuery.String
     */
    $.String.
    /**
     * Splits a string with a regex correctly cross browser
     * 
     *     $.String.rsplit("a.b.c.d", /\./) //-> ['a','b','c','d']
     * 
     * @param {String} string The string to split
     * @param {RegExp} regex A regular expression
     * @return {Array} An array of strings
     */
    rsplit = function( string, regex ) {
        var result = regex.exec(string),
            retArr = [],
            first_idx, last_idx;
        while ( result !== null ) {
            first_idx = result.index;
            last_idx = regex.lastIndex;
            if ( first_idx !== 0 ) {
                retArr.push(string.substring(0, first_idx));
                string = string.slice(first_idx);
            }
            retArr.push(result[0]);
            string = string.slice(result[0].length);
            result = regex.exec(string);
        }
        if ( string !== '' ) {
            retArr.push(string);
        }
        return retArr;
    };
})();(function(){
    
    var digitTest = /^\d+$/,
        keyBreaker = /([^\[\]]+)|(\[\])/g,
        plus = /\+/g,
        paramTest = /([^?#]*)(#.*)?$/;
    
    /**
     * @add jQuery.String
     */
    $.String = $.extend($.String || {}, { 
        
        /**
         * @function deparam
         * 
         * Takes a string of name value pairs and returns a Object literal that represents those params.
         * 
         * @param {String} params a string like <code>"foo=bar&person[age]=3"</code>
         * @return {Object} A JavaScript Object that represents the params:
         * 
         *     {
         *       foo: "bar",
         *       person: {
         *         age: "3"
         *       }
         *     }
         */
        deparam: function(params){
        
            if(! params || ! paramTest.test(params) ) {
                return {};
            } 
           
        
            var data = {},
                pairs = params.split('&'),
                current;
                
            for(var i=0; i < pairs.length; i++){
                current = data;
                var pair = pairs[i].split('=');
                
                // if we find foo=1+1=2
                if(pair.length != 2) { 
                    pair = [pair[0], pair.slice(1).join("=")]
                }
                  
        var key = decodeURIComponent(pair[0].replace(plus, " ")), 
          value = decodeURIComponent(pair[1].replace(plus, " ")),
                    parts = key.match(keyBreaker);
        
                for ( var j = 0; j < parts.length - 1; j++ ) {
                    var part = parts[j];
                    if (!current[part] ) {
                        // if what we are pointing to looks like an array
                        current[part] = digitTest.test(parts[j+1]) || parts[j+1] == "[]" ? [] : {}
                    }
                    current = current[part];
                }
                lastPart = parts[parts.length - 1];
                if(lastPart == "[]"){
                    current.push(value)
                }else{
                    current[lastPart] = value;
                }
            }
            return data;
        }
    });
    
})();(function(){
    /**
     * @attribute destroyed
     * @parent specialevents
     * @download  http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/dom/destroyed/destroyed.js
     * @test jquery/event/destroyed/qunit.html
     * Provides a destroyed event on an element.
     * <p>
     * The destroyed event is called when the element
     * is removed as a result of jQuery DOM manipulators like remove, html,
     * replaceWith, etc. Destroyed events do not bubble, so make sure you don't use live or delegate with destroyed
     * events.
     * </p>
     * <h2>Quick Example</h2>
     * @codestart
     * $(".foo").bind("destroyed", function(){
     *    //clean up code
     * })
     * @codeend
     * <h2>Quick Demo</h2>
     * @demo jquery/event/destroyed/destroyed.html
     * <h2>More Involved Demo</h2>
     * @demo jquery/event/destroyed/destroyed_menu.html
     */

    var oldClean = $.cleanData;

    $.cleanData = function( elems ) {
        for ( var i = 0, elem;
        (elem = elems[i]) !== undefined; i++ ) {
            $(elem).triggerHandler("destroyed");
            //$.event.remove( elem, 'destroyed' );
        }
        oldClean(elems);
    };

})();(function(){
    /**
     * @function closest
     * @parent dom
     * @plugin jquery/dom/closest
     * Overwrites closest to allow open > selectors.  This allows controller
     * actions such as:
     *
     *     ">li click" : function( el, ev ) { ... }
     */
    var oldClosest = $.fn._closest = $.fn.closest;
    $.fn.closest = function(selectors, context){

        // FOUNDRY_HACK
        // If a jQuery or node element was passed in, use original closest method.
        if (selectors instanceof $ || $.isElement(selectors)) {
            return oldClosest.call(this, arguments);
        }

        var rooted = {}, res, result, thing, i, j, selector, rootedIsEmpty = true, selector, selectorsArr = selectors;
        if(typeof selectors == "string") selectorsArr = [selectors];

        $.each(selectorsArr, function(i, selector){
            if(selector.indexOf(">") == 0 ){
                if(selector.indexOf(" ") != -1){
                    throw " closest does not work with > followed by spaces!"
                }
                rooted[( selectorsArr[i] = selector.substr(1)  )] = selector;
                if(typeof selectors == "string") selectors = selector.substr(1);
                rootedIsEmpty = false;
            }
        })

        res = oldClosest.call(this, selectors, context);

        if(rootedIsEmpty) return res;
        i =0;
        while(i < res.length){
            result = res[i], selector = result.selector;
            if (rooted[selector] !== undefined) {
                result.selector = rooted[selector];
                rooted[selector] = false;
                if(typeof result.selector !== "string"  || result.elem.parentNode !== context ){
                    res.splice(i,1);
                        continue;
                }
            }
            i++;
        }
        return res;
    }
})();(function(){
    // break
    /**
     * @function jQuery.cookie
     * @parent dom
     * @plugin jquery/dom/cookie
     * @author Klaus Hartl/klaus.hartl@stilbuero.de
     *
     *  JavaScriptMVC's packaged cookie plugin is written by
     *  Klaus Hartl (stilbuero.de)<br />
     *  Dual licensed under the MIT and GPL licenses:<br />
     *  http://www.opensource.org/licenses/mit-license.php<br />
     *  http://www.gnu.org/licenses/gpl.html
     *  </p>
     *  <p>
     *  Create a cookie with the given name and value and other optional parameters.
     *  / Get the value of a cookie with the given name.
     *  </p>
     *  <h3>Quick Examples</h3>
     *
     *  Set the value of a cookie.
     *
     *     $.cookie('the_cookie', 'the_value');
     *
     *  Create a cookie with all available options.
     *  @codestart
     *  $.cookie('the_cookie', 'the_value',
     *  { expires: 7, path: '/', domain: 'jquery.com', secure: true });
     *  @codeend
     *
     *  Create a session cookie.
     *  @codestart
     *  $.cookie('the_cookie', 'the_value');
     *  @codeend
     *
     *  Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
     *  used when the cookie was set.
     *  @codestart
     *  $.cookie('the_cookie', null);
     *  @codeend
     *
     *  Get the value of a cookie.
     *  @codestart
     *  $.cookie('the_cookie');
     *  @codeend
     *
     *
     * @param {String} [name] The name of the cookie.
     * @param {String} [value] The value of the cookie.
     * @param {Object} [options] An object literal containing key/value pairs to provide optional cookie attributes.<br />
     * @param {Number|Date} [expires] Either an integer specifying the expiration date from now on in days or a Date object.
     *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
     *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
     *                             when the the browser exits.<br />
     * @param {String} [path] The value of the path atribute of the cookie (default: path of page that created the cookie).<br />
     * @param {String} [domain] The value of the domain attribute of the cookie (default: domain of page that created the cookie).<br />
     * @param {Boolean} secure If true, the secure attribute of the cookie will be set and the cookie transmission will
     *                        require a secure protocol (like HTTPS).<br />
     * @return {String} the value of the cookie or {undefined} when setting the cookie.
     */
    $.cookie = function(name, value, options) {
        if (typeof value != 'undefined') { // name and value given, set cookie
            options = options ||
            {};
            if (value === null) {
                value = '';
                options.expires = -1;
            }
            if (typeof value == 'object' && jQuery.toJSON) {
                value = jQuery.toJSON(value);
            }
            var expires = '';
            if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
                var date;
                if (typeof options.expires == 'number') {
                    date = new Date();
                    date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
                }
                else {
                    date = options.expires;
                }
                expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
            }
            // CAUTION: Needed to parenthesize options.path and options.domain
            // in the following expressions, otherwise they evaluate to undefined
            // in the packed version for some reason...
            var path = options.path ? '; path=' + (options.path) : '';
            var domain = options.domain ? '; domain=' + (options.domain) : '';
            var secure = options.secure ? '; secure' : '';
            document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
        }
        else { // only name given, get cookie
            var cookieValue = null;
            if (document.cookie && document.cookie != '') {
                var cookies = document.cookie.split(';');
                for (var i = 0; i < cookies.length; i++) {
                    var cookie = jQuery.trim(cookies[i]);
                    // Does this cookie string begin with the name we want?
                    if (cookie.substring(0, name.length + 1) == (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            if (jQuery.evalJSON && cookieValue && cookieValue.match(/^\s*\{/)) {
                try {
                    cookieValue = jQuery.evalJSON(cookieValue);
                }
                catch (e) {
                }
            }
            return cookieValue;
        }
    };

})();(function(){

    // =============== HELPERS =================

        // if we are initializing a new class
    var initializing = false,
        makeArray = $.makeArray,
        isFunction = $.isFunction,
        isArray = $.isArray,
        extend = $.extend,
        getObject = $.String.getObject,
        concatArgs = function(arr, args){
            return arr.concat(makeArray(args));
        },

        // tests if we can get super in .toString()
        fnTest = /xyz/.test(function() {
            xyz;
        }) ? /\b_super\b/ : /.*/,

        // overwrites an object with methods, sets up _super
        //   newProps - new properties
        //   oldProps - where the old properties might be
        //   addTo - what we are adding to
        inheritProps = function( newProps, oldProps, addTo ) {
            addTo = addTo || newProps
            for ( var name in newProps ) {
                // Check if we're overwriting an existing function
                addTo[name] = isFunction(newProps[name]) &&
                              isFunction(oldProps[name]) &&
                              fnTest.test(newProps[name]) ? (function( name, fn ) {
                    return function() {
                        var tmp = this._super,
                            ret;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = oldProps[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        ret = fn.apply(this, arguments);
                        this._super = tmp;
                        return ret;
                    };
                })(name, newProps[name]) : newProps[name];
            }
        },
        STR_PROTOTYPE = 'prototype'

    /**
     * @class jQuery.Class
     * @plugin jquery/class
     * @parent jquerymx
     * @download dist/jquery/jquery.class.js
     * @test jquery/class/qunit.html
     * @description Easy inheritance in JavaScript.
     *
     * Class provides simulated inheritance in JavaScript. Use clss to bridge the gap between
     * jQuery's functional programming style and Object Oriented Programming. It
     * is based off John Resig's [http://ejohn.org/blog/simple-javascript-inheritance/|Simple Class]
     * Inheritance library.  Besides prototypal inheritance, it includes a few important features:
     *
     *   - Static inheritance
     *   - Introspection
     *   - Namespaces
     *   - Setup and initialization methods
     *   - Easy callback function creation
     *
     *
     * The [mvc.class Get Started with jQueryMX] has a good walkthrough of $.Class.
     *
     * ## Static v. Prototype
     *
     * Before learning about Class, it's important to
     * understand the difference between
     * a class's __static__ and __prototype__ properties.
     *
     *     //STATIC
     *     MyClass.staticProperty  //shared property
     *
     *     //PROTOTYPE
     *     myclass = new MyClass()
     *     myclass.prototypeMethod() //instance method
     *
     * A static (or class) property is on the Class constructor
     * function itself
     * and can be thought of being shared by all instances of the
     * Class. Prototype propertes are available only on instances of the Class.
     *
     * ## A Basic Class
     *
     * The following creates a Monster class with a
     * name (for introspection), static, and prototype members.
     * Every time a monster instance is created, the static
     * count is incremented.
     *
     * @codestart
     * $.Class('Monster',
     * /* @static *|
     * {
     *   count: 0
     * },
     * /* @prototype *|
     * {
     *   init: function( name ) {
     *
     *     // saves name on the monster instance
     *     this.name = name;
     *
     *     // sets the health
     *     this.health = 10;
     *
     *     // increments count
     *     this.constructor.count++;
     *   },
     *   eat: function( smallChildren ){
     *     this.health += smallChildren;
     *   },
     *   fight: function() {
     *     this.health -= 2;
     *   }
     * });
     *
     * hydra = new Monster('hydra');
     *
     * dragon = new Monster('dragon');
     *
     * hydra.name        // -> hydra
     * Monster.count     // -> 2
     * Monster.shortName // -> 'Monster'
     *
     * hydra.eat(2);     // health = 12
     *
     * dragon.fight();   // health = 8
     *
     * @codeend
     *
     *
     * Notice that the prototype <b>init</b> function is called when a new instance of Monster is created.
     *
     *
     * ## Inheritance
     *
     * When a class is extended, all static and prototype properties are available on the new class.
     * If you overwrite a function, you can call the base class's function by calling
     * <code>this._super</code>.  Lets create a SeaMonster class.  SeaMonsters are less
     * efficient at eating small children, but more powerful fighters.
     *
     *
     *     Monster("SeaMonster",{
     *       eat: function( smallChildren ) {
     *         this._super(smallChildren / 2);
     *       },
     *       fight: function() {
     *         this.health -= 1;
     *       }
     *     });
     *
     *     lockNess = new SeaMonster('Lock Ness');
     *     lockNess.eat(4);   //health = 12
     *     lockNess.fight();  //health = 11
     *
     * ### Static property inheritance
     *
     * You can also inherit static properties in the same way:
     *
     *     $.Class("First",
     *     {
     *         staticMethod: function() { return 1;}
     *     },{})
     *
     *     First("Second",{
     *         staticMethod: function() { return this._super()+1;}
     *     },{})
     *
     *     Second.staticMethod() // -> 2
     *
     * ## Namespaces
     *
     * Namespaces are a good idea! We encourage you to namespace all of your code.
     * It makes it possible to drop your code into another app without problems.
     * Making a namespaced class is easy:
     *
     *
     *     $.Class("MyNamespace.MyClass",{},{});
     *
     *     new MyNamespace.MyClass()
     *
     *
     * <h2 id='introspection'>Introspection</h2>
     *
     * Often, it's nice to create classes whose name helps determine functionality.  Ruby on
     * Rails's [http://api.rubyonrails.org/classes/ActiveRecord/Base.html|ActiveRecord] ORM class
     * is a great example of this.  Unfortunately, JavaScript doesn't have a way of determining
     * an object's name, so the developer must provide a name.  Class fixes this by taking a String name for the class.
     *
     *     $.Class("MyOrg.MyClass",{},{})
     *     MyOrg.MyClass.shortName //-> 'MyClass'
     *     MyOrg.MyClass.fullName //->  'MyOrg.MyClass'
     *
     * The fullName (with namespaces) and the shortName (without namespaces) are added to the Class's
     * static properties.
     *
     *
     * ## Setup and initialization methods
     *
     * <p>
     * Class provides static and prototype initialization functions.
     * These come in two flavors - setup and init.
     * Setup is called before init and
     * can be used to 'normalize' init's arguments.
     * </p>
     * <div class='whisper'>PRO TIP: Typically, you don't need setup methods in your classes. Use Init instead.
     * Reserve setup methods for when you need to do complex pre-processing of your class before init is called.
     *
     * </div>
     * @codestart
     * $.Class("MyClass",
     * {
     *   setup: function() {} //static setup
     *   init: function() {} //static constructor
     * },
     * {
     *   setup: function() {} //prototype setup
     *   init: function() {} //prototype constructor
     * })
     * @codeend
     *
     * ### Setup
     *
     * Setup functions are called before init functions.  Static setup functions are passed
     * the base class followed by arguments passed to the extend function.
     * Prototype static functions are passed the Class constructor
     * function arguments.
     *
     * If a setup function returns an array, that array will be used as the arguments
     * for the following init method.  This provides setup functions the ability to normalize
     * arguments passed to the init constructors.  They are also excellent places
     * to put setup code you want to almost always run.
     *
     *
     * The following is similar to how [jQuery.Controller.prototype.setup]
     * makes sure init is always called with a jQuery element and merged options
     * even if it is passed a raw
     * HTMLElement and no second parameter.
     *
     *     $.Class("jQuery.Controller",{
     *       ...
     *     },{
     *       setup: function( el, options ) {
     *         ...
     *         return [$(el),
     *                 $.extend(true,
     *                    this.Class.defaults,
     *                    options || {} ) ]
     *       }
     *     })
     *
     * Typically, you won't need to make or overwrite setup functions.
     *
     * ### Init
     *
     * Init functions are called after setup functions.
     * Typically, they receive the same arguments
     * as their preceding setup function.  The Foo class's <code>init</code> method
     * gets called in the following example:
     *
     *     $.Class("Foo", {
     *       init: function( arg1, arg2, arg3 ) {
     *         this.sum = arg1+arg2+arg3;
     *       }
     *     })
     *     var foo = new Foo(1,2,3);
     *     foo.sum //-> 6
     *
     * ## Proxies
     *
     * Similar to jQuery's proxy method, Class provides a
     * [jQuery.Class.static.proxy proxy]
     * function that returns a callback to a method that will always
     * have
     * <code>this</code> set to the class or instance of the class.
     *
     *
     * The following example uses this.proxy to make sure
     * <code>this.name</code> is available in <code>show</code>.
     *
     *     $.Class("Todo",{
     *       init: function( name ) {
     *          this.name = name
     *       },
     *       get: function() {
     *         $.get("/stuff",this.proxy('show'))
     *       },
     *       show: function( txt ) {
     *         alert(this.name+txt)
     *       }
     *     })
     *     new Todo("Trash").get()
     *
     * Callback is available as a static and prototype method.
     *
     * ##  Demo
     *
     * @demo jquery/class/class.html
     *
     *
     * @constructor
     *
     * To create a Class call:
     *
     *     $.Class( [NAME , STATIC,] PROTOTYPE ) -> Class
     *
     * <div class='params'>
     *   <div class='param'><label>NAME</label><code>{optional:String}</code>
     *   <p>If provided, this sets the shortName and fullName of the
     *      class and adds it and any necessary namespaces to the
     *      window object.</p>
     *   </div>
     *   <div class='param'><label>STATIC</label><code>{optional:Object}</code>
     *   <p>If provided, this creates static properties and methods
     *   on the class.</p>
     *   </div>
     *   <div class='param'><label>PROTOTYPE</label><code>{Object}</code>
     *   <p>Creates prototype methods on the class.</p>
     *   </div>
     * </div>
     *
     * When a Class is created, the static [jQuery.Class.static.setup setup]
     * and [jQuery.Class.static.init init]  methods are called.
     *
     * To create an instance of a Class, call:
     *
     *     new Class([args ... ]) -> instance
     *
     * The created instance will have all the
     * prototype properties and methods defined by the PROTOTYPE object.
     *
     * When an instance is created, the prototype [jQuery.Class.prototype.setup setup]
     * and [jQuery.Class.prototype.init init]  methods
     * are called.
     */

    clss = $.Class = function() {
        if (arguments.length) {
            clss.extend.apply(clss, arguments);
        }
    };

    /* @Static*/
    extend(clss, {
        /**
         * @function proxy
         * Returns a callback function for a function on this Class.
         * Proxy ensures that 'this' is set appropriately.
         * @codestart
         * $.Class("MyClass",{
         *     getData: function() {
         *         this.showing = null;
         *         $.get("data.json",this.proxy('gotData'),'json')
         *     },
         *     gotData: function( data ) {
         *         this.showing = data;
         *     }
         * },{});
         * MyClass.showData();
         * @codeend
         * <h2>Currying Arguments</h2>
         * Additional arguments to proxy will fill in arguments on the returning function.
         * @codestart
         * $.Class("MyClass",{
         *    getData: function( <b>callback</b> ) {
         *      $.get("data.json",this.proxy('process',<b>callback</b>),'json');
         *    },
         *    process: function( <b>callback</b>, jsonData ) { //callback is added as first argument
         *        jsonData.processed = true;
         *        callback(jsonData);
         *    }
         * },{});
         * MyClass.getData(showDataFunc)
         * @codeend
         * <h2>Nesting Functions</h2>
         * Proxy can take an array of functions to call as
         * the first argument.  When the returned callback function
         * is called each function in the array is passed the return value of the prior function.  This is often used
         * to eliminate currying initial arguments.
         * @codestart
         * $.Class("MyClass",{
         *    getData: function( callback ) {
         *      //calls process, then callback with value from process
         *      $.get("data.json",this.proxy(['process2',callback]),'json')
         *    },
         *    process2: function( type,jsonData ) {
         *        jsonData.processed = true;
         *        return [jsonData];
         *    }
         * },{});
         * MyClass.getData(showDataFunc);
         * @codeend
         * @param {String|Array} fname If a string, it represents the function to be called.
         * If it is an array, it will call each function in order and pass the return value of the prior function to the
         * next function.
         * @return {Function} the callback function.
         */
        proxy: function( funcs ) {

            //args that should be curried
            var args = makeArray(arguments),
                self;

            // get the functions to callback
            funcs = args.shift();

            // if there is only one function, make funcs into an array
            if (!isArray(funcs) ) {
                funcs = [funcs];
            }

            // keep a reference to us in self
            self = this;

            
            return function class_cb() {
                // add the arguments after the curried args
                var cur = concatArgs(args, arguments),
                    isString,
                    length = funcs.length,
                    f = 0,
                    func;

                // go through each function to call back
                for (; f < length; f++ ) {
                    func = funcs[f];
                    if (!func ) {
                        continue;
                    }

                    // set called with the name of the function on self (this is how this.view works)
                    isString = typeof func == "string";
                    if ( isString && self._set_called ) {
                        self.called = func;
                    }

                    // call the function
                    cur = (isString ? self[func] : func).apply(self, cur || []);

                    // pass the result to the next function (if there is a next function)
                    if ( f < length - 1 ) {
                        cur = !isArray(cur) || cur._use_call ? [cur] : cur
                    }
                }
                return cur;
            }
        },
        /**
         * @function newInstance
         * Creates a new instance of the class.  This method is useful for creating new instances
         * with arbitrary parameters.
         * <h3>Example</h3>
         * @codestart
         * $.Class("MyClass",{},{})
         * var mc = MyClass.newInstance.apply(null, new Array(parseInt(Math.random()*10,10))
         * @codeend
         * @return {class} instance of the class
         */
        newInstance: function() {
            // get a raw instance objet (init is not called)
            var inst = this.rawInstance(),
                args;

            // call setup if there is a setup
            if ( inst.setup ) {
                args = inst.setup.apply(inst, arguments);
            }
            // call init if there is an init, if setup returned args, use those as the arguments
            if ( inst.init ) {
                inst.init.apply(inst, isArray(args) ? args : arguments);
            }
            return inst;
        },
        /**
         * Setup gets called on the inherting class with the base class followed by the
         * inheriting class's raw properties.
         *
         * Setup will deeply extend a static defaults property on the base class with
         * properties on the base class.  For example:
         *
         *     $.Class("MyBase",{
         *       defaults : {
         *         foo: 'bar'
         *       }
         *     },{})
         *
         *     MyBase("Inheriting",{
         *       defaults : {
         *         newProp : 'newVal'
         *       }
         *     },{}
         *
         *     Inheriting.defaults -> {foo: 'bar', 'newProp': 'newVal'}
         *
         * @param {Object} baseClass the base class that is being inherited from
         * @param {String} fullName the name of the new class
         * @param {Object} staticProps the static properties of the new class
         * @param {Object} protoProps the prototype properties of the new class
         */
        setup: function( baseClass, fullName ) {
            // set defaults as the merger of the parent defaults and this object's defaults
            this.defaults = extend(true, {}, baseClass.defaults, this.defaults);
            return arguments;
        },
        rawInstance: function() {
            // prevent running init
            initializing = true;
            var inst = new this();
            initializing = false;
            // allow running init
            return inst;
        },
        /**
         * Extends a class with new static and prototype functions.  There are a variety of ways
         * to use extend:
         *
         *     // with className, static and prototype functions
         *     $.Class('Task',{ STATIC },{ PROTOTYPE })
         *     // with just classname and prototype functions
         *     $.Class('Task',{ PROTOTYPE })
         *     // with just a className
         *     $.Class('Task')
         *
         * You no longer have to use <code>.extend</code>.  Instead, you can pass those options directly to
         * $.Class (and any inheriting classes):
         *
         *     // with className, static and prototype functions
         *     $.Class('Task',{ STATIC },{ PROTOTYPE })
         *     // with just classname and prototype functions
         *     $.Class('Task',{ PROTOTYPE })
         *     // with just a className
         *     $.Class('Task')
         *
         * @param {String} [fullName]  the classes name (used for classes w/ introspection)
         * @param {Object} [klass]  the new classes static/class functions
         * @param {Object} [proto]  the new classes prototype functions
         *
         * @return {jQuery.Class} returns the new class
         */
        extend: function( fullName, klass, proto ) {
            // figure out what was passed and normalize it
            if ( typeof fullName != 'string' ) {
                proto = klass;
                klass = fullName;
                fullName = null;
            }
            if (!proto ) {
                proto = klass;
                klass = null;
            }

            proto = proto || {};
            var _super_class = this,
                _super = this[STR_PROTOTYPE],
                name, shortName, namespace, prototype;

            // Instantiate a base class (but only create the instance,
            // don't run the init constructor)
            initializing = true;
            prototype = new this();
            initializing = false;

            // Copy the properties over onto the new prototype
            inheritProps(proto, _super, prototype);

            // The dummy class constructor
            function Class() {
                // All construction is actually done in the init method
                if ( initializing ) return;

                // we are being called w/o new, we are extending
                if ( this.constructor !== Class && arguments.length ) {
                    return arguments.callee.extend.apply(arguments.callee, arguments)
                } else { //we are being called w/ new
                    return this.Class.newInstance.apply(this.Class, arguments)
                }
            }
            // Copy old stuff onto class
            for ( name in this ) {
                if ( this.hasOwnProperty(name) ) {
                    Class[name] = this[name];
                }
            }

            // copy new static props on class
            inheritProps(klass, this, Class);

            // do namespace stuff
            if ( fullName ) {

                var root;
                if (klass && klass.root) {
                    root = klass.root;
                    if ($.isString(root)) {
                        root = getObject(root, window, true);
                    }
                }

                var parts = fullName.split(/\./),
                    shortName = parts.pop(),
                    current = getObject(parts.join('.'), root || window, true),
                    namespace = current;

                

                // !-- FOUNDRY HACK --! //
                // Inherit any existing properties from the namespace where Class is being assigned to.
                extend(true, Class, current[shortName]);

                current[shortName] = Class;
            }

            // set things that can't be overwritten
            extend(Class, {
                prototype: prototype,
                /**
                 * @attribute namespace
                 * The namespaces object
                 *
                 *     $.Class("MyOrg.MyClass",{},{})
                 *     MyOrg.MyClass.namespace //-> MyOrg
                 *
                 */
                namespace: namespace,
                /**
                 * @attribute shortName
                 * The name of the class without its namespace, provided for introspection purposes.
                 *
                 *     $.Class("MyOrg.MyClass",{},{})
                 *     MyOrg.MyClass.shortName //-> 'MyClass'
                 *     MyOrg.MyClass.fullName //->  'MyOrg.MyClass'
                 *
                 */
                shortName: shortName,
                constructor: Class,
                /**
                 * @attribute fullName
                 * The full name of the class, including namespace, provided for introspection purposes.
                 *
                 *     $.Class("MyOrg.MyClass",{},{})
                 *     MyOrg.MyClass.shortName //-> 'MyClass'
                 *     MyOrg.MyClass.fullName //->  'MyOrg.MyClass'
                 *
                 */
                fullName: fullName
            });

            //make sure our prototype looks nice
            Class[STR_PROTOTYPE].Class = Class[STR_PROTOTYPE].constructor = Class;



            // call the class setup
            var args = Class.setup.apply(Class, concatArgs([_super_class],arguments));

            // call the class init
            if ( Class.init ) {
                Class.init.apply(Class, args || concatArgs([_super_class],arguments));
            }

            /* @Prototype*/
            return Class;
            /**
             * @function setup
             * If a setup method is provided, it is called when a new
             * instances is created.  It gets passed the same arguments that
             * were given to the Class constructor function (<code> new Class( arguments ... )</code>).
             *
             *     $.Class("MyClass",
             *     {
             *        setup: function( val ) {
             *           this.val = val;
             *         }
             *     })
             *     var mc = new MyClass("Check Check")
             *     mc.val //-> 'Check Check'
             *
             * Setup is called before [jQuery.Class.prototype.init init].  If setup
             * return an array, those arguments will be used for init.
             *
             *     $.Class("jQuery.Controller",{
             *       setup : function(htmlElement, rawOptions){
             *         return [$(htmlElement),
             *                   $.extend({}, this.Class.defaults, rawOptions )]
             *       }
             *     })
             *
             * <div class='whisper'>PRO TIP:
             * Setup functions are used to normalize constructor arguments and provide a place for
             * setup code that extending classes don't have to remember to call _super to
             * run.
             * </div>
             *
             * Setup is not defined on $.Class itself, so calling super in inherting classes
             * will break.  Don't do the following:
             *
             *     $.Class("Thing",{
             *       setup : function(){
             *         this._super(); // breaks!
             *       }
             *     })
             *
             * @return {Array|undefined} If an array is return, [jQuery.Class.prototype.init] is
             * called with those arguments; otherwise, the original arguments are used.
             */
            //break up
            /**
             * @function init
             * If an <code>init</code> method is provided, it gets called when a new instance
             * is created.  Init gets called after [jQuery.Class.prototype.setup setup], typically with the
             * same arguments passed to the Class
             * constructor: (<code> new Class( arguments ... )</code>).
             *
             *     $.Class("MyClass",
             *     {
             *        init: function( val ) {
             *           this.val = val;
             *        }
             *     })
             *     var mc = new MyClass(1)
             *     mc.val //-> 1
             *
             * [jQuery.Class.prototype.setup Setup] is able to modify the arguments passed to init.  Read
             * about it there.
             *
             */
            //Breaks up code
            /**
             * @attribute constructor
             *
             * A reference to the Class (or constructor function).  This allows you to access
             * a class's static properties from an instance.
             *
             * ### Quick Example
             *
             *     // a class with a static property
             *     $.Class("MyClass", {staticProperty : true}, {});
             *
             *     // a new instance of myClass
             *     var mc1 = new MyClass();
             *
             *     // read the static property from the instance:
             *     mc1.constructor.staticProperty //-> true
             *
             * Getting static properties with the constructor property, like
             * [jQuery.Class.static.fullName fullName], is very common.
             *
             */
        }

    })





    clss.callback = clss[STR_PROTOTYPE].callback = clss[STR_PROTOTYPE].
    /**
     * @function proxy
     * Returns a method that sets 'this' to the current instance.  This does the same thing as
     * and is described better in [jQuery.Class.static.proxy].
     * The only difference is this proxy works
     * on a instance instead of a class.
     * @param {String|Array} fname If a string, it represents the function to be called.
     * If it is an array, it will call each function in order and pass the return value of the prior function to the
     * next function.
     * @return {Function} the callback function
     */
    proxy = clss.proxy;


})();(function(){
    // ------- HELPER FUNCTIONS  ------

    // Binds an element, returns a function that unbinds
    var bind = function( el, ev, callback, eventData ) {
        var wrappedCallback,
            binder = el.bind && el.unbind ? el : $(isFunction(el) ? [el] : el);
        //this is for events like >click.
        if ( ev.indexOf(">") === 0 ) {
            ev = ev.substr(1);
            wrappedCallback = function( event ) {
                if ( event.target === el ) {
                    callback.apply(this, arguments);
                }
            };
        }
        // !-- FOUNDRY HACK --! //
        // Support for passing event data
        if (eventData) {
            binder.bind(ev, eventData, wrappedCallback || callback);
        } else {
            binder.bind(ev, wrappedCallback || callback);
        }
        // if ev name has >, change the name and bind
        // in the wrapped callback, check that the element matches the actual element
        return function() {
            binder.unbind(ev, wrappedCallback || callback);
            el = ev = callback = wrappedCallback = null;
        };
    },
        makeArray = $.makeArray,
        isArray = $.isArray,
        isFunction = $.isFunction,
        isString = $.isString,
        extend = $.extend,
        Str = $.String,
        each = $.each,
        getObject = Str.getObject,

        STR_PROTOTYPE = 'prototype',
        STR_CONSTRUCTOR = 'constructor',
        slice = Array[STR_PROTOTYPE].slice,

        // Binds an element, returns a function that unbinds
        delegate = function( el, selector, ev, callback, eventData ) {

            // !-- FOUNDRY HACK --! //
            // Make event delegation work with direct child selector
            if ( selector.indexOf(">") === 0 ) {
                selector = (el.data("directSelector") + " " || "") + selector;
            }

            var binder = el.delegate && el.undelegate ? el : $(isFunction(el) ? [el] : el)

            // !-- FOUNDRY HACK --! //
            // Support for passing event data
            if (eventData) {
                binder.delegate(selector, ev, eventData, callback);
            } else {
                binder.delegate(selector, ev, callback);
            }

            return function() {
                binder.undelegate(selector, ev, callback);
                binder = el = ev = callback = selector = null;
            };
        },

        // calls bind or unbind depending if there is a selector
        binder = function( el, ev, callback, selector, eventData ) {
            // !-- FOUNDRY HACK --! //
            // Support for passing event data
            return selector ? delegate(el, selector, ev, callback, eventData) : bind(el, ev, callback, eventData);
        },

        // moves 'this' to the first argument, wraps it with jQuery if it's an element
        shifter = function shifter(context, name) {
            var method = typeof name == "string" ? context[name] : name;

            // !-- FOUNDRY HACK --! //
            // Support for passing event data
            if (isArray(method) && isFunction(method[1])) {
                method = method[1];
            }

            return function() {
                context.called = name;
                return method.apply(context, [this.nodeName ? $(this) : this].concat( slice.call(arguments, 0) ) );
            };
        },
        // matches dots
        dotsReg = /\./g,
        // matches controller
        controllersReg = /_?controllers?/ig,
        //used to remove the controller from the name
        underscoreAndRemoveController = function( className ) {
            return Str.underscore(className.replace($.globalNamespace + ".", "").replace(dotsReg, '_').replace(controllersReg, ""));
        },
        // checks if it looks like an action
        // actionMatcher = /[^\w]/,

        // !-- FOUNDRY HACK --! //
        // Prevent inclusion of single word property name that starts with a symbol, e.g. $family from MooTools.
        // This is coming from an environment where jQuery and MooTools may coexist.
        actionMatcher = /^\S(.*)\s(.*)/,

        // handles parameterized action names
        parameterReplacer = /\{([^\}]+)\}/g,
        controllerReplacer = /\{([^\.]+[\.][^\.]+)\}/g,
        breaker = /^(?:(.*?)\s)?([\w\.\:>]+)$/,
        basicProcessor,
        data = function(el, data){
            return $.data(el, "controllers", data)
        };
    /**
     * @class jQuery.Controller
     * @parent jquerymx
     * @plugin jquery/controller
     * @download  http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/controller/controller.js
     * @test jquery/controller/qunit.html
     * @inherits jQuery.Class
     * @description jQuery widget factory.
     *
     * jQuery.Controller helps create organized, memory-leak free, rapidly performing
     * jQuery widgets.  Its extreme flexibility allows it to serve as both
     * a traditional View and a traditional Controller.
     *
     * This means it is used to
     * create things like tabs, grids, and contextmenus as well as
     * organizing them into higher-order business rules.
     *
     * Controllers make your code deterministic, reusable, organized and can tear themselves
     * down auto-magically. Read about [http://jupiterjs.com/news/writing-the-perfect-jquery-plugin
     * the theory behind controller] and
     * a [http://jupiterjs.com/news/organize-jquery-widgets-with-jquery-controller walkthrough of its features]
     * on Jupiter's blog. [mvc.controller Get Started with jQueryMX] also has a great walkthrough.
     *
     * Controller inherits from [jQuery.Class $.Class] and makes heavy use of
     * [http://api.jquery.com/delegate/ event delegation]. Make sure
     * you understand these concepts before using it.
     *
     * ## Basic Example
     *
     * Instead of
     *
     *
     *     $(function(){
     *       $('#tabs').click(someCallbackFunction1)
     *       $('#tabs .tab').click(someCallbackFunction2)
     *       $('#tabs .delete click').click(someCallbackFunction3)
     *     });
     *
     * do this
     *
     *     $.Controller('Tabs',{
     *       click: function() {...},
     *       '.tab click' : function() {...},
     *       '.delete click' : function() {...}
     *     })
     *     $('#tabs').tabs();
     *
     *
     * ## Tabs Example
     *
     * @demo jquery/controller/controller.html
     *
     * ## Using Controller
     *
     * Controller helps you build and organize jQuery plugins.  It can be used
     * to build simple widgets, like a slider, or organize multiple
     * widgets into something greater.
     *
     * To understand how to use Controller, you need to understand
     * the typical lifecycle of a jQuery widget and how that maps to
     * controller's functionality:
     *
     * ### A controller class is created.
     *
     *     $.Controller("MyWidget",
     *     {
     *       defaults :  {
     *         message : "Remove Me"
     *       }
     *     },
     *     {
     *       init : function(rawEl, rawOptions){
     *         this.element.append(
     *            "<div>"+this.options.message+"</div>"
     *           );
     *       },
     *       "div click" : function(div, ev){
     *         div.remove();
     *       }
     *     })
     *
     * This creates a <code>$.fn.my_widget</code> jQuery helper function
     * that can be used to create a new controller instance on an element. Find
     * more information [jquery.controller.plugin  here] about the plugin gets created
     * and the rules around its name.
     *
     * ### An instance of controller is created on an element
     *
     *     $('.thing').my_widget(options) // calls new MyWidget(el, options)
     *
     * This calls <code>new MyWidget(el, options)</code> on
     * each <code>'.thing'</code> element.
     *
     * When a new [jQuery.Class Class] instance is created, it calls the class's
     * prototype setup and init methods. Controller's [jQuery.Controller.prototype.setup setup]
     * method:
     *
     *  - Sets [jQuery.Controller.prototype.element this.element] and adds the controller's name to element's className.
     *  - Merges passed in options with defaults object and sets it as [jQuery.Controller.prototype.options this.options]
     *  - Saves a reference to the controller in <code>$.data</code>.
     *  - [jquery.controller.listening Binds all event handler methods].
     *
     *
     * ### The controller responds to events
     *
     * Typically, Controller event handlers are automatically bound.  However, there are
     * multiple ways to [jquery.controller.listening listen to events] with a controller.
     *
     * Once an event does happen, the callback function is always called with 'this'
     * referencing the controller instance.  This makes it easy to use helper functions and
     * save state on the controller.
     *
     *
     * ### The widget is destroyed
     *
     * If the element is removed from the page, the
     * controller's [jQuery.Controller.prototype.destroy] method is called.
     * This is a great place to put any additional teardown functionality.
     *
     * You can also teardown a controller programatically like:
     *
     *     $('.thing').my_widget('destroy');
     *
     * ## Todos Example
     *
     * Lets look at a very basic example -
     * a list of todos and a button you want to click to create a new todo.
     * Your HTML might look like:
     *
     * @codestart html
     * &lt;div id='todos'>
     *  &lt;ol>
     *    &lt;li class="todo">Laundry&lt;/li>
     *    &lt;li class="todo">Dishes&lt;/li>
     *    &lt;li class="todo">Walk Dog&lt;/li>
     *  &lt;/ol>
     *  &lt;a class="create">Create&lt;/a>
     * &lt;/div>
     * @codeend
     *
     * To add a mousover effect and create todos, your controller might look like:
     *
     *     $.Controller('Todos',{
     *       ".todo mouseover" : function( el, ev ) {
     *         el.css("backgroundColor","red")
     *       },
     *       ".todo mouseout" : function( el, ev ) {
     *         el.css("backgroundColor","")
     *       },
     *       ".create click" : function() {
     *         this.find("ol").append("<li class='todo'>New Todo</li>");
     *       }
     *     })
     *
     * Now that you've created the controller class, you've must attach the event handlers on the '#todos' div by
     * creating [jQuery.Controller.prototype.setup|a new controller instance].  There are 2 ways of doing this.
     *
     * @codestart
     * //1. Create a new controller directly:
     * new Todos($('#todos'));
     * //2. Use jQuery function
     * $('#todos').todos();
     * @codeend
     *
     * ## Controller Initialization
     *
     * It can be extremely useful to add an init method with
     * setup functionality for your widget.
     *
     * In the following example, I create a controller that when created, will put a message as the content of the element:
     *
     *     $.Controller("SpecialController",
     *     {
     *       init: function( el, message ) {
     *         this.element.html(message)
     *       }
     *     })
     *     $(".special").special("Hello World")
     *
     * ## Removing Controllers
     *
     * Controller removal is built into jQuery.  So to remove a controller, you just have to remove its element:
     *
     * @codestart
     * $(".special_controller").remove()
     * $("#containsControllers").html("")
     * @codeend
     *
     * It's important to note that if you use raw DOM methods (<code>innerHTML, removeChild</code>), the controllers won't be destroyed.
     *
     * If you just want to remove controller functionality, call destroy on the controller instance:
     *
     * @codestart
     * $(".special_controller").controller().destroy()
     * @codeend
     *
     * ## Accessing Controllers
     *
     * Often you need to get a reference to a controller, there are a few ways of doing that.  For the
     * following example, we assume there are 2 elements with <code>className="special"</code>.
     *
     * @codestart
     * //creates 2 foo controllers
     * $(".special").foo()
     *
     * //creates 2 bar controllers
     * $(".special").bar()
     *
     * //gets all controllers on all elements:
     * $(".special").controllers() //-> [foo, bar, foo, bar]
     *
     * //gets only foo controllers
     * $(".special").controllers(FooController) //-> [foo, foo]
     *
     * //gets all bar controllers
     * $(".special").controllers(BarController) //-> [bar, bar]
     *
     * //gets first controller
     * $(".special").controller() //-> foo
     *
     * //gets foo controller via data
     * $(".special").data("controllers")["FooController"] //-> foo
     * @codeend
     *
     * ## Calling methods on Controllers
     *
     * Once you have a reference to an element, you can call methods on it.  However, Controller has
     * a few shortcuts:
     *
     * @codestart
     * //creates foo controller
     * $(".special").foo({name: "value"})
     *
     * //calls FooController.prototype.update
     * $(".special").foo({name: "value2"})
     *
     * //calls FooController.prototype.bar
     * $(".special").foo("bar","something I want to pass")
     * @codeend
     *
     * These methods let you call one controller from another controller.
     *
     */
    var controllerRoot = $.globalNamespace + ".Controller";

    $.Controller = function(name) {

        // !-- FOUNDRY HACK --! //
        // By default, all controllers are created under the
        // $.Controller root namespace.
        var args = makeArray(arguments),
            _static = {
                root: controllerRoot
            },
            _prototype;

        if (args.length > 2) {
            // Namespace can be overriden
            _static = $.extend(_static, args[1]);
            _prototype = args[2];
        } else {
            _prototype = args[1];
        }

        if (_static.namespace) {
            name = _static.namespace + "." + name;
        }

        return $.Controller.Class(name, _static, _prototype);
    }

    var controllerClass = controllerRoot + ".Class";

    $.Class(controllerClass,
    /**
     * @Static
     */
    {
        /**
         * Does 2 things:
         *
         *   - Creates a jQuery helper for this controller.</li>
         *   - Calculates and caches which functions listen for events.</li>
         *
         * ### jQuery Helper Naming Examples
         *
         *
         *     "TaskController" -> $().task_controller()
         *     "Controllers.Task" -> $().controllers_task()
         *
         */
        setup: function(baseClass, name) {

            // Allow contollers to inherit "defaults" from superclasses as it done in $.Class
            this._super.apply(this, arguments);

            // if you didn't provide a name, or are controller, don't do anything
            if (!this.shortName || this.fullName == controllerClass) {
                return;
            }

            // !-- FOUNDRY HACK --! //
            // Added support for expandable elements.
            var elements = this.elements || [],
                i = 0,
                defaults = this.defaults;

            while (element = elements[i++]) {

                var start  = element.indexOf("{"),
                    end    = element.indexOf("}"),
                    length = element.length,
                    prefix = element.slice(0, start),
                    suffix = element.slice(end + 1),
                    names  = element.slice(start + 1, end).split("|"),
                    j = 0;

                    // "^width [data-eb{label|slider}]" turns into
                    // widthLabel  => [data-eb-label]
                    // widthSlider => [data-eb-slider]

                    // "^width [data-eb".match(/^\^(\S*)\s(.*)/);
                    // 0 ==> "^width [data-eb"
                    // 1 ==> "width",
                    // 2 ==> "[data-eb"
                    var parts = prefix.match(/^\^(\S*)\s(.*)/),
                        propPrefix = "";

                    if (parts) {
                        propPrefix = parts[1] + "-";
                        prefix = parts[2];
                    }

                    while (name = names[j++]) {
                        var prop = "{" + $.camelize(propPrefix + name) + "}";

                        !$.has(defaults, prop) &&
                            (defaults[prop] = prefix + name + suffix);
                    }
            }

            // cache the underscored names
            this._fullName = underscoreAndRemoveController(this.fullName);
            this._shortName = underscoreAndRemoveController(this.shortName);

            var controller = this,
                /**
                 * @attribute pluginName
                 * Setting the <code>pluginName</code> property allows you
                 * to change the jQuery plugin helper name from its
                 * default value.
                 *
                 *     $.Controller("Mxui.Layout.Fill",{
                 *       pluginName: "fillWith"
                 *     },{});
                 *
                 *     $("#foo").fillWith();
                 */
                funcName, forLint;

            // !-- FOUNDRY HACK --! //
            // Make creation of jQuery plugin by testing the existence of pluginName.
            if (isString(this.pluginName)) {

                // !-- FOUNDRY HACK --! //
                // Add a reference to the fullname
                var _fullName = this._fullName;
                var pluginname = this.pluginName;

                // create jQuery plugin
                if (!$.fn[pluginname] ) {
                    $.fn[pluginname] = function( options ) {

                        var args = makeArray(arguments);

                        // Returning controller instance if it exists
                        if ($.isString(options) && options==="controller") {

                            var controllers = data(this[0]),
                                instance = controllers && controllers[_fullName];

                            return instance;
                        }

                        return this.each(function() {
                            //check if created
                            var controllers = data(this),
                                //plugin is actually the controller instance
                                //plugin = controllers && controllers[pluginname];

                                // !-- FOUNDRY HACK --! //
                                // Check using controller full name
                                instance = controllers && controllers[_fullName];

                            if (instance) {

                                // call a method on the controller with the remaining args
                                if ($.isString(options)) {
                                    var method = instance[options];
                                    $.isFunction(method) && method.apply(instance, args.slice(1));
                                    return;
                                }

                                // call the plugin's update method
                                instance.update.apply(instance, args);

                            } else {
                                //create a new controller instance
                                controller.newInstance.apply(controller, [this].concat(args));
                            }
                        });
                    };
                }
            }

            // !-- FOUNDRY HACK --! //
            // If a prototype factory function was given instead of a prototype object,
            // we expect the factory function to return the prototype object upon execution
            // of the factory function. This factory function gets executed during the
            // instantiation of the controller.

            var args         = makeArray(arguments),
                prototype    = this[STR_PROTOTYPE],
                protoFactory = args[(args.length > 3) ? 3 : 2];

            if (isFunction(protoFactory)) {

                // Remap the factory function
                this.protoFactory = protoFactory;

                // Attempt to execute the prototype factory once to get
                // a list of actions that we can cache first.
                prototype = this.protoFactory.call(this, null);
            }

            // calculate and cache actions
            this.actions = {};

            // !-- FOUNDRY HACK --! //
            // Support for handlers that also pass in event data
            for (funcName in prototype) {

                if (funcName=='constructor') continue;

                if (this._isAction(funcName)) {

                    var method   = prototype[funcName],
                        isMethod = isFunction(method) || (isArray(method) && isFunction(method[1]));

                    if (!isMethod) continue;

                    this.actions[funcName] = this._action(funcName);
                }
            }

            // !-- FOUNDRY HACK --! //
            // Controller has been created. Resolve module.
            $.module("$:/Controllers/" + this.fullName).resolve(this);
        },

        hookup: function( el ) {
            return new this(el);
        },

        /**
         * @hide
         * @param {String} methodName a prototype function
         * @return {Boolean} truthy if an action or not
         */
        _isAction: function( methodName ) {
            if ( actionMatcher.test(methodName) ) {
                return true;
            } else {
                return $.inArray(methodName, this.listensTo) > -1 || $.event.special[methodName] || processors[methodName];
            }

        },
        /**
         * @hide
         * This takes a method name and the options passed to a controller
         * and tries to return the data necessary to pass to a processor
         * (something that binds things).
         *
         * For performance reasons, this called twice.  First, it is called when
         * the Controller class is created.  If the methodName is templated
         * like : "{window} foo", it returns null.  If it is not templated
         * it returns event binding data.
         *
         * The resulting data is added to this.actions.
         *
         * When a controller instance is created, _action is called again, but only
         * on templated actions.
         *
         * @param {Object} methodName the method that will be bound
         * @param {Object} [options] first param merged with class default options
         * @return {Object} null or the processor and pre-split parts.
         * The processor is what does the binding/subscribing.
         */
        _action: function( methodName, options ) {
            // reset the test index
            parameterReplacer.lastIndex = 0;

            //if we don't have options (a controller instance), we'll run this later
            if (!options && parameterReplacer.test(methodName) ) {
                return null;
            }

            // !-- FOUNDRY HACK --! //
            // Ability to bind custom event to self.
            // "{self} customEvent"
            methodName = methodName.replace("{self} ", "");

            // If we have options, run sub to replace templates "{}" with a value from the options
            // or the window
            var convertedName = methodName;

            if (options) {

                var bindingOtherController = false;

                if (controllerReplacer.test(methodName)) {

                    var controller, selector = "";
                    convertedName =
                        methodName
                            .replace(controllerReplacer, function(whole, inside){
                                var parts = inside.split(".");
                                controller = options["{"+parts[0]+"}"] || {};
                                if ($.isControllerInstance(controller)) {
                                    selector = (controller[parts[1]] || {})["selector"];
                                }
                                return selector;
                            })
                            .match(breaker);

                    // If there is a selector, this will be true.
                    bindingOtherController = !!selector;

                    convertedName = [controller.element].concat(convertedName || []);
                }

                if (!bindingOtherController) {

                    convertedName = Str.sub(methodName, [options, window]);
                }
            }

            // If a "{}" resolves to an object, convertedName will be an array
            var arr = isArray(convertedName),

                // get the parts of the function = [convertedName, delegatePart, eventPart]
                parts = (arr ? convertedName[1] : convertedName).match(breaker),
                event = parts[2],
                processor = processors[event] || basicProcessor;

            return {
                processor: processor,
                parts: parts,
                delegate : arr ? convertedName[0] : undefined
            };
        },

        /**
         * @attribute processors
         * An object of {eventName : function} pairs that Controller uses to hook up events
         * auto-magically.  A processor function looks like:
         *
         *     jQuery.Controller.processors.
         *       myprocessor = function( el, event, selector, cb, controller ) {
         *          //el - the controller's element
         *          //event - the event (myprocessor)
         *          //selector - the left of the selector
         *          //cb - the function to call
         *          //controller - the binding controller
         *       };
         *
         * This would bind anything like: "foo~3242 myprocessor".
         *
         * The processor must return a function that when called,
         * unbinds the event handler.
         *
         * Controller already has processors for the following events:
         *
         *   - change
         *   - click
         *   - contextmenu
         *   - dblclick
         *   - focusin
         *   - focusout
         *   - keydown
         *   - keyup
         *   - keypress
         *   - mousedown
         *   - mouseenter
         *   - mouseleave
         *   - mousemove
         *   - mouseout
         *   - mouseover
         *   - mouseup
         *   - reset
         *   - resize
         *   - scroll
         *   - select
         *   - submit
         *
         * Listen to events on the document or window
         * with templated event handlers:
         *
         *
         *     $.Controller('Sized',{
         *       "{window} resize" : function(){
         *         this.element.width(this.element.parent().width() / 2);
         *       }
         *     });
         *
         *     $('.foo').sized();
         */
        processors: {},
        /**
         * @attribute listensTo
         * An array of special events this controller
         * listens too.  You only need to add event names that
         * are whole words (ie have no special characters).
         *
         *     $.Controller('TabPanel',{
         *       listensTo : ['show']
         *     },{
         *       'show' : function(){
         *         this.element.show();
         *       }
         *     })
         *
         *     $('.foo').tab_panel().trigger("show");
         *
         */
        listensTo: [],
        /**
         * @attribute defaults
         * A object of name-value pairs that act as default values for a controller's
         * [jQuery.Controller.prototype.options options].
         *
         *     $.Controller("Message",
         *     {
         *       defaults : {
         *         message : "Hello World"
         *       }
         *     },{
         *       init : function(){
         *         this.element.text(this.options.message);
         *       }
         *     })
         *
         *     $("#el1").message(); //writes "Hello World"
         *     $("#el12").message({message: "hi"}); //writes hi
         *
         * In [jQuery.Controller.prototype.setup setup] the options passed to the controller
         * are merged with defaults.  This is not a deep merge.
         */
        defaults: {},

        hostname: "parent"
    },
    /**
     * @Prototype
     */
    {
        /**
         * Setup is where most of controller's magic happens.  It does the following:
         *
         * ### 1. Sets this.element
         *
         * The first parameter passed to new Controller(el, options) is expected to be
         * an element.  This gets converted to a jQuery wrapped element and set as
         * [jQuery.Controller.prototype.element this.element].
         *
         * ### 2. Adds the controller's name to the element's className.
         *
         * Controller adds it's plugin name to the element's className for easier
         * debugging.  For example, if your Controller is named "Foo.Bar", it adds
         * "foo_bar" to the className.
         *
         * ### 3. Saves the controller in $.data
         *
         * A reference to the controller instance is saved in $.data.  You can find
         * instances of "Foo.Bar" like:
         *
         *     $("#el").data("controllers")['foo_bar'].
         *
         * ### Binds event handlers
         *
         * Setup does the event binding described in [jquery.controller.listening Listening To Events].
         *
         * @param {HTMLElement} element the element this instance operates on.
         * @param {Object} [options] option values for the controller.  These get added to
         * this.options and merged with [jQuery.Controller.static.defaults defaults].
         * @return {Array} return an array if you wan to change what init is called with. By
         * default it is called with the element and options passed to the controller.
         */
        setup: function(elem, options) {

            var instance  = this,
                Class     = instance[STR_CONSTRUCTOR],
                prototype = instance[STR_PROTOTYPE];

            var _fullName = Class._fullName;

            // !-- FOUNDRY HACK --! //
            // Unique id for every controller instance.
            instance.instanceId = $.uid(_fullName + '_');

            // !-- FOUNDRY HACK --! //
            // Added defaultOptions as an alternative to defaults
            var instanceOptions = instance.options
                                = extend(true, {}, Class.defaults, Class.defaultOptions, options);

            // Convert HTML element into a jQuery element
            // and store it inside instance.element.
            var element = instance.element
                        = $(elem);

            // !-- FOUNDRY HACK --! //
            // Execute factory function if exists, extends the properties
            // of the returned object onto the instance.
            if (Class.protoFactory) {

                // This is where "self" keyword is passed as first argument.
                prototype = Class.protoFactory.apply(Class, [instance, instanceOptions, element]);

                // Extend the properties of the prototype object onto the instance.
                extend(true, instance, prototype);
            }

            // !-- FOUNDRY HACK --! //
            // Use _fullName instead
            // This actually does $(e).data("controllers", _fullName);
            (data(elem) || data(elem, {}))[_fullName] = instance;

            // !-- FOUNDRY HACK --~ //
            // Add a unique direct selector for every controller instance.
            if (!element.data("directSelector")) {
                var selector = $.uid("DS");
                element
                    .addClass(selector)
                    .data("directSelector", "." + selector);
            }

            // !-- FOUNDRY HACK --! //
            // Augment selector properties into selector functions.
            // The rest are passed in as controller properties.
            instance.selectors = {};

            for (var name in instanceOptions) {

                if (!name.match(/^\{.+\}$/)) continue;

                var key = name.replace(/^\{|\}$/g,''),
                    val = instanceOptions[name];

                // Augmented selector function
                if (isString(val)) {

                    var selectorFuncExtension = instance[key];

                    instance[key] = instance.selectors[key] = (function(instance, selector, funcName) {

                        // Selector shorthand for controllers
                        selector = /^(\.|\#)$/.test(selector) ? selector + funcName : selector;

                        // Create selector function
                        var selectorFunc = function(filter) {

                            var elements = (selectorFunc.baseElement || instance.element).find(selector);

                            if ($.isString(filter)) {
                                elements = elements.filter(filter);
                            }

                            if ($.isPlainObject(filter)) {
                                $.each(filter, function(key, val){
                                    elements = elements.filterBy(key, val);
                                });
                            }

                            return elements;
                        };

                        // Keep the selector as a property of the function
                        selectorFunc.selector = selector;

                        selectorFunc.css = function() {

                            var cssRule = selectorFunc.cssRule;

                            if (!cssRule) {

                                var directSelector = element.data("directSelector"),

                                    ruleSelector = $.map(selector.split(","), function(selector) {
                                                        return directSelector + " " + selector
                                                    });

                                cssRule = selectorFunc.cssRule = $.cssRule(ruleSelector);
                                cssRule.important = true;
                            }

                            return (arguments.length) ? cssRule.css.apply(cssRule, arguments) : cssRule;
                        };

                        selectorFunc.inside = function(el) {
                            return $(el).find(selector);
                        };

                        selectorFunc.of = function(el) {
                            return $(el).parents(selector).eq(0);
                        };

                        selectorFunc.under = function(el) {

                            var nodes = [];

                            selectorFunc().each(function(){
                                if ($(this).parents().filter(el).length) {
                                    nodes.push(this);
                                }
                            });

                            return $(nodes);
                        };
                        
                        if ($.isPlainObject(selectorFuncExtension)) {
                            $.extend(selectorFunc, selectorFuncExtension);
                        }

                        return selectorFunc;

                    })(instance, val, key);

                // Else just reference it, e.g. controller instance
                } else {

                    instance[key] = val;
                }
            }

            // !-- FOUNDRY HACK --! //
            // Augment view properties into view functions.
            // self.view.listItem(useHtml, data, callback);
            var views = instanceOptions.view;

            // Prevent augmented functions from being
            // extended onto the prototype view function.
            var __view = instance.view;

            instance.view = function() {
                return __view.apply(this, arguments);
            };

            each(views || {}, function(name, view){

                instance.view[name] = function(useHtml) {

                    var args = makeArray(arguments);

                    if ($.isBoolean(useHtml)) {
                        args = args.slice(1);
                    } else {
                        useHtml = false;
                    }

                    return instance.view.apply(instance, [useHtml, name].concat(args));
                }
            });

            // !-- FOUNDRY HACK --! //
            // Instance property override
            $.extend(instance, instanceOptions.controller);

            // !--- FOUNDRY HACK --! //
            instance.pluginInstances = {};

            /**
             * @attribute called
             * String name of current function being called on controller instance.  This is
             * used for picking the right view in render.
             * @hide
             */
            instance.called = "init";

            // bind all event handlers
            instance._bind();

            var __init = instance.init || $.noop;

            // !-- FOUNDRY HACK --! //
            // Trigger init event when controller is created.
            instance.init = function(){
                instance.init = __init;
                result = __init.apply(instance, arguments);
                instance.trigger("init." + Class.fullName.toLowerCase(), [instance]);
                return result;
            }

            /**
             * @attribute element
             * The controller instance's delegated element. This
             * is set by [jQuery.Controller.prototype.setup setup]. It
             * is a jQuery wrapped element.
             *
             * For example, if I add MyWidget to a '#myelement' element like:
             *
             *     $.Controller("MyWidget",{
             *       init : function(){
             *         this.element.css("color","red")
             *       }
             *     })
             *
             *     $("#myelement").my_widget()
             *
             * MyWidget will turn #myelement's font color red.
             *
             * ## Using a different element.
             *
             * Sometimes, you want a different element to be this.element.  A
             * very common example is making progressively enhanced form widgets.
             *
             * To change this.element, overwrite Controller's setup method like:
             *
             *     $.Controller("Combobox",{
             *       setup : function(el, options){
             *          this.oldElement = $(el);
             *          var newEl = $('<div/>');
             *          this.oldElement.wrap(newEl);
             *          this._super(newEl, options);
             *       },
             *       init : function(){
             *          this.element //-> the div
             *       },
             *       ".option click" : function(){
             *         // event handler bound on the div
             *       },
             *       destroy : function(){
             *          var div = this.element; //save reference
             *          this._super();
             *          div.replaceWith(this.oldElement);
             *       }
             *     }
             */
            return [element, instanceOptions].concat(makeArray(arguments).slice(2));
            /**
             * @function init
             *
             * Implement this.
             */
        },
        /**
         * Bind attaches event handlers that will be
         * removed when the controller is removed.
         *
         * This used to be a good way to listen to events outside the controller's
         * [jQuery.Controller.prototype.element element].  However,
         * using templated event listeners is now the prefered way of doing this.
         *
         * ### Example:
         *
         *     init: function() {
         *        // calls somethingClicked(el,ev)
         *        this.bind('click','somethingClicked')
         *
         *        // calls function when the window is clicked
         *        this.bind(window, 'click', function(ev){
         *          //do something
         *        })
         *     },
         *     somethingClicked: function( el, ev ) {
         *
         *     }
         *
         * @param {HTMLElement|jQuery.fn|Object} [el=this.element]
         * The element to be bound.  If an eventName is provided,
         * the controller's element is used instead.
         *
         * @param {String} eventName The event to listen for.
         * @param {Function|String} func A callback function or the String name of a controller function.  If a controller
         * function name is given, the controller function is called back with the bound element and event as the first
         * and second parameter.  Otherwise the function is called back like a normal bind.
         * @return {Integer} The id of the binding in this._bindings
         */

        on: function(eventName) {

            var args = makeArray(arguments),
                element = this.element,
                length = args.length;

            // Listen to the controller's element
            // on(eventName, eventHandler);
            if (length==2) {
                return this._binder(element, eventName, args[1]);
            }

            // Listen to controller's child elements matching the selector
            // on(eventName, selector, eventHandler);
            // args[1] == selector, jquery collection or dom node.
            // args[2] == eventHandler.
            if (length==3 && isString(args[1])) {
                return this._binder(element, eventName, args[2], args[1]);
            } else {
                return this._binder(args[1], eventName, args[2]);
            }

            // Listen to an element from another element
            // on(eventName, element, selector, eventHandler);
            if (length==4) {
                return this._binder($(args[1]), eventName, args[3], args[2]);
            }
        },

        // !-- FOUNDRY HACK --! //
        // Rename this.bind from this_bind. Conflict with mootools.
        // _bind: function( el, eventName, func ) {
        _bind: function() {

            var instance = this,
                Class    = instance[STR_CONSTRUCTOR],
                actions  = Class.actions,
                bindings = instance._bindings = [],
                element  = instance.element;

            each(actions || {}, function(name, action){

                if (!actions.hasOwnProperty(name)) return;

                var ready = Class.actions[name] || Class._action(name, instance.options);

                // Translate to the controller element first
                if ($.isControllerInstance(ready.delegate)) {
                    ready.delegate = ready.delegate.element;
                }

                bindings.push(
                    ready.processor(
                        ready.delegate || element,
                        ready.parts[2],
                        ready.parts[1],
                        name,
                        instance
                    )
                );
            });

            //setup to be destroyed ... don't bind b/c we don't want to remove it
            var destroyCB = shifter(this,"destroy");
            element.bind("destroyed", destroyCB);
            bindings.push(function( el ) {
                $(el).unbind("destroyed", destroyCB);
            });
            return bindings.length;
        },
        _binder: function( el, eventName, func, selector ) {
            if ( typeof func == 'string' ) {
                func = shifter(this,func);
            }
            this._bindings.push(binder(el, eventName, func, selector));
            return this._bindings.length;
        },
        _unbind : function(){
            var el = this.element[0];
            each(this._bindings, function( key, value ) {
                value(el);
            });
            //adds bindings
            this._bindings = [];
        },
        // !-- FOUNDRY HACK --! //
        // Element event triggering
        trigger: function(name) {

            var el = this.element;
            if (!el) return;

            var event = $.Event(name);
                el.trigger.apply(el, [event].concat($.makeArray(arguments).slice(1)));

            return event;
        },
        /**
         * Delegate will delegate on an elememt and will be undelegated when the controller is removed.
         * This is a good way to delegate on elements not in a controller's element.<br/>
         * <h3>Example:</h3>
         * @codestart
         * // calls function when the any 'a.foo' is clicked.
         * this.delegate(document.documentElement,'a.foo', 'click', function(ev){
         *   //do something
         * })
         * @codeend
         * @param {HTMLElement|jQuery.fn} [element=this.element] the element to delegate from
         * @param {String} selector the css selector
         * @param {String} eventName the event to bind to
         * @param {Function|String} func A callback function or the String name of a controller function.  If a controller
         * function name is given, the controller function is called back with the bound element and event as the first
         * and second parameter.  Otherwise the function is called back like a normal bind.
         * @return {Integer} The id of the binding in this._bindings
         */
        delegate: function( element, selector, eventName, func ) {
            if ( typeof element == 'string' ) {
                func = eventName;
                eventName = selector;
                selector = element;
                element = this.element;
            }
            return this._binder(element, eventName, func, selector);
        },
        /**
         * Update extends [jQuery.Controller.prototype.options this.options]
         * with the `options` argument and rebinds all events.  It basically
         * re-configures the controller.
         *
         * For example, the following controller wraps a recipe form. When the form
         * is submitted, it creates the recipe on the server.  When the recipe
         * is `created`, it resets the form with a new instance.
         *
         *     $.Controller('Creator',{
         *       "{recipe} created" : function(){
         *         this.update({recipe : new Recipe()});
         *         this.element[0].reset();
         *         this.find("[type=submit]").val("Create Recipe")
         *       },
         *       "submit" : function(el, ev){
         *         ev.preventDefault();
         *         var recipe = this.options.recipe;
         *         recipe.attrs( this.element.formParams() );
         *         this.find("[type=submit]").val("Saving...")
         *         recipe.save();
         *       }
         *     });
         *     $('#createRecipes').creator({recipe : new Recipe()})
         *
         *
         * @demo jquery/controller/demo-update.html
         *
         * Update is called if a controller's [jquery.controller.plugin jQuery helper] is
         * called on an element that already has a controller instance
         * of the same type.
         *
         * For example, a widget that listens for model updates
         * and updates it's html would look like.
         *
         *     $.Controller('Updater',{
         *       // when the controller is created, update the html
         *       init : function(){
         *         this.updateView();
         *       },
         *
         *       // update the html with a template
         *       updateView : function(){
         *         this.element.html( "content.ejs",
         *                            this.options.model );
         *       },
         *
         *       // if the model is updated
         *       "{model} updated" : function(){
         *         this.updateView();
         *       },
         *       update : function(options){
         *         // make sure you call super
         *         this._super(options);
         *
         *         this.updateView();
         *       }
         *     })
         *
         *     // create the controller
         *     // this calls init
         *     $('#item').updater({model: recipe1});
         *
         *     // later, update that model
         *     // this calls "{model} updated"
         *     recipe1.update({name: "something new"});
         *
         *     // later, update the controller with a new recipe
         *     // this calls update
         *     $('#item').updater({model: recipe2});
         *
         *     // later, update the new model
         *     // this calls "{model} updated"
         *     recipe2.update({name: "something newer"});
         *
         * _NOTE:_ If you overwrite `update`, you probably need to call
         * this._super.
         *
         * ### Example
         *
         *     $.Controller("Thing",{
         *       init: function( el, options ) {
         *         alert( 'init:'+this.options.prop )
         *       },
         *       update: function( options ) {
         *         this._super(options);
         *         alert('update:'+this.options.prop)
         *       }
         *     });
         *     $('#myel').thing({prop : 'val1'}); // alerts init:val1
         *     $('#myel').thing({prop : 'val2'}); // alerts update:val2
         *
         * @param {Object} options A list of options to merge with
         * [jQuery.Controller.prototype.options this.options].  Often, this method
         * is called by the [jquery.controller.plugin jQuery helper function].
         */
        update: function( options ) {
            extend(this.options, options);
            this._unbind();
            this._bind();
        },
        /**
         * Destroy unbinds and undelegates all event handlers on this controller,
         * and prevents memory leaks.  This is called automatically
         * if the element is removed.  You can overwrite it to add your own
         * teardown functionality:
         *
         *     $.Controller("ChangeText",{
         *       init : function(){
         *         this.oldText = this.element.text();
         *         this.element.text("Changed!!!")
         *       },
         *       destroy : function(){
         *         this.element.text(this.oldText);
         *         this._super(); //Always call this!
         *     })
         *
         * Make sure you always call <code>_super</code> when overwriting
         * controller's destroy event.  The base destroy functionality unbinds
         * all event handlers the controller has created.
         *
         * You could call destroy manually on an element with ChangeText
         * added like:
         *
         *     $("#changed").change_text("destroy");
         *
         */
        destroy: function() {

            if ( this._destroyed ) {
                return;
            }
            var fname = this[STR_CONSTRUCTOR]._fullName,
                controllers;

            // remove all plugins
            for (pname in this.pluginInstances) {
                this.removePlugin(pname);
            }

            // mark as destroyed
            this._destroyed = true;

            // remove the className
            this.element.removeClass(fname);

            // unbind bindings
            this._unbind();
            // clean up
            delete this._actions;

            delete this.element.data("controllers")[fname];

            $(this).triggerHandler("destroyed"); //in case we want to know if the controller is removed

            // !-- FOUNDRY HACK --! //
            // Reassign this.element to an empty jQuery element instead.
            this.element = $();
        },
        /**
         * Queries from the controller's element.
         * @codestart
         * ".destroy_all click" : function() {
         *    this.find(".todos").remove();
         * }
         * @codeend
         * @param {String} selector selection string
         * @return {jQuery.fn} returns the matched elements
         */
        find: function( selector ) {
            return this.element.find(selector);
        },

        // !-- FOUNDRY HACK --! //
        // Quick acccess to views.
        view: function() {

            var args = makeArray(arguments),
                name,
                options = args,
                useHtml = false,
                context = this[STR_CONSTRUCTOR].component || $,
                html = "",
                view = this.options.view || {};

            if (typeof args[0] == "boolean") {
                useHtml = args[0];
                options = args.slice(1);
            }

            name = options[0] = view[options[0]];

            // If view is not assigned, return empty string.
            if (name==undefined) {
                return (useHtml) ? "" : $("");
            }

            html = context.View.apply(context, options);

            return (useHtml) ? html : $($.parseHTML($.trim(html)));
        },

        getPlugin: function(name) {

            return this.pluginInstances[name];
        },

        addSubscriber: function(instance) {

            var instances = ($.isArray(instance)) ? instance : [instance || {}];

            // Prep options
            var host = this,
                hostname = this.Class.hostname,
                options = {};
                options["{" + hostname + "}"] = host;

            $.map(instances, function(instance, i){

                // If this is not a controller instance.
                if (!$.isControllerInstance(instance)) return false;

                // If instance is already a subscriber,skip.
                if (instance.options[hostname]===this) return instance;

                // Also map itself as a method name
                instance[hostname] = host;

                // Attach publisher to subscriber
                return instance.update(options);
            });

            return instances;
        },

        // addPlugin(name, object, [options]);
        // The object should consist of a method called destroy();

        // addPlugin(name, function, [options]);
        // The function should return an object with a method called destroy();

        addPlugin: function(name, plugin, options) {

            if (!name) return;

            // This means we are working with plugin shorthand
            if ((!plugin && !options) || $.isPlainObject(plugin)) {
                options = plugin;
                plugin = [this.Class.root, this.Class.fullName, $.String.capitalize(name)].join(".");
            }

            // If plugin is a string, get the controller from it.
            if ($.isString(plugin)) {
                plugin = $.getController(plugin);
            }

            var isPluginInstance = $.isControllerInstance(plugin);

            // Controller class are also functions,
            // so this simple test is good enough.
            if (!isFunction(plugin) && !isPluginInstance) return;

            // Normalize plugin options
            var pluginOptions =
                this.Class.pluginExtendsInstance ?
                    this.options[name] :
                    (this.options.plugin || {})[name];

            options = $.extend(true, {element: this.element}, options, pluginOptions);

            // Determine plugin type
            var type =
                ((isPluginInstance) ? "instance" :
                (($.isController(plugin)) ? "controller" : "function"));

            // Trigger addPlugin event so controller can decorate the options
            this.trigger("addPlugin", [name, plugin, options, type]);

            var hostname = this.Class.hostname;

            // Subcontrollers should have a way to listen back to host controller
            options["{" + hostname + "}"] = this;

            var pluginInstance;

            switch(type) {

                // Plugin instance
                case "instance":

                    pluginInstance = plugin;

                    // Update child plugin with custom plugin options from host
                    plugin.update(options);

                    plugin[hostname] = this;
                    break;

                // Plugin controller
                case "controller":
                    pluginInstance = options.element.addController(plugin, options);
                    break;

                // Plugin function
                case "function":
                    pluginInstance = plugin(this, options);
                    break;
            }

            // If pluginInstance could not be created, stop.
            if (!pluginInstance) return;

            // Register plugin
            this.pluginInstances[name] = pluginInstance;

            // Also extend instance with a property point to the plugin
            if (this.Class.pluginExtendsInstance) {
                this[name] = pluginInstance;
            }

            // Host controller should also have a way to listen back to the child controller
            if (type!=="function") {

                var hostOptions = {};
                hostOptions["{" + name + "}"] = pluginInstance;

                this.update(hostOptions);
            }

            // Trigger registerPlugin
            this.trigger("registerPlugin", [name, pluginInstance, options, type]);

            return pluginInstance;
        },

        removePlugin: function(name) {

            var plugin = this.getPlugin(name);

            if (!plugin) return;

            // Trigger removePlugin
            this.trigger("removePlugin", [name, plugin]);

            delete this.pluginInstances[name];

            return $.isFunction(plugin.destroy) ? plugin.destroy() : null;
        },

        invokePlugin: function(name, method, args) {

            var plugin = this.getPlugin(name);

            // If plugin not exist, stop.
            if (!plugin) return;

            // If plugin method not exist, stop.
            if (!$.isFunction(plugin[method])) return;

            // Let any third party modify the arguments if required
            this.trigger("invokePlugin", [name, plugin, args]);

            return plugin[method].apply(this, args);
        },

        getMessageGroup: function() {

            // Find parent element
            var messageGroup = ($.isFunction(this.messageGroup)) ? this.messageGroup() : this.element.find("[data-message-group]");

            if (messageGroup.length < 1) {
                messageGroup = $("<div data-message-group></div>").prependTo(this.element);
            }

            return messageGroup;
        },

        setMessage: function(message, type) {

            // Normalize arguments
            var defaultOptions = {
                    type   : "warning", // type: info, error, success
                    message: "",
                    parent : this.getMessageGroup(),
                    element: $('<div class="o-alert o-alert--dismissible"><button type="button" class="o-alert__close" data-bs-dismiss="alert"></button></div>')
                },
                userOptions = {},
                isDeferred = $.isDeferred(message);

            // Normalize user options
            if ($.isPlainObject(message) && !isDeferred) {
                userOptions = message;
            } else {
                userOptions = {
                    message: message,
                    type   : type || "warning"
                }
            }

            var options = $.extend({}, defaultOptions, userOptions),
                element = options.element;

            if ($.isDeferred(message)) {

                var myself = arguments.callee,
                    context = this;

                message.done(function(message, type) {
                    options.message = message;
                    options.type = type || "warning";
                    myself.call(context, options);
                    element.show();
                });

            } else {

                element
                    .addClass("o-alert--" + options.type)
                    .append(options.message);

                if ($('html').has(element).length < 1) {
                    element.appendTo(options.parent);
                }
            }

            return element;
        },

        clearMessage: function() {

            this.getMessageGroup().empty();
        },

        //tells callback to set called on this.  I hate this.
        _set_called: true
    });

    var processors = $.Controller.Class.processors,

    //------------- PROCESSSORS -----------------------------
    //processors do the binding.  They return a function that
    //unbinds when called.
    //the basic processor that binds events
    basicProcessor = function( el, event, selector, methodName, controller ) {

        // !-- FOUNDRY HACK --! //
        // Support for passing event data

        var method = controller[methodName],
            eventData;

        if (isArray(method) && isFunction(method[1])) {
            eventData = method[0];
        }

        return binder(el, event, shifter(controller, methodName), selector, eventData);
    };


    //set common events to be processed as a basicProcessor
    each("change click contextmenu dblclick keydown keyup keypress mousedown mousemove mouseout mouseover mouseup reset resize scroll select submit focusin focusout mouseenter mouseleave".split(" "), function( i, v ) {
        processors[v] = basicProcessor;
    });
    /**
     *  @add jQuery.fn
     */

    //used to determine if a controller instance is one of controllers
    //controllers can be strings or classes

    var normalizeController = function(controller) {
        return controller.replace("$.Controller", controllerRoot);
    }

    var getController = function(controller) {
        if (isString(controller)) {
            controller = normalizeController(controller);
            controller = getObject(controller) || getObject(controllerRoot + "." + controller);
        };
        if (isController(controller)) {
            return controller;
        };
    }

    var isController = function(controller) {
        return isFunction(controller) && controller.hasOwnProperty("_fullName");
    }

    var flattenControllers = function(controllers) {
        return $.map(controllers, function(controller){
            return (isArray(controller)) ? flattenControllers(controller) : getController(controller);
        });
    };

    $.getController = getController;

    $.isController = function(controller) {
        return !!getController(controller);
    }

    $.isControllerInstance = function(instance) {
        return instance && instance[STR_CONSTRUCTOR] && isController(instance[STR_CONSTRUCTOR]);
    }

    $.isControllerOf = function(instance, controllers) {

        if (!controllers) return false;

        if (!isArray(controllers)) {
            controllers = [controllers];
        }

        for (var i=0; i<controllers.length; i++) {
            var controller = getController(controllers[i]);
            if (instance instanceof controller) return true;
        }

        return false;
    };

    $.fn.extend({
        /**
         * @function controllers
         * Gets all controllers in the jQuery element.
         * @return {Array} an array of controller instances.
         */
        controllers: function() {

            var candidates = flattenControllers(makeArray(arguments)),
                instances = [];

            this.each(function() {

                var controllers = $.data(this, "controllers");

                each(controllers || {}, function(_fullName, instance){

                    if (!controllers.hasOwnProperty(_fullName)) return;

                    if (!candidates.length || $.isControllerOf(instance, candidates)) {
                        instances.push(instance);
                    }
                });
            });

            return instances;
        },

        /**
         * @function controller
         * Gets a controller in the jQuery element.  With no arguments, returns the first one found.
         * @param {Object} controller (optional) if exists, the first controller instance with this class type will be returned.
         * @return {jQuery.Controller} the first controller.
         */
        controller: function(controller, options) {

            // Getter
            if (options===undefined) {
                return this.controllers(controller)[0];
            }

            // Setter
            this.addController.apply(this, arguments);
            return this;
        },

        hasController: function(controller) {

            var _fullName =
                (getController(controller) || {})._fullName ||
                (isString(controller) ? underscoreAndRemoveController(normalizeController(controller)) : "");

            return (!_fullName) ? false : (($(this).data("controllers") || {}).hasOwnProperty(_fullName));
        },

        addController: function(controller, options, callback) {

            var Controller = getController(controller);

            if (!Controller) return;

            var instances = [];

            this.each(function(){

                // Do not add controller on script node or non-element nodes.
                if (this.nodeType!==1 || this.nodeName=="SCRIPT") return;

                // Just return existing instance
                var existingInstance = $(this).controller(controller);
                if (existingInstance) {
                    instances.push(existingInstance);
                    return;
                }

                // Or create a new instance
                var instance = new Controller(this, options);
                isFunction(callback) && callback.apply(instance, [$(this), instance]);
                instances.push(instance);
            });

            return (instances.length > 1) ? instances : instances[0];
        },

        removeController: function(controller) {
            this.each(function(){
                var instances = $(this).controllers(controller);
                while (instances.length) {
                    instances.shift().destroy();
                }
            });
            return this;
        },

        addControllerWhenAvailable: function(controller) {

            var elements = this,
                args = arguments,
                task = $.Deferred();

            if ($.isController(controller)) {
                controller = controller.fullName;
            }

            if (!isString(controller)) {
                return task.reject();
            }

            $.module("$:/Controllers/" + controller)
                .pipe(
                    function(){
                        var instance = elements.addController.apply(elements, args);
                        task.resolveWith(instance, [elements, instance]);
                    },
                    task.reject,
                    task.fail
                );

            return task;
        },

        // @deprecated 2.2
        implement: function() {
            this.addController.apply(this, arguments);
            return this;
        }

    });

    // !-- FOUNDRY HACK --! //
    // Add support for augmented selector function on jQuery's DOM traversal/filtering methods.
    (function(){
    var fns = ["is", "find"],
        _fns = {},
        fn;

    while (fn = fns.shift()) {
        _fns[fn] = $.fn[fn];
        $.fn[fn] = (function(fn) {
            return function(obj) {
                return _fns[fn].apply(this, (obj || {}).hasOwnProperty("of") ? [obj.selector] : arguments);
            }
        })(fn);
    }
    })();

})();(function(){

    // a path like string into something that's ok for an element ID
    var toId = function( src ) {
        return src.replace(/^\/\//, "").replace(/[\/\.]/g, "_");
    },
        makeArray = $.makeArray,
        // used for hookup ids
        id = 1;
    // this might be useful for testing if html
    // htmlTest = /^[\s\n\r\xA0]*<(.|[\r\n])*>[\s\n\r\xA0]*$/
    /**
     * @class jQuery.View
     * @parent jquerymx
     * @plugin jquery/view
     * @test jquery/view/qunit.html
     * @download dist/jquery.view.js
     *
     * @description A JavaScript template framework.
     *
     * View provides a uniform interface for using templates with
     * jQuery. When template engines [jQuery.View.register register]
     * themselves, you are able to:
     *
     *  - Use views with jQuery extensions [jQuery.fn.after after], [jQuery.fn.append append],
     *   [jQuery.fn.before before], [jQuery.fn.html html], [jQuery.fn.prepend prepend],
     *   [jQuery.fn.replaceWith replaceWith], [jQuery.fn.text text].
     *  - Template loading from html elements and external files.
     *  - Synchronous and asynchronous template loading.
     *  - [view.deferreds Deferred Rendering].
     *  - Template caching.
     *  - Bundling of processed templates in production builds.
     *  - Hookup jquery plugins directly in the template.
     *
     * The [mvc.view Get Started with jQueryMX] has a good walkthrough of $.View.
     *
     * ## Use
     *
     *
     * When using views, you're almost always wanting to insert the results
     * of a rendered template into the page. jQuery.View overwrites the
     * jQuery modifiers so using a view is as easy as:
     *
     *     $("#foo").html('mytemplate.ejs',{message: 'hello world'})
     *
     * This code:
     *
     *  - Loads the template a 'mytemplate.ejs'. It might look like:
     *    <pre><code>&lt;h2>&lt;%= message %>&lt;/h2></pre></code>
     *
     *  - Renders it with {message: 'hello world'}, resulting in:
     *    <pre><code>&lt;div id='foo'>"&lt;h2>hello world&lt;/h2>&lt;/div></pre></code>
     *
     *  - Inserts the result into the foo element. Foo might look like:
     *    <pre><code>&lt;div id='foo'>&lt;h2>hello world&lt;/h2>&lt;/div></pre></code>
     *
     * ## jQuery Modifiers
     *
     * You can use a template with the following jQuery modifiers:
     *
     * <table>
     * <tr><td>[jQuery.fn.after after]</td><td> <code>$('#bar').after('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.append append] </td><td>  <code>$('#bar').append('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.before before] </td><td> <code>$('#bar').before('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.html html] </td><td> <code>$('#bar').html('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.prepend prepend] </td><td> <code>$('#bar').prepend('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.replaceWith replaceWith] </td><td> <code>$('#bar').replaceWith('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.text text] </td><td> <code>$('#bar').text('temp.jaml',{});</code></td></tr>
     * </table>
     *
     * You always have to pass a string and an object (or function) for the jQuery modifier
     * to user a template.
     *
     * ## Template Locations
     *
     * View can load from script tags or from files.
     *
     * ## From Script Tags
     *
     * To load from a script tag, create a script tag with your template and an id like:
     *
     * <pre><code>&lt;script type='text/ejs' id='recipes'>
     * &lt;% for(var i=0; i &lt; recipes.length; i++){ %>
     *   &lt;li>&lt;%=recipes[i].name %>&lt;/li>
     * &lt;%} %>
     * &lt;/script></code></pre>
     *
     * Render with this template like:
     *
     * @codestart
     * $("#foo").html('recipes',recipeData)
     * @codeend
     *
     * Notice we passed the id of the element we want to render.
     *
     * ## From File
     *
     * You can pass the path of a template file location like:
     *
     *     $("#foo").html('templates/recipes.ejs',recipeData)
     *
     * However, you typically want to make the template work from whatever page they
     * are called from.  To do this, use // to look up templates from JMVC root:
     *
     *     $("#foo").html('//app/views/recipes.ejs',recipeData)
     *
     * Finally, the [jQuery.Controller.prototype.view controller/view] plugin can make looking
     * up a thread (and adding helpers) even easier:
     *
     *     $("#foo").html( this.view('recipes', recipeData) )
     *
     * ## Packaging Templates
     *
     * If you're making heavy use of templates, you want to organize
     * them in files so they can be reused between pages and applications.
     *
     * But, this organization would come at a high price
     * if the browser has to
     * retrieve each template individually. The additional
     * HTTP requests would slow down your app.
     *
     * Fortunately, [steal.static.views steal.views] can build templates
     * into your production files. You just have to point to the view file like:
     *
     *     steal.views('path/to/the/view.ejs');
     *
     * ## Asynchronous
     *
     * By default, retrieving requests is done synchronously. This is
     * fine because StealJS packages view templates with your JS download.
     *
     * However, some people might not be using StealJS or want to delay loading
     * templates until necessary. If you have the need, you can
     * provide a callback paramter like:
     *
     *     $("#foo").html('recipes',recipeData, function(result){
     *       this.fadeIn()
     *     });
     *
     * The callback function will be called with the result of the
     * rendered template and 'this' will be set to the original jQuery object.
     *
     * ## Deferreds (3.0.6)
     *
     * If you pass deferreds to $.View or any of the jQuery
     * modifiers, the view will wait until all deferreds resolve before
     * rendering the view.  This makes it a one-liner to make a request and
     * use the result to render a template.
     *
     * The following makes a request for todos in parallel with the
     * todos.ejs template.  Once todos and template have been loaded, it with
     * render the view with the todos.
     *
     *     $('#todos').html("todos.ejs",Todo.findAll());
     *
     * ## Just Render Templates
     *
     * Sometimes, you just want to get the result of a rendered
     * template without inserting it, you can do this with $.View:
     *
     *     var out = $.View('path/to/template.jaml',{});
     *
     * ## Preloading Templates
     *
     * You can preload templates asynchronously like:
     *
     *     $.get('path/to/template.jaml',{},function(){},'view');
     *
     * ## Supported Template Engines
     *
     * JavaScriptMVC comes with the following template languages:
     *
     *   - EmbeddedJS
     *     <pre><code>&lt;h2>&lt;%= message %>&lt;/h2></code></pre>
     *
     *   - JAML
     *     <pre><code>h2(data.message);</code></pre>
     *
     *   - Micro
     *     <pre><code>&lt;h2>{%= message %}&lt;/h2></code></pre>
     *
     *   - jQuery.Tmpl
     *     <pre><code>&lt;h2>${message}&lt;/h2></code></pre>

     *
     * The popular <a href='http://awardwinningfjords.com/2010/08/09/mustache-for-javascriptmvc-3.html'>Mustache</a>
     * template engine is supported in a 2nd party plugin.
     *
     * ## Using other Template Engines
     *
     * It's easy to integrate your favorite template into $.View and Steal.  Read
     * how in [jQuery.View.register].
     *
     * @constructor
     *
     * Looks up a template, processes it, caches it, then renders the template
     * with data and optional helpers.
     *
     * With [stealjs StealJS], views are typically bundled in the production build.
     * This makes it ok to use views synchronously like:
     *
     * @codestart
     * $.View("//myplugin/views/init.ejs",{message: "Hello World"})
     * @codeend
     *
     * If you aren't using StealJS, it's best to use views asynchronously like:
     *
     * @codestart
     * $.View("//myplugin/views/init.ejs",
     *        {message: "Hello World"}, function(result){
     *   // do something with result
     * })
     * @codeend
     *
     * @param {String} view The url or id of an element to use as the template's source.
     * @param {Object} data The data to be passed to the view.
     * @param {Object} [helpers] Optional helper functions the view might use. Not all
     * templates support helpers.
     * @param {Object} [callback] Optional callback function.  If present, the template is
     * retrieved asynchronously.  This is a good idea if you aren't compressing the templates
     * into your view.
     * @return {String} The rendered result of the view or if deferreds
     * are passed, a deferred that will resolve to
     * the rendered result of the view.
     */
    var $view = $.View = function( view, data, helpers, callback ) {
        // if helpers is a function, it is actually a callback
        if ( typeof helpers === 'function' ) {
            callback = helpers;
            helpers = undefined;
        }

        // see if we got passed any deferreds
        var deferreds = getDeferreds(data);


        if ( deferreds.length ) { // does data contain any deferreds?
            // the deferred that resolves into the rendered content ...
            var deferred = $.Deferred();

            // add the view request to the list of deferreds
            deferreds.push(get(view, true))

            // wait for the view and all deferreds to finish
            $.when.apply($, deferreds).then(function( resolved ) {
                // get all the resolved deferreds
                var objs = makeArray(arguments),
                    // renderer is last [0] is the data
                    renderer = objs.pop()[0],
                    // the result of the template rendering with data
                    result;

                // make data look like the resolved deferreds
                if ( isDeferred(data) ) {
                    data = usefulPart(resolved);
                }
                else {
                    // go through each prop in data again,
                    // replace the defferreds with what they resolved to
                    for ( var prop in data ) {
                        if ( isDeferred(data[prop]) ) {
                            data[prop] = usefulPart(objs.shift());
                        }
                    }
                }
                // get the rendered result
                result = renderer(data, helpers);

                //resolve with the rendered view
                deferred.resolve(result);
                // if there's a callback, call it back with the result
                callback && callback(result);
            });
            // return the deferred ....
            return deferred.promise();
        }
        else {
            // no deferreds, render this bad boy
            var response,
                // if there's a callback function
                async = typeof callback === "function",
                // get the 'view' type
                deferred = get(view, async);

            // if we are async,
            if ( async ) {
                // return the deferred
                response = deferred;
                // and callback callback with the rendered result
                deferred.done(function( renderer ) {
                    callback(renderer(data, helpers))
                })
            } else {
                // otherwise, the deferred is complete, so
                // set response to the result of the rendering
                deferred.done(function( renderer ) {
                    response = renderer(data, helpers);
                });
            }

            return response;
        }
    },
        // makes sure there's a template, if not, has steal provide a warning
        checkText = function( text, url ) {
            if (!text.match(/[^\s]/) ) {
                
                throw "$.View ERROR: There is no template or an empty template at " + url;
            }
        },
        // returns a 'view' renderer deferred
        // url - the url to the view template
        // async - if the ajax request should be synchronous
        get = function( url, async ) {
            return $.ajax({
                url: url,
                dataType: "view",
                async: async
            });
        },
        // returns true if something looks like a deferred
        isDeferred = function( obj ) {
            return obj && $.isFunction(obj.always) // check if obj is a $.Deferred
        },
        // gets an array of deferreds from an object
        // this only goes one level deep
        getDeferreds = function( data ) {
            var deferreds = [];

            // pull out deferreds
            if ( isDeferred(data) ) {
                return [data]
            } else {
                for ( var prop in data ) {
                    if ( isDeferred(data[prop]) ) {
                        deferreds.push(data[prop]);
                    }
                }
            }
            return deferreds;
        },
        // gets the useful part of deferred
        // this is for Models and $.ajax that resolve to array (with success and such)
        // returns the useful, content part
        usefulPart = function( resolved ) {
            return $.isArray(resolved) && resolved.length === 3 && resolved[1] === 'success' ? resolved[0] : resolved
        };



    // you can request a view renderer (a function you pass data to and get html)
    // Creates a 'view' transport.  These resolve to a 'view' renderer
    // a 'view' renderer takes data and returns a string result.
    // For example:
    //
    //  $.ajax({dataType : 'view', src: 'foo.ejs'}).then(function(renderer){
    //     renderer({message: 'hello world'})
    //  })
    $.ajaxTransport("view", function( options, orig ) {
        // the url (or possibly id) of the view content
        var url = orig.url,
            // check if a suffix exists (ex: "foo.ejs")
            suffix = url.match(/\.[\w\d]+$/),
            type,
            // if we are reading a script element for the content of the template
            // el will be set to that script element
            el,
            // a unique identifier for the view (used for caching)
            // this is typically derived from the element id or
            // the url for the template
            id,
            // the AJAX request used to retrieve the template content
            jqXHR,

            // used to generate the response
            response = function( text ) {
                // get the renderer function
                var func = type.renderer(id, text);
                // cache if if we are caching
                if ( $view.cache ) {
                    $view.cached[id] = func;
                }
                // return the objects for the response's dataTypes
                // (in this case view)
                return {
                    view: func
                };
            };

        // if we have an inline template, derive the suffix from the 'text/???' part
        // this only supports '<script></script>' tags
        if ( el = document.getElementById(url) ) {
            suffix = "."+el.type.match(/\/(x\-)?(.+)/)[2];
        }

        // if there is no suffix, add one
        if (!suffix ) {
            suffix = $view.ext;
            url = url + $view.ext;
        }

        // convert to a unique and valid id
        id = toId(url);

        // if a absolute path, use steal to get it
        // you should only be using // if you are using steal
        if ( url.match(/^\/\//) ) {
            var sub = url.substr(2);
            url = typeof steal === "undefined" ?
                url = "/" + sub :
                steal.root.mapJoin(sub) +'';
        }

        //set the template engine type
        type = $view.types[suffix];

        // !-- FOUNDRY HACK --! //
        // Retrieve templates stored within $.template
        var template = $.template()[orig.url];

        // return the ajax transport contract: http://api.jquery.com/extending-ajax/
        return {
            send: function( headers, callback ) {

                // !-- FOUNDRY HACK --! //
                // Retrieve templates stored within $.template
                if ( template ) {

                    type = $view.types["." + template.type];

                    return callback(200, "success", response(template.content));

                // if it is cached,
                } else if ( $view.cached[id] ) {

                    // return the catched renderer
                    return callback(200, "success", {
                        view: $view.cached[id]
                    });

                // otherwise if we are getting this from a script elment
                } else if ( el ) {
                    // resolve immediately with the element's innerHTML
                    callback(200, "success", response(el.innerHTML));
                } else {
                    // make an ajax request for text
                    jqXHR = $.ajax({
                        async: orig.async,
                        url: url,
                        dataType: "text",
                        error: function() {
                            checkText("", url);
                            callback(404);
                        },
                        success: function( text ) {
                            // make sure we got some text back
                            checkText(text, url);
                            // cache and send back text
                            callback(200, "success", response(text))
                        }
                    });
                }
            },
            abort: function() {
                jqXHR && jqXHR.abort();
            }
        }
    })
    $.extend($view, {
        /**
         * @attribute hookups
         * @hide
         * A list of pending 'hookups'
         */
        hookups: {},
        /**
         * @function hookup
         * Registers a hookup function that can be called back after the html is
         * put on the page.  Typically this is handled by the template engine.  Currently
         * only EJS supports this functionality.
         *
         *     var id = $.View.hookup(function(el){
         *            //do something with el
         *         }),
         *         html = "<div data-view-id='"+id+"'>"
         *     $('.foo').html(html);
         *
         *
         * @param {Function} cb a callback function to be called with the element
         * @param {Number} the hookup number
         */
        hookup: function( cb ) {
            var myid = ++id;
            $view.hookups[myid] = cb;
            return myid;
        },
        /**
         * @attribute cached
         * @hide
         * Cached are put in this object
         */
        cached: {},
        /**
         * @attribute cache
         * Should the views be cached or reloaded from the server. Defaults to true.
         */
        cache: true,
        /**
         * @function register
         * Registers a template engine to be used with
         * view helpers and compression.
         *
         * ## Example
         *
         * @codestart
         * $.View.register({
         *  suffix : "tmpl",
         *  plugin : "jquery/view/tmpl",
         *  renderer: function( id, text ) {
         *      return function(data){
         *          return jQuery.render( text, data );
         *      }
         *  },
         *  script: function( id, text ) {
         *      var tmpl = $.tmpl(text).toString();
         *      return "function(data){return ("+
         *          tmpl+
         *          ").call(jQuery, jQuery, data); }";
         *  }
         * })
         * @codeend
         * Here's what each property does:
         *
         *    * plugin - the location of the plugin
         *    * suffix - files that use this suffix will be processed by this template engine
         *    * renderer - returns a function that will render the template provided by text
         *    * script - returns a string form of the processed template function.
         *
         * @param {Object} info a object of method and properties
         *
         * that enable template integration:
         * <ul>
         *   <li>plugin - the location of the plugin.  EX: 'jquery/view/ejs'</li>
         *   <li>suffix - the view extension.  EX: 'ejs'</li>
         *   <li>script(id, src) - a function that returns a string that when evaluated returns a function that can be
         *    used as the render (i.e. have func.call(data, data, helpers) called on it).</li>
         *   <li>renderer(id, text) - a function that takes the id of the template and the text of the template and
         *    returns a render function.</li>
         * </ul>
         */
        register: function( info ) {
            this.types["." + info.suffix] = info;

            if ( window.steal ) {
                steal.type(info.suffix + " view js", function( options, success, error ) {
                    var type = $view.types["." + options.type],
                        id = toId(options.rootSrc+'');

                    options.text = type.script(id, options.text)
                    success();
                })
            }
        },
        types: {},
        /**
         * @attribute ext
         * The default suffix to use if none is provided in the view's url.
         * This is set to .ejs by default.
         */
        ext: ".ejs",
        /**
         * Returns the text that
         * @hide
         * @param {Object} type
         * @param {Object} id
         * @param {Object} src
         */
        registerScript: function( type, id, src ) {
            return "$.View.preload('" + id + "'," + $view.types["." + type].script(id, src) + ");";
        },
        /**
         * @hide
         * Called by a production script to pre-load a renderer function
         * into the view cache.
         * @param {String} id
         * @param {Function} renderer
         */
        preload: function( id, renderer ) {
            $view.cached[id] = function( data, helpers ) {
                return renderer.call(data, data, helpers);
            };
        }

    });
    if ( window.steal ) {
        steal.type("view js", function( options, success, error ) {
            var type = $view.types["." + options.type],
                id = toId(options.rootSrc+'');

            options.text = "steal('" + (type.plugin || "jquery/view/" + options.type) + "').then(function($){" + "$.View.preload('" + id + "'," + options.text + ");\n})";
            success();
        })
    }

    //---- ADD jQUERY HELPERS -----
    //converts jquery functions to use views
    var convert, modify, isTemplate, isHTML, isDOM, getCallback, hookupView, funcs,
        // text and val cannot produce an element, so don't run hookups on them
        noHookup = {'val':true,'text':true};

    convert = function( func_name ) {
        // save the old jQuery helper
        var old = $.fn[func_name];

        // replace it wiht our new helper
        $.fn[func_name] = function() {

            var args = makeArray(arguments),
                callbackNum,
                callback,
                self = this,
                result;

            // if the first arg is a deferred
            // wait until it finishes, and call
            // modify with the result
            if ( isDeferred(args[0]) ) {
                args[0].done(function( res ) {
                    modify.call(self, [res], old);
                })
                return this;
            }
            //check if a template
            else if ( isTemplate(args) ) {

                // if we should operate async
                if ((callbackNum = getCallback(args))) {
                    callback = args[callbackNum];
                    args[callbackNum] = function( result ) {
                        modify.call(self, [result], old);
                        callback.call(self, result);
                    };
                    $view.apply($view, args);
                    return this;
                }
                // call view with args (there might be deferreds)
                result = $view.apply($view, args);

                // if we got a string back
                if (!isDeferred(result) ) {
                    // we are going to call the old method with that string
                    args = [result];
                } else {
                    // if there is a deferred, wait until it is done before calling modify
                    result.done(function( res ) {
                        modify.call(self, [res], old);
                    })
                    return this;
                }
            }
            return noHookup[func_name] ? old.apply(this,args) :
                modify.call(this, args, old);
        };
    };

    // modifies the content of the element
    // but also will run any hookup
    modify = function( args, old ) {
        var res, stub, hooks;

        //check if there are new hookups
        for ( var hasHookups in $view.hookups ) {
            break;
        }

        //if there are hookups, get jQuery object
        if ( hasHookups && args[0] && isHTML(args[0]) ) {
            hooks = $view.hookups;
            $view.hookups = {};
            args[0] = $(args[0]);
        }
        res = old.apply(this, args);

        //now hookup the hookups
        if ( hooks
        /* && args.length*/
        ) {
            hookupView(args[0], hooks);
        }
        return res;
    };

    // returns true or false if the args indicate a template is being used
    // $('#foo').html('/path/to/template.ejs',{data})
    // in general, we want to make sure the first arg is a string
    // and the second arg is data
    isTemplate = function( args ) {
        // save the second arg type
        var secArgType = typeof args[1];

        // the first arg is a string
        return typeof args[0] == "string" &&
                // the second arg is an object or function
               (secArgType == 'object' || secArgType == 'function') &&
               // but it is not a dom element
               !isDOM(args[1]);
    };
    // returns true if the arg is a jQuery object or HTMLElement
    isDOM = function(arg){
        return arg.nodeType || arg.jquery
    };
    // returns whether the argument is some sort of HTML data
    isHTML = function( arg ) {
        if ( isDOM(arg) ) {
            // if jQuery object or DOM node we're good
            return true;
        } else if ( typeof arg === "string" ) {
            // if string, do a quick sanity check that we're HTML
            arg = $.trim(arg);
            return arg.substr(0, 1) === "<" && arg.substr(arg.length - 1, 1) === ">" && arg.length >= 3;
        } else {
            // don't know what you are
            return false;
        }
    };

    //returns the callback arg number if there is one (for async view use)
    getCallback = function( args ) {
        return typeof args[3] === 'function' ? 3 : typeof args[2] === 'function' && 2;
    };

    hookupView = function( els, hooks ) {
        //remove all hookups
        var hookupEls, len, i = 0,
            id, func;
        els = els.filter(function() {
            return this.nodeType != 3; //filter out text nodes
        })
        hookupEls = els.add("[data-view-id]", els);
        len = hookupEls.length;
        for (; i < len; i++ ) {
            if ( hookupEls[i].getAttribute && (id = hookupEls[i].getAttribute('data-view-id')) && (func = hooks[id]) ) {
                func(hookupEls[i], id);
                delete hooks[id];
                hookupEls[i].removeAttribute('data-view-id');
            }
        }
        //copy remaining hooks back
        $.extend($view.hookups, hooks);
    };

    /**
     *  @add jQuery.fn
     *  @parent jQuery.View
     *  Called on a jQuery collection that was rendered with $.View with pending hookups.  $.View can render a
     *  template with hookups, but not actually perform the hookup, because it returns a string without actual DOM
     *  elements to hook up to.  So hookup performs the hookup and clears the pending hookups, preventing errors in
     *  future templates.
     *
     * @codestart
     * $($.View('//views/recipes.ejs',recipeData)).hookup()
     * @codeend
     */
    $.fn.hookup = function() {
        var hooks = $view.hookups;
        $view.hookups = {};
        hookupView(this, hooks);
        return this;
    };

    /**
     *  @add jQuery.fn
     */
    $.each([
    /**
     *  @function prepend
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/prepend/ jQuery().prepend()]
     *  to render [jQuery.View] templates inserted at the beginning of each element in the set of matched elements.
     *
     *      $('#test').prepend('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "prepend",
    /**
     *  @function append
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/append/ jQuery().append()]
     *  to render [jQuery.View] templates inserted at the end of each element in the set of matched elements.
     *
     *      $('#test').append('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "append",
    /**
     *  @function after
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/after/ jQuery().after()]
     *  to render [jQuery.View] templates inserted after each element in the set of matched elements.
     *
     *      $('#test').after('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "after",
    /**
     *  @function before
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/before/ jQuery().before()]
     *  to render [jQuery.View] templates inserted before each element in the set of matched elements.
     *
     *      $('#test').before('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "before",
    /**
     *  @function text
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/text/ jQuery().text()]
     *  to render [jQuery.View] templates as the content of each matched element.
     *  Unlike [jQuery.fn.html] jQuery.fn.text also works with XML, escaping the provided
     *  string as necessary.
     *
     *      $('#test').text('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "text",
    /**
     *  @function html
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/html/ jQuery().html()]
     *  to render [jQuery.View] templates as the content of each matched element.
     *
     *      $('#test').html('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "html",
    /**
     *  @function replaceWith
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/replaceWith/ jQuery().replaceWith()]
     *  to render [jQuery.View] templates replacing each element in the set of matched elements.
     *
     *      $('#test').replaceWith('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "replaceWith", "val"],function(i, func){
        convert(func);
    });

    //go through helper funcs and convert


})();(function(){

    // HELPER METHODS ==============
    var myEval = function( script ) {
        eval(script);
    },
        // removes the last character from a string
        // this is no longer needed
        // chop = function( string ) {
        //  return string.substr(0, string.length - 1);
        //},
        rSplit = $.String.rsplit,
        extend = $.extend,
        isArray = $.isArray,
        // regular expressions for caching
        returnReg = /\r\n/g,
        retReg = /\r/g,
        newReg = /\n/g,
        nReg = /\n/,
        slashReg = /\\/g,
        quoteReg = /"/g,
        singleQuoteReg = /'/g,
        tabReg = /\t/g,
        leftBracket = /\{/g,
        rightBracket = /\}/g,
        quickFunc = /\s*\(([\$\w]+)\)\s*->([^\n]*)/,
        // escapes characters starting with \
        clean = function( content ) {
            return content.replace(slashReg, '\\\\').replace(newReg, '\\n').replace(quoteReg, '\\"').replace(tabReg, '\\t');
        },
        // escapes html
        // - from prototype  http://www.prototypejs.org/
        escapeHTML = function( content ) {
            return content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(quoteReg, '&#34;').replace(singleQuoteReg, "&#39;");
        },
        $View = $.View,
        bracketNum = function(content){
            var lefts = content.match(leftBracket),
                rights = content.match(rightBracket);

            return (lefts ? lefts.length : 0) -
                   (rights ? rights.length : 0);
        },
        /**
         * @class jQuery.EJS
         *
         * @plugin jquery/view/ejs
         * @parent jQuery.View
         * @download  http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/view/ejs/ejs.js
         * @test jquery/view/ejs/qunit.html
         *
         *
         * Ejs provides <a href="http://www.ruby-doc.org/stdlib/libdoc/erb/rdoc/">ERB</a>
         * style client side templates.  Use them with controllers to easily build html and inject
         * it into the DOM.
         *
         * ###  Example
         *
         * The following generates a list of tasks:
         *
         * @codestart html
         * &lt;ul>
         * &lt;% for(var i = 0; i < tasks.length; i++){ %>
         *     &lt;li class="task &lt;%= tasks[i].identity %>">&lt;%= tasks[i].name %>&lt;/li>
         * &lt;% } %>
         * &lt;/ul>
         * @codeend
         *
         * For the following examples, we assume this view is in <i>'views\tasks\list.ejs'</i>.
         *
         *
         * ## Use
         *
         * ### Loading and Rendering EJS:
         *
         * You should use EJS through the helper functions [jQuery.View] provides such as:
         *
         *   - [jQuery.fn.after after]
         *   - [jQuery.fn.append append]
         *   - [jQuery.fn.before before]
         *   - [jQuery.fn.html html],
         *   - [jQuery.fn.prepend prepend],
         *   - [jQuery.fn.replaceWith replaceWith], and
         *   - [jQuery.fn.text text].
         *
         * or [jQuery.Controller.prototype.view].
         *
         * ### Syntax
         *
         * EJS uses 5 types of tags:
         *
         *   - <code>&lt;% CODE %&gt;</code> - Runs JS Code.
         *     For example:
         *
         *         <% alert('hello world') %>
         *
         *   - <code>&lt;%= CODE %&gt;</code> - Runs JS Code and writes the _escaped_ result into the result of the template.
         *     For example:
         *
         *         <h1><%= 'hello world' %></h1>
         *
         *   - <code>&lt;%== CODE %&gt;</code> - Runs JS Code and writes the _unescaped_ result into the result of the template.
         *     For example:
         *
         *         <h1><%== '<span>hello world</span>' %></h1>
         *
         *   - <code>&lt;%%= CODE %&gt;</code> - Writes <%= CODE %> to the result of the template.  This is very useful for generators.
         *
         *         <%%= 'hello world' %>
         *
         *   - <code>&lt;%# CODE %&gt;</code> - Used for comments.  This does nothing.
         *
         *         <%# 'hello world' %>
         *
         * ## Hooking up controllers
         *
         * After drawing some html, you often want to add other widgets and plugins inside that html.
         * View makes this easy.  You just have to return the Contoller class you want to be hooked up.
         *
         * @codestart
         * &lt;ul &lt;%= Mxui.Tabs%>>...&lt;ul>
         * @codeend
         *
         * You can even hook up multiple controllers:
         *
         * @codestart
         * &lt;ul &lt;%= [Mxui.Tabs, Mxui.Filler]%>>...&lt;ul>
         * @codeend
         *
         * To hook up a controller with options or any other jQuery plugin use the
         * [jQuery.EJS.Helpers.prototype.plugin | plugin view helper]:
         *
         * @codestart
         * &lt;ul &lt;%= plugin('mxui_tabs', { option: 'value' }) %>>...&lt;ul>
         * @codeend
         *
         * Don't add a semicolon when using view helpers.
         *
         *
         * <h2>View Helpers</h2>
         * View Helpers return html code.  View by default only comes with
         * [jQuery.EJS.Helpers.prototype.view view] and [jQuery.EJS.Helpers.prototype.text text].
         * You can include more with the view/helpers plugin.  But, you can easily make your own!
         * Learn how in the [jQuery.EJS.Helpers Helpers] page.
         *
         * @constructor Creates a new view
         * @param {Object} options A hash with the following options
         * <table class="options">
         *     <tbody><tr><th>Option</th><th>Default</th><th>Description</th></tr>
         *     <tr>
         *      <td>text</td>
         *      <td>&nbsp;</td>
         *      <td>uses the provided text as the template. Example:<br/><code>new View({text: '&lt;%=user%>'})</code>
         *      </td>
         *     </tr>
         *     <tr>
         *      <td>type</td>
         *      <td>'<'</td>
         *      <td>type of magic tags.  Options are '&lt;' or '['
         *      </td>
         *     </tr>
         *     <tr>
         *      <td>name</td>
         *      <td>the element ID or url </td>
         *      <td>an optional name that is used for caching.
         *      </td>
         *     </tr>
         *    </tbody></table>
         */
        EJS = function( options ) {
            // If called without new, return a function that
            // renders with data and helpers like
            // EJS({text: '<%= message %>'})({message: 'foo'});
            // this is useful for steal's build system
            if ( this.constructor != EJS ) {
                var ejs = new EJS(options);
                return function( data, helpers ) {
                    return ejs.render(data, helpers);
                };
            }
            // if we get a function directly, it probably is coming from
            // a steal-packaged view
            if ( typeof options == "function" ) {
                this.template = {
                    fn: options
                };
                return;
            }
            //set options on self
            extend(this, EJS.options, options);
            this.template = compile(this.text, this.type, this.name);
        };
    // add EJS to jQuery if it exists
    $ && ($.EJS = EJS);
    /**
     * @Prototype
     */
    EJS.prototype.
    /**
     * Renders an object with view helpers attached to the view.
     *
     *     new EJS({text: "<%= message %>"}).render({
     *       message: "foo"
     *     },{helper: function(){ ... }})
     *
     * @param {Object} object data to be rendered
     * @param {Object} [extraHelpers] an object with view helpers
     * @return {String} returns the result of the string
     */
    render = function( object, extraHelpers ) {
        object = object || {};
        this._extra_helpers = extraHelpers;
        var v = new EJS.Helpers(object, extraHelpers || {});
        return this.template.fn.call(object, object, v);
    };
    /**
     * @Static
     */

    extend(EJS, {
        /**
         * Used to convert what's in &lt;%= %> magic tags to a string
         * to be inserted in the rendered output.
         *
         * Typically, it's a string, and the string is just inserted.  However,
         * if it's a function or an object with a hookup method, it can potentially be
         * be ran on the element after it's inserted into the page.
         *
         * This is a very nice way of adding functionality through the view.
         * Usually this is done with [jQuery.EJS.Helpers.prototype.plugin]
         * but the following fades in the div element after it has been inserted:
         *
         * @codestart
         * &lt;%= function(el){$(el).fadeIn()} %>
         * @codeend
         *
         * @param {String|Object|Function} input the value in between the
         * write magic tags: &lt;%= %>
         * @return {String} returns the content to be added to the rendered
         * output.  The content is different depending on the type:
         *
         *   * string - the original string
         *   * null or undefined - the empty string ""
         *   * an object with a hookup method - the attribute "data-view-id='XX'", where XX is a hookup number for jQuery.View
         *   * a function - the attribute "data-view-id='XX'", where XX is a hookup number for jQuery.View
         *   * an array - the attribute "data-view-id='XX'", where XX is a hookup number for jQuery.View
         */
        text: function( input ) {
            // if it's a string, return
            if ( typeof input == 'string' ) {
                return input;
            }
            // if has no value
            if ( input === null || input === undefined ) {
                return '';
            }

            // if it's an object, and it has a hookup method
            var hook = (input.hookup &&
            // make a function call the hookup method

            function( el, id ) {
                input.hookup.call(input, el, id);
            }) ||
            // or if it's a function, just use the input
            (typeof input == 'function' && input) ||
            // of it its an array, make a function that calls hookup or the function
            // on each item in the array
            (isArray(input) &&
            function( el, id ) {
                for ( var i = 0; i < input.length; i++ ) {
                    input[i].hookup ? input[i].hookup(el, id) : input[i](el, id);
                }
            });
            // finally, if there is a funciton to hookup on some dom
            // pass it to hookup to get the data-view-id back
            if ( hook ) {
                return "data-view-id='" + $View.hookup(hook) + "'";
            }
            // finally, if all else false, toString it
            return input.toString ? input.toString() : "";
        },
        /**
         * Escapes the text provided as html if it's a string.
         * Otherwise, the value is passed to EJS.text(text).
         *
         * @param {String|Object|Array|Function} text to escape.  Otherwise,
         * the result of [jQuery.EJS.text] is returned.
         * @return {String} the escaped text or likely a $.View data-view-id attribute.
         */
        clean: function( text ) {
            //return sanatized text
            if ( typeof text == 'string' ) {
                return escapeHTML(text);
            } else if ( typeof text == 'number' ) {
                return text;
            } else {
                return EJS.text(text);
            }
        },
        /**
         * @attribute options
         * Sets default options for all views.
         *
         *     $.EJS.options.type = '['
         *
         * Only one option is currently supported: type.
         *
         * Type is the left hand magic tag.
         */
        options: {
            type: '[',
            ext: '.ejs'
        }
    });
    // ========= SCANNING CODE =========
    // Given a scanner, and source content, calls block  with each token
    // scanner - an object of magicTagName : values
    // source - the source you want to scan
    // block - function(token, scanner), called with each token
    var scan = function( scanner, source, block ) {
        // split on /\n/ to have new lines on their own line.
        var source_split = rSplit(source, nReg),
            i = 0;
        for (; i < source_split.length; i++ ) {
            scanline(scanner, source_split[i], block);
        }

    },
        scanline = function( scanner, line, block ) {
            scanner.lines++;
            var line_split = rSplit(line, scanner.splitter),
                token;
            for ( var i = 0; i < line_split.length; i++ ) {
                token = line_split[i];
                if ( token !== null ) {
                    block(token, scanner);
                }
            }
        },
        // creates a 'scanner' object.  This creates
        // values for the left and right magic tags
        // it's splitter property is a regexp that splits content
        // by all tags
        makeScanner = function( left, right ) {
            var scanner = {};
            extend(scanner, {
                left: left + '%',
                right: '%' + right,
                dLeft: left + '%%',
                dRight: '%%' + right,
                eeLeft : left + '%==',
                eLeft: left + '%=',
                cmnt: left + '%#',
                cleanLeft: left+"%~",
                scan: scan,
                lines: 0
            });
            scanner.splitter = new RegExp("(" + [scanner.dLeft, scanner.dRight, scanner.eeLeft, scanner.eLeft, scanner.cmnt, scanner.left, scanner.right + '\n', scanner.right, '\n'].join(")|(").
            replace(/\[/g, "\\[").replace(/\]/g, "\\]") + ")");
            return scanner;
        },


        // compiles a template where
        // source - template text
        // left - the left magic tag
        // name - the name of the template (for debugging)
        // returns an object like: {out : "", fn : function(){ ... }} where
        //   out -  the converted JS source of the view
        //   fn - a function made from the JS source
        compile = function( source, left, name ) {
            // make everything only use \n
            source = source.replace(returnReg, "\n").replace(retReg, "\n");
            // if no left is given, assume <
            left = left || '[';

            // put and insert cmds are used for adding content to the template
            // currently they are identical, I am not sure why
            var put_cmd = "___v1ew.push(",
                insert_cmd = put_cmd,
                // the text that starts the view code (or block function)
                startTxt = 'var ___v1ew = [];',
                // the text that ends the view code (or block function)
                finishTxt = "return ___v1ew.join('')",
                // initialize a buffer
                buff = new EJS.Buffer([startTxt], []),
                // content is used as the current 'processing' string
                // this is the content between magic tags
                content = '',
                // adds something to be inserted into the view template
                // this comes out looking like __v1ew.push("CONENT")
                put = function( content ) {
                    buff.push(put_cmd, '"', clean(content), '");');
                },
                // the starting magic tag
                startTag = null,
                // cleans the running content
                empty = function() {
                    content = ''
                },
                // what comes after clean or text
                doubleParen = "));",
                // a stack used to keep track of how we should end a bracket }
                // once we have a <%= %> with a leftBracket
                // we store how the file should end here (either '))' or ';' )
                endStack =[];

            // start going token to token
            scan(makeScanner(left, left === '[' ? ']' : '>'), source || "", function( token, scanner ) {
                // if we don't have a start pair
                var bn;
                if ( startTag === null ) {
                    switch ( token ) {
                    case '\n':
                        content = content + "\n";
                        put(content);
                        buff.cr();
                        empty();
                        break;
                        // set start tag, add previous content (if there is some)
                        // clean content
                    case scanner.left:
                    case scanner.eLeft:
                    case scanner.eeLeft:
                    case scanner.cmnt:
                        // a new line, just add whatever content w/i a clean
                        // reset everything
                        startTag = token;
                        if ( content.length > 0 ) {
                            put(content);
                        }
                        empty();
                        break;

                    case scanner.dLeft:
                        // replace <%% with <%
                        content += scanner.left;
                        break;
                    default:
                        content += token;
                        break;
                    }
                }
                else {
                    //we have a start tag
                    switch ( token ) {
                    case scanner.right:
                        // %>
                        switch ( startTag ) {
                        case scanner.left:
                            // <%

                            // get the number of { minus }
                            bn = bracketNum(content);
                            // how are we ending this statement
                            var last =
                                // if the stack has value and we are ending a block
                                endStack.length && bn == -1 ?
                                // use the last item in the block stack
                                endStack.pop() :
                                // or use the default ending
                                ";";

                            // if we are ending a returning block
                            // add the finish text which returns the result of the
                            // block
                            if(last === doubleParen) {
                                buff.push(finishTxt)
                            }
                            // add the remaining content
                            buff.push(content, last);

                            // if we have a block, start counting
                            if(bn === 1 ){
                                endStack.push(";")
                            }
                            break;
                        case scanner.eLeft:
                            // <%= clean content
                            bn = bracketNum(content);
                            if( bn ) {
                                endStack.push(doubleParen)
                            }
                            if(quickFunc.test(content)){
                                var parts = content.match(quickFunc)
                                content = "function(__){var "+parts[1]+"=$(__);"+parts[2]+"}"
                            }
                            buff.push(insert_cmd, $.globalNamespace + ".EJS.clean(", content,bn ? startTxt : doubleParen);
                            break;
                        case scanner.eeLeft:
                            // <%== content

                            // get the number of { minus }
                            bn = bracketNum(content);
                            // if we have more {, it means there is a block
                            if( bn ){
                                // when we return to the same # of { vs } end wiht a doubleParen
                                endStack.push(doubleParen)
                            }

                            buff.push(insert_cmd, $.globalNamespace + ".EJS.text(", content,
                                // if we have a block
                                bn ?
                                // start w/ startTxt "var _v1ew = [])"
                                startTxt :
                                // if not, add doubleParent to close push and text
                                doubleParen
                                );
                            break;
                        }
                        startTag = null;
                        empty();
                        break;
                    case scanner.dRight:
                        content += scanner.right;
                        break;
                    default:
                        content += token;
                        break;
                    }
                }
            })
            if ( content.length > 0 ) {
                // Should be content.dump in Ruby
                buff.push(put_cmd, '"', clean(content) + '");');
            }
            var template = buff.close(),
                out = {
                    out: 'try { with(_VIEW) { with (_CONTEXT) {' + template + " "+finishTxt+"}}}catch(e){e.lineNumber=null;throw e;}"
                };
            //use eval instead of creating a function, b/c it is easier to debug
            // myEval.call(out, 'this.fn = (function(_CONTEXT,_VIEW){' + out.out + '});\r\n//@ sourceURL=' + name + ".js");

            // !-- FOUNDRY HACK --! //
            // Removed //@ sourceURL as it will break with conditional compilation turned on in IE.
            myEval.call(out, 'this.fn = (function(_CONTEXT,_VIEW){ var $ = ' + $.globalNamespace + ';' + out.out + '});');

            return out;
        };


    // A Buffer used to add content to.
    // This is useful for performance and simplifying the
    // code above.
    // We also can use this so we know line numbers when there
    // is an error.
    // pre_cmd - code that sets up the buffer
    // post - code that finalizes the buffer
    EJS.Buffer = function( pre_cmd, post ) {
        // the current line we are on
        this.line = [];
        // the combined content added to this buffer
        this.script = [];
        // content at the end of the buffer
        this.post = post;
        // add the pre commands to the first line
        this.push.apply(this, pre_cmd);
    };
    EJS.Buffer.prototype = {
        // add content to this line
        // need to maintain your own semi-colons (for performance)
        push: function() {
            this.line.push.apply(this.line, arguments);
        },
        // starts a new line
        cr: function() {
            this.script.push(this.line.join(''), "\n");
            this.line = [];
        },
        //returns the script too
        close: function() {
            // if we have ending line content, add it to the script
            if ( this.line.length > 0 ) {
                this.script.push(this.line.join(''));
                this.line = [];
            }
            // if we have ending content, add it
            this.post.length && this.push.apply(this, this.post);
            // always end in a ;
            this.script.push(";");
            return this.script.join("");
        }

    };

    /**
     * @class jQuery.EJS.Helpers
     * @parent jQuery.EJS
     * By adding functions to jQuery.EJS.Helpers.prototype, those functions will be available in the
     * views.
     *
     * The following helper converts a given string to upper case:
     *
     *  $.EJS.Helpers.prototype.toUpper = function(params)
     *  {
     *      return params.toUpperCase();
     *  }
     *
     * Use it like this in any EJS template:
     *
     *  <%= toUpper('javascriptmvc') %>
     *
     * To access the current DOM element return a function that takes the element as a parameter:
     *
     *  $.EJS.Helpers.prototype.upperHtml = function(params)
     *  {
     *      return function(el) {
     *          $(el).html(params.toUpperCase());
     *      }
     *  }
     *
     * In your EJS view you can then call the helper on an element tag:
     *
     *  <div <%= upperHtml('javascriptmvc') %>></div>
     *
     *
     * @constructor Creates a view helper.  This function
     * is called internally.  You should never call it.
     * @param {Object} data The data passed to the
     * view.  Helpers have access to it through this._data
     */
    EJS.Helpers = function( data, extras ) {
        this._data = data;
        this._extras = extras;
        extend(this, extras);
    };
    /**
     * @prototype
     */
    EJS.Helpers.prototype = {
        /**
         * Hooks up a jQuery plugin on.
         * @param {String} name the plugin name
         */
        plugin: function( name ) {
            var args = $.makeArray(arguments),
                widget = args.shift();
            return function( el ) {
                var jq = $(el);
                jq[widget].apply(jq, args);
            };
        },
        /**
         * Renders a partial view.  This is deprecated in favor of <code>$.View()</code>.
         */
        view: function( url, data, helpers ) {
            helpers = helpers || this._extras;
            data = data || this._data;
            return $View(url, data, helpers); //new EJS(options).render(data, helpers);
        }
    };

    // options for steal's build
    $View.register({
        suffix: "ejs",
        //returns a function that renders the view
        script: function( id, src ) {
            return $.globalNamespace + ".EJS(function(_CONTEXT,_VIEW) { " + new EJS({
                text: src,
                name: id
            }).template.out + " })";
        },
        renderer: function( id, text ) {
            return EJS({
                text: text,
                name: id
            });
        }
    });
})();(function(){

    // Alias helpful methods from jQuery
    var isArray = $.isArray,
        isObject = function( obj ) {
            return typeof obj === 'object' && obj !== null && obj;
        },
        makeArray = $.makeArray,
        each = $.each,
        // listens to changes on val and 'bubbles' the event up
        // - val the object to listen to changes on
        // - prop the property name val is at on
        // - parent the parent object of prop
        hookup = function( val, prop, parent ) {
            // if it's an array make a list, otherwise a val
            if (val instanceof $.Observe){
                // we have an observe already
                // make sure it is not listening to this already
                unhookup([val], parent._namespace)
            } else if ( isArray(val) ) {
                val = new $.Observe.List(val)
            } else {
                val = new $.Observe(val)
            }
            // attr (like target, how you (delegate) to get to the target)
            // currentAttr (how to get to you)
            // delegateAttr (hot to get to the delegated Attr)

            //
            //
            //listen to all changes and trigger upwards
            val.bind("change" + parent._namespace, function( ev, attr ) {
                // trigger the type on this ...
                var args = $.makeArray(arguments),
                    ev = args.shift();
                if(prop === "*"){
                    args[0] = parent.indexOf(val)+"." + args[0]
                } else {
                    args[0] = prop +  "." + args[0]
                }
                // change the attr
                //ev.origTarget = ev.origTarget || ev.target;
                // the target should still be the original object ...
                $.event.trigger(ev, args, parent)
            });

            return val;
        },
        unhookup = function(items, namespace){
            var item;
            for(var i =0; i < items.length; i++){
                item = items[i]
                if(  item && item.unbind ){
                    item.unbind("change" + namespace)
                }
            }
        },
        // an id to track events for a given observe
        id = 0,
        collecting = null,
        // call to start collecting events (Observe sends all events at once)
        collect = function() {
            if (!collecting ) {
                collecting = [];
                return true;
            }
        },
        // creates an event on item, but will not send immediately
        // if collecting events
        // - item - the item the event should happen on
        // - event - the event name ("change")
        // - args - an array of arguments
        trigger = function( item, event, args ) {
            // send no events if initalizing
            if (item._init) {
                return;
            }
            if (!collecting ) {
                return $.event.trigger(event, args, item, true)
            } else {
                collecting.push({
                    t: item,
                    ev: event,
                    args: args
                })
            }
        },
        // which batch of events this is for, might not want to send multiple
        // messages on the same batch.  This is mostly for
        // event delegation
        batchNum = 0,
        // sends all pending events
        sendCollection = function() {
            var len = collecting.length,
                items = collecting.slice(0),
                cur;
            collecting = null;
            batchNum ++;
            for ( var i = 0; i < len; i++ ) {
                cur = items[i];
                // batchNum
                $.event.trigger({
                    type: cur.ev,
                    batchNum : batchNum
                }, cur.args, cur.t)
            }

        },
        // a helper used to serialize an Observe or Observe.List where:
        // observe - the observable
        // how - to serialize with 'attrs' or 'serialize'
        // where - to put properties, in a {} or [].
        serialize = function( observe, how, where ) {
            // go through each property
            observe.each(function( name, val ) {
                // if the value is an object, and has a attrs or serialize function
                where[name] = isObject(val) && typeof val[how] == 'function' ?
                // call attrs or serialize to get the original data back
                val[how]() :
                // otherwise return the value
                val
            })
            return where;
        };

    /**
     * @class jQuery.Observe
     * @parent jquerymx.lang
     * @test jquery/lang/observe/qunit.html
     *
     * Observe provides the awesome observable pattern for
     * JavaScript Objects and Arrays. It lets you
     *
     *   - Set and remove property or property values on objects and arrays
     *   - Listen for changes in objects and arrays
     *   - Work with nested properties
     *
     * ## Creating an $.Observe
     *
     * To create an $.Observe, or $.Observe.List, you can simply use
     * the `$.O(data)` shortcut like:
     *
     *     var person = $.O({name: 'justin', age: 29}),
     *         hobbies = $.O(['programming', 'basketball', 'nose picking'])
     *
     * Depending on the type of data passed to $.O, it will create an instance of either:
     *
     *   - $.Observe, which is used for objects like: `{foo: 'bar'}`, and
     *   - [jQuery.Observe.List $.Observe.List], which is used for arrays like `['foo','bar']`
     *
     * $.Observe.List and $.Observe are very similar. In fact,
     * $.Observe.List inherits $.Observe and only adds a few extra methods for
     * manipulating arrays like [jQuery.Observe.List.prototype.push push].  Go to
     * [jQuery.Observe.List $.Observe.List] for more information about $.Observe.List.
     *
     * You can also create a `new $.Observe` simply by pass it the data you want to observe:
     *
     *     var data = {
     *       addresses : [
     *         {
     *           city: 'Chicago',
     *           state: 'IL'
     *         },
     *         {
     *           city: 'Boston',
     *           state : 'MA'
     *         }
     *         ],
     *       name : "Justin Meyer"
     *     },
     *     o = new $.Observe(data);
     *
     * _o_ now represents an observable copy of _data_.
     *
     * ## Getting and Setting Properties
     *
     * Use [jQuery.Observe.prototype.attr attr] and [jQuery.Observe.prototype.attr attrs]
     * to get and set properties.
     *
     * For example, you can read the property values of _o_ with
     * `observe.attr( name )` like:
     *
     *     // read name
     *     o.attr('name') //-> Justin Meyer
     *
     * And set property names of _o_ with
     * `observe.attr( name, value )` like:
     *
     *     // update name
     *     o.attr('name', "Brian Moschel") //-> o
     *
     * Observe handles nested data.  Nested Objects and
     * Arrays are converted to $.Observe and
     * $.Observe.Lists.  This lets you read nested properties
     * and use $.Observe methods on them.  The following
     * updates the second address (Boston) to 'New York':
     *
     *     o.attr('addresses.1').attrs({
     *       city: 'New York',
     *       state: 'NY'
     *     })
     *
     * `attrs()` can be used to get all properties back from the observe:
     *
     *     o.attrs() // ->
     *     {
     *       addresses : [
     *         {
     *           city: 'Chicago',
     *           state: 'IL'
     *         },
     *         {
     *           city: 'New York',
     *           state : 'MA'
     *         }
     *       ],
     *       name : "Brian Moschel"
     *     }
     *
     * ## Listening to property changes
     *
     * When a property value is changed, it creates events
     * that you can listen to.  There are two ways to listen
     * for events:
     *
     *   - [jQuery.Observe.prototype.bind bind] - listen for any type of change
     *   - [jQuery.Observe.prototype.delegate delegate] - listen to a specific type of change
     *
     * With `bind( "change" , handler( ev, attr, how, newVal, oldVal ) )`, you can listen
     * to any change that happens within the
     * observe. The handler gets called with the property name that was
     * changed, how it was changed ['add','remove','set'], the new value
     * and the old value.
     *
     *     o.bind('change', function( ev, attr, how, nevVal, oldVal ) {
     *
     *     })
     *
     * `delegate( attr, event, handler(ev, newVal, oldVal ) )` lets you listen
     * to a specific event on a specific attribute.
     *
     *     // listen for name changes
     *     o.delegate("name","set", function(){
     *
     *     })
     *
     * Delegate lets you specify multiple attributes and values to match
     * for the callback. For example,
     *
     *     r = $.O({type: "video", id : 5})
     *     r.delegate("type=images id","set", function(){})
     *
     * This is used heavily by [jQuery.route $.route].
     *
     * @constructor
     *
     * @param {Object} obj a JavaScript Object that will be
     * converted to an observable
     */
    $.Class($.globalNamespace + '.Observe',
    /**
     * @prototype
     */
    {
        init: function( obj ) {
            // _data is where we keep the properties
            this._data = {};
            // the namespace this object uses to listen to events
            this._namespace = ".observe" + (++id);
            // sets all attrs
            this._init = true;
            this.attrs(obj);
            delete this._init;
        },
        /**
         * Get or set an attribute on the observe.
         *
         *     o = new $.Observe({});
         *
         *     // sets a user property
         *     o.attr('user',{name: 'hank'});
         *
         *     // read the user's name
         *     o.attr('user.name') //-> 'hank'
         *
         * If a value is set for the first time, it will trigger
         * an `'add'` and `'set'` change event.  Once
         * the value has been added.  Any future value changes will
         * trigger only `'set'` events.
         *
         *
         * @param {String} attr the attribute to read or write.
         *
         *     o.attr('name') //-> reads the name
         *     o.attr('name', 'Justin') //-> writes the name
         *
         * You can read or write deep property names.  For example:
         *
         *     o.attr('person', {name: 'Justin'})
         *     o.attr('person.name') //-> 'Justin'
         *
         * @param {Object} [val] if provided, sets the value.
         * @return {Object} the observable or the attribute property.
         *
         * If you are reading, the property value is returned:
         *
         *     o.attr('name') //-> Justin
         *
         * If you are writing, the observe is returned for chaining:
         *
         *     o.attr('name',"Brian").attr('name') //-> Justin
         */
        attr: function( attr, val ) {

            if ( val === undefined ) {
                // if we are getting a value
                return this._get(attr)
            } else {
                // otherwise we are setting
                this._set(attr, val);
                return this;
            }
        },
        /**
         * Iterates through each attribute, calling handler
         * with each attribute name and value.
         *
         *     new Observe({foo: 'bar'})
         *       .each(function(name, value){
         *         equals(name, 'foo')
         *         equals(value,'bar')
         *       })
         *
         * @param {function} handler(attrName,value) A function that will get
         * called back with the name and value of each attribute on the observe.
         *
         * Returning `false` breaks the looping.  The following will never
         * log 3:
         *
         *     new Observe({a : 1, b : 2, c: 3})
         *       .each(function(name, value){
         *         console.log(value)
         *         if(name == 2){
         *           return false;
         *         }
         *       })
         *
         * @return {jQuery.Observe} the original observable.
         */
        each: function() {
            return each.apply(null, [this.__get()].concat(makeArray(arguments)))
        },
        /**
         * Removes a property
         *
         *     o =  new $.Observe({foo: 'bar'});
         *     o.removeAttr('foo'); //-> 'bar'
         *
         * This creates a `'remove'` change event. Learn more about events
         * in [jQuery.Observe.prototype.bind bind] and [jQuery.Observe.prototype.delegate delegate].
         *
         * @param {String} attr the attribute name to remove.
         * @return {Object} the value that was removed.
         */
        removeAttr: function( attr ) {
            // convert the attr into parts (if nested)
            var parts = isArray(attr) ? attr : attr.split("."),
                // the actual property to remove
                prop = parts.shift(),
                // the current value
                current = this._data[prop];

            // if we have more parts, call removeAttr on that part
            if ( parts.length ) {
                return current.removeAttr(parts)
            } else {
                // otherwise, delete
                delete this._data[prop];
                // create the event
                trigger(this, "change", [prop, "remove", undefined, current]);
                return current;
            }
        },
        // reads a property from the object
        _get: function( attr ) {
            var parts = isArray(attr) ? attr : (""+attr).split("."),
                current = this.__get(parts.shift());
            if ( parts.length ) {
                return current ? current._get(parts) : undefined
            } else {
                return current;
            }
        },
        // reads a property directly if an attr is provided, otherwise
        // returns the 'real' data object itself
        __get: function( attr ) {
            return attr ? this._data[attr] : this._data;
        },
        // sets attr prop as value on this object where
        // attr - is a string of properties or an array  of property values
        // value - the raw value to set
        // description - an object with converters / serializers / defaults / getterSetters?
        _set: function( attr, value ) {
            // convert attr to attr parts (if it isn't already)
            var parts = isArray(attr) ? attr : ("" + attr).split("."),
                // the immediate prop we are setting
                prop = parts.shift(),
                // its current value
                current = this.__get(prop);

            // if we have an object and remaining parts
            if ( isObject(current) && parts.length ) {
                // that object should set it (this might need to call attr)
                current._set(parts, value)
            } else if (!parts.length ) {
                // otherwise, we are setting it on this object
                // todo: check if value is object and transform
                // are we changing the value
                if ( value !== current ) {

                    // check if we are adding this for the first time
                    // if we are, we need to create an 'add' event
                    var changeType = this.__get().hasOwnProperty(prop) ? "set" : "add";

                    // set the value on data
                    this.__set(prop,
                    // if we are getting an object
                    isObject(value) ?
                    // hook it up to send event to us
                    hookup(value, prop, this) :
                    // value is normal
                    value);



                    // trigger the change event
                    trigger(this, "change", [prop, changeType, value, current]);

                    // if we can stop listening to our old value, do it
                    current && unhookup([current], this._namespace);
                }

            } else {
                throw "jQuery.Observe: set a property on an object that does not exist"
            }
        },
        // directly sets a property on this object
        __set: function( prop, val ) {
            this._data[prop] = val;
            // add property directly for easy writing
            // check if its on the prototype so we don't overwrite methods like attrs
            if (!(prop in this.constructor.prototype)) {
                this[prop] = val
            }
        },
        /**
         * Listens to changes on a jQuery.Observe.
         *
         * When attributes of an observe change, including attributes on nested objects,
         * a `'change'` event is triggered on the observe.  These events come
         * in three flavors:
         *
         *   - `add` - a attribute is added
         *   - `set` - an existing attribute's value is changed
         *   - `remove` - an attribute is removed
         *
         * The change event is fired with:
         *
         *  - the attribute changed
         *  - how it was changed
         *  - the newValue of the attribute
         *  - the oldValue of the attribute
         *
         * Example:
         *
         *     o = new $.Observe({name : "Payal"});
         *     o.bind('change', function(ev, attr, how, newVal, oldVal){
         *       // ev    -> {type: 'change'}
         *       // attr  -> "name"
         *       // how   -> "add"
         *       // newVal-> "Justin"
         *       // oldVal-> undefined
         *     })
         *
         *     o.attr('name', 'Justin')
         *
         * Listening to `change` is only useful for when you want to
         * know every change on an Observe.  For most applications,
         * [jQuery.Observe.prototype.delegate delegate] is
         * much more useful as it lets you listen to specific attribute
         * changes and sepecific types of changes.
         *
         *
         * @param {String} eventType the event name.  Currently,
         * only 'change' events are supported. For more fine
         * grained control, use [jQuery.Observe.prototype.delegate].
         *
         * @param {Function} handler(event, attr, how, newVal, oldVal) A
         * callback function where
         *
         *   - event - the event
         *   - attr - the name of the attribute changed
         *   - how - how the attribute was changed (add, set, remove)
         *   - newVal - the new value of the attribute
         *   - oldVal - the old value of the attribute
         *
         * @return {$.Observe} the observe for chaining.
         */
        bind: function( eventType, handler ) {
            $.fn.bind.apply($([this]), arguments);
            return this;
        },
        /**
         * Unbinds a listener.  This uses [http://api.jquery.com/unbind/ jQuery.unbind]
         * and works very similar.  This means you can
         * use namespaces or unbind all event handlers for a given event:
         *
         *     // unbind a specific event handler
         *     o.unbind('change', handler)
         *
         *     // unbind all change event handlers bound with the
         *     // foo namespace
         *     o.unbind('change.foo')
         *
         *     // unbind all change event handlers
         *     o.unbind('change')
         *
         * @param {String} eventType - the type of event with
         * any optional namespaces.  Currently, only `change` events
         * are supported with bind.
         *
         * @param {Function} [handler] - The original handler function passed
         * to [jQuery.Observe.prototype.bind bind].
         *
         * @return {jQuery.Observe} the original observe for chaining.
         */
        unbind: function( eventType, handler ) {
            $.fn.unbind.apply($([this]), arguments);
            return this;
        },
        /**
         * Get the serialized Object form of the observe.  Serialized
         * data is typically used to send back to a server.
         *
         *     o.serialize() //-> { name: 'Justin' }
         *
         * Serialize currently returns the same data
         * as [jQuery.Observe.prototype.attrs].  However, in future
         * versions, serialize will be able to return serialized
         * data similar to [jQuery.Model].  The following will work:
         *
         *     new Observe({time: new Date()})
         *       .serialize() //-> { time: 1319666613663 }
         *
         * @return {Object} a JavaScript Object that can be
         * serialized with `JSON.stringify` or other methods.
         *
         */
        serialize: function() {
            return serialize(this, 'serialize', {});
        },
        /**
         * Set multiple properties on the observable
         * @param {Object} props
         * @param {Boolean} remove true if you should remove properties that are not in props
         */
        attrs: function( props, remove ) {
            if ( props === undefined ) {
                return serialize(this, 'attrs', {})
            }

            props = $.extend(true, {}, props);
            var prop, collectingStarted = collect();

            for ( prop in this._data ) {
                var curVal = this._data[prop],
                    newVal = props[prop];

                // if we are merging ...
                if ( newVal === undefined ) {
                    remove && this.removeAttr(prop);
                    continue;
                }
                if ( isObject(curVal) && isObject(newVal) ) {
                    curVal.attrs(newVal, remove)
                } else if ( curVal != newVal ) {
                    this._set(prop, newVal)
                } else {

                }
                delete props[prop];
            }
            // add remaining props
            for ( var prop in props ) {
                newVal = props[prop];
                this._set(prop, newVal)
            }
            if ( collectingStarted ) {
                sendCollection();
            }
        }
    });
    // Helpers for list
    /**
     * @class jQuery.Observe.List
     * @inherits jQuery.Observe
     * @parent jQuery.Observe
     *
     * An observable list.  You can listen to when items are push, popped,
     * spliced, shifted, and unshifted on this array.
     *
     *
     */
    var list = $.Observe($.globalNamespace + '.Observe.List',
    /**
     * @prototype
     */
    {
        init: function( instances, options ) {
            this.length = 0;
            this._namespace = ".list" + (++id);
            this._init = true;
            this.bind('change',this.proxy('_changes'));
            this.push.apply(this, makeArray(instances || []));
            $.extend(this, options);
            if(this.comparator){
                this.sort()
            }
            delete this._init;
        },
        _changes : function(ev, attr, how, newVal, oldVal){
            // detects an add, sorts it, re-adds?
            //console.log("")



            // if we are sorting, and an attribute inside us changed
            if(this.comparator && /^\d+./.test(attr) ) {

                // get the index
                var index = +(/^\d+/.exec(attr)[0]),
                    // and item
                    item = this[index],
                    // and the new item
                    newIndex = this.sortedIndex(item);

                if(newIndex !== index){
                    // move ...
                    [].splice.call(this, index, 1);
                    [].splice.call(this, newIndex, 0, item);

                    trigger(this, "move", [item, newIndex, index]);
                    ev.stopImmediatePropagation();
                    trigger(this,"change", [
                        attr.replace(/^\d+/,newIndex),
                        how,
                        newVal,
                        oldVal
                    ]);
                    return;
                }
            }


            // if we add items, we need to handle
            // sorting and such

            // trigger direct add and remove events ...
            if(attr.indexOf('.') === -1){

                if( how === 'add' ) {
                    trigger(this, how, [newVal,+attr]);
                } else if( how === 'remove' ) {
                    trigger(this, how, [oldVal, +attr])
                }

            }
            // issue add, remove, and move events ...
        },
        sortedIndex : function(item){
            var itemCompare = item.attr(this.comparator),
                equaled = 0,
                i;
            for(var i =0; i < this.length; i++){
                if(item === this[i]){
                    equaled = -1;
                    continue;
                }
                if(itemCompare <= this[i].attr(this.comparator) ) {
                    return i+equaled;
                }
            }
            return i+equaled;
        },
        __get : function(attr){
            return attr ? this[attr] : this;
        },
        __set : function(attr, val){
            this[attr] = val;
        },
        /**
         * Returns the serialized form of this list.
         */
        serialize: function() {
            return serialize(this, 'serialize', []);
        },
        /**
         * Iterates through each item of the list, calling handler
         * with each index and value.
         *
         *     new Observe.List(['a'])
         *       .each(function(index, value){
         *         equals(index, 1)
         *         equals(value,'a')
         *       })
         *
         * @param {function} handler(index,value) A function that will get
         * called back with the index and value of each item on the list.
         *
         * Returning `false` breaks the looping.  The following will never
         * log 'c':
         *
         *     new Observe(['a','b','c'])
         *       .each(function(index, value){
         *         console.log(value)
         *         if(index == 1){
         *           return false;
         *         }
         *       })
         *
         * @return {jQuery.Observe.List} the original observable.
         */
        // placeholder for each
        /**
         * Remove items or add items from a specific point in the list.
         *
         * ### Example
         *
         * The following creates a list of numbers and replaces 2 and 3 with
         * "a", and "b".
         *
         *     var l = new $.Observe.List([0,1,2,3]);
         *
         *     l.bind('change', function( ev, attr, how, newVals, oldVals, where ) { ... })
         *
         *     l.splice(1,2, "a", "b"); // results in [0,"a","b",3]
         *
         * This creates 2 change events.  The first event is the removal of
         * numbers one and two where it's callback values will be:
         *
         *   - attr - "1" - indicates where the remove event took place
         *   - how - "remove"
         *   - newVals - undefined
         *   - oldVals - [1,2] -the array of removed values
         *   - where - 1 - the location of where these items where removed
         *
         * The second change event is the addition of the "a", and "b" values where
         * the callback values will be:
         *
         *   - attr - "1" - indicates where the add event took place
         *   - how - "added"
         *   - newVals - ["a","b"]
         *   - oldVals - [1, 2] - the array of removed values
         *   - where - 1 - the location of where these items where added
         *
         * @param {Number} index where to start removing or adding items
         * @param {Object} count the number of items to remove
         * @param {Object} [added] an object to add to
         */
        splice: function( index, count ) {
            var args = makeArray(arguments),
                i;

            for ( i = 2; i < args.length; i++ ) {
                var val = args[i];
                if ( isObject(val) ) {
                    args[i] = hookup(val, "*", this)
                }
            }
            if ( count === undefined ) {
                count = args[1] = this.length - index;
            }
            var removed = [].splice.apply(this, args);
            if ( count > 0 ) {
                trigger(this, "change", [""+index, "remove", undefined, removed]);
                unhookup(removed, this._namespace);
            }
            if ( args.length > 2 ) {
                trigger(this, "change", [""+index, "add", args.slice(2), removed]);
            }
            return removed;
        },
        /**
         * Updates an array with a new array.  It is able to handle
         * removes in the middle of the array.
         *
         * @param {Array} props
         * @param {Boolean} remove
         */
        attrs: function( props, remove ) {
            if ( props === undefined ) {
                return serialize(this, 'attrs', []);
            }

            // copy
            props = props.slice(0);

            var len = Math.min(props.length, this.length),
                collectingStarted = collect();
            for ( var prop = 0; prop < len; prop++ ) {
                var curVal = this[prop],
                    newVal = props[prop];

                if ( isObject(curVal) && isObject(newVal) ) {
                    curVal.attrs(newVal, remove)
                } else if ( curVal != newVal ) {
                    this._set(prop, newVal)
                } else {

                }
            }
            if ( props.length > this.length ) {
                // add in the remaining props
                this.push(props.slice(this.length))
            } else if ( props.length < this.length && remove ) {
                this.splice(props.length)
            }
            //remove those props didn't get too
            if ( collectingStarted ) {
                sendCollection()
            }
        },
        sort: function(method, silent){
            var comparator = this.comparator,
                args = comparator ? [function(a, b){
                    a = a[comparator]
                    b = b[comparator]
                    return a === b ? 0 : (a < b ? -1 : 1);
                }] : [],
                res = [].sort.apply(this, args);

            !silent && trigger(this, "reset");

        }
    }),


        // create push, pop, shift, and unshift
        // converts to an array of arguments
        getArgs = function( args ) {
            if ( args[0] && ($.isArray(args[0])) ) {
                return args[0]
            }
            else {
                return makeArray(args)
            }
        };
    // describes the method and where items should be added
    each({
        /**
         * @function push
         * Add items to the end of the list.
         *
         *     var l = new $.Observe.List([]);
         *
         *     l.bind('change', function(
         *         ev,        // the change event
         *         attr,      // the attr that was changed, for multiple items, "*" is used
         *         how,       // "add"
         *         newVals,   // an array of new values pushed
         *         oldVals,   // undefined
         *         where      // the location where these items where added
         *         ) {
         *
         *     })
         *
         *     l.push('0','1','2');
         *
         * @return {Number} the number of items in the array
         */
        push: "length",
        /**
         * @function unshift
         * Add items to the start of the list.  This is very similar to
         * [jQuery.Observe.prototype.push].
         */
        unshift: 0
    },
    // adds a method where
    // - name - method name
    // - where - where items in the array should be added


    function( name, where ) {
        list.prototype[name] = function() {
            // get the items being added
            var args = getArgs(arguments),
                // where we are going to add items
                len = where ? this.length : 0;

            // go through and convert anything to an observe that needs to be converted
            for ( var i = 0; i < args.length; i++ ) {
                var val = args[i];
                if ( isObject(val) ) {
                    args[i] = hookup(val, "*", this)
                }
            }

            // if we have a sort item, add that
            if( args.length == 1 && this.comparator ) {
                // add each item ...
                // we could make this check if we are already adding in order
                // but that would be confusing ...
                var index = this.sortedIndex(args[0]);
                this.splice(index, 0, args[0]);
                return this.length;
            }

            // call the original method
            var res = [][name].apply(this, args)

            // cause the change where the args are:
            // len - where the additions happened
            // add - items added
            // args - the items added
            // undefined - the old value
            if ( this.comparator  && args.length > 1) {
                this.sort(null, true);
                trigger(this,"reset", [args])
            } else {
                trigger(this, "change", [""+len, "add", args, undefined])
            }


            return res;
        }
    });

    each({
        /**
         * @function pop
         *
         * Removes an item from the end of the list.
         *
         *     var l = new $.Observe.List([0,1,2]);
         *
         *     l.bind('change', function(
         *         ev,        // the change event
         *         attr,      // the attr that was changed, for multiple items, "*" is used
         *         how,       // "remove"
         *         newVals,   // undefined
         *         oldVals,   // 2
         *         where      // the location where these items where added
         *         ) {
         *
         *     })
         *
         *     l.pop();
         *
         * @return {Object} the element at the end of the list
         */
        pop: "length",
        /**
         * @function shift
         * Removes an item from the start of the list.  This is very similar to
         * [jQuery.Observe.prototype.pop].
         *
         * @return {Object} the element at the start of the list
         */
        shift: 0
    },
    // creates a 'remove' type method


    function( name, where ) {
        list.prototype[name] = function() {

            var args = getArgs(arguments),
                len = where && this.length ? this.length - 1 : 0;


            var res = [][name].apply(this, args)

            // create a change where the args are
            // "*" - change on potentially multiple properties
            // "remove" - items removed
            // undefined - the new values (there are none)
            // res - the old, removed values (should these be unbound)
            // len - where these items were removed
            trigger(this, "change", [""+len, "remove", undefined, [res]])

            if ( res && res.unbind ) {
                res.unbind("change" + this._namespace)
            }
            return res;
        }
    });

    list.prototype.
    /**
     * @function indexOf
     * Returns the position of the item in the array.  Returns -1 if the
     * item is not in the array.
     * @param {Object} item
     * @return {Number}
     */
    indexOf = [].indexOf || function(item){
        return $.inArray(item, this)
    }

    /**
     * @class $.O
     */
    $.O = function(data, options){
        if(isArray(data) || data instanceof $.Observe.List){
            return new $.Observe.List(data, options)
        } else {
            return new $.Observe(data, options)
        }
    }
})();

});
FD40.plugin("joomla", function($) {

/**
 * joomla
 * Abstraction layer for Joomla client-side API.
 * https://github.com/foundry-modules/joomla
 *
 * Copyright (c) 2012 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var parser = {
	squeezebox: function() {
		return window.parent.SqueezeBox;
	}
};

var self = $.Joomla = function(method, args) {

	// Overriding function
	if ($.isFunction(args)) {

		var fn = args;

		if (self.isJoomla15) {
			window[method] = fn;
		} else {
			window.Joomla[method] = fn;
		};

		return;
	}

	// Calling function
	var method = parser[method] || ((self.isJoomla15) ? window[method] : window.Joomla[method]);

	if ($.isFunction(method)) {
		return method.apply(window, args);
	}
};

});FD40.plugin("module", function($) {

/**
 * jquery.module.
 * An AMD manager built on top of $.Deferred() backbone.
 * An alternative take on RequireJS's define().
 *
 * Part of the jquery.require family.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var Module = function(name) {

	var module = this,
		ready = $.Callbacks("once memory");

	$.extend(this, $.Deferred(), {

		// Name of the module
		name: name,

		// Module status
		// pending, ready, executing, resolved, rejected
		status: "pending",

		// When a module factory is received,
		// this event is fired.
		ready: function(fn) {
			if (fn===true) ready.fire.call(module, $);
			if ($.isFunction(fn)) ready.add(fn);
		}
	});

	// Listen to the events of the module
	// and update the module status as necessary.
	module.then(
		function() {
			module.exports = this;
			module.status  = "resolved";
		},
		function() {
			module.status  = "rejected";
		}
	);

	// Keep a copy of the original done method.
	// This is so that we can track when this done
	// method is being called for the first time,
	// and perform the necessary actions below.
	var done = module.done;

	module.done = function() {

		// Flag this module as required
		// This indicates that we should
		// execute the module factory.
		module.required = true;

		// Execute the module factory
		// if this module has received it
		// and it hasn't been executed yet.
		var factory = module.factory;
		if (factory && module.status==="ready") {
			factory.call(module, $);
		}

		// Replace this first-time done method
		// with the original done method.
		module.done = done;

		// Execute the original done method.
		return module.done.apply(this, arguments);
	}
}

$.module = (function() {

	var self = function(name, factory) {

		var module;

		if (typeof name === "string") {

			module = self.get(name);

			/** Facade #1. Get module.
			 *
			 *  $.module('foobar'); // returns module
             *
		     */
			if (factory === undefined) {
				return module;
			}

			/** Facade #2. Factory assignment.
             *
			 *  $.module('foobar', function() {
			 *
			 *      // This is required in every module factory.
			 *      // Resolve module, return exports.
			 *
			 *      this.resolveWith(exports, [args]);
			 *
		     *  });
             *
		     */

			if ($.isFunction(factory)) {

				// If module is resolved, don't let new factory overwrite it.
				if (module.status=="resolved") return module;

				module.factory = factory;

				module.status = "ready";

				// Indicates that the module factory
				// for this module has been received.
				module.ready("true");

				// If the module is required,
				// execute the module factory.
				if (module.required) {

					module.status = "executing";

					// Execute factory
					factory.call(module, $);
				}

				return module;
			}
		}

		/** Facade #3. Multiple factory assignments / Predefine modules.
		 *	This is used by Foundry compiler when combining multiple script files into one.
         *
		 *  $.module([
	     *
	     *      // Module task object
	     *      {
	     *			name: "module.name"
	     *			factory: function(){}
	     *      }
	     *
	     *      // Module which is loading
	     *      // but factory assignment kicks in later
	     *      "module.name"
		 *	]);
		 *
		 */

		// Predefine modules
		if ($.isArray(name)) {

			var tasks = $.map(name, function(task) {

				var module = self.get($.isString(task) ? task : task.name);

				if (!module) return;

				// If module is pending, set it to ready.
				// This trick require calls into thinking that
				// the script file of this module has been loaded,
				// so it won't go and load the script file again.
				if (module.status === "pending") {
					module.status = "ready";
				}

				if ($.isPlainObject(task)) return task;
			});

			// Run through the list of tasks and assign its factory to the module.
			$.each(tasks, function(i, task) {

				// Assign factory to module
				self(task.name, task.factory);
			});
		}
	}

	// $.module static methods
	$.extend(self, {

		registry: {},

		get: function(name) {
			if (!name) return;

			if ($.isModule(name)) {
				name = name.replace("module://", "");
			}

			return self.registry[name] || self.create(name);
		},

		create: function(name) {
			return self.registry[name] = new Module(name);
		},

		remove: function(name) {
			delete self.registry[name];
		}
	});

	return self;

})();

$.isModule = function(module) {

	if ($.isString(module)) {
		return !!module.match("module://");
	}

	return module && module instanceof Module;
}

});FD40.plugin("script", function($) {

/**
 * jquery.script
 * Script injection utility built on top $.Deferred() backbone.
 * https://github.com/jstonne/jquery.script
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.Script = function(fn) {

    var script = document.createElement("script");
    script.text = $.isString(fn) ? fn : $.callback(fn) + "();";

    return $(script);
};

$.script = (function(){

    var self = function(options) {

        if (options===undefined) {
            return;
        }

        if (typeof options==="string") {
            options = {
                url: options
            }
        }

        var script = new Script(options);

        return script;
    };

    var Script = function(options) {

        var script = $.extend(this, options);

        script.manager = $.Deferred();

        $.extend(script, script.manager.promise());

        script.load();
    };

    var head = document.getElementsByTagName("head")[0];
    var baseElement = document.getElementsByTagName("base")[0];

    $.extend(Script.prototype, {

        timeout: 7000,
        retry: 3,
        retryCount: 1,
        type: "text/javascript",
        async: false,
        charset: "UTF-8",
        verbose: false,
        head: head,

        insert: function() {

            var node = this.node;

            this.head.appendChild(node);
        },

        remove: function() {

            var node = this.node;

            // This prevents IE7-8 locking up.
            setTimeout(function(){

                // Handle memory leak in IE
                node.onload = node.onerror = node.onreadystatechange = null;

                try {
                    head.removeChild(node);
                } catch(e) {};

            }, 1000);
        },

        load: function() {

            var script = this,
                node;

            script.endTime = undefined;

            script.startTime = new Date();

            script.node = node = document.createElement('script');

            script.insert();

            // Create a reference to these proxied functions,
            // so that we can detach them from event listeners.
            script._ready = $.proxy(script.ready, script);
            script._error = $.proxy(script.error, script);

            // On IE9, addEventListener() does not necessary fire the onload event after
            // the script is loaded, attachEvent() method behaves correctly.
            if (node.attachEvent && !$.browser.opera) {
                node.attachEvent("onreadystatechange", script._ready);
                node.attachEvent("onerror"           , script._error); // IE9 only.
            } else {
                node.addEventListener("load"         , script._ready, false);
                node.addEventListener("error"        , script._error, false);
            }

            $(node).attr({
                type    : script.type,
                async   : script.async,
                charset : script.charset,
                src     : script.url
            });

            script.monitor();
        },

        monitor: function() {

            var script = this;

            if (script.retryCount > script.retry) {

                script._error();

                return;
            }

            setTimeout(function() {

                if (script.state()!=="resolved") {

                    if (script.verbose) {
                        console.warn('$.script: Load timeout. [Retry: ' + script.retryCount + ']', script);
                    }

                    script.remove();

                    script.retryCount++;

                    script.load();
                }

            }, script.timeout * script.retryCount);

        },

        ready: function(event) {

            var script = this,
                node = script.node;

            // if (script.verbose) {
            //     console.info('$.script: Loaded' + (($.browser.msie) ? ' ' + script.url.replace($.scriptPath, '') + ' ': ''), script);
            // }

            if (event.type==="load" || /loaded|complete/.test(node.readyState)) {

                script.complete.call(script, event);

                script.manager.resolve(script);
            }
        },

        error: function(event) {

            var script = this;

            if (script.verbose) {
                console.error('$.script: Unable to load ', script);
            }

            script.complete.call(script, event);

            script.remove();

            script.manager.reject(script);
        },

        complete: function(event) {

            var script = this,
                node = script.node;

            script.endTime = new Date();

            if (node.detachEvent && !$.browser.opera) {
                node.detachEvent("onreadystatechange", script._ready);
                node.detachEvent("onerror"           , script._error);
            } else {
                node.removeEventListener("load"      , script._ready, false);
                node.removeEventListener("error"     , script._error, false);
            }
        }

    });

    return self;

})();

});FD40.plugin("stylesheet", function($) {

/**
 * jquery.stylesheet
 * Stylesheet injector utility with workarounds
 * for IE's 31 stylesheet limitation.
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var head = document.getElementsByTagName('head')[0],
	stylesheets = document.styleSheets,
	IE_STYLESHEET = document.createStyleSheet,
	IE_MAX_STYLESHEET = 31,
	IE_MAX_IMPORT = 31,
	IE_MAX_RULE = 4095;

$.stylesheet = (function() {

	var self = function(url, attr) {

		var options = {};

		$.extend(

			options,

			self.defaultOptions,

			($.isPlainObject(url)) ?
				url :
				{
					url: url,
					attr: attr || {}
				}
		);

		// Create a new stylesheet object
		if (options.url===undefined) {

			return self.create(options);
		}

		// Loading an external stylesheet
		return self.load(options);
	};

	$.extend(self, {

		defaultOptions: {

			type: "text/css",

			rel: "stylesheet",

			media: "all",

			title: "",

			// Force link injection, ignores IE workarounds, overrides XHR value.
			forceInject: false,

			// @TODO: XHR loading.
			xhr: false
		},

		setup: function(options) {

			$.extend(self.defaultOptions, options);
		},

		availability: function() {

			// @TODO: Also calculate bleedImports.
			var stat = {},
				links = $('link[rel*="stylesheet"]')
				styles = $('style');

			stat.groups = IE_MAX_STYLESHEET - links.length - styles.length;

			stat.slots = stat.groups * IE_MAX_IMPORT;

			if (self.currentGroup) {
				stat.slots += IE_MAX_IMPORT - self.currentGroup.imports.length;
			}

			return stat;
		},

		get: function(style) {

			var i=0;

			for (; i<stylesheets.length; i++) {

				var stylesheet = stylesheets[i];

				if ((stylesheet.ownerNode || stylesheet.owningElement)==style) {
					return stylesheet;
				}
			}
		},

		create: function(options) {

			var stylesheet,
				style,
				length = stylesheets.length;

			if (IE_STYLESHEET) {
				// Unable to create further stylesheets
				if (length>=IE_MAX_STYLESHEET) return;
				stylesheet = document.createStyleSheet();
				style = stylesheet.ownerNode || stylesheet.owningElement;
			} else {
				style = document.createElement('style');
				head.appendChild(style);
			}

			$.extend(style, {
				type : options.type,
				title: options.title,
				media: options.media,
				rel  : options.rel
			});

			// Insert stylesheet content
			var content = options.content;
			if (content!==undefined) {
				if (IE_STYLESHEET) {
					stylesheet.cssText = content;
				} else {
					style.appendChild(document.createTextNode(content));
				}
			}

			return style;
		},

		nextAvailable: function(alsoCreateIfUnavailable) {

			var stylesheet,
				length = stylesheets.length;

			if (length) {

				var i;

				for (i=length; i--; i<0) {

					stylesheet = stylesheets[i];

					// If this is IE and the maximum amount of rules have exceeded,
					if (IE_STYLESHEET && ((stylesheet.cssRules || stylesheet.rules).length >= IE_MAX_RULE)) {

						// then this stylesheet cannot be used.
						stylesheet = undefined;

						// try an older stylesheet.
						continue;
					}

					break;
				}
			}

			return stylesheet.ownerNode || stylesheet.owningElement || ((alsoCreateIfUnavailable) ? self() : undefined);
		},

		load: function(options) {

			if ($.browser.msie && !options.forceInject) {

				return self._import(options);

			} else {

				// @TODO: Use onload/onerror events on browsers that support them.
				var link =
					$('<link>')
						.attr({
							href: options.url,
							type: options.type,
							rel: options.rel,
							media: options.media
						})
						.appendTo('head');

				return link[0];
			}
		},

		_import: function(options) {

			var failed;

			if (self.currentGroup===undefined) {

				var group;

				try {

					group = document.createStyleSheet();

					// It is only a getter on IE.
					// group.type = "text/css";

					group.media = "all";
					group.title = "jquery_stylesheet";

				} catch(e) {

					failed = true;

					if (options.verbose) {
						console.error('There is not enough slots left to create a new stylesheet group.');
					}
				}

				if (failed) return false;

				self.currentGroup = group;
			}

			try {

				self.currentGroup.addImport(options.url);

			} catch(e) {

				failed = true;

				if (options.verbose) {
					console.info('Import slots exceeded. Creating a new stylesheet group.');
				}
			}

			if (failed) {

				self.currentGroup = undefined;

				return self._import(options);
			}

			return true;
		}

	});

	return self;

})();

(function(){

var cssRule = function(selectors, rules, style) {

	$.extend(this, {
		id       : $.uid(),
		style    : style,
		selectors: [],
		preRule  : "",
		rules    : {},
		legacy   : $.IE===8,
		important: false
	});

	// If selector is given, automatically add rule.
	// Else assume caller wants a blank rule object.
	if (selectors) {
		this.set(selectors, rules);
	}
}

$.extend(cssRule.prototype, {

	set: function(selectors, rules) {

		// Normalize selectors into array
		if ($.isString(selectors)) {
			this.selectors = selectors.split(",");
		} else {
			this.selectors = selectors;
		}

		// Normalize rules
		if ($.isString(rules)) {
			this.preRule = rules + "\n";
			this.rules = {};
		} else {
			this.preRule = "";
			this.rules = rules || this.rules;
		}

		this.update();

		return this;
	},

	cssText: function() {
		return this.selectors.join(",") + "{" + this.ruleText() + "}\n";
	},

	ruleText: function() {

		var important = this.important;
		return this.preRule +
		       ((this.legacy) ? "-rule-id:" + this.id + ";" : "") +
			   $.map(this.rules, function(val, prop) {
			   		if ($.isNumeric(val) && !$.cssNumber[prop]) val += "px";
			   		if (important) val += " !important";
			   		return prop + ":" + val;
			   }).join(";");
	},

	update: function() {

		if (this.legacy) return this.updateLegacy();

		// Generate css text
		var cssText = this.cssText();

		// If new, insert textnode
		if (this.textNode===undefined) {
			this.textNode = document.createTextNode(cssText);
			this.style.appendChild(this.textNode);

		// Or update existing textnode.
		} else {
			this.textNode.nodeValue = cssText;
		}

		return this;
	},

	updateLegacy: function() {

		this.removeLegacy();

		var stylesheet = $.stylesheet.get(this.style),
			selectors = this.selectors,
			ruleText = this.ruleText(),
			i=0;

		for (;i<selectors.length;i++) {
			stylesheet.addRule(selectors[i], ruleText);
		}

		return this;
	},

	remove: function() {

		if (this.legacy) return this.removeLegacy();

		if (this.textNode!==undefined) {

			// Removing text node is so much quicker
			// than searching for the rule
			this.style.removeChild(this.textNode);

			delete this.textNode;
		}

		return this;
	},

	removeLegacy: function() {

		var stylesheet = $.stylesheet.get(this.style),
			rules = stylesheet.rules,
			i = 0;

		for (;i<rules.length;i++) {

			if (rules[i].cssText.match(this.id)!==null) {
				stylesheet.removeRule(i);
			}
		}

		return this;
	},

	css: function(prop, val) {

		// Getter
		if ($.isString(prop) && val===undefined) {
			return this.rules[prop];
		}

		// Setter
		if ($.isPlainObject(prop)) {
			$.extend(this.rules, prop);
		} else {
			this.rules[prop] = val;
		}

		this.update();

		return this;
	}
});

var self = $.cssRule = function(selector, rules, style) {

	var style = style || self.style || $.stylesheet.nextAvailable(true);

	// If no stylesheet available at this point, stop.
	if (!style) return;

	return new cssRule(selector, rules, style);
};

self.style = $.stylesheet();

})();

(function(){
$.cssUrl = function(url) {
	return 'url("' + encodeURI(url) + '")';
}
})();

});FD40.plugin("template", function($) {

/**
 * jquery.template
 * Template repository
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.template = (function() {

	var defaultTemplate = {
		content: "",
		type: "ejs"
	};

	var self = function(name, content) {

		if (name===undefined) {
			return self.templates;
		}

		var template;

		if (typeof content == "string") {

			if ($.isPlainObject(content)) {

				template = content;

			} else {

				template = $.extend({}, defaultTemplate, {name: name, content: content});
			}

			self.templates[name] = template;

			return template;

		} else {

			template = self.templates[name] || {};

			return template.content || "";
		}
	};

	$.extend(self, {

		templates: {},

		remove: function(name) {

			delete self.templates[name];
		}
	});

	return self;

 })();

});FD40.plugin("require", function($) {

/**
 * jquery.require.
 * A dependency loader built on top of $.Deferred() backbone.
 * An alternative take on RequireJS.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require = (function() {

	// internal function
	var getFolderPath = function(path) {
		return $.uri(path).setAnchor('').setQuery('').toPath('../').toString();
	};

	var self = function(options) {

		var batch = new Batch(options);

		self.batches[batch.id] = batch;

		return batch;
	};

	// Require methods & properties

	$.extend(self, {

		defaultOptions: {

			// Path selection order:
			path: (function() {
				var path = 
					$.path ||

					// By "require_path" attribute
					$('[require-path]').attr('require-path') ||

					// By last script tag's "src" attribute
					getFolderPath($('script:last').attr('src')) ||

					// By window location
					getFolderPath(window.location.href);

				if (/^(\/|\.)/.test(path)) {
					path = $.uri(window.location.href).toPath(path).toString();
				}

				return path;
			})(),

			timeout: 10000,

			retry: 3,

			verbose: ($.environment=="development")
		},

		setup: function(options) {

			$.extend(self.defaultOptions, options);
		},

		batches: {},

		status: function(filter) {

			$.each(self.batches, function(i, batch){

				var count = {pending: 0, resolved: 0, rejected: 0, ready: 0, total: 0},
					messages = [];

				// Calculate statistics
				$.each(batch.tasks, function(i, task){

					state = (task.module && task.module.status=="ready") ? "ready" : task.state();
					count[state]++;
					count.total++;

					messages.push({
						state: state,
						content: '[' + state + '] ' + task.name 
					});
				});

				var batchName = batch.id + ": " + batch.state() + " [" + count.resolved + "/" + count.total + "]";

				if (filter && count[filter] < 1) return;

				if ($.IE) {

					console.log("$.require.batches[\"" + batch.id + "\"]");
					$.each(messages, function(i, message){
						console.log(message.content);
					});
					console.log("");

				} else {

					// Create log group
					console.groupCollapsed(batchName);

					// Generate list
					console.log("$.require.batches[\"" + batch.id + "\"]", batch);

					$.each(messages, function(i, message){

						var state   = message.state,
							content = message.content;

						if (!filter || state==filter) {
							switch (state) {
								case 'pending' : console.warn(content);  break;
								case 'rejected': console.error(content); break;
								default        : console.info(content);  break;
							}
						}
					});

					console.groupEnd(batchName);
				}
			});

			return "$.require.status(pending|resolved|rejected|ready);";
		},

		loaders: {},

		addLoader: function(name, factory) {

			// Static call, e.g.
			// $.require.script.setup({});
			self[name] = factory;

			// Create proxy functions to require loaders,
			// assigning current batch to factory's "this".
			Batch.prototype[name] = function() {

				var batch = this;

				// Reset auto-finalize timer
				batch.autoFinalize();

				// this == batch
				factory.apply(batch, arguments);

				// Ensure require calls are chainable
				return batch;
			};

			self.loaders[name] = self[name] = factory;
		},

		removeLoader: function(name) {
			delete Batch.prototype[name];
			delete self[name];
		}

	});

	// This serves as batch id counter, it increments
	// whenever a new batch instance is created.
	var id = 0;

	// Batch class.
	// When calling $.require(), it is actually
	// returning an new instance of this class.
	var Batch = function(options) {

		var required = $.Callbacks("once memory"),
		    isRequired = false;

		// We are extending the batch instance
		// with the following properties.
		var batch = $.extend(this, {

			// Unique ID for this batch.
			id: ++id,

			// This array keeps a list of tasks to load.
			tasks: [],

			// Stores options like load path, timeout and retry count. 
			options: $.extend({}, self.defaultOptions, options),

			// Require chain automatically finalizes itself after
			// 300ms if no promise methods were called in the require chain.
			// Set false to disable.
			autoFinalizeDuration: 300,

			// When batch is finalized, further loader calls will be ignored.
			finalized: false,

			// Determine if the contents of the loaded task is required.
			required: function(fn) {
				if (fn===true) isRequired=true && required.fire();
				if ($.isFunction(fn)) required.add(fn);
				return isRequired;
			}
		});

		return batch;
	}

	$.extend(Batch.prototype, {

		addTask: function(task) {

			var batch = this;

			// Don't add invalid tasks.
			// Tasks should be a deferred object.
			if (!$.isDeferred(task)) return;

			// Don't accept anymore tasks if this batch is finalized.
			// Batch is finalized upon calling any of the promises, e.g.
			// done, fail, progress, always, then, pipe
			if (batch.finalized) return;

			// Add this task to the batch's task list
			batch.tasks.push(task);

			// Decorate task with a reference to the current batch
			task.batch = batch;
		},

		autoFinalize: function() {

			var batch = this,
				duration = batch.autoFinalizeDuration;

			// If autoFinalize is disabled, stop.
			if (duration===false) return;

			// Clear previous timer
			clearTimeout(batch.autoFinalizeTimer);

			// Start a new timer
			batch.autoFinalizeTimer = 
				setTimeout(function(){
					batch.finalize();
				}, duration);
		},

		finalize: function() {

			var batch = this;

			// If this batch has been finalized, stop.
			if (batch.finalized) return;

			// Finalize all tasks so no further
			// tasks can be added to this batch.
			batch.finalized = true;

			// Create batch manager which is a
			// master deferred object for all tasks.
			var manager = batch.manager = $.when.apply(null, batch.tasks);

			// Now that tasks are finalized, we can override
			// this batch's pseudo-promise methods with actual
			// promise methods from batch manager.
			var promise  = manager.promise(),
				progress = $.Callbacks();

			$.extend(batch, promise, {

				// Progress & notify method behaves differently.
				// We want progress callback to continue executing
				// even after after manager has been resolved or rejected.
				progress: progress.add,
				notify  : progress.fire,

				// Done method also behaves differently.
				// It will trigger an event notifying all tasks that
				// there is a demand for the content of the task.
				// This is currently used to lazy execute module factories
				// to ensure they don't execute until they are asked for.
				done: function(){

					// Trigger required event
					batch.required(true);

					// After done has been called once, it will be
					// replaced with the actual done method from the
					// master deferred object.
					batch.done = promise.done;

					// And the actual done method gets executed.
					return batch.done.apply(batch, arguments);
				}
			});

			// Flag to indicate whether to make
			// generate debug messages.
			var verbose = batch.options.verbose;

			manager
				.progress(function(state, task){
					if (verbose && state=="rejected") {
						console.warn('Require: Task ' + task.name + ' failed to load.', task);
					}
				})
				.fail(function(){
					if (verbose) {
						console.warn('Require: Batch ' + batch.id + ' failed.', batch);
					}
				});

			// We wrap this in a setTimeout to let existing require chain
			// to continue execute. This ensures that progress call in that
			// require chain receives the activities of each task below.
			setTimeout(function(){

				// Always notify whenever there is an activity on every task.
				$.each(batch.tasks, function(i, task){
					task.then(
						function(){ batch.notify("resolved", task) },
						function(){ batch.notify("rejected", task) },
						function(){ batch.notify("progress", task) }
					);
				});
			}, 1);
		},

		expand: function(args, opts) {

			var args = $.makeArray(args),
				options = opts || {},
				names = [];

	        if ($.isPlainObject(args[0])) {
	            options = $.extend(args[0], opts);
	            names = args.slice(1);
	        } else {
	            names = args;
	        }

	        return {
	        	options: options,
	        	names: names
	        }
		}
	});

	// Masquerade newly created batch instances as a pseudo-promise object
	// until one of those promise's method is called. This is to ensure that
	// no callbacks are fired too early until all require tasks are finalized.
	$.each(["done","fail","progress","always","then"], function(i, method) {

		Batch.prototype[method] = function() {

			var batch = this;

			// Finalize batch
			batch.finalize();

			// Execute method that was originally called
			return batch[method].apply(batch, arguments);
		}
	});

	return self;

})();
/**
 * jquery.require.script
 * Script loader plugin for $.require.
 *
 * Part of jquery.require family.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require.addLoader('script', (function() {

	// IE & Opera thinks punycoded urls are cross-domain requests,
	// and rejects the ajax request because they think they don't have
	// the necesary transport to facilitate such requests.

	var ajaxHost = $.uri($.indexUrl).host(),
		documentHost = $.uri(document.location.href).host();

	if (ajaxHost!==documentHost && ajaxHost.match("xn--")) {
		$.support.cors = true;
	}

	var canAsync = document.createElement("script").async === true || "MozAppearance" in document.documentElement.style || window.opera;

	var self = function() {

		var batch = this,
			args = $.makeArray(arguments),
			options,
			names;

		// Expand arguments into its actual definition
		if ($.isPlainObject(args[0])) {
			options = args[0];
			names = args.slice(1);
		} else {
			names = args;
		}

		options = $.extend(
			{},
			self.defaultOptions,
			batch.options,
			options,
			{batch: batch}
		);

		// Create tasks and add it to the batch.
		var taskBefore;

		$.each(names, function(i, name) {

			var task = new self.task(name, options, taskBefore);

			batch.addTask(task);

			// Serial script loading
			if (options.serial && taskBefore!==undefined) {

				// Only start current task when the
				// task before is resolved/rejected.
				taskBefore.always(task.start);

			} else {

				task.start();
			}

			taskBefore = task;

		});

	};

	$.extend(self, {

		defaultOptions: {
			// Overrides require path.
			path: '',

			extension: (($.mode=='compressed') ? 'min.js' : 'js'),

			// Serial script loading. Default: Parallel script loading.
			serial: false,

			// Asynchronous script execution. Default: Synchronous script execution.
			async: false,

			// Use XHR to load script. Default: Script injection.
			xhr: false
		},

		setup: function() {

			$.extend(self.defaultOptions, options);
		},

		scripts: {},

		task: function(name, options, taskBefore) {

			var task = $.extend(this, $.Deferred());

			task.name = name;

			task.options = options;

			task.taskBefore = taskBefore;

			// Module assignment or module url override
			if ($.isArray(name)) {

				task.name = name[0] + "@" + name[1];

				task.moduleName = name[0];

				var overrideModuleUrl = name[2];

				// Module assignment
				if (!overrideModuleUrl) {

					// Set module flag
					task.defineModule = true;

					// Raise a warning if the module already exist
					if ($.module.registry[task.moduleName]) {
						console.warn("$.require.script: " + task.moduleName + ' exists! Using existing module instead.');
					}

					// Use XHR for module assignments
					task.options.xhr = true;
				}

				// Assign path to be resolved
				name = name[1];

				task.module = $.module(task.moduleName);
			}

			// Resolve name to paths

			// Absolute path
			if ($.isUrl(name)) {

				task.url = name;

			// Relative path
			} else if (/^(\/|\.)/.test(name)) {

				task.url = $.uri(task.options.path)
							.toPath(name)
							.toString();

			// Module path
			} else {

				task.url = $.uri(task.options.path)
							.toPath('./' + name + '.' + task.options.extension)
							.toString();

				task.module = $.module(name);
			}
		}

	});

	$.extend(self.task.prototype, {

		start: function() {

			var task = this,
				module = task.module;

			// If module has already been loaded,
			// we can skip the whole script loading process.
			if (module && module.status!=="pending") {
				task.waitForModule();
				return;
			}

			// Else load the script that has this module.
			task.load();
		},

		waitForModule: function() {

			var task = this,
				module = task.module;

			// Listen to the events in the module
			// without causing the module factory to execute.
			module.then(
				task.resolve,
				task.reject,
				task.notify
			);

			// When there is demand for this module,
			// we will call the module's done method.
			task.batch.required(function(){

				// This will execute the module factory
				// in case it wasn't executed before.
				module.done(task.resolve);
			});
		},

		load: function() {

			var task = this,
				taskBefore = task.taskBefore,
				options = {};

			// Use previously created script instance if exists,
			// else create a new one.
			task.script = self.scripts[task.url] || (function() {

				var script = (task.options.xhr) ?

					// Load script via ajax.
					$.ajax({

						url: task.url,

						dataType: "text"

					}) :

					// Load script using script injection.
					$.script({

						url: task.url,

						type: "text/javascript",

						async: task.options.async,

						timeout: task.batch.options.timeout,

						retry: task.batch.options.retry,

						verbose: task.batch.options.verbose

					});

				return self.scripts[task.url] = script;

			})();

			// At this point, script may be loaded, BUT may yet
			// to be executed under the following conditions:
			// - Module loaded via script injection/xhr.
			// - Script loaded via via xhr.
			task.script
				.done(function(data) {

					var resolveTask = function() {

						// If task loads a module, resolve/reject task only when
						// the module is resolved/rejected as the module itself
						// may perform additional require tasks.
						if (task.module) {

							task.waitForModule();

						} else {

							task.resolve();
						}
					};

					if (task.options.xhr) {

						if (task.defineModule) {

							// Create our own module factory
							task.module = $.module(task.moduleName, function() {

								var module = this;

								$.globalEval(data);

								module.resolveWith(data);
							});
						};

						// For XHR, if scripts needs to be executed synchronously
						// a.k.a. ordered script execution, then only eval it when
						// the task before it is resolved.
						if (!task.options.async || taskBefore) {

							taskBefore.done(function() {

								$.globalEval(data);

								resolveTask();

							});

							return;
						}

					};

					resolveTask();

				})
				.fail(function() {

					task.reject();
				});
		}
	});

	return self;

})()
);

/**
 * jquery.require.library
 * Foundry script loader.
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require.addLoader('library', function() {

	var batch = this,
		args = $.makeArray(arguments),
		options = {},
		names;

	// Expand arguments into its actual definition
	if ($.isPlainObject(args[0])) {
		options = args[0];
		names = args.slice(1);
	} else {
		names = args;
	}

	$.extend(options, {
		path: $.scriptPath
	});

	return batch.script.apply(batch, [options].concat(names));

});
/**
 * jquery.require.stylesheet
 * Stylesheet loader plugin for $.require.
 *
 * Part of jquery.require family.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require.addLoader('image', (function() {

	var self = function() {

		var batch = this,
			args = $.makeArray(arguments),
			options,
			names;

		// Expand arguments into its actual definition
		if ($.isPlainObject(args[0])) {
			options = args[0];
			names = args.slice(1);
		} else {
			names = args;
		}

		options = $.extend(
			{},
			self.defaultOptions,
			batch.options,
			options,
			{batch: batch}
		);

		$.each(names, function(i, name) {

			var task = new self.task(name, options),
				existingTask = self.images[task.url];

			task = existingTask || task;

			batch.addTask(task);

			if (!existingTask) {
				self.images[task.url] = task;
				task.start();
			}
		});
	};

	$.extend(self, {

		defaultOptions: {
			// Overrides require path.
			path: ''
		},

		setup: function() {

			$.extend(self.defaultOptions, options);
		},

		images: {},

		task: function(name, options) {

			var task = $.extend(this, $.Deferred());

			task.name = name;

			task.options = options;

			// Absolute path
			if ($.isUrl(name)) {

				task.url = name;

			// Relative path
			} else if (/^(\/|\.)/.test(name)) {

				task.url = $.uri(task.options.path)
							.toPath(name)
							.toString();

			// Module path
			} else {

				task.url = $.uri(task.options.path)
							.toPath('./' + name)
							.toString();
			}

			// Remap task.url to task.options.url
			task.options.url = task.url;
		}

	});

	$.extend(self.task.prototype, {

		start: function() {

			var task = this;

			task.image = $(new Image())
							.load(function(){
								task.resolve();
							})
							.error(function(){
								task.reject();
							})
							.attr("src", task.options.url);
		}

	});

	return self;

})()
);

});FD40.plugin("iframe-transport", function($) {

// This [jQuery](http://jquery.com/) plugin implements an `<iframe>`
// [transport](http://api.jquery.com/extending-ajax/#Transports) so that
// `$.ajax()` calls support the uploading of files using standard HTML file
// input fields. This is done by switching the exchange from `XMLHttpRequest`
// to a hidden `iframe` element containing a form that is submitted.

// The [source for the plugin](http://github.com/cmlenz/jquery-iframe-transport)
// is available on [Github](http://github.com/) and dual licensed under the MIT
// or GPL Version 2 licenses.

// ## Usage

// To use this plugin, you simply add an `iframe` option with the value `true`
// to the Ajax settings an `$.ajax()` call, and specify the file fields to
// include in the submssion using the `files` option, which can be a selector,
// jQuery object, or a list of DOM elements containing one or more
// `<input type="file">` elements:

//     $("#myform").submit(function() {
//         $.ajax(this.action, {
//             files: $(":file", this),
//             iframe: true
//         }).complete(function(data) {
//             console.log(data);
//         });
//     });

// The plugin will construct hidden `<iframe>` and `<form>` elements, add the
// file field(s) to that form, submit the form, and process the response.

// If you want to include other form fields in the form submission, include
// them in the `data` option, and set the `processData` option to `false`:

//     $("#myform").submit(function() {
//         $.ajax(this.action, {
//             data: $(":text", this).serializeArray(),
//             files: $(":file", this),
//             iframe: true,
//             processData: false
//         }).complete(function(data) {
//             console.log(data);
//         });
//     });

// ### Response Data Types

// As the transport does not have access to the HTTP headers of the server
// response, it is not as simple to make use of the automatic content type
// detection provided by jQuery as with regular XHR. If you can't set the
// expected response data type (for example because it may vary depending on
// the outcome of processing by the server), you will need to employ a
// workaround on the server side: Send back an HTML document containing just a
// `<textarea>` element with a `data-type` attribute that specifies the MIME
// type, and put the actual payload in the textarea:

//     <textarea data-type="application/json">
//       {"ok": true, "message": "Thanks so much"}
//     </textarea>

// The iframe transport plugin will detect this and pass the value of the
// `data-type` attribute on to jQuery as if it was the "Content-Type" response
// header, thereby enabling the same kind of conversions that jQuery applies
// to regular responses. For the example above you should get a Javascript
// object as the `data` parameter of the `complete` callback, with the
// properties `ok: true` and `message: "Thanks so much"`.

// ### Handling Server Errors

// Another problem with using an `iframe` for file uploads is that it is
// impossible for the javascript code to determine the HTTP status code of the
// servers response. Effectively, all of the calls you make will look like they
// are getting successful responses, and thus invoke the `done()` or
// `complete()`callbacks. You can only determine communicate problems using
// the content of the response payload. For example, consider using a JSON
// response such as the following to indicate a problem with an uploaded file:

//     <textarea data-type="application/json">
//       {"ok": false, "message": "Please only upload reasonably sized files."}
//     </textarea>

// ### Compatibility

// This plugin has primarily been tested on Safari 5 (or later), Firefox 4 (or
// later), and Internet Explorer (all the way back to version 6). While I
// haven't found any issues with it so far, I'm fairly sure it still doesn't
// work around all the quirks in all different browsers. But the code is still
// pretty simple overall, so you should be able to fix it and contribute a
// patch :)

// ## Annotated Source



  // Register a prefilter that checks whether the `iframe` option is set, and
  // switches to the "iframe" data type if it is `true`.
  $.ajaxPrefilter(function(options, origOptions, jqXHR) {
    if (options.iframe) {
      return "iframe";
    }
  });

  // Register a transport for the "iframe" data type. It will only activate
  // when the "files" option has been set to a non-empty list of enabled file
  // inputs.
  $.ajaxTransport("iframe", function(options, origOptions, jqXHR) {
    var form = null,
        iframe = null,
        name = "iframe-" + $.now(),
        files = $(options.files).filter(":file:enabled"),
        hasFiles = files.length > 0,
        markers = null;

    // This function gets called after a successful submission or an abortion
    // and should revert all changes made to the page to enable the
    // submission via this transport.
    function cleanUp() {
      if (hasFiles) {
        markers.replaceWith(function(idx) {
          return files.get(idx);
        });
      }
      form.remove();
      iframe.attr("src", "javascript:false;").remove();
    }

    // Remove "iframe" from the data types list so that further processing is
    // based on the content type returned by the server, without attempting an
    // (unsupported) conversion from "iframe" to the actual type.
    options.dataTypes.shift();

      form = $("<form enctype='multipart/form-data' method='post'></form>").
        hide().attr({action: options.url, target: name});

      // If there is any additional data specified via the `data` option,
      // we add it as hidden fields to the form. This (currently) requires
      // the `processData` option to be set to false so that the data doesn't
      // get serialized to a string.
      if (typeof(options.data) === "string" && options.data.length > 0) {
        $.error("data must not be serialized");
      }
      $.each(options.data || {}, function(name, value) {
        if ($.isPlainObject(value)) {
          name = value.name;
          value = value.value;
        }

        if (!$.isArray(value)) {
          value = [value];
        }

        $.each(value, function(i, value){
          $("<input type='hidden' />").attr({name:  name, value: value}).
            appendTo(form);
        });

      });


      // Add a hidden `X-Requested-With` field with the value `IFrame` to the
      // field, to help server-side code to determine that the upload happened
      // through this transport.
      $("<input type='hidden' value='IFrame' name='X-Requested-With' />").
        appendTo(form);

      // Move the file fields into the hidden form, but first remember their
      // original locations in the document by replacing them with disabled
      // clones. This should also avoid introducing unwanted changes to the
      // page layout during submission.
      if (hasFiles) {
        markers = files.after(function(idx) {
          return $(this).clone().prop("disabled", true);
        }).next();
        files.appendTo(form);
      }

      return {

        // The `send` function is called by jQuery when the request should be
        // sent.
        send: function(headers, completeCallback) {
          iframe = $("<iframe src='about:blank' name='" + name +
            "' id='" + name + "' style='display:none'></iframe>");

          // The first load event gets fired after the iframe has been injected
          // into the DOM, and is used to prepare the actual submission.
          iframe.bind("load", function() {

            // The second load event gets fired when the response to the form
            // submission is received. The implementation detects whether the
            // actual payload is embedded in a `<textarea>` element, and
            // prepares the required conversions to be made in that case.
            iframe.unbind("load").bind("load", function() {
              var doc = this.contentWindow ? this.contentWindow.document :
                (this.contentDocument ? this.contentDocument : this.document),
                root = doc.documentElement ? doc.documentElement : doc.body,
                textarea = root.getElementsByTagName("textarea")[0],
                type = textarea ? textarea.getAttribute("data-type") : null,
                status = textarea ? textarea.getAttribute("data-status") : 200,
                statusText = textarea ? textarea.getAttribute("data-statusText") : "OK",
                content = {
                  html: root.innerHTML,
                  text: type ?
                    textarea.value :
                    root ? (root.textContent || root.innerText) : null
                };
              cleanUp();
              completeCallback(status, statusText, content, type ?
                ("Content-Type: " + type) :
                null);
            });

            // Now that the load handler has been set up, submit the form.
            form[0].submit();
          });

          // After everything has been set up correctly, the form and iframe
          // get injected into the DOM so that the submission can be
          // initiated.
          $("body").append(form, iframe);
        },

        // The `abort` function is called by jQuery when the request should be
        // aborted.
        abort: function() {
          if (iframe !== null) {
            iframe.unbind("load").attr("src", "javascript:false;");
            cleanUp();
          }
        }

      };
  });


});FD40.plugin("server", function($) {

/*!
 * jquery.server.
 * Extension of jquery.ajax with ability to parse server commands.
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */
var self = $.server = function(options) {

	var request = $.Deferred(),

		ajaxOptions = $.extend(true, {}, self.defaultOptions, options, {success: function(){}}),

		xhr = request.xhr =
			$.Ajax(ajaxOptions)
				.done(function(commands){

					if (typeof commands==="string") {
						try {
							commands = $.parseJSON(commands);
						} catch(e) {
							request.rejectWith(request, ["Unable to parse Ajax commands.", "error"])
						}
					}

					if (!$.isArray(commands)) {

						request.rejectWith(request, ["Invalid ajax commands.", "error"]);

					} else {

						var parse = function(command){
							var type = command.type,
								parser = self.parsers[type] || options[type];

							if ($.isFunction(parser)) {
								return parser.apply(request, command.data);
							}
						}

						// Execute all the notifications first
						var commands = $.map(commands, function(command) {
							if (command.type=="notify") {
								parse(command);
							} else {
								return command;
							}
						})

						$.each(commands, function(i, command) {
							parse(command);
						});
					}

					// If server did not resolve this request
					if (request.state()==="pending") {

						// We'll resolve it ourselves
						request.resolveWith(request);
					}
				})
				.fail(function(jqXHR, status, statusText){

					request.rejectWith(request, [statusText, status]);
				});

		// Add abort method
		request.abort = xhr.abort;

	return request;
};

self.defaultOptions = {
	type: 'POST',
	data: {
		tmpl: 'component',
		format: 'ajax',
		no_html: 1
	},
	cache: false,
	contentType: 'application/x-www-form-urlencoded',
	dataType: 'json'
};

self.parsers = {

	script: function() {

		var data = $.makeArray(arguments);

		// For hardcoded javascript codes
		if (typeof data[0] == 'string') {
			try { eval(data[0]) } catch(err) {};
			return;
		}

		/**
		* Execute each method and assign returned object back to the chain.
		*
		* Foundry().attr('checked', true);
		* 	is equivalent to:
		* window['Foundry']('.element')[attr]('checked', true);
		*/
		var chain = window, chainBroken = false;

		$.each(data, function(i, chainer)
		{
			if (chainer.property==="Foundry") {
				chainer.property = $.globalNamespace;
			}

			if (chainer.method==="Foundry") {
				chainer.method = $.globalNamespace;
			}

			try {
				switch(chainer.type)
				{
					case 'get':
						chain = chain[chainer.property];
						break;

					case 'set':
						chain[chainer.property] = chainer.value;
						chainBroken=true;
						break;

					case 'call':
						chain = chain[chainer.method].apply(chain, chainer.args);
						break;
				}
			} catch(err) {
				chainBroken = true;
			}
		})
	},

	resolve: function() {

		this.resolveWith(this, arguments);
	},

	reject: function() {

		this.rejectWith(this, arguments);
	},

	notify: function() {

		this.notifyWith(this, arguments);
	},

	redirect: function(url) {

		window.location = url;
	}
};
});FD40.plugin("component", function($) {

/**
 * jquery.component.
 * Boilerplate for client-side MVC application.
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var Component = $.Component = function(name, options) {

    if (arguments.length < 1) {
        return Component.registry;
    }

    if (arguments.length < 2) {
        return Component.registry[name];
    }

    return Component.register(name, options);
}

Component.registry = {};

Component.proxy = function(component, property, value) {

    // If it's a method
    if ($.isFunction(value)) {

        // Change the "this" context to the component itself
        component[property] = $.proxy(value, component);

    } else {

        component[property] = value;
    }
}

Component.register = function(name, options) {

    // If an abstract component was passed in
    var abstractComponent;

    // Normalize arguments
    if ($.isFunction(name)) {
        abstractComponent = name;
        name = abstractComponent.className;
        options = abstractComponent.options;
    }

    var self =

        // Put it in component registry
        Component.registry[name] =

        // Set it to the global namespace
        window[name] =

        // When called as a function, it will return the correct jQuery object.
        function(command) {

            return ($.isFunction(command)) ? command($) : component;
        };

    // Extend component with properties in component prototype
    $.each(Component.prototype, function(property, value) {

        Component.proxy(self, property, value);
    });


    self.$ = $;
    self.options = options;
    self.className = name;
    self.identifier = 'easysocial';
    self.componentName = "com_easysocial";
    self.prefix = self.identifier + "/";
    self.version = options.version;
    self.safeVersion = self.version.replace(/\./g,"");
    self.environment = options.environment  || $.environment;
    self.mode = options.mode || $.mode;
    self.debug = (self.environment==='development');
    self.console = Component.console(self);
    self.language = options.language || $.locale.lang || "en";
    self.baseUrl = options.baseUrl || $.indexUrl + "?option=" + self.componentName;
    self.ajaxUrl = options.ajaxUrl || $.basePath + "/?option=" + self.componentName;
    self.scriptPath = options.scriptPath || $.rootPath + "/media/" + self.componentName + "/scripts/";

    // Legacy and needs to be removed
    self.stylePath = options.stylePath    || $.rootPath + "/media/" + self.componentName + "/styles/";
    self.templatePath = options.templatePath || options.scriptPath;
    self.languagePath = options.languagePath || self.ajaxUrl + '&tmpl=component&no_html=1&controller=lang&task=getLanguage';
    self.viewPath = options.viewPath     || self.ajaxUrl + '&tmpl=component&no_html=1&controller=themes&task=getAjaxTemplate';
    self.optimizeResources = true;
    self.resourcePath = options.resourcePath || self.ajaxUrl + '&tmpl=component&no_html=1&controller=foundry&task=getResource';
    self.resourceInterval = 1200; // Joomla session timestamp is per second, we add another 200ms just to be safe.
    
    self.scriptVersioning  = options.scriptVersioning || false;
    self.tasks = [];

    // Register component to bootleader
    FD40.component(name, self);

    // If there's no abstract componet prior to this, we're done!
    if (!abstractComponent) {
        return;
    }

    // If we're on development mode
    if (self.debug) {

        // Execute queue in abstract component straightaway
        abstractComponent.queue.execute();

    // If we're on static or optimized mode
    } else {

        // Get component installers from bootloader and install them
        var installer, installers = FD40.installer(name);
        while(installer = installers.shift()) {
            self.install.apply(self, installer);
        }

        // Wait until definitions, scripts & resources are installed
        $.when(
            self.install("definitions"),
            self.install("scripts"),
            self.install("resources")
        ).done(function(){

            // Then only execute queue in abstract component.
            abstractComponent.queue.execute();
        });
    }

    var storage = self.storage = function(key, val) {

        var prefix = self.prefix,
            key = prefix + key,
            length = arguments.length;

        // Getter
        if (length==1) return $.Storage.get(key)

        // Setter (remove or set)
        if (length==2) return key===false ? $.Storage.remove(prefix + val) : $.Storage.set(key, val);

        return storage.getAll();
    };

    $.extend(self.storage, {

        getAll: function() {

            var prefix = self.prefix,
                i = prefix.length,
                storage = $.Storage.getAll(),
                obj = {};

            for (key in storage) {
                if (key.substr(0, i)==prefix) {
                    obj[key.substr(i)] = storage[key];
                }
            }

            return obj;
        },

        remove: function(key) {
            $.Storage.remove(self.prefix + key);
        },

        clear: function() {
            for (key in storage.getAll()) {
                storage.remove(key);
            }
        }
    });
}

Component.extend = function(property, value) {

    // For later components
    Component.prototype[property] = value;

    // For existing components
    $.each(Component.registry, function(name, component) {
        Component.proxy(component, property, value);
    });
}

$.template("component/console",'<div id="[%== component.identifier %]-console" class="foundry-console" style="display: none; z-index: 999999;"><div class="console-header"><div class="console-title">[%= component.className %] [%= component.version %]</div><div class="console-remove-button">x</div></div><div class="console-log-item-group"></div><style type="text/css">.foundry-console{position:fixed;width:50%;height:50%;bottom:0;left:0;background:white;box-shadow: 0 0 5px 0;margin-left: 25px;}.console-log-item-group{width: 100%;height: 100%;overflow-y:scroll;}.console-header{position: absolute;background:red;color:white;font-weight:bold;top:-24px;left: 0;line-height:24px;width:100%}.console-remove-button{text-align:center;cursor: pointer;display:block;width: 24px;float:right}.console-remove-button:hover{color: yellow}.console-title{padding: 0 5px;float:left}.console-log-item{padding: 5px}.console-log-item + .console-log-item{border-top: 1px solid #ccc}</style></div>');

Component.console = function(component) {

    return (function(self){

        var instance = function(method) {

                if (arguments.length < 1) {
                    return instance.toggle();
                }

                return instance[method] && instance[method].apply(instance, arguments);
            },

            element;

            instance.selector = "#" + self.identifier + "-console";

            instance.init = function() {

                element = $(instance.selector);

                if (element.length < 1) {
                    element = $($.View("component/console", {component: self})).appendTo("body");

                    element.find(".console-remove-button").click(function(){
                        element.hide();
                    });
                }

                instance.element = element;

                return arguments.callee;
            };

            instance.methods = {

                log: function(message, type, code) {

                    type = type || "info";

                    var itemGroup = element.find(".console-log-item-group"),
                        item =
                            $(document.createElement("div"))
                                .addClass("console-log-item type-" + type)
                                .attr("data-code", code)
                                .html(message);

                    itemGroup.append(item);
                    itemGroup[0].scrollTop = itemGroup[0].scrollHeight;

                    // Automatically show window on each log
                    if (self.debug) { element.show(); }
                },

                toggle: function() {
                    element.toggle();
                },

                reset: function() {
                    element.find(".console-log-item-group").empty();
                }
            };

        $.each(instance.methods, function(method, fn) {
            instance[method] = function() {
                instance.init(); // Always call init in case of destruction of element
                return fn.apply(instance, arguments);
            }
        });

        return instance;

    })(component);
}

var doc = $(document),
    proto = Component.prototype;

$.extend(proto, {

    run: function(command) {

        return ($.isFunction(command)) ? command($) : this;
    },

    ready: (function(){

        // Replace itself once document is ready
        doc.ready(function(){
            proto.ready = proto.run;
        });

        return function(callback) {

            if (!$.isFunction(callback)) return;

            // When document is ready
            doc.ready(function() {
                callback($);
            });
        }
    })(),

    install: function(name, factory) {

        var self = this,
            task = self.tasks[name] || (self.tasks[name] = $.Deferred());

        // Getter
        if (!factory) return task;

        // Setter
        var install = function(){
            factory($, self);
            return task.resolve();
        }

        // If this is installer contains component definitions,
        // install straightaway.
        if (name=="definitions") return install();

        // Else for component definitiosn to install first,
        // then only install this installer.
        $.when(self.install("definitions")).done(install);
    },

    token: function() {

        var self = this;

        if (self.token.value) {
            return self.token.value;
        }

        return self.token.value = window.es.token;
    },

    template: function(name) {

        var self = this;

        // Get all component templates
        if (name==undefined) {

            return $.grep($.template(), function(template) {

                return template.indexOf(self.prefix)==0;
            });
        }

        // Prepend component prefix
        arguments[0] = self.prefix + name;

        // Getter or setter
        return $.template.apply(null, arguments);
    },

    // Component require extends $.require with the following additional methods:
    // - resource()
    // - view()
    // - language()
    //
    // It also changes the behaviour of existing methods to load in component-specific behaviour.
    require: function(options) {

        var self = this,

            options = options || {},

            require = $.require(options),

            _require = {};

            // Keep a copy of the original method so the duck punchers below can use it.
            $.each(["library", "script", "template", "done"], function(i, method){
                _require[method] = require[method];
            });

        // Resource call should NOT be called directly.
        // .resource({type: "view", name: "photo.item", loader: deferredObject})
        require.resource = function(resource) {

            // If this is not a valid resource object, skip.
            if (!$.isPlainObject(resource)) return;
            if (!resource.type || !resource.name || !$.isDeferred(resource.loader)) return;

            var batch = this;

            // Get resource collector
            var resourceCollector = self.resourceCollector;

            // If we haven't started collecting resources
            if (!resourceCollector) {

                // Then start collecting resources
                resourceCollector = self.resourceCollector = $.Deferred();

                $.extend(resourceCollector, {

                    name: $.uid("ResourceCollector"),

                    manifest: [],

                    loaderList: [],

                    loaders: [],

                    load: function() {

                        // End this batch of resource collecting
                        delete self.resourceCollector;

                        // If there are not resources to pull,
                        // just resolve resource collector.
                        if (resourceCollector.manifest.length < 0) {
                            resourceCollector.resolve();
                            return;
                        }

                        var retry = 0;

                        var loadResources = function(){

                            retry++;

                            $.Ajax(
                                {
                                    type: 'POST',
                                    url: self.resourcePath,
                                    dataType: "json",
                                    data: {
                                        resource: resourceCollector.manifest
                                    }
                                })
                                .done(function(manifest) {

                                    if (!$.isArray(manifest)) {
                                        resourceCollector.reject("Server did not return a valid resource manifest.");
                                        return;
                                    }

                                    $.each(manifest, function(i, resource) {

                                        var content = resource.content;

                                        resourceCollector.loaders[resource.id]
                                            [content!==undefined ? "resolve" : "reject"]
                                            (content);
                                    });

                                    if (retry > 1 && self.debug) {
                                        console.info("Attempt to try and get resources again was successful!");
                                    }
                                })
                                .fail(function(){
                                    if (retry > 2) {
                                        if (self.debug) { console.error("Unable to get resource again. Giving up!"); };
                                        return;
                                    }
                                    if (self.debug) {
                                        console.warn("Unable to get resource. Trying again...");
                                    }
                                    loadResources();
                                });
                        }

                        loadResources();

                        // Resolve resource collector when all is done
                        $.when.apply(null, resourceCollector.loaderList)
                            .done(resourceCollector.resolve)
                            .fail(resourceCollector.reject);
                    }
                });

                setTimeout(resourceCollector.load, self.resourceCollectionInterval);
            }

            // Create a resource id
            var id = resource.id = $.uid("Resource");

            // Add to the loader map
            // - to be used to resolve the loader with the returned content
            resourceCollector.loaders[id] = resource.loader;

            // Add to the loader list
            // - to be used with $.when()
            resourceCollector.loaderList.push(resource.loader);

            // Remove the reference to the loader
            // - so the loader doesn't get included in the manifest that gets sent to the server
            delete resource.loader;

            // Then add it to our list of resource manifest
            resourceCollector.manifest.push(resource);

            // Note: Only resource loaders are batch tasks, not resource collectors.
            // var task = resourceCollector;
            // batch.addTask(task);
            return require;
        };

        require.view = function() {

            var batch   = this,

                request = batch.expand(arguments, {path: self.viewPath}),

                loaders = {},

                options = request.options,

                names   = $.map(request.names, function(name) {

                    // Get template loader
                    var absoluteName = self.prefix + name,
                        loader = $.require.template.loaders[absoluteName];

                    // If this is being loaded, skip.
                    if (loader) return;

                    loader = $.require.template.loader(absoluteName);

                    loader.name = absoluteName;

                    // Add template loader as a task of this batch
                    batch.addTask(loader);

                    // Load as part of a coalesced ajax call if enabled
                    if (self.optimizeResources) {

                        require.resource({
                            type: "view",
                            name: name,
                            loader: loader
                        });

                        return;

                    } else {

                        loaders[name] = loader;
                        return name;
                    }
                });

            // Load using regular ajax call
            // This will always be zero when optimizeResources is enabled.
            if (names.length > 0) {

                $.Ajax(
                    {
                        url: options.path,
                        dataType: "json",
                        data: { names: names }
                    })
                    .done(function(templates) {

                        if (!$.isArray(templates)) return;

                        $.each(templates, function(i, template) {

                            var content = template.content;

                            loaders[template.name]
                                [content!==undefined ? "resolve" : "reject"]
                                (content);
                        });
                    });
            }

            return require;
        };

        require.library = function() {

            _require.script.apply(this, arguments);

            return require;
        };

        require.script = function() {

            var batch = this,

                request = batch.expand(arguments, {path: self.scriptPath}),

                names = $.map(request.names, function(name) {

                    // Ignore module definitions
                    if ($.isArray(name) ||

                        // and urls
                        $.isUrl(name) ||

                        // and relative paths.
                        /^(\/|\.)/.test(name)) return name;

                    var moduleName = self.prefix + name,

                        moduleUrl =

                            $.uri(request.options.path)
                                .toPath(
                                    './' + name + '.' + (request.options.extension || 'js') +
                                    ((self.scriptVersioning) ? "?" + "version=" + self.safeVersion : "")
                                )
                                .toString();

                    return [[moduleName, moduleUrl, true]];
                });

            _require.script.apply(require, [request.options].concat(names));

            return require;
        };

        // Override path
        require.template = function() {

            var batch   = this,

                request = batch.expand(arguments, {path: self.templatePath});

            _require.template.apply(require, [request.options].concat(

                $.map(request.names, function(name) {

                    return [[self.prefix + name, name]];
                })
            ));

            return require;
        };

        require.app = function() {

            var batch = this,

                request = batch.expand(arguments, {path: self.scriptPath})

                names = $.map(request.names, function(name) {

                    // Ignore module definitions
                    if ($.isArray(name) ||

                        // and urls
                        $.isUrl(name) ||

                        // and relative paths.
                        /^(\/|\.)/.test(name)) return name;

                    var parts = name.split('/'),
                        path = $.rootPath + '/media/' + self.componentName + '/apps';

                    // Currently used by fields
                    if (parts.length===4) {
                        path += '/' + parts.shift();
                    }

                    // Build path
                    path += '/' + parts[0] + '/' + parts[1] + '/scripts/' + parts[2];

                    var moduleName = self.prefix + name,

                        moduleUrl = path + '.' +
                            (request.options.extension || 'js') +
                            ((self.scriptVersioning) ? "?" + "version=" + self.safeVersion : "");

                    return [[moduleName, moduleUrl, true]];
                });

            _require.script.apply(require, [request.options].concat(names));

            return require;
        };

        // Only execute require done callback when component is ready
        require.done = function(callback) {

            return _require.done.call(require, function(){

                self.ready(callback);
            });
        };

        return require;
    },

    module: function(name, factory) {

        var self = this;

        // TODO: Support for multiple module factory assignment
        if ($.isArray(name)) {
            return;
        }

        var fullname = self.prefix + name;

        return (factory) ?

            // Set module
            $.module.apply(null, [fullname, function(){

                var module = this;

                factory.call(module, $);
            }])

            :

            // Get module
            $.module(fullname);
    }
});
$.Component.extend("ajax", function(namespace, params, callback) {

    var self = this;
    var date = new Date();

    var options = {
            url: self.ajaxUrl + "&_ts=" + date.getTime(),
            data: $.extend(
                params, {
                    option: self.componentName,
                    namespace: namespace
                }
            )
        };

    options = $.extend(true, options, self.options.ajax);
    options.data[self.token()] = 1;

    // This is for server-side function arguments
    if (options.data.hasOwnProperty('args')) {
        options.data.args = $.toJSON(options.data.args);
    }

    if ($.isPlainObject(callback)) {

        if (callback.type) {

            switch (callback.type) {

                case 'jsonp':

                    callback.dataType = 'jsonp';

                    // This ensure jQuery doesn't use XHR should it detect the ajax url is a local domain.
                    callback.crossDomain = true;

                    options.data.transport = 'jsonp';
                    break;

                case 'iframe':

                    // For use with iframe-transport
                    callback.iframe = true;

                    callback.processData = false;

                    callback.files = options.data.files;

                    delete options.data.files;

                    options.data.transport = 'iframe';
                    break;
            }

            delete callback.type;
        }

        $.extend(options, callback);
    }

    if ($.isFunction(callback)) {
        options.success = callback;
    }

    var ajax = $.server(options);

    ajax.progress(function(message, type, code) {
        if (self.debug && type=="debug") {
            self.console.log(message, type, code);
        }
    });

    return ajax;
});

$.Component.extend("Controller", function() {

    var self = this,
        args = $.makeArray(arguments),
        name = args[0],
        staticProps,
        protoFactory;

    // Getter
    if (args.length==1) {
        return $.String.getObject(name);
    };

    // Setter
    if (args.length > 2) {
        staticProps = args[1],
        protoFactory = args[2]
    } else {
        staticProps = {},
        protoFactory = args[1]
    }

    // Map component as a static property
    // of the controller class
    $.extend(staticProps, {
        root: self.className + '.Controller',
        component: self
    });

    return $.Controller.apply(this, [name, staticProps, protoFactory]);
});

$.Component.extend("Model", function() {
    var self = this,
        args = $.makeArray(arguments),
        name = self.className + '.Model.' + args[0],
        staticProps,
        protoFactory;

    // Getter
    if (args.length==1) {
        return $.String.getObject(args[0]);
    }

    if( args.length==2) {
        staticProps = {},
        protoFactory = args[1]
    }

    if( args.length > 2) {
        staticProps = args[1],
        protoFactory = args[2]
    }

    // Map component as a static property
    // of the model class
    $.extend(staticProps, {
        component: self
    });

    return $.Model.apply(this, [name, staticProps, protoFactory]);
});

$.Component.extend("Model.List", function() {
    var self = this,
        args = $.makeArray(arguments),
        name = self.className + '.Model.List.' + args[0],
        staticProps,
        protoFactory;

    // Getter
    if (args.length==1) {
        return $.String.getObject(args[0]);
    }

    if( args.length==2) {
        staticProps = {},
        protoFactory = args[1]
    }

    if( args.length > 2) {
        staticProps = args[1],
        protoFactory = args[2]
    }

    // Map component as a static property
    // of the model class
    $.extend(staticProps, {
        component: self
    });

    return $.Model.List.apply(this, [name, staticProps, protoFactory]);
});

$.Component.extend("View", function(name) {

    var self = this;

    // Gett all component views
    if (arguments.length < 1) {
        return self.template();
    }

    // Prepend component prefix
    arguments[0] = self.prefix + arguments[0];

    // Getter or setter
    return $.View.apply(this, arguments);
});
// Component should always be the last core plugin to load.

// Execute all pending foundry modules
FD40.module.execute();

// Get all abstract components
$.each(FD40.component(), function(i, abstractComponent){

    // If this component is registered, stop.
    if (abstractComponent.registered) return;

    // Create an instance of the component
    $.Component.register(abstractComponent);
});

});FD40.plugin("static", function($) {
	$.module(["autosize.input","datetimepicker","dialog","expanding","gmaps","history","image","leaflet-providers","leaflet","markitup","mentions","mobile-events","moment","passwordstrength","placeholder","plupload","popbox","scrollTo","select2","sly","textboxlist","ui\/core","ui\/mouse","ui\/position","ui\/resizable","ui\/slider","ui\/widget","wavesurfer"]);

	// Now we need to retrieve the contents of each files
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

var AutosizeInput = function(input, options) {

    var self = this;

    self.input   = $(input);
    self.options = $.extend(AutosizeInput.defaultOptions, options);
    self.mirror  = $('<span style="position:absolute; top:-999px; left:0; white-space:pre;"/>');

    $.each([
        'fontFamily',
        'fontSize',
        'fontWeight',
        'fontStyle',
        'letterSpacing',
        'textTransform',
        'wordSpacing',
        'textIndent'
    ], function (i, val) {
        self.mirror[0].style[val] = self.input.css(val);
    });

    $("body").append(self.mirror);

    self.input.bind("keydown keyup input", function(e){
        self.update();
    });

    self.update();
}

AutosizeInput.defaultOptions = {
    space: 30
}

AutosizeInput.validTypes = [
    "text",
    "password",
    "search",
    "url",
    "tel",
    "email"
];

AutosizeInput.prototype.update = function() {

    var self   = this,
        input  = self.input,
        mirror = self.mirror,
        value  = input.val();

    if (!value) {
        value = input.attr("placeholder");
    }

    if (value === mirror.text()) {
        return;
    }

    mirror.text(value);

    var newWidth = mirror.width() + self.options.space;
    input.width(newWidth);
};

$.fn.autosizeInput = function(options) {

    return this.each(function () {
        if(!(this.tagName == "INPUT" && $.inArray(this.type, AutosizeInput.validTypes) > -1)) {
            return;
        }
        var $this = $(this);
        if (!$this.data("autosizeInputInstance")) {
            $this.data("autosizeInputInstance", new AutosizeInput(this, options));
        }
    });
};

$(function () {
    $("input[data-autosize-input]").autosizeInput();
});


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("autosize.input", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
$.require() 
 .script("moment") 
 .done(function() { 
var exports = function() { 

/*
Version 3.0.0
=========================================================
bootstrap-datetimepicker.js
https://github.com/Eonasdan/bootstrap-datetimepicker
=========================================================
The MIT License (MIT)

Copyright (c) 2014 Jonathan Peterson

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

	var dpgId = 0,

	pMoment = $.moment,

// ReSharper disable once InconsistentNaming
	DateTimePicker = function (element, options) {
		var defaults = {
			pickDate: true,
			pickTime: true,
			useMinutes: true,
			useSeconds: false,
			useCurrent: true,
			minuteStepping: 1,
			minDate: new pMoment({ y: 1900 }),
			maxDate: new pMoment().add(100, "y"),
			showToday: true,
			collapse: true,
			language: "en",
			defaultDate: "",
			disabledDates: false,
			enabledDates: false,
			icons: {},
			useStrict: false,
			direction: "auto",
			sideBySide: false,
			daysOfWeekDisabled: false,
			component: "",
			dow: 0
		},

		icons = {
			time  : 'far fa-clock',
			date  : 'fa fa-calendar',
			up    : 'fa fa-chevron-up',
			down  : 'fa fa-chevron-down'
		},

		picker = this,

		init = function () {

			var icon = false, i, dDate, longDateFormat;
			picker.options = $.extend({}, defaults, options);
			picker.options.icons = $.extend({}, icons, picker.options.icons);

			picker.element = $(element);

			dataToOptions();

			if (!(picker.options.pickTime || picker.options.pickDate))
				throw new Error('Must choose at least one picker');

			picker.id = dpgId++;
			pMoment.lang(picker.options.language);
			picker.date = pMoment();
			picker.unset = false;
			picker.isInput = picker.element.is('input');
			picker.component = false;

			// Set the start of week
			pMoment()._lang._week.dow = picker.options.dow;

			if (picker.element.hasClass('input-group')) {
				if (picker.element.find('.datepickerbutton').size() == 0) {//in case there is more then one 'input-group-addon' Issue #48
					picker.component = picker.element.find("[class^='input-group-']");
				}
				else {
					picker.component = picker.element.find('.datepickerbutton');
				}
			}
			picker.format = picker.options.format;

			longDateFormat = pMoment()._lang._longDateFormat;

			if (!picker.format) {
				picker.format = (picker.options.pickDate ? longDateFormat.L : '');
				if (picker.options.pickDate && picker.options.pickTime) picker.format += ' ';
				picker.format += (picker.options.pickTime ? longDateFormat.LT : '');
				if (picker.options.useSeconds) {
					if (~longDateFormat.LT.indexOf(' A')) {
						picker.format = picker.format.split(" A")[0] + ":ss A";
					}
					else {
						picker.format += ':ss';
					}
				}
			}
			picker.use24hours = picker.format.toLowerCase().indexOf("a") < 1;

			if (picker.component) icon = picker.component.find('span');

			if (picker.options.pickTime) {
				if (icon) icon.addClass(picker.options.icons.time);
			}
			if (picker.options.pickDate) {
				if (icon) {
					icon.removeClass(picker.options.icons.time);
					icon.addClass(picker.options.icons.date);
				}
			}

			picker.widget = $(getTemplate()).appendTo('body');

			if (picker.options.useSeconds && !picker.use24hours) {
				picker.widget.width(300);
			}

			picker.minViewMode = picker.options.minViewMode || 0;
			if (typeof picker.minViewMode === 'string') {
				switch (picker.minViewMode) {
					case 'months':
						picker.minViewMode = 1;
						break;
					case 'years':
						picker.minViewMode = 2;
						break;
					default:
						picker.minViewMode = 0;
						break;
				}
			}
			picker.viewMode = picker.options.viewMode || 0;
			if (typeof picker.viewMode === 'string') {
				switch (picker.viewMode) {
					case 'months':
						picker.viewMode = 1;
						break;
					case 'years':
						picker.viewMode = 2;
						break;
					default:
						picker.viewMode = 0;
						break;
				}
			}

			picker.options.disabledDates = indexGivenDates(picker.options.disabledDates);
			picker.options.enabledDates = indexGivenDates(picker.options.enabledDates);

			picker.startViewMode = picker.viewMode;
			picker.setMinDate(picker.options.minDate);
			picker.setMaxDate(picker.options.maxDate);
			fillDow();
			fillMonths();
			fillHours();
			fillMinutes();
			fillSeconds();
			update();
			showMode();
			attachDatePickerEvents();
			if (picker.options.defaultDate !== "" && getPickerInput().val() == "") picker.setValue(picker.options.defaultDate);
			if (picker.options.minuteStepping !== 1) {
				var rInterval = picker.options.minuteStepping;
				picker.date.minutes((Math.round(picker.date.minutes() / rInterval) * rInterval) % 60).seconds(0);
			}
		},

		getPickerInput = function () {
			if (picker.isInput) {
				return picker.element;
			} else {
				return dateStr = picker.element.find('input');
			}
		},

		dataToOptions = function () {
			var eData
			if (picker.element.is('input')) {
				eData = picker.element.data();
			}
			else {
				eData = picker.element.data();
			}
			if (eData.dateFormat !== undefined) picker.options.format = eData.dateFormat;
			if (eData.datePickdate !== undefined) picker.options.pickDate = eData.datePickdate;
			if (eData.datePicktime !== undefined) picker.options.pickTime = eData.datePicktime;
			if (eData.dateUseminutes !== undefined) picker.options.useMinutes = eData.dateUseminutes;
			if (eData.dateUseseconds !== undefined) picker.options.useSeconds = eData.dateUseseconds;
			if (eData.dateUsecurrent !== undefined) picker.options.useCurrent = eData.dateUsecurrent;
			if (eData.dateMinutestepping !== undefined) picker.options.minuteStepping = eData.dateMinutestepping;
			if (eData.dateMindate !== undefined) picker.options.minDate = eData.dateMindate;
			if (eData.dateMaxdate !== undefined) picker.options.maxDate = eData.dateMaxdate;
			if (eData.dateShowtoday !== undefined) picker.options.showToday = eData.dateShowtoday;
			if (eData.dateCollapse !== undefined) picker.options.collapse = eData.dateCollapse;
			if (eData.dateLanguage !== undefined) picker.options.language = eData.dateLanguage;
			if (eData.dateDefaultdate !== undefined) picker.options.defaultDate = eData.dateDefaultdate;
			if (eData.dateDisableddates !== undefined) picker.options.disabledDates = eData.dateDisableddates;
			if (eData.dateEnableddates !== undefined) picker.options.enabledDates = eData.dateEnableddates;
			if (eData.dateIcons !== undefined) picker.options.icons = eData.dateIcons;
			if (eData.dateUsestrict !== undefined) picker.options.useStrict = eData.dateUsestrict;
			if (eData.dateDirection !== undefined) picker.options.direction = eData.dateDirection;
			if (eData.dateSidebyside !== undefined) picker.options.sideBySide = eData.dateSidebyside;
		},

		place = function () {
			var position = 'absolute',
			offset = picker.component ? picker.component.offset() : picker.element.offset(), $window = $(window);
			picker.width = picker.component ? picker.component.outerWidth() : picker.element.outerWidth();
			offset.top = offset.top + picker.element.outerHeight();

			var placePosition;
			if (picker.options.direction === 'up') {
				placePosition = 'top'
			} else if (picker.options.direction === 'bottom') {
				placePosition = 'bottom'
			} else if (picker.options.direction === 'auto') {
				if (offset.top + picker.widget.height() > $window.height() + $window.scrollTop() && picker.widget.height() + picker.element.outerHeight() < offset.top) {
					placePosition = 'top';
				} else {
					placePosition = 'bottom';
				}
			};
			if (placePosition === 'top') {
				offset.top -= picker.widget.height() + picker.element.outerHeight() + 15;
				picker.widget.addClass('top').removeClass('bottom');
			} else {
				offset.top += 1;
				picker.widget.addClass('bottom').removeClass('top');
			}

			if (picker.options.width !== undefined) {
				picker.widget.width(picker.options.width);
			}

			if (picker.options.orientation === 'left') {
				picker.widget.addClass('left-oriented');
				offset.left = offset.left - picker.widget.width() + 20;
			}

			if (isInFixed()) {
				position = 'fixed';
				offset.top -= $window.scrollTop();
				offset.left -= $window.scrollLeft();
			}

			if ($window.width() < offset.left + picker.widget.outerWidth()) {
				offset.right = $window.width() - offset.left - picker.width;
				offset.left = 'auto';
				picker.widget.addClass('pull-right');
			} else {
				offset.right = 'auto';
				picker.widget.removeClass('pull-right');
			}

			picker.widget.css({
				position: position,
				top: offset.top,
				left: offset.left,
				right: offset.right
			});
		},

		notifyChange = function (oldDate, eventType) {
			if (pMoment(picker.date).isSame(pMoment(oldDate))) return;
			picker.element.trigger({
				type: 'dp.change',
				date: pMoment(picker.date),
				oldDate: pMoment(oldDate)
			});

			if (eventType !== 'change')
				picker.element.change();
		},

		notifyError = function (date) {
			picker.element.trigger({
				type: 'dp.error',
				date: pMoment(date)
			});
		},

		update = function (newDate) {
			pMoment.lang(picker.options.language);
			var dateStr = newDate;
			if (!dateStr) {
				dateStr = getPickerInput().val()
				if (dateStr) picker.date = pMoment(dateStr, picker.format, picker.options.useStrict);
				if (!picker.date) picker.date = pMoment();
			}
			picker.viewDate = pMoment(picker.date).startOf("month");
			fillDate();
			fillTime();
		},

		fillDow = function () {
			pMoment.lang(picker.options.language);
			var html = $('<tr>'), weekdaysMin = pMoment.weekdaysMin(), i;

			// Reconstruct weekdays structure by start day of the week
			var spliced = weekdaysMin.splice(pMoment()._lang._week.dow);
			weekdaysMin = spliced.concat(weekdaysMin);

			$.each(weekdaysMin, function(i, w) {
				html.append('<th class="dow">' + w + '</th>');
			});

			// if (pMoment()._lang._week.dow == 0) { // starts on Sunday
			//     for (i = 0; i < 7; i++) {
			//         html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
			//     }
			// } else {
			//     for (i = 1; i < 8; i++) {
			//         if (i == 7) {
			//             html.append('<th class="dow">' + weekdaysMin[0] + '</th>');
			//         } else {
			//             html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
			//         }
			//     }
			// }
			picker.widget.find('.datepicker-days thead').append(html);
		},

		fillMonths = function () {
			pMoment.lang(picker.options.language);
			var html = '', i = 0, monthsShort = pMoment.monthsShort();
			while (i < 12) {
				html += '<span class="month">' + monthsShort[i++] + '</span>';
			}
			picker.widget.find('.datepicker-months td').append(html);
		},

		fillDate = function () {
			pMoment.lang(picker.options.language);
			var year = picker.viewDate.year(),
				month = picker.viewDate.month(),
				startYear = picker.options.minDate.year(),
				startMonth = picker.options.minDate.month(),
				endYear = picker.options.maxDate.year(),
				endMonth = picker.options.maxDate.month(),
				currentDate,
				prevMonth, nextMonth, html = [], row, clsName, i, days, yearCont, currentYear, months = pMoment.months();

			picker.widget.find('.datepicker-days').find('.disabled').removeClass('disabled');
			picker.widget.find('.datepicker-months').find('.disabled').removeClass('disabled');
			picker.widget.find('.datepicker-years').find('.disabled').removeClass('disabled');

			picker.widget.find('.datepicker-days th:eq(1)').text(
				months[month] + ' ' + year);

			prevMonth = pMoment(picker.viewDate).subtract("months", 1);
			days = prevMonth.daysInMonth();
			prevMonth.date(days).startOf('week');
			if ((year == startYear && month <= startMonth) || year < startYear) {
				picker.widget.find('.datepicker-days th:eq(0)').addClass('disabled');
			}
			if ((year == endYear && month >= endMonth) || year > endYear) {
				picker.widget.find('.datepicker-days th:eq(2)').addClass('disabled');
			}

			nextMonth = pMoment(prevMonth).add(42, "d");
			while (prevMonth.isBefore(nextMonth)) {
				if (prevMonth.weekday() === pMoment().startOf('week').weekday()) {
					row = $('<tr>');
					html.push(row);
				}
				clsName = '';
				if (prevMonth.year() < year || (prevMonth.year() == year && prevMonth.month() < month)) {
					clsName += ' old';
				} else if (prevMonth.year() > year || (prevMonth.year() == year && prevMonth.month() > month)) {
					clsName += ' new';
				}
				if (prevMonth.isSame(pMoment({ y: picker.date.year(), M: picker.date.month(), d: picker.date.date() }))) {
					clsName += ' active';
				}
				if (isInDisableDates(prevMonth) || !isInEnableDates(prevMonth)) {
					clsName += ' disabled';
				}
				if (picker.options.showToday === true) {
					if (prevMonth.isSame(pMoment(), 'day')) {
						clsName += ' today';
					}
				}
				if (picker.options.daysOfWeekDisabled) {
					for (i in picker.options.daysOfWeekDisabled) {
						if (prevMonth.day() == picker.options.daysOfWeekDisabled[i]) {
							clsName += ' disabled';
							break;
						}
					}
				}
				row.append('<td class="day' + clsName + '">' + prevMonth.date() + '</td>');

				currentDate = prevMonth.date();
				prevMonth.add(1, "d");

				if (currentDate == prevMonth.date()) {
				  prevMonth.add(1, "d");
				}
			}
			picker.widget.find('.datepicker-days tbody').empty().append(html);
			currentYear = picker.date.year(), months = picker.widget.find('.datepicker-months')
				.find('th:eq(1)').text(year).end().find('span').removeClass('active');
			if (currentYear === year) {
				months.eq(picker.date.month()).addClass('active');
			}
			if (currentYear - 1 < startYear) {
				picker.widget.find('.datepicker-months th:eq(0)').addClass('disabled');
			}
			if (currentYear + 1 > endYear) {
				picker.widget.find('.datepicker-months th:eq(2)').addClass('disabled');
			}
			for (i = 0; i < 12; i++) {
				if ((year == startYear && startMonth > i) || (year < startYear)) {
					$(months[i]).addClass('disabled');
				} else if ((year == endYear && endMonth < i) || (year > endYear)) {
					$(months[i]).addClass('disabled');
				}
			}

			html = '';
			year = parseInt(year / 10, 10) * 10;
			yearCont = picker.widget.find('.datepicker-years').find(
				'th:eq(1)').text(year + '-' + (year + 9)).end().find('td');
			picker.widget.find('.datepicker-years').find('th').removeClass('disabled');
			if (startYear > year) {
				picker.widget.find('.datepicker-years').find('th:eq(0)').addClass('disabled');
			}
			if (endYear < year + 9) {
				picker.widget.find('.datepicker-years').find('th:eq(2)').addClass('disabled');
			}
			year -= 1;
			for (i = -1; i < 11; i++) {
				html += '<span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + ((year < startYear || year > endYear) ? ' disabled' : '') + '">' + year + '</span>';
				year += 1;
			}
			yearCont.html(html);
		},

		fillHours = function () {
			pMoment.lang(picker.options.language);
			var table = picker.widget.find('.timepicker .timepicker-hours table'), html = '', current, i, j;
			table.parent().hide();
			if (picker.use24hours) {
				current = 0;
				for (i = 0; i < 6; i += 1) {
					html += '<tr>';
					for (j = 0; j < 4; j += 1) {
						html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
						current++;
					}
					html += '</tr>';
				}
			}
			else {
				current = 1;
				for (i = 0; i < 3; i += 1) {
					html += '<tr>';
					for (j = 0; j < 4; j += 1) {
						html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
						current++;
					}
					html += '</tr>';
				}
			}
			table.html(html);
		},

		fillMinutes = function () {
			var table = picker.widget.find('.timepicker .timepicker-minutes table'), html = '', current = 0, i, j, step = picker.options.minuteStepping;
			table.parent().hide();
			if (step == 1) step = 5;
			for (i = 0; i < Math.ceil(60 / step / 4) ; i++) {
				html += '<tr>';
				for (j = 0; j < 4; j += 1) {
					if (current < 60) {
						html += '<td class="minute">' + padLeft(current.toString()) + '</td>';
						current += step;
					} else {
						html += '<td></td>';
					}
				}
				html += '</tr>';
			}
			table.html(html);
		},

		fillSeconds = function () {
			var table = picker.widget.find('.timepicker .timepicker-seconds table'), html = '', current = 0, i, j;
			table.parent().hide();
			for (i = 0; i < 3; i++) {
				html += '<tr>';
				for (j = 0; j < 4; j += 1) {
					html += '<td class="second">' + padLeft(current.toString()) + '</td>';
					current += 5;
				}
				html += '</tr>';
			}
			table.html(html);
		},

		fillTime = function () {
			if (!picker.date) return;
			var timeComponents = picker.widget.find('.timepicker span[data-time-component]'),
			hour = picker.date.hours(),
			period = 'AM';

			if (!picker.use24hours) {
				
				if (hour >= 12) {
					period = 'PM';
				}
				
				if (hour === 0) {
					hour = 12;
				} else if (hour != 12) {
					hour = hour % 12;
				}

				picker.widget.find('.timepicker [data-action=togglePeriod]').text(period);
			}

			timeComponents.filter('[data-time-component=hours]').text(padLeft(hour));
			timeComponents.filter('[data-time-component=minutes]').text(padLeft(picker.date.minutes()));
			timeComponents.filter('[data-time-component=seconds]').text(padLeft(picker.date.second()));
		},

		click = function (e) {
			e.stopPropagation();
			e.preventDefault();
			picker.unset = false;
			var target = $(e.target).closest('span, td, th'), month, year, step, day, oldDate = pMoment(picker.date);
			if (target.length === 1) {
				if (!target.is('.disabled')) {
					switch (target[0].nodeName.toLowerCase()) {
						case 'th':
							switch (target[0].className) {
								case 'switch':
									showMode(1);
									break;
								case 'prev':
								case 'next':
									step = dpGlobal.modes[picker.viewMode].navStep;
									if (target[0].className === 'prev') step = step * -1;
									picker.viewDate.add(step, dpGlobal.modes[picker.viewMode].navFnc);
									fillDate();
									break;
							}
							break;
						case 'span':
							if (target.is('.month')) {
								month = target.parent().find('span').index(target);
								picker.viewDate.month(month);
							} else {
								year = parseInt(target.text(), 10) || 0;
								picker.viewDate.year(year);
							}
							if (picker.viewMode === picker.minViewMode) {
								picker.date = pMoment({
									y: picker.viewDate.year(),
									M: picker.viewDate.month(),
									d: picker.viewDate.date(),
									h: picker.date.hours(),
									m: picker.date.minutes(),
									s: picker.date.seconds()
								});
								notifyChange(oldDate, e.type);
								set();
							}
							showMode(-1);
							fillDate();
							break;
						case 'td':
							if (target.is('.day')) {
								day = parseInt(target.text(), 10) || 1;
								month = picker.viewDate.month();
								year = picker.viewDate.year();
								if (target.is('.old')) {
									if (month === 0) {
										month = 11;
										year -= 1;
									} else {
										month -= 1;
									}
								} else if (target.is('.new')) {
									if (month == 11) {
										month = 0;
										year += 1;
									} else {
										month += 1;
									}
								}
								picker.date = pMoment({
									y: year,
									M: month,
									d: day,
									h: picker.date.hours(),
									m: picker.date.minutes(),
									s: picker.date.seconds()
								}
								);
								picker.viewDate = pMoment({
									y: year, M: month, d: Math.min(28, day)
								});
								fillDate();
								set();
								notifyChange(oldDate, e.type);
							}
							break;
					}
				}
			}
		},

		actions = {
			incrementHours: function () {
				checkDate("add", "hours", 1);
			},

			incrementMinutes: function () {
				checkDate("add", "minutes", picker.options.minuteStepping);
			},

			incrementSeconds: function () {
				checkDate("add", "seconds", 1);
			},

			decrementHours: function () {
				checkDate("subtract", "hours", 1);
			},

			decrementMinutes: function () {
				checkDate("subtract", "minutes", picker.options.minuteStepping);
			},

			decrementSeconds: function () {
				checkDate("subtract", "seconds", 1);
			},

			togglePeriod: function () {
				var hour = picker.date.hours();
				if (hour >= 12) hour -= 12;
				else hour += 12;
				picker.date.hours(hour);
			},

			showPicker: function () {
				picker.widget.find('.timepicker > div:not(.timepicker-picker)').hide();
				picker.widget.find('.timepicker .timepicker-picker').show();
			},

			showHours: function () {
				picker.widget.find('.timepicker .timepicker-picker').hide();
				picker.widget.find('.timepicker .timepicker-hours').show();
			},

			showMinutes: function () {
				picker.widget.find('.timepicker .timepicker-picker').hide();
				picker.widget.find('.timepicker .timepicker-minutes').show();
			},

			showSeconds: function () {
				picker.widget.find('.timepicker .timepicker-picker').hide();
				picker.widget.find('.timepicker .timepicker-seconds').show();
			},

			selectHour: function (e) {
				var period = picker.widget.find('.timepicker [data-action=togglePeriod]').text(), hour = parseInt($(e.target).text(), 10);
				if (period == "PM") hour += 12
				picker.date.hours(hour);
				actions.showPicker.call(picker);
			},

			selectMinute: function (e) {
				picker.date.minutes(parseInt($(e.target).text(), 10));
				actions.showPicker.call(picker);
			},

			selectSecond: function (e) {
				picker.date.seconds(parseInt($(e.target).text(), 10));
				actions.showPicker.call(picker);
			}
		},

		doAction = function (e) {
			var oldDate = pMoment(picker.date), action = $(e.currentTarget).data('action'), rv = actions[action].apply(picker, arguments);
			stopEvent(e);
			if (!picker.date) picker.date = pMoment({ y: 1970 });
			set();
			fillTime();
			notifyChange(oldDate, e.type);
			return rv;
		},

		stopEvent = function (e) {
			e.stopPropagation();
			e.preventDefault();
		},

		change = function (e) {
			pMoment.lang(picker.options.language);
			var input = $(e.target), oldDate = pMoment(picker.date), newDate = pMoment(input.val(), picker.format, picker.options.useStrict);
			if (newDate.isValid() && !isInDisableDates(newDate) && isInEnableDates(newDate)) {
				update();
				picker.setValue(newDate);
				notifyChange(oldDate, e.type);
				set();
			}
			else {
				picker.viewDate = oldDate;
				notifyChange(oldDate, e.type);
				notifyError(newDate);
				picker.unset = true;
			}
		},

		showMode = function (dir) {
			if (dir) {
				picker.viewMode = Math.max(picker.minViewMode, Math.min(2, picker.viewMode + dir));
			}
			var f = dpGlobal.modes[picker.viewMode].clsName;
			picker.widget.find('.datepicker > div').hide().filter('.datepicker-' + dpGlobal.modes[picker.viewMode].clsName).show();
		},

		attachDatePickerEvents = function () {
			var $this, $parent, expanded, closed, collapseData;
			picker.widget.on('click', '.datepicker *', $.proxy(click, this)); // this handles date picker clicks
			picker.widget.on('click', '[data-action]', $.proxy(doAction, this)); // this handles time picker clicks
			picker.widget.on('mousedown', $.proxy(stopEvent, this));
			if (picker.options.pickDate && picker.options.pickTime) {
				picker.widget.on('click.togglePicker', '.accordion-toggle', function (e) {
					e.stopPropagation();
					$this = $(this);
					$parent = $this.closest('ul');
					expanded = $parent.find('.in');
					closed = $parent.find('.collapse:not(.in)');

					if (expanded && expanded.length) {
						collapseData = expanded.data('collapse');
						if (collapseData && collapseData.date - transitioning) return;
						expanded.collapse('hide');
						closed.collapse('show');
						$this.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
						picker.element.find('.input-group-addon span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
					}
				});
			}
			if (picker.isInput) {
				picker.element.on({
					'focus': $.proxy(picker.show, this),
					'change': $.proxy(change, this),
					'blur': $.proxy(picker.hide, this)
				});
			} else {
				picker.element.on({
					'change': $.proxy(change, this)
				}, 'input');
				if (picker.component) {
					picker.component.on('click', $.proxy(picker.show, this));
				} else {
					picker.element.on('click', $.proxy(picker.show, this));
				}
			}
		},

		attachDatePickerGlobalEvents = function () {
			$(window).on(
				'resize.datetimepicker' + picker.id, $.proxy(place, this));
			if (!picker.isInput) {
				$(document).on(
					'mousedown.datetimepicker' + picker.id, $.proxy(picker.hide, this));
			}
		},

		detachDatePickerEvents = function () {
			picker.widget.off('click', '.datepicker *', picker.click);
			picker.widget.off('click', '[data-action]');
			picker.widget.off('mousedown', picker.stopEvent);
			if (picker.options.pickDate && picker.options.pickTime) {
				picker.widget.off('click.togglePicker');
			}
			if (picker.isInput) {
				picker.element.off({
					'focus': picker.show,
					'change': picker.change
				});
			} else {
				picker.element.off({
					'change': picker.change
				}, 'input');
				if (picker.component) {
					picker.component.off('click', picker.show);
				} else {
					picker.element.off('click', picker.show);
				}
			}
		},

		detachDatePickerGlobalEvents = function () {
			$(window).off('resize.datetimepicker' + picker.id);
			if (!picker.isInput) {
				$(document).off('mousedown.datetimepicker' + picker.id);
			}
		},

		isInFixed = function () {
			if (picker.element) {
				var parents = picker.element.parents(), inFixed = false, i;
				for (i = 0; i < parents.length; i++) {
					if ($(parents[i]).css('position') == 'fixed') {
						inFixed = true;
						break;
					}
				}
				;
				return inFixed;
			} else {
				return false;
			}
		},

		set = function () {
			pMoment.lang(picker.options.language);
			var formatted = '', input;
			if (!picker.unset) formatted = pMoment(picker.date).format(picker.format);
			getPickerInput().val(formatted);
			picker.element.data('date', formatted);
			if (!picker.options.pickTime) picker.hide();
		},

		checkDate = function (direction, unit, amount) {
			pMoment.lang(picker.options.language);
			var newDate;
			if (direction == "add") {
				newDate = pMoment(picker.date);
				if (newDate.hours() == 23) newDate.add(amount, unit);
				newDate.add(amount, unit);
			}
			else {
				newDate = pMoment(picker.date).subtract(amount, unit);
			}
			if (isInDisableDates(pMoment(newDate.subtract(amount, unit))) || isInDisableDates(newDate)) {
				notifyError(newDate.format(picker.format));
				return;
			}

			if (direction == "add") {
				picker.date.add(amount, unit);
			}
			else {
				picker.date.subtract(amount, unit);
			}
			picker.unset = false;
		},

		isInDisableDates = function (date) {
			pMoment.lang(picker.options.language);
			if (date.isAfter(picker.options.maxDate) || date.isBefore(picker.options.minDate)) return true;
			if (picker.options.disabledDates === false) {
				return false;
			}
			return picker.options.disabledDates[pMoment(date).format("YYYY-MM-DD")] === true;
		},
		isInEnableDates = function (date) {
			pMoment.lang(picker.options.language);
			if (picker.options.enabledDates === false) {
				return true;
			}
			return picker.options.enabledDates[pMoment(date).format("YYYY-MM-DD")] === true;
		},

		indexGivenDates = function (givenDatesArray) {
			// Store given enabledDates and disabledDates as keys.
			// This way we can check their existence in O(1) time instead of looping through whole array.
			// (for example: picker.options.enabledDates['2014-02-27'] === true)
			var givenDatesIndexed = {};
			var givenDatesCount = 0;
			for (i = 0; i < givenDatesArray.length; i++) {
				dDate = pMoment(givenDatesArray[i]);
				if (dDate.isValid()) {
					givenDatesIndexed[dDate.format("YYYY-MM-DD")] = true;
					givenDatesCount++;
				}
			}
			if (givenDatesCount > 0) {
				return givenDatesIndexed;
			}
			return false;
		},

		padLeft = function (string) {
			string = string.toString();
			if (string.length >= 2) return string;
			else return '0' + string;
		},

		getTemplate = function () {
			if (picker.options.pickDate && picker.options.pickTime) {
				var ret = '';
				ret = '<div id="es" class="ui bootstrap-datetimepicker-widget' + (picker.options.sideBySide ? ' timepicker-sbs' : '') + ' ' + (picker.options.component) + '" style="z-index:99999 !important;">';
				if (picker.options.sideBySide) {
					ret += '<div class="row">' +
					   '<div class="col-sm-6 datepicker">' + dpGlobal.template + '</div>' +
					   '<div class="col-sm-6 timepicker">' + tpGlobal.getTemplate() + '</div>' +
					 '</div>';
				} else {
					ret += '<ul class="g-list-unstyled">' +
						'<li' + (picker.options.collapse ? ' class="collapse in"' : '') + '>' +
							'<div class="datepicker">' + dpGlobal.template + '</div>' +
						'</li>' +
						'<li class="picker-switch accordion-toggle"><a class="btn btn-es-primary" style="width:100%"><span class="' + picker.options.icons.time + '"></span></a></li>' +
						'<li' + (picker.options.collapse ? ' class="collapse"' : '') + '>' +
							'<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
						'</li>' +
				   '</ul>';

				   // Reserved in case if topdown layout is needed
				   //  ret += '<ul class="list-unstyled">' +
				   //      '<li>' +
				   //          '<div class="datepicker">' + dpGlobal.template + '</div>' +
				   //      '</li>' +
				   //      '<li>' +
				   //          '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
				   //      '</li>' +
				   // '</ul>';
				}
				ret += '</div>';
				return ret;
			} else if (picker.options.pickTime) {
				return (
					'<div id="es" class="ui bootstrap-datetimepicker-widget">' +
						'<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
					'</div>'
				);
			} else {
				return (
					'<div id="es" class="ui bootstrap-datetimepicker-widget">' +
						'<div class="datepicker">' + dpGlobal.template + '</div>' +
					'</div>'
				);
			}
		},

		dpGlobal = {
			modes: [
				{
					clsName: 'days',
					navFnc: 'month',
					navStep: 1
				},
				{
					clsName: 'months',
					navFnc: 'year',
					navStep: 1
				},
				{
					clsName: 'years',
					navFnc: 'year',
					navStep: 10
				}],
			headTemplate:
					'<thead>' +
						'<tr>' +
							'<th class="prev">&lsaquo;</th><th colspan="5" class="switch"></th><th class="next">&rsaquo;</th>' +
						'</tr>' +
					'</thead>',
			contTemplate:
		'<tbody><tr><td colspan="7"></td></tr></tbody>'
		},

		tpGlobal = {
			hourTemplate: '<span data-action="showHours"   data-time-component="hours"   class="timepicker-hour"></span>',
			minuteTemplate: '<span data-action="showMinutes" data-time-component="minutes" class="timepicker-minute"></span>',
			secondTemplate: '<span data-action="showSeconds"  data-time-component="seconds" class="timepicker-second"></span>'
		};

		dpGlobal.template =
			'<div class="datepicker-days">' +
				'<table class="table-condensed">' + dpGlobal.headTemplate + '<tbody></tbody></table>' +
			'</div>' +
			'<div class="datepicker-months">' +
				'<table class="table-condensed">' + dpGlobal.headTemplate + dpGlobal.contTemplate + '</table>' +
			'</div>' +
			'<div class="datepicker-years">' +
				'<table class="table-condensed">' + dpGlobal.headTemplate + dpGlobal.contTemplate + '</table>' +
			'</div>';

		tpGlobal.getTemplate = function () {
			return (
				'<div class="timepicker-picker">' +
					'<table class="table-condensed">' +
						'<tr>' +
							'<td><a href="#" class="btn" data-action="incrementHours"><i class="' + picker.options.icons.up + '"></i></a></td>' +
							'<td class="separator"></td>' +
							'<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="incrementMinutes"><i class="' + picker.options.icons.up + '"></i></a>' : '') + '</td>' +
							(picker.options.useSeconds ?
								'<td class="separator"></td><td><a href="#" class="btn" data-action="incrementSeconds"><i class="' + picker.options.icons.up + '"></i></a></td>' : '') +
							(picker.use24hours ? '' : '<td class="separator"></td>') +
						'</tr>' +
						'<tr>' +
							'<td>' + tpGlobal.hourTemplate + '</td> ' +
							'<td class="separator">:</td>' +
							'<td>' + (picker.options.useMinutes ? tpGlobal.minuteTemplate : '<span class="timepicker-minute">00</span>') + '</td> ' +
							(picker.options.useSeconds ?
								'<td class="separator">:</td><td>' + tpGlobal.secondTemplate + '</td>' : '') +
							(picker.use24hours ? '' : '<td class="separator"></td>' +
							'<td><button type="button" class="btn btn-primary" data-action="togglePeriod"></button></td>') +
						'</tr>' +
						'<tr>' +
							'<td><a href="#" class="btn" data-action="decrementHours"><i class="' + picker.options.icons.down + '"></i></a></td>' +
							'<td class="separator"></td>' +
							'<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="decrementMinutes"><i class="' + picker.options.icons.down + '"></i></a>' : '') + '</td>' +
							(picker.options.useSeconds ?
								'<td class="separator"></td><td><a href="#" class="btn" data-action="decrementSeconds"><i class="' + picker.options.icons.down + '"></i></a></td>' : '') +
							(picker.use24hours ? '' : '<td class="separator"></td>') +
						'</tr>' +
					'</table>' +
				'</div>' +
				'<div class="timepicker-hours" data-action="selectHour">' +
					'<table class="table-condensed"></table>' +
				'</div>' +
				'<div class="timepicker-minutes" data-action="selectMinute">' +
					'<table class="table-condensed"></table>' +
				'</div>' +
				(picker.options.useSeconds ?
					'<div class="timepicker-seconds" data-action="selectSecond"><table class="table-condensed"></table></div>' : '')
			);
		};

		picker.destroy = function () {
			detachDatePickerEvents();
			detachDatePickerGlobalEvents();
			picker.widget.remove();
			picker.element.removeData('DateTimePicker');
			if (picker.component)
				picker.component.removeData('DateTimePicker');
		};

		picker.show = function (e) {
			if (picker.options.useCurrent) {
				if (getPickerInput().val() == '') {
					if (picker.options.minuteStepping !== 1) {
						var mDate = pMoment(),
						rInterval = picker.options.minuteStepping;
						mDate.minutes((Math.round(mDate.minutes() / rInterval) * rInterval) % 60)
							.seconds(0);
						picker.setValue(mDate.format(picker.format))
					} else {
						picker.setValue(pMoment().format(picker.format))
					}
				};
			}
			if (picker.widget.hasClass("picker-open")) {
				picker.widget.hide();
				picker.widget.removeClass("picker-open");
			}
			else {
				picker.widget.show();
				picker.widget.addClass("picker-open");
			}
			picker.height = picker.component ? picker.component.outerHeight() : picker.element.outerHeight();
			place();
			picker.element.trigger({
				type: 'dp.show',
				date: pMoment(picker.date)
			});
			attachDatePickerGlobalEvents();
			if (e) {
				stopEvent(e);
			}
		},

		picker.disable = function () {
			var input = picker.element.find('input');
			if (input.prop('disabled')) return;

			input.prop('disabled', true);
			detachDatePickerEvents();
		},

		picker.enable = function () {
			var input = picker.element.find('input');
			if (!input.prop('disabled')) return;

			input.prop('disabled', false);
			attachDatePickerEvents();
		},

		picker.hide = function (event) {
			if (event && $(event.target).is(picker.element.attr("id")))
				return;
			// Ignore event if in the middle of a picker transition
			var collapse = picker.widget.find('.collapse'), i, collapseData;
			for (i = 0; i < collapse.length; i++) {
				collapseData = collapse.eq(i).data('collapse');
				if (collapseData && collapseData.date - transitioning)
					return;
			}
			picker.widget.hide();
			picker.widget.removeClass("picker-open");
			picker.viewMode = picker.startViewMode;
			showMode();
			picker.element.trigger({
				type: 'dp.hide',
				date: pMoment(picker.date)
			});
			detachDatePickerGlobalEvents();
		},

		picker.setValue = function (newDate) {
			pMoment.lang(picker.options.language);
			if (!newDate) {
				picker.unset = true;
				set();
			} else {
				picker.unset = false;
			}
			if (!pMoment.isMoment(newDate)) newDate = pMoment(newDate, picker.format);
			if (newDate.isValid()) {
				picker.date = newDate;
				set();
				picker.viewDate = pMoment({ y: picker.date.year(), M: picker.date.month() });
				fillDate();
				fillTime();
			}
			else {
				notifyError(newDate);
			}
		},

		picker.getDate = function () {
			if (picker.unset) return null;
			return picker.date;
		},

		picker.setDate = function (date) {
			var oldDate = pMoment(picker.date);
			if (!date) {
				picker.setValue(null);
			} else {
				picker.setValue(date);
			}
			notifyChange(oldDate, "function");
		},

		picker.setDisabledDates = function (dates) {
			picker.options.disabledDates = indexGivenDates(dates);
			if (picker.viewDate) update();
		},
		picker.setEnabledDates = function (dates) {
			picker.options.enabledDates = indexGivenDates(dates);
			if (picker.viewDate) update();
		},

		picker.setMaxDate = function (date) {
			if (date == undefined) return;
			picker.options.maxDate = pMoment(date);
			if (picker.viewDate) update();
		},

		picker.setMinDate = function (date) {
			if (date == undefined) return;
			picker.options.minDate = pMoment(date);
			if (picker.viewDate) update();
		};

		init();
	};

	$.fn._datetimepicker = function (options) {
		return this.each(function () {
			var $this = $(this), data = $this.data('DateTimePicker');
			if (!data) $this.data('DateTimePicker', new DateTimePicker(this, options));
		});
	};

}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("datetimepicker", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() {

var dialogHtml = '<div id="es" class="es-dialog"> <div class="es-dialog-modal"> <div class="es-dialog-header"> <div class="es-dialog-header__grid"> <div class="es-dialog-back-button t-hidden"><i class="fa fa-chevron-left"></i></div> <div class="es-dialog-header__cell"><span class="es-dialog-title"></span></div> <div class="es-dialog-close-button"><i class="fa fa-times"></i></div> </div> </div> <div class="es-dialog-body"> <div class="es-dialog-container"> <div class="es-dialog-content"></div> <div class="o-loader"></div> <div class="o-empty"> <div class="o-empty__content"><i class="o-empty__icon fa fa-exclamation-triangle"></i> <div class="o-empty__text"><span class="es-dialog-error-message"></span></div> </div> </div> </div> </div> <div class="es-dialog-footer"> <div class=""> <div class="es-dialog-footer-content"></div> </div> </div> </div></div>';
var dialog_ = ".es-dialog";
var dialogModal_ = ".es-dialog-modal";
var dialogContent_ = ".es-dialog-content";
var dialogHeader_ = ".es-dialog-header";
var dialogFooter_ = ".es-dialog-footer";
var dialogFooterContent_ = ".es-dialog-footer-content";
var dialogCloseButton_ = ".es-dialog-close-button";
var dialogTitle_ = ".es-dialog-title";
var dialogErrorMessage_ = ".es-dialog-error-message";

var isFailed = "is-failed";
var isLoading = "is-loading";
var rxBraces = /\{|\}/gi;

var self = EasySocial.dialog = function(options) {

	// For places calling EasySocial.dialog().close();
	if (options === undefined) {
		return self;
	}

	// Normalize options
	if ($.isString(options)) {
		options = {content: options};
	}

	var method = self.open;

	method.apply(self, [options]);

	return self;
}

$.extend(self, {

	defaultOptions: {
		title: "",
		content: "",
		buttons: "",
		classname: "",
		width: "auto",
		height: "auto",
		escapeKey: true
	},

	open: function(options) {

		// Get dialog
		var dialog = $(dialog_);
		if (dialog.length < 1) {
			dialog = $(dialogHtml).appendTo("body");
		}

		// Normalize options
		var options = $.extend({}, self.defaultOptions, options);

		// Set title
		var dialogTitle = $(dialogTitle_);
		dialogTitle.text(options.title);

		// Set buttons
		var dialogFooterContent = $(dialogFooterContent_);
		dialogFooterContent.html(options.buttons);
		dialog.toggleClass("has-footer", !!options.buttons)

		// Set bindings
		self.setBindings(options);

		// Set content
		var dialogContent = $(dialogContent_).empty();
		var content = options.content;
		var contentType = self.getContentType(content);
		dialog.switchClass("type-" + contentType)

		if (window.es.mobile) {
			dialog.addClass('is-mobile');
		}
		
		// Set width & height
		var dialogModal = $(dialogModal_);
		var dialogWidth = options.width;
		var dialogHeight = options.height;

		if ($.isNumeric(dialogHeight)) {
			var dialogHeader = $(dialogHeader_);
			var dialogFooter = $(dialogFooter_);
			dialogHeight += dialogHeader.height() + dialogFooter.height();
		}

		dialogModal.css({
			width: dialogWidth,
			height: dialogHeight
		});

		dialog.addClassAfter("active");

		// HTML
		switch (contentType) {

			case "html":
				dialogContent.html(content);
				dialog.trigger('init');
				break;

			case "iframe":
				var iframe = $("<iframe>");
				var iframeUrl = content;
				iframe
					.appendTo(dialogContent)
					.one("load", function(){

					})
					.attr("src", iframeUrl);
				break;

			case "deferred":
				dialog.switchClass(isLoading);
				content
					.done(function(content) {
						// Options
						if ($.isPlainObject(content)) {
							self.reopen($.extend(true, options, content));
						// Content
						} else if ($.isString(content)) {
							options.content = content;
							self.reopen(options);
						// Unknown
						} else {
							dialog.switchClass(isFailed);
						}
					})
					.fail(function(exception){
						dialog.switchClass(isFailed);

						var dialogErrorMessage = $(dialogErrorMessage_);

						// Error message
						if ($.isString(exception)) {
							dialogErrorMessage.html(exception);
						}

						// Exception object
						if ($.isPlainObject(exception) && exception.message) {
							dialogErrorMessage.html(exception.message);
						}
					});
				return;
				break;

			case "dialog":
				var xmlOptions = self.parseXMLOptions(content);
				self.open($.extend(true, options, xmlOptions));
				return;
				break;
		}
	},

	reopen: function(options) {
		self.close();
		self.open(options);
	},

	close: function() {

		// Unset bindings
		self.unsetBindings();

		// Remove dialog
		var dialog = $(dialog_);
		dialog.remove();
	},

	getContentType: function(content) {

		if (/<dialog>(.*?)/.test(content)) {
			return "dialog";
		}

		if ($.isUrl(content)) {
			return "iframe";
		}

		if ($.isDeferred(content)) {
			return "deferred";
		}

		return "html";
	},

	parseXMLOptions: function(xml) {

		var xmlOptions = $.buildHTML(xml);
		var newOptions = {};

		$.each(xmlOptions.children(), function(i, node){

			var node = $(node);
			var key  = $.String.camelize(this.nodeName.toLowerCase());
			var val  = node.html();
			var type = node.attr("type");

			switch (type) {
				case "json":
					try {
						val = $.parseJSON(val);
					} catch(e) {};
					break;

				case "javascript":
					try {
						val = eval('(function($){ return ' + $.trim(val) + ' })(' + $.globalNamespace + ')');
					} catch(e) {};
					break;

				case "text":
					val = node.text();
					break;
			}

			// Automatically convert numerical values
			if ($.isNumeric(val)) {
				val = parseFloat(val);
			}

			newOptions[key] = val;
		});

		return newOptions;
	},

	bindings: {},

	setBindings: function(options) {

		// Remove previous bindings
		self.unsetBindings();

		// Create new bindings
		var selectors = options.selectors;
		var bindings  = options.bindings;
		var dialog = $(dialog_);

		if (selectors && bindings) {

			// Simulate a controller instance
			var controller = {parent: self};
			
			$.each(selectors, function(element, selector){

				var element = element.replace(rxBraces, "");

				// Create selector fn
				var selectorFn = controller[element] = function() {
					return dialog.find(selector);
				};
				selectorFn.selector = selector;
			});

			// Simulate mvc here
			controller["parent"] = self;
			controller["element"] = dialog;
			controller["self"] = function() {
									return dialog;
								};

			// Make the caller available to the dialog if a caller is provided
			if (options.caller) {
				controller["caller"] = options.caller;
			}
			// controller["self"].selector = dialog.selector;

			$.each(bindings, function(binder, eventHandler){

				// Get element and event name
				var parts = binder.split(" ");
				var element = parts[0].replace(rxBraces, "");
				var eventName = parts[1] + ".es.dialog";

				// Get selector fn
				var selectorFn = controller[element];

				// Custom way of simulating a controller's init method
				if (element == 'init') {
					dialog.on(element, function() {

						var args = [this].concat(arguments);

						eventHandler.apply(controller, args);
					});
				}

				// No binding if selector fn is not found
				if (!selectorFn) {

					// These items could be 
					controller[element] = eventHandler;

					return;
				}

				// Bind event handler
				var selector = selectorFn.selector;

				dialog.on(eventName, selector, function(){
					// Convert the argument object into an array first.
					var args = [].slice.call(arguments);
					
					eventHandler.apply(controller, [$(this)].concat(args));
				});

				// Add to bindings
				self.bindings[eventName] = eventHandler;
			});
		}

		if (options.escapeKey) {
			$(document).on("keydown.es.dialog", function(event){
				if (event.keyCode==27) {
					self.close();
				}
			});
		}
	},

	setMessage: function(response) {
		var element = $('<div class="o-alert o-alert--' + response.type + '"><button type="button" class="close" data-bs-dismiss="alert"></button></div>');
		var content = $(dialogContent_);

		element.append(response.message);
		element.prependTo(content);
	},

	unsetBindings: function() {

		// Get dialog
		var dialog = $(dialog_);

		// Unbind bindings
		$.each(self.bindings, function(eventName, eventHandler){
			dialog.off(eventName);
		});

		// Unbind escape
		$(document).off("keydown.es.dialog");
	}
});

$(document)
	.on("click", dialogCloseButton_, function(){
		self.close();
	})
	.on("click", dialog_, function(event){
		var dialog = $(dialog_);

		if (event.target==dialog[0]) {
			self.close();
		}
	});


};

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("dialog", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

// Expanding Textareas
// https://github.com/bgrins/ExpandingTextareas

    $.expandingTextarea = $.extend({
        autoInitialize: true,
        initialSelector: "textarea.expanding",
        opts: {
            resize: function() { }
        }
    }, $.expandingTextarea || {});
    
    var cloneCSSProperties = [
        'lineHeight', 'textDecoration', 'letterSpacing',
        'fontSize', 'fontFamily', 'fontStyle', 
        'fontWeight', 'textTransform', 'textAlign', 
        'direction', 'wordSpacing', 'fontSizeAdjust', 
        'wordWrap', 'word-break',
        'borderLeftWidth', 'borderRightWidth',
        'borderTopWidth','borderBottomWidth',
        'paddingLeft', 'paddingRight',
        'paddingTop','paddingBottom',
        'marginLeft', 'marginRight',
        'marginTop','marginBottom',
        'boxSizing', 'webkitBoxSizing', 'mozBoxSizing', 'msBoxSizing'
    ];
    
    var textareaCSS = {
        position: "absolute",
        height: "100%",
        resize: "none"
    };
    
    var preCSS = {
        visibility: "hidden",
        border: "0 solid",
        whiteSpace: "pre-wrap" 
    };
    
    var containerCSS = {
        position: "relative"
    };
    
    function resize() {

        var clone = $(this).data("textareaClone");
        clone.find("div").text(this.value.replace(/\r\n/g, "\n") + ' ');
        $(this).trigger("resize.expanding");
    }
    
    $.fn.expandingTextarea = function(o) {
        
        var opts = $.extend({ }, $.expandingTextarea.opts, o);
        
        if (o === "resize") {
            return this.trigger("input.expanding");
        }
        
        if (o === "destroy") {
            this.filter(".expanding-init").each(function() {
                // TODO: Restore container position value
                var textarea = $(this).removeClass('expanding-init');
                textarea
                    .attr('style', textarea.data('expanding-styles') || '')
                    .removeData('expanding-styles');
            });
            
            return this;
        }
        
        this.filter("textarea").not(".expanding-init").addClass("expanding-init").each(function() {

            var textarea  = $(this),
                container = textarea.parent(),
                clone     = $($.parseHTML("<pre class='textareaClone'><div></div></pre>"));

            textarea
                .after(clone)
                .data("textareaClone", clone);

            // Container
            container.css(containerCSS);
            
            // Store the original styles in case of destroying.
            textarea.data('expanding-styles', textarea.attr('style'));
            textarea.css(textareaCSS);

            // Clone
            clone.css(preCSS);
            
            $.each(cloneCSSProperties, function(i, p) {
                var val = textarea.css(p);
                
                // Only set if different to prevent overriding percentage css values.
                if (clone.css(p) !== val) {
                    clone.css(p, val);
                }
            });
            
            textarea.bind("input.expanding propertychange.expanding keyup.expanding", resize);
            resize.apply(this);
            
            if (opts.resize) {
                textarea.bind("resize.expanding", opts.resize);
            }
        });
        
        return this;
    };
    
    $(function () {
        if ($.expandingTextarea.autoInitialize) {
            $($.expandingTextarea.initialSelector).expandingTextarea();
        }
    });


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("expanding", moduleFactory);

}());			
(function(){
// module factory: start


var moduleFactory = function($) {
// module body: start

var module = this;

if (!window.es.requireGmaps) {
	module.resolve();
}

var callbackId = $.callback(function(){/*!
 * GMaps.js v0.3.1
 * http://hpneo.github.com/gmaps/
 *
 * Copyright 2012, Gustavo Leon
 * Released under the MIT License.
 */


  if(!window.google && !window.google.maps){
	module.reject("Google Maps API is required. Please register the following JavaScript library http://maps.google.com/maps/api/js?sensor=true.");
  }

  var GMaps = (function(global) {
	"use strict";

	var doc = document;
	var getElementById = function(id, context) {
	  return $("#"+id.replace('#', ''), context)[0];
	};

	var GMaps = function(options) {
	  var self = this;

	  var events_that_hide_context_menu = ['bounds_changed', 'center_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'idle', 'maptypeid_changed', 'projection_changed', 'resize', 'tilesloaded', 'zoom_changed'];
	  var events_that_doesnt_hide_context_menu = ['mousemove', 'mouseout', 'mouseover'];

	  window.context_menu = {};

	  if (typeof(options.el) === 'string' || typeof(options.div) === 'string') {
		this.el = getElementById(options.el || options.div, options.context);
	  } else {
		this.el = options.el || options.div;
	  };

	  if (typeof(this.el) === 'undefined' || this.el === null) {
		throw 'No element defined.';
	  }

	  this.el.style.width = options.width || this.el.scrollWidth || this.el.offsetWidth;
	  this.el.style.height = options.height || this.el.scrollHeight || this.el.offsetHeight;

	  this.controls = [];
	  this.overlays = [];
	  this.layers = []; // array with kml and ft layers, can be as many
	  this.singleLayers = {}; // object with the other layers, only one per layer
	  this.markers = [];
	  this.polylines = [];
	  this.routes = [];
	  this.polygons = [];
	  this.infoWindow = null;
	  this.overlay_el = null;
	  this.zoom = options.zoom || 15;
	  this.registered_events = {};

	  var markerClusterer = options.markerClusterer;

	  //'Hybrid', 'Roadmap', 'Satellite' or 'Terrain'
	  var mapType;

	  if (options.mapType) {
		mapType = google.maps.MapTypeId[options.mapType.toUpperCase()];
	  }
	  else {
		mapType = google.maps.MapTypeId.ROADMAP;
	  }

	  var map_center = new google.maps.LatLng(options.lat, options.lng);

	  delete options.el;
	  delete options.lat;
	  delete options.lng;
	  delete options.mapType;
	  delete options.width;
	  delete options.height;
	  delete options.markerClusterer;

	  var zoomControlOpt = options.zoomControlOpt || {
		style: 'DEFAULT',
		position: 'TOP_LEFT'
	  };

	  var zoomControl = options.zoomControl || true,
		  zoomControlStyle = zoomControlOpt.style || 'DEFAULT',
		  zoomControlPosition = zoomControlOpt.position || 'TOP_LEFT',
		  panControl = options.panControl || true,
		  mapTypeControl = options.mapTypeControl || true,
		  scaleControl = options.scaleControl || true,
		  streetViewControl = options.streetViewControl || true,
		  overviewMapControl = overviewMapControl || true;

	  var map_options = {};

	  var map_base_options = {
		zoom: this.zoom,
		center: map_center,
		mapTypeId: mapType
	  };

	  var map_controls_options = {
		panControl: panControl,
		zoomControl: zoomControl,
		zoomControlOptions: {
		  style: google.maps.ZoomControlStyle[zoomControlStyle], // DEFAULT LARGE SMALL
		  position: google.maps.ControlPosition[zoomControlPosition]
		},
		mapTypeControl: mapTypeControl,
		scaleControl: scaleControl,
		streetViewControl: streetViewControl,
		overviewMapControl: overviewMapControl
	  }

	  if(options.disableDefaultUI != true)
		map_base_options = extend_object(map_base_options, map_controls_options);

	  map_options = extend_object(map_base_options, options);

	  for(var i = 0; i < events_that_hide_context_menu.length; i++) {
		delete map_options[events_that_hide_context_menu[i]];
	  }

	  for(var i = 0; i < events_that_doesnt_hide_context_menu.length; i++) {
		delete map_options[events_that_doesnt_hide_context_menu[i]];
	  }

	  this.map = new google.maps.Map(this.el, map_options);

	  if(markerClusterer) {
		this.markerClusterer = markerClusterer.apply(this, [this.map]);
	  }

	  // finds absolute position of an element
	  var findAbsolutePosition = function(obj)  {
		var curleft = 0;
		var curtop = 0;
		if (obj.offsetParent) {
		  do {
			curleft += obj.offsetLeft;
			curtop += obj.offsetTop;
		  } while (obj = obj.offsetParent);
		}
		return [curleft,curtop];
	  //returns an array
	  }


	  // Context menus
	  var buildContextMenuHTML = function(control, e) {
		var html = '';
		var options = window.context_menu[control];
		for (var i in options){
		  if (options.hasOwnProperty(i)){
			var option = options[i];
			html += '<li><a id="' + control + '_' + i + '" href="#">' +
			  option.title + '</a></li>';
		  }
		}

		if(!getElementById('gmaps_context_menu')) return;

		var context_menu_element = getElementById('gmaps_context_menu');
		context_menu_element.innerHTML = html;

		var context_menu_items = context_menu_element.getElementsByTagName('a');

		var context_menu_items_count = context_menu_items.length;

		for(var i = 0; i < context_menu_items_count; i++){
		  var context_menu_item = context_menu_items[i];

		  var assign_menu_item_action = function(ev){
			ev.preventDefault();

			options[this.id.replace(control + '_', '')].action.apply(self, [e]);
			self.hideContextMenu();
		  };

		  google.maps.event.clearListeners(context_menu_item, 'click');
		  google.maps.event.addDomListenerOnce(context_menu_item, 'click', assign_menu_item_action, false);
		}

		var position = findAbsolutePosition.apply(this, [self.el]);
		var left = position[0] + e.pixel.x - 15;
		var top = position[1] + e.pixel.y- 15;

		context_menu_element.style.left = left + "px";
		context_menu_element.style.top = top + "px";

		context_menu_element.style.display = 'block';
	  };

	  var buildContextMenu = function(control, e) {
		if (control === 'marker') {
		  e.pixel = {};
		  var overlay = new google.maps.OverlayView();
		  overlay.setMap(self.map);
		  overlay.draw = function() {
			var projection = overlay.getProjection();
			var position = e.marker.getPosition();
			e.pixel = projection.fromLatLngToContainerPixel(position);

			buildContextMenuHTML(control, e);
		  };
		}
		else {
		  buildContextMenuHTML(control, e);
		}
	  };

	  this.setContextMenu = function(options) {
		window.context_menu[options.control] = {};

		for (var i in options.options){
		  if (options.options.hasOwnProperty(i)){
			var option = options.options[i];
			window.context_menu[options.control][option.name] = {
			  title: option.title,
			  action: option.action
			};
		  }
		}

		var ul = doc.createElement('ul');

		ul.id = 'gmaps_context_menu';
		ul.style.display = 'none';
		ul.style.position = 'absolute';
		ul.style.minWidth = '100px';
		ul.style.background = 'white';
		ul.style.listStyle = 'none';
		ul.style.padding = '8px';
		ul.style.boxShadow = '2px 2px 6px #ccc';

		doc.body.appendChild(ul);

		var context_menu_element = getElementById('gmaps_context_menu');

		google.maps.event.addDomListener(context_menu_element, 'mouseout', function(ev) {
		  if(!ev.relatedTarget || !this.contains(ev.relatedTarget)){
			window.setTimeout(function(){
			  context_menu_element.style.display = 'none';
			}, 400);
		  }
		}, false);
	  };

	  this.hideContextMenu = function() {
		var context_menu_element = getElementById('gmaps_context_menu');
		if(context_menu_element)
		  context_menu_element.style.display = 'none';
	  };

	  //Events

	  var setupListener = function(object, name) {
		google.maps.event.addListener(object, name, function(e){
		  if(e == undefined) {
			e = this;
		  }

		  options[name].apply(this, [e]);

		  self.hideContextMenu();
		});
	  }

	  for (var ev = 0; ev < events_that_hide_context_menu.length; ev++) {
		var name = events_that_hide_context_menu[ev];

		if (name in options) {
		  setupListener(this.map, name);
		}
	  }

	  for (var ev = 0; ev < events_that_doesnt_hide_context_menu.length; ev++) {
		var name = events_that_doesnt_hide_context_menu[ev];

		if (name in options) {
		  setupListener(this.map, name);
		}
	  }

	  google.maps.event.addListener(this.map, 'rightclick', function(e) {
		if (options.rightclick) {
		  options.rightclick.apply(this, [e]);
		}

		if(window.context_menu['map'] != undefined) {
		  buildContextMenu('map', e);
		}
	  });

	  this.refresh = function() {
		google.maps.event.trigger(this.map, 'resize');
	  };

	  this.fitZoom = function() {
		var latLngs = [];
		var markers_length = this.markers.length;

		for(var i=0; i < markers_length; i++) {
		  latLngs.push(this.markers[i].getPosition());
		}

		this.fitLatLngBounds(latLngs);
	  };

	  this.fitLatLngBounds = function(latLngs) {
		var total = latLngs.length;
		var bounds = new google.maps.LatLngBounds();

		for(var i=0; i < total; i++) {
		  bounds.extend(latLngs[i]);
		}

		this.map.fitBounds(bounds);
	  };

	  // Map methods
	  this.setCenter = function(lat, lng, callback) {
		this.map.panTo(new google.maps.LatLng(lat, lng));
		if (callback) {
		  callback();
		}
	  };

	  this.getElement = function() {
		return this.el;
	  };

	  this.zoomIn = function(value) {
		value = value || 1;
		this.zoom = this.map.getZoom() + value;
		this.map.setZoom(this.zoom);
	  };

	  this.zoomOut = function(value) {
		value = value || 1;
		this.zoom = this.map.getZoom() - value;
		this.map.setZoom(this.zoom);
	  };

	  var native_methods = [];

	  for(var method in this.map){
		if(typeof(this.map[method]) == 'function' && !this[method]){
		  native_methods.push(method);
		}
	  }

	  for(var i=0; i < native_methods.length; i++){
		(function(gmaps, scope, method_name) {
		  gmaps[method_name] = function(){
			return scope[method_name].apply(scope, arguments);
		  };
		})(this, this.map, native_methods[i]);
	  }

	  this.createControl = function(options) {
		var control = doc.createElement('div');

		control.style.cursor = 'pointer';
		control.style.fontFamily = 'Arial, sans-serif';
		control.style.fontSize = '13px';
		control.style.boxShadow = 'rgba(0, 0, 0, 0.398438) 0px 2px 4px';

		for(var option in options.style)
		  control.style[option] = options.style[option];

		if(options.id) {
		  control.id = options.id;
		}

		if(options.classes) {
		  control.className = options.classes;
		}

		if(options.content) {
		  control.innerHTML = options.content;
		}

		for (var ev in options.events) {
		  (function(object, name) {
			google.maps.event.addDomListener(object, name, function(){
			  options.events[name].apply(this, [this]);
			});
		  })(control, ev);
		}

		control.index = 1;

		return control;
	  };

	  this.addControl = function(options) {
		var position = google.maps.ControlPosition[options.position.toUpperCase()];

		delete options.position;

		var control = this.createControl(options);
		this.controls.push(control);
		this.map.controls[position].push(control);

		return control;
	  };

	  // Markers
	  this.createMarker = function(options) {
		if ((options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) || options.position) {
		  var self = this;
		  var details = options.details;
		  var fences = options.fences;
		  var outside = options.outside;

		  var base_options = {
			position: new google.maps.LatLng(options.lat, options.lng),
			map: null
		  };

		  delete options.lat;
		  delete options.lng;
		  delete options.fences;
		  delete options.outside;

		  var marker_options = extend_object(base_options, options);

		  var marker = new google.maps.Marker(marker_options);

		  marker.fences = fences;

		  if (options.infoWindow) {
			marker.infoWindow = new google.maps.InfoWindow(options.infoWindow);

			var info_window_events = ['closeclick', 'content_changed', 'domready', 'position_changed', 'zindex_changed'];

			for (var ev = 0; ev < info_window_events.length; ev++) {
			  (function(object, name) {
				if (options.infoWindow[name]) {
				  google.maps.event.addListener(object, name, function(e){
					options.infoWindow[name].apply(this, [e]);
				  });
				}
			  })(marker.infoWindow, info_window_events[ev]);
			}
		  }

		  var marker_events = ['animation_changed', 'clickable_changed', 'cursor_changed', 'draggable_changed', 'flat_changed', 'icon_changed', 'position_changed', 'shadow_changed', 'shape_changed', 'title_changed', 'visible_changed', 'zindex_changed'];

		  var marker_events_with_mouse = ['dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];

		  for (var ev = 0; ev < marker_events.length; ev++) {
			(function(object, name) {
			  if (options[name]) {
				google.maps.event.addListener(object, name, function(){
				  options[name].apply(this, [this]);
				});
			  }
			})(marker, marker_events[ev]);
		  }

		  for (var ev = 0; ev < marker_events_with_mouse.length; ev++) {
			(function(map, object, name) {
			  if (options[name]) {
				google.maps.event.addListener(object, name, function(me){
				  if(!me.pixel){
					me.pixel = map.getProjection().fromLatLngToPoint(me.latLng)
				  }

				  options[name].apply(this, [me]);
				});
			  }
			})(this.map, marker, marker_events_with_mouse[ev]);
		  }

		  google.maps.event.addListener(marker, 'click', function() {
			this.details = details;

			if (options.click) {
			  options.click.apply(this, [this]);
			}

			if (marker.infoWindow) {
			  self.hideInfoWindows();
			  marker.infoWindow.open(self.map, marker);
			}
		  });

		  google.maps.event.addListener(marker, 'rightclick', function(e) {
			e.marker = this;

			if (options.rightclick) {
			  options.rightclick.apply(this, [e]);
			}

			if (window.context_menu['marker'] != undefined) {
			  buildContextMenu('marker', e);
			}
		  });

		  if (marker.fences) {
			google.maps.event.addListener(marker, 'dragend', function() {
			  self.checkMarkerGeofence(marker, function(m, f) {
				outside(m, f);
			  });
			});
		  }

		  return marker;
		}
		else {
		  throw 'No latitude or longitude defined.';
		}
	  };

	  this.addMarker = function(options) {
		var marker;
		if(options.hasOwnProperty('gm_accessors_')) {
		  // Native google.maps.Marker object
		  marker = options;
		}
		else {
		  if ((options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) || options.position) {
			marker = this.createMarker(options);
		  }
		  else {
			throw 'No latitude or longitude defined.';
		  }
		}

		marker.setMap(this.map);

		if(this.markerClusterer) {
		  this.markerClusterer.addMarker(marker);
		}

		this.markers.push(marker);

		GMaps.fire('marker_added', marker, this);

		return marker;
	  };

	  this.addMarkers = function(array) {
		for (var i=0, marker; marker=array[i]; i++) {
		  this.addMarker(marker);
		}
		return this.markers;
	  };

	  this.hideInfoWindows = function() {
		for (var i=0, marker; marker=this.markers[i]; i++){
		  if (marker.infoWindow){
			marker.infoWindow.close();
		  }
		}
	  };

	  this.removeMarker = function(marker) {
		for(var i = 0; i < this.markers.length; i++) {
		  if(this.markers[i] === marker) {
			this.markers[i].setMap(null);
			this.markers.splice(i, 1);

			GMaps.fire('marker_removed', marker, this);

			break;
		  }
		}

		return marker;
	  };

	  this.removeMarkers = function(collection) {
		var collection = (collection || this.markers);

		for(var i=0;i < this.markers.length; i++){
		  if(this.markers[i] === collection[i])
			this.markers[i].setMap(null);
		}

		var new_markers = [];

		for(var i=0;i < this.markers.length; i++){
		  if(this.markers[i].getMap() != null)
			new_markers.push(this.markers[i]);
		}

		this.markers = new_markers;
	  };

	  // Overlays

	  this.drawOverlay = function(options) {
		var overlay = new google.maps.OverlayView();
		overlay.setMap(self.map);

		var auto_show = true;

		if(options.auto_show != null)
		  auto_show = options.auto_show;

		overlay.onAdd = function() {
		  var el = doc.createElement('div');
		  el.style.borderStyle = "none";
		  el.style.borderWidth = "0px";
		  el.style.position = "absolute";
		  el.style.zIndex = 100;
		  el.innerHTML = options.content;

		  overlay.el = el;

		  var panes = this.getPanes();
		  if (!options.layer) {
			options.layer = 'overlayLayer';
		  }
		  var overlayLayer = panes[options.layer];
		  overlayLayer.appendChild(el);

		  var stop_overlay_events = ['contextmenu', 'DOMMouseScroll', 'dblclick', 'mousedown'];

		  for (var ev = 0; ev < stop_overlay_events.length; ev++) {
			(function(object, name) {
			  google.maps.event.addDomListener(object, name, function(e){
				if(navigator.userAgent.toLowerCase().indexOf('msie') != -1 && document.all) {
				  e.cancelBubble = true;
				  e.returnValue = false;
				}
				else {
				  e.stopPropagation();
				}
			  });
			})(el, stop_overlay_events[ev]);
		  }

		  google.maps.event.trigger(this, 'ready');
		};

		overlay.draw = function() {
		  var projection = this.getProjection();
		  var pixel = projection.fromLatLngToDivPixel(new google.maps.LatLng(options.lat, options.lng));

		  options.horizontalOffset = options.horizontalOffset || 0;
		  options.verticalOffset = options.verticalOffset || 0;

		  var el = overlay.el;
		  var content = el.children[0];

		  var content_height = content.clientHeight;
		  var content_width = content.clientWidth;

		  switch (options.verticalAlign) {
			case 'top':
			  el.style.top = (pixel.y - content_height + options.verticalOffset) + 'px';
			  break;
			default:
			case 'middle':
			  el.style.top = (pixel.y - (content_height / 2) + options.verticalOffset) + 'px';
			  break;
			case 'bottom':
			  el.style.top = (pixel.y + options.verticalOffset) + 'px';
			  break;
		  }

		  switch (options.horizontalAlign) {
			case 'left':
			  el.style.left = (pixel.x - content_width + options.horizontalOffset) + 'px';
			  break;
			default:
			case 'center':
			  el.style.left = (pixel.x - (content_width / 2) + options.horizontalOffset) + 'px';
			  break;
			case 'right':
			  el.style.left = (pixel.x + options.horizontalOffset) + 'px';
			  break;
		  }

		  el.style.display = auto_show ? 'block' : 'none';

		  if(!auto_show){
			options.show.apply(this, [el]);
		  }
		};

		overlay.onRemove = function() {
		  var el = overlay.el;

		  if(options.remove){
			options.remove.apply(this, [el]);
		  }
		  else {
			overlay.el.parentNode.removeChild(overlay.el);
			overlay.el = null;
		  }
		};

		self.overlays.push(overlay);
		return overlay;
	  };

	  this.removeOverlay = function(overlay) {
		for(var i = 0; i < this.overlays.length; i++) {
		  if(this.overlays[i] === overlay) {
			this.overlays[i].setMap(null);
			this.overlays.splice(i, 1);

			break;
		  }
		}
	  };

	  this.removeOverlays = function() {
		for (var i=0, item; item=self.overlays[i]; i++){
		  item.setMap(null);
		}
		self.overlays = [];
	  };

	  // Geometry

	  this.drawPolyline = function(options) {
		var path = [];
		var points = options.path;

		if (points.length){
		  if (points[0][0] === undefined){
			path = points;
		  }
		  else {
			for (var i=0, latlng; latlng=points[i]; i++){
			  path.push(new google.maps.LatLng(latlng[0], latlng[1]));
			}
		  }
		}

		var polyline_options = {
		  map: this.map,
		  path: path,
		  strokeColor: options.strokeColor,
		  strokeOpacity: options.strokeOpacity,
		  strokeWeight: options.strokeWeight,
		  geodesic: options.geodesic,
		  clickable: true,
		  editable: false,
		  visible: true
		};

		if(options.hasOwnProperty("clickable"))
		  polyline_options.clickable = options.clickable;

		if(options.hasOwnProperty("editable"))
		  polyline_options.editable = options.editable;

		if(options.hasOwnProperty("icons"))
		  polyline_options.icons = options.icons;

		if(options.hasOwnProperty("zIndex"))
		  polyline_options.zIndex = options.zIndex;

		var polyline = new google.maps.Polyline(polyline_options);

		var polyline_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

		for (var ev = 0; ev < polyline_events.length; ev++) {
		  (function(object, name) {
			if (options[name]) {
			  google.maps.event.addListener(object, name, function(e){
				options[name].apply(this, [e]);
			  });
			}
		  })(polyline, polyline_events[ev]);
		}

		this.polylines.push(polyline);

		GMaps.fire('polyline_added', polyline, this);

		return polyline;
	  };

	  this.removePolyline = function(polyline) {
		for(var i = 0; i < this.polylines.length; i++) {
		  if(this.polylines[i] === polyline) {
			this.polylines[i].setMap(null);
			this.polylines.splice(i, 1);

			GMaps.fire('polyline_removed', polyline, this);

			break;
		  }
		}
	  };

	  this.removePolylines = function() {
		for (var i=0, item; item=self.polylines[i]; i++){
		  item.setMap(null);
		}
		self.polylines = [];
	  };

	  this.drawCircle = function(options) {
		options =  extend_object({
		  map: this.map,
		  center: new google.maps.LatLng(options.lat, options.lng)
		}, options);

		delete options.lat;
		delete options.lng;
		var polygon = new google.maps.Circle(options);

		var polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

		for (var ev = 0; ev < polygon_events.length; ev++) {
		  (function(object, name) {
			if (options[name]) {
			  google.maps.event.addListener(object, name, function(e){
				options[name].apply(this, [e]);
			  });
			}
		  })(polygon, polygon_events[ev]);
		}

		this.polygons.push(polygon);

		return polygon;
	  };

	  this.drawRectangle = function(options) {
		options = extend_object({
		  map: this.map
		}, options);

		var latLngBounds = new google.maps.LatLngBounds(
		  new google.maps.LatLng(options.bounds[0][0], options.bounds[0][1]),
		  new google.maps.LatLng(options.bounds[1][0], options.bounds[1][1])
		);

		options.bounds = latLngBounds;

		var polygon = new google.maps.Rectangle(options);

		var polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

		for (var ev = 0; ev < polygon_events.length; ev++) {
		  (function(object, name) {
			if (options[name]) {
			  google.maps.event.addListener(object, name, function(e){
				options[name].apply(this, [e]);
			  });
			}
		  })(polygon, polygon_events[ev]);
		}

		this.polygons.push(polygon);

		return polygon;
	  };

	  this.drawPolygon = function(options) {
		var useGeoJSON = false;
		if(options.hasOwnProperty("useGeoJSON"))
		  useGeoJSON = options.useGeoJSON;

		delete options.useGeoJSON;

		options = extend_object({
		  map: this.map
		}, options);

		if(useGeoJSON == false)
		  options.paths = [options.paths.slice(0)];

		if(options.paths.length > 0) {
		  if(options.paths[0].length > 0) {
			options.paths = array_flat(array_map(options.paths, arrayToLatLng, useGeoJSON));
		  }
		}

		var polygon = new google.maps.Polygon(options);

		var polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

		for (var ev = 0; ev < polygon_events.length; ev++) {
		  (function(object, name) {
			if (options[name]) {
			  google.maps.event.addListener(object, name, function(e){
				options[name].apply(this, [e]);
			  });
			}
		  })(polygon, polygon_events[ev]);
		}

		this.polygons.push(polygon);

		GMaps.fire('polygon_added', polygon, this);

		return polygon;
	  };

	  this.removePolygon = function(polygon) {
		for(var i = 0; i < this.polygons.length; i++) {
		  if(this.polygons[i] === polygon) {
			this.polygons[i].setMap(null);
			this.polygons.splice(i, 1);

			GMaps.fire('polygon_removed', polygon, this);

			break;
		  }
		}
	  };

	  this.removePolygons = function() {
		for (var i=0, item; item=self.polygons[i]; i++){
		  item.setMap(null);
		}
		self.polygons = [];
	  };

	  // Fusion Tables

	  this.getFromFusionTables = function(options) {
		var events = options.events;

		delete options.events;

		var fusion_tables_options = options;

		var layer = new google.maps.FusionTablesLayer(fusion_tables_options);

		for (var ev in events) {
		  (function(object, name) {
			google.maps.event.addListener(object, name, function(e){
			  events[name].apply(this, [e]);
			});
		  })(layer, ev);
		}

		this.layers.push(layer);

		return layer;
	  };

	  this.loadFromFusionTables = function(options) {
		var layer = this.getFromFusionTables(options);
		layer.setMap(this.map);

		return layer;
	  };

	  // KML

	  this.getFromKML = function(options) {
		var url = options.url;
		var events = options.events;

		delete options.url;
		delete options.events;

		var kml_options = options;

		var layer = new google.maps.KmlLayer(url, kml_options);

		for (var ev in events) {
		  (function(object, name) {
			google.maps.event.addListener(object, name, function(e){
			  events[name].apply(this, [e]);
			});
		  })(layer, ev);
		}

		this.layers.push(layer);

		return layer;
	  };

	  this.loadFromKML = function(options) {
		var layer = this.getFromKML(options);
		layer.setMap(this.map);

		return layer;
	  };

	  // Routes

	  var travelMode, unitSystem;
	  this.getRoutes = function(options) {
		switch (options.travelMode) {
		case 'bicycling':
		  travelMode = google.maps.TravelMode.BICYCLING;
		  break;
		case 'transit':
		  travelMode = google.maps.TravelMode.TRANSIT;
		  break;
		case 'driving':
		  travelMode = google.maps.TravelMode.DRIVING;
		  break;
		// case 'walking':
		default:
		  travelMode = google.maps.TravelMode.WALKING;
		  break;
		}

		if (options.unitSystem === 'imperial') {
		  unitSystem = google.maps.UnitSystem.IMPERIAL;
		}
		else {
		  unitSystem = google.maps.UnitSystem.METRIC;
		}

		var base_options = {
		  avoidHighways: false,
		  avoidTolls: false,
		  optimizeWaypoints: false,
		  waypoints: []
		};

		var request_options =  extend_object(base_options, options);

		request_options.origin = /string/.test(typeof options.origin) ? options.origin : new google.maps.LatLng(options.origin[0], options.origin[1]);
		request_options.destination = new google.maps.LatLng(options.destination[0], options.destination[1]);
		request_options.travelMode = travelMode;
		request_options.unitSystem = unitSystem;

		delete request_options.callback;

		var self = this;
		var service = new google.maps.DirectionsService();

		service.route(request_options, function(result, status) {
		  if (status === google.maps.DirectionsStatus.OK) {
			for (var r in result.routes) {
			  if (result.routes.hasOwnProperty(r)) {
				self.routes.push(result.routes[r]);
			  }
			}
		  }
		  if (options.callback) {
			options.callback(self.routes);
		  }
		});
	  };

	  this.removeRoutes = function() {
		this.routes = [];
	  };

	  this.getElevations = function(options) {
		options = extend_object({
		  locations: [],
		  path : false,
		  samples : 256
		}, options);

		if(options.locations.length > 0) {
		  if(options.locations[0].length > 0) {
			options.locations = array_flat(array_map([options.locations], arrayToLatLng,  false));
		  }
		}

		var callback = options.callback;
		delete options.callback;

		var service = new google.maps.ElevationService();

		//location request
		if (!options.path) {
		  delete options.path;
		  delete options.samples;
		  service.getElevationForLocations(options, function(result, status){
			if (callback && typeof(callback) === "function") {
			  callback(result, status);
			}
		  });
		//path request
		} else {
		  var pathRequest = {
			path : options.locations,
			samples : options.samples
		  };

		  service.getElevationAlongPath(pathRequest, function(result, status){
		   if (callback && typeof(callback) === "function") {
			  callback(result, status);
			}
		  });
		}
	  };

	  // Alias for the method "drawRoute"
	  this.cleanRoute = this.removePolylines;

	  this.drawRoute = function(options) {
		var self = this;
		this.getRoutes({
		  origin: options.origin,
		  destination: options.destination,
		  travelMode: options.travelMode,
		  waypoints: options.waypoints,
		  unitSystem: options.unitSystem,
		  callback: function(e) {
			if (e.length > 0) {
			  self.drawPolyline({
				path: e[e.length - 1].overview_path,
				strokeColor: options.strokeColor,
				strokeOpacity: options.strokeOpacity,
				strokeWeight: options.strokeWeight
			  });
			  if (options.callback) {
				options.callback(e[e.length - 1]);
			  }
			}
		  }
		});
	  };

	  this.travelRoute = function(options) {
		if (options.origin && options.destination) {
		  this.getRoutes({
			origin: options.origin,
			destination: options.destination,
			travelMode: options.travelMode,
			waypoints : options.waypoints,
			callback: function(e) {
			  //start callback
			  if (e.length > 0 && options.start) {
				options.start(e[e.length - 1]);
			  }

			  //step callback
			  if (e.length > 0 && options.step) {
				var route = e[e.length - 1];
				if (route.legs.length > 0) {
				  var steps = route.legs[0].steps;
				  for (var i=0, step; step=steps[i]; i++) {
					step.step_number = i;
					options.step(step, (route.legs[0].steps.length - 1));
				  }
				}
			  }

			  //end callback
			  if (e.length > 0 && options.end) {
				 options.end(e[e.length - 1]);
			  }
			}
		  });
		}
		else if (options.route) {
		  if (options.route.legs.length > 0) {
			var steps = options.route.legs[0].steps;
			for (var i=0, step; step=steps[i]; i++) {
			  step.step_number = i;
			  options.step(step);
			}
		  }
		}
	  };

	  this.drawSteppedRoute = function(options) {
		if (options.origin && options.destination) {
		  this.getRoutes({
			origin: options.origin,
			destination: options.destination,
			travelMode: options.travelMode,
			waypoints : options.waypoints,
			callback: function(e) {
			  //start callback
			  if (e.length > 0 && options.start) {
				options.start(e[e.length - 1]);
			  }

			  //step callback
			  if (e.length > 0 && options.step) {
				var route = e[e.length - 1];
				if (route.legs.length > 0) {
				  var steps = route.legs[0].steps;
				  for (var i=0, step; step=steps[i]; i++) {
					step.step_number = i;
					self.drawPolyline({
					  path: step.path,
					  strokeColor: options.strokeColor,
					  strokeOpacity: options.strokeOpacity,
					  strokeWeight: options.strokeWeight
					});
					options.step(step, (route.legs[0].steps.length - 1));
				  }
				}
			  }

			  //end callback
			  if (e.length > 0 && options.end) {
				 options.end(e[e.length - 1]);
			  }
			}
		  });
		}
		else if (options.route) {
		  if (options.route.legs.length > 0) {
			var steps = options.route.legs[0].steps;
			for (var i=0, step; step=steps[i]; i++) {
			  step.step_number = i;
			  self.drawPolyline({
				path: step.path,
				strokeColor: options.strokeColor,
				strokeOpacity: options.strokeOpacity,
				strokeWeight: options.strokeWeight
			  });
			  options.step(step);
			}
		  }
		}
	  };

	  // Geofence

	  this.checkGeofence = function(lat, lng, fence) {
		return fence.containsLatLng(new google.maps.LatLng(lat, lng));
	  };

	  this.checkMarkerGeofence = function(marker, outside_callback) {
		if (marker.fences) {
		  for (var i=0, fence; fence=marker.fences[i]; i++) {
			var pos = marker.getPosition();
			if (!self.checkGeofence(pos.lat(), pos.lng(), fence)) {
			  outside_callback(marker, fence);
			}
		  }
		}
	  };

	  // Layers

	  this.addLayer = function(layerName, options) {
		//var default_layers = ['weather', 'clouds', 'traffic', 'transit', 'bicycling', 'panoramio', 'places'];
		options = options || {};
		var layer;

		switch(layerName) {
		  case 'weather': this.singleLayers.weather = layer = new google.maps.weather.WeatherLayer();
			break;
		  case 'clouds': this.singleLayers.clouds = layer = new google.maps.weather.CloudLayer();
			break;
		  case 'traffic': this.singleLayers.traffic = layer = new google.maps.TrafficLayer();
			break;
		  case 'transit': this.singleLayers.transit = layer = new google.maps.TransitLayer();
			break;
		  case 'bicycling': this.singleLayers.bicycling = layer = new google.maps.BicyclingLayer();
			break;
		  case 'panoramio':
			  this.singleLayers.panoramio = layer = new google.maps.panoramio.PanoramioLayer();
			  layer.setTag(options.filter);
			  delete options.filter;

			  //click event
			  if(options.click) {
				google.maps.event.addListener(layer, 'click', function(event) {
				  options.click(event);
				  delete options.click;
				});
			  }
			break;
			case 'places':
			  this.singleLayers.places = layer = new google.maps.places.PlacesService(this.map);

			  //search and  nearbySearch callback, Both are the same
			  if(options.search || options.nearbySearch) {
				var placeSearchRequest  = {
				  bounds : options.bounds || null,
				  keyword : options.keyword || null,
				  location : options.location || null,
				  name : options.name || null,
				  radius : options.radius || null,
				  rankBy : options.rankBy || null,
				  types : options.types || null
				};

				if(options.search) {
				  layer.search(placeSearchRequest, options.search);
				}

				if(options.nearbySearch) {
				  layer.nearbySearch(placeSearchRequest, options.nearbySearch);
				}
			  }

			  //textSearch callback
			  if(options.textSearch) {
				var textSearchRequest  = {
				  bounds : options.bounds || null,
				  location : options.location || null,
				  query : options.query || null,
				  radius : options.radius || null
				};

				layer.textSearch(textSearchRequest, options.textSearch);
			  }
			break;
		}

		if(layer !== undefined) {
		  if(typeof layer.setOptions == 'function') {
			layer.setOptions(options);
		  }
		  if(typeof layer.setMap == 'function') {
			layer.setMap(this.map);
		  }

		  return layer;
		}
	  };

	  this.removeLayer = function(layerName) {
		if(this.singleLayers[layerName] !== undefined) {
		   this.singleLayers[layerName].setMap(null);
		   delete this.singleLayers[layerName];
		}
	  };

	  // Static Maps

	  this.toImage = function(options) {
		var options = options || {};
		var static_map_options = {};
		static_map_options['size'] = options['size'] || [this.el.clientWidth, this.el.clientHeight];
		static_map_options['lat'] = this.getCenter().lat();
		static_map_options['lng'] = this.getCenter().lng();

		if(this.markers.length > 0) {
		  static_map_options['markers'] = [];
		  for(var i=0; i < this.markers.length; i++) {
			static_map_options['markers'].push({
			  lat: this.markers[i].getPosition().lat(),
			  lng: this.markers[i].getPosition().lng()
			});
		  }
		}

		if(this.polylines.length > 0) {
		  var polyline = this.polylines[0];
		  static_map_options['polyline'] = {};
		  static_map_options['polyline']['path'] = google.maps.geometry.encoding.encodePath(polyline.getPath());
		  static_map_options['polyline']['strokeColor'] = polyline.strokeColor
		  static_map_options['polyline']['strokeOpacity'] = polyline.strokeOpacity
		  static_map_options['polyline']['strokeWeight'] = polyline.strokeWeight
		}

		return GMaps.staticMapURL(static_map_options);
	  };

	  // Map Types

	  this.addMapType = function(mapTypeId, options) {
		if(options.hasOwnProperty("getTileUrl") && typeof(options["getTileUrl"]) == "function") {
		  options.tileSize = options.tileSize || new google.maps.Size(256, 256);

		  var mapType = new google.maps.ImageMapType(options);

		  this.map.mapTypes.set(mapTypeId, mapType);
		}
		else {
		  throw "'getTileUrl' function required.";
		}
	  };

	  this.addOverlayMapType = function(options) {
		if(options.hasOwnProperty("getTile") && typeof(options["getTile"]) == "function") {
		  var overlayMapTypeIndex = options.index;

		  delete options.index;

		  this.map.overlayMapTypes.insertAt(overlayMapTypeIndex, options);
		}
		else {
		  throw "'getTile' function required.";
		}
	  };

	  this.removeOverlayMapType = function(overlayMapTypeIndex) {
		this.map.overlayMapTypes.removeAt(overlayMapTypeIndex);
	  };

	  // Styles

	  this.addStyle = function(options) {
		var styledMapType = new google.maps.StyledMapType(options.styles, options.styledMapName);

		this.map.mapTypes.set(options.mapTypeId, styledMapType);
	  };

	  this.setStyle = function(mapTypeId) {
		this.map.setMapTypeId(mapTypeId);
	  };

	  // StreetView

	  this.createPanorama = function(streetview_options) {
		if (!streetview_options.hasOwnProperty('lat') || !streetview_options.hasOwnProperty('lng')) {
		  streetview_options.lat = this.getCenter().lat();
		  streetview_options.lng = this.getCenter().lng();
		}

		this.panorama = GMaps.createPanorama(streetview_options);

		this.map.setStreetView(this.panorama);

		return this.panorama;
	  };

	  // Events

	  this.on = function(event_name, handler) {
		return GMaps.on(event_name, this, handler);
	  };

	  this.off = function(event_name) {
		GMaps.off(event_name, this);
	  };
	};

	GMaps.createPanorama = function(options) {
	  var el = getElementById(options.el, options.context);

	  options.position = new google.maps.LatLng(options.lat, options.lng);

	  delete options.el;
	  delete options.context;
	  delete options.lat;
	  delete options.lng;

	  var streetview_events = ['closeclick', 'links_changed', 'pano_changed', 'position_changed', 'pov_changed', 'resize', 'visible_changed'];

	  var streetview_options = extend_object({visible : true}, options);

	  for(var i = 0; i < streetview_events.length; i++) {
		delete streetview_options[streetview_events[i]];
	  }

	  var panorama = new google.maps.StreetViewPanorama(el, streetview_options);

	  for(var i = 0; i < streetview_events.length; i++) {
		(function(object, name) {
		  if (options[name]) {
			google.maps.event.addListener(object, name, function(){
			  options[name].apply(this);
			});
		  }
		})(panorama, streetview_events[i]);
	  }

	  return panorama;
	};

	GMaps.Route = function(options) {
	  this.map = options.map;
	  this.route = options.route;
	  this.step_count = 0;
	  this.steps = this.route.legs[0].steps;
	  this.steps_length = this.steps.length;

	  this.polyline = this.map.drawPolyline({
		path: new google.maps.MVCArray(),
		strokeColor: options.strokeColor,
		strokeOpacity: options.strokeOpacity,
		strokeWeight: options.strokeWeight
	  }).getPath();

	  this.back = function() {
		if (this.step_count > 0) {
		  this.step_count--;
		  var path = this.route.legs[0].steps[this.step_count].path;
		  for (var p in path){
			if (path.hasOwnProperty(p)){
			  this.polyline.pop();
			}
		  }
		}
	  };

	  this.forward = function() {
		if (this.step_count < this.steps_length) {
		  var path = this.route.legs[0].steps[this.step_count].path;
		  for (var p in path){
			if (path.hasOwnProperty(p)){
			  this.polyline.push(path[p]);
			}
		  }
		  this.step_count++;
		}
	  };
	};

	// Geolocation (Modern browsers only)

	GMaps.geolocate = function(options) {
	  var complete_callback = options.always || options.complete;

	  if (navigator.geolocation) {
		navigator.geolocation.getCurrentPosition(function(position) {
		  options.success(position);

		  if (complete_callback) {
			complete_callback();
		  }
		}, function(error) {
		  options.error(error);

		  if (complete_callback) {
			complete_callback();
		  }
		}, options.options);
	  }
	  else {
		options.not_supported();

		if (complete_callback) {
		  complete_callback();
		}
	  }
	};

	// Geocoding

	GMaps.geocode = function(options) {
	  this.geocoder = new google.maps.Geocoder();
	  var callback = options.callback;
	  if (options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) {
		options.latLng = new google.maps.LatLng(options.lat, options.lng);
	  }

	  delete options.lat;
	  delete options.lng;
	  delete options.callback;
	  this.geocoder.geocode(options, function(results, status) {
		callback(results, status);
	  });
	};

	// Static maps

	GMaps.staticMapURL = function(options){
	  var parameters = [];
	  var data;

	  var static_root = 'https://maps.googleapis.com/maps/api/staticmap';
	  if (options.url){
		static_root = options.url;
		delete options.url;
	  }
	  static_root += '?';

	  var markers = options.markers;
	  delete options.markers;
	  if (!markers && options.marker){
		markers = [options.marker];
		delete options.marker;
	  }

	  var polyline = options.polyline;
	  delete options.polyline;

	  // Retrieve API key
	  var apiKey = window.es.gmapsApiKey;

	  if (apiKey) {
		parameters.push('key=' + apiKey);
	  }

	  // Retrieve language
	  var language = window.es.locationLanguage;

	  if (language) {
		parameters.push('language=' + language)
	  }

	  /** Map options **/
	  if (options.center){
		parameters.push('center=' + options.center);
		delete options.center;
	  }
	  else if (options.address){
		parameters.push('center=' + options.address);
		delete options.address;
	  }
	  else if (options.lat){
		parameters.push(['center=', options.lat, ',', options.lng].join(''));
		delete options.lat;
		delete options.lng;
	  }
	  else if (options.visible){
		var visible = encodeURI(options.visible.join('|'));
		parameters.push('visible=' + visible);
	  }

	  var size = options.size;
	  if (size){
		if (size.join){
		  size = size.join('x');
		}
		delete options.size;
	  }
	  else {
		size = '630x300';
	  }
	  parameters.push('size=' + size);

	  if (!options.zoom){
		options.zoom = 15;
	  }

	  var sensor = options.hasOwnProperty('sensor') ? !!options.sensor : true;
	  delete options.sensor;
	  parameters.push('sensor=' + sensor);

	  for (var param in options){
		if (options.hasOwnProperty(param)){
		  parameters.push(param + '=' + options[param]);
		}
	  }

	  /** Markers **/
	  if (markers){
		var marker, loc;

		for (var i=0; data=markers[i]; i++){
		  marker = [];

		  if (data.size && data.size !== 'normal'){
			marker.push('size:' + data.size);
		  }
		  else if (data.icon){
			marker.push('icon:' + encodeURI(data.icon));
		  }

		  if (data.color){
			marker.push('color:' + data.color.replace('#', '0x'));
		  }

		  if (data.label){
			marker.push('label:' + data.label[0].toUpperCase());
		  }

		  loc = (data.address ? data.address : data.lat + ',' + data.lng);

		  if (marker.length || i === 0){
			marker.push(loc);
			marker = marker.join('|');
			parameters.push('markers=' + encodeURI(marker));
		  }
		  // New marker without styles
		  else {
			marker = parameters.pop() + encodeURI('|' + loc);
			parameters.push(marker);
		  }
		}
	  }

	  /** Polylines **/
	  function parseColor(color, opacity){
		if (color[0] === '#'){
		  color = color.replace('#', '0x');

		  if (opacity){
			opacity = parseFloat(opacity);
			opacity = Math.min(1, Math.max(opacity, 0));
			if (opacity === 0){
			  return '0x00000000';
			}
			opacity = (opacity * 255).toString(16);
			if (opacity.length === 1){
			  opacity += opacity;
			}

			color = color.slice(0,8) + opacity;
		  }
		}
		return color;
	  }

	  if (polyline){
		data = polyline;
		polyline = [];

		if (data.strokeWeight){
		  polyline.push('weight:' + parseInt(data.strokeWeight, 10));
		}

		if (data.strokeColor){
		  var color = parseColor(data.strokeColor, data.strokeOpacity);
		  polyline.push('color:' + color);
		}

		if (data.fillColor){
		  var fillcolor = parseColor(data.fillColor, data.fillOpacity);
		  polyline.push('fillcolor:' + fillcolor);
		}

		var path = data.path;
		if (path.join){
		  for (var j=0, pos; pos=path[j]; j++){
			polyline.push(pos.join(','));
		  }
		}
		else {
		  polyline.push('enc:' + path);
		}

		polyline = polyline.join('|');
		parameters.push('path=' + encodeURI(polyline));
	  }

	  parameters = parameters.join('&');
	  return static_root + parameters;
	};

	// Events

	GMaps.custom_events = ['marker_added', 'marker_removed', 'polyline_added', 'polyline_removed', 'polygon_added', 'polygon_removed', 'geolocated', 'geolocation_failed'];

	GMaps.on = function(event_name, object, handler) {
	  if (GMaps.custom_events.indexOf(event_name) == -1) {
		return google.maps.event.addListener(object, event_name, handler);
	  }
	  else {
		var registered_event = {
		  handler : handler,
		  eventName : event_name
		};

		object.registered_events[event_name] = object.registered_events[event_name] || [];
		object.registered_events[event_name].push(registered_event);

		return registered_event;
	  }
	};

	GMaps.off = function(event_name, object) {
	  if (GMaps.custom_events.indexOf(event_name) == -1) {
		google.maps.event.clearListeners(object, event_name);
	  }
	  else {
		object.registered_events[event_name] = [];
	  }
	};

	GMaps.fire = function(event_name, object, scope) {
	  if (GMaps.custom_events.indexOf(event_name) == -1) {
		google.maps.event.trigger(object, event_name, Array.prototype.slice.apply(arguments).slice(2));
	  }
	  else {
		if(event_name in scope.registered_events) {
		  var firing_events = scope.registered_events[event_name];

		  for(var i = 0; i < firing_events.length; i++) {
			(function(handler, scope, object) {
			  handler.apply(scope, [object]);
			})(firing_events[i]['handler'], scope, object);
		  }
		}
	  }
	};

	//==========================
	// Polygon containsLatLng
	// https://github.com/tparkin/Google-Maps-Point-in-Polygon
	// Poygon getBounds extension - google-maps-extensions
	// http://code.google.com/p/google-maps-extensions/source/browse/google.maps.Polygon.getBounds.js
	if (!google.maps.Polygon.prototype.getBounds) {
	  google.maps.Polygon.prototype.getBounds = function(latLng) {
		var bounds = new google.maps.LatLngBounds();
		var paths = this.getPaths();
		var path;

		for (var p = 0; p < paths.getLength(); p++) {
		  path = paths.getAt(p);
		  for (var i = 0; i < path.getLength(); i++) {
			bounds.extend(path.getAt(i));
		  }
		}

		return bounds;
	  };
	}

	if (!google.maps.Polygon.prototype.containsLatLng) {
	  // Polygon containsLatLng - method to determine if a latLng is within a polygon
	  google.maps.Polygon.prototype.containsLatLng = function(latLng) {
		// Exclude points outside of bounds as there is no way they are in the poly
		var bounds = this.getBounds();

		if (bounds !== null && !bounds.contains(latLng)) {
		  return false;
		}

		// Raycast point in polygon method
		var inPoly = false;

		var numPaths = this.getPaths().getLength();
		for (var p = 0; p < numPaths; p++) {
		  var path = this.getPaths().getAt(p);
		  var numPoints = path.getLength();
		  var j = numPoints - 1;

		  for (var i = 0; i < numPoints; i++) {
			var vertex1 = path.getAt(i);
			var vertex2 = path.getAt(j);

			if (vertex1.lng() < latLng.lng() && vertex2.lng() >= latLng.lng() || vertex2.lng() < latLng.lng() && vertex1.lng() >= latLng.lng()) {
			  if (vertex1.lat() + (latLng.lng() - vertex1.lng()) / (vertex2.lng() - vertex1.lng()) * (vertex2.lat() - vertex1.lat()) < latLng.lat()) {
				inPoly = !inPoly;
			  }
			}

			j = i;
		  }
		}

		return inPoly;
	  };
	}

	google.maps.LatLngBounds.prototype.containsLatLng = function(latLng) {
	  return this.contains(latLng);
	};

	google.maps.Marker.prototype.setFences = function(fences) {
	  this.fences = fences;
	};

	google.maps.Marker.prototype.addFence = function(fence) {
	  this.fences.push(fence);
	};

	return GMaps;
  }(this));

  var coordsToLatLngs = function(coords, useGeoJSON) {
	var first_coord = coords[0];
	var second_coord = coords[1];

	if(useGeoJSON) {
	  first_coord = coords[1];
	  second_coord = coords[0];
	}

	return new google.maps.LatLng(first_coord, second_coord);
  };

  var arrayToLatLng = function(coords, useGeoJSON) {
	for(var i=0; i < coords.length; i++) {
	  if(coords[i].length > 0 && typeof(coords[i][0]) != "number") {
		coords[i] = arrayToLatLng(coords[i], useGeoJSON);
	  }
	  else {
		coords[i] = coordsToLatLngs(coords[i], useGeoJSON);
	  }
	}

	return coords;
  };

  var extend_object = function(obj, new_obj) {
	if(obj === new_obj) return obj;

	for(var name in new_obj) {
	  obj[name] = new_obj[name];
	}

	return obj;
  };

  var replace_object = function(obj, replace) {
	if(obj === replace) return obj;

	for(var name in replace) {
	  if(obj[name] != undefined)
		obj[name] = replace[name];
	}

	return obj;
  };

  var array_map = function(array, callback) {
	var original_callback_params = Array.prototype.slice.call(arguments, 2);

	if (Array.prototype.map && array.map === Array.prototype.map) {
	  return Array.prototype.map.call(array, function(item) {
		callback_params = original_callback_params;
		callback_params.splice(0, 0, item);

		return callback.apply(this, callback_params);
	  });
	}
	else {
	  var array_return = [];
	  var array_length = array.length;

	  for(var i = 0; i < array_length; i++) {
		callback_params = original_callback_params;
		callback_params = callback_params.splice(0, 0, array[i]);
		array_return.push(callback.apply(this, callback_params));
	  }

	  return array_return;
	}
  };

  var array_flat = function(array) {
	new_array = [];

	for(var i=0; i < array.length; i++) {
	  new_array = new_array.concat(array[i]);
	}

	return new_array;
  };
// Class
$.GMaps = GMaps;

$.GMaps.mapEvents = [
  "bounds_changed",
  "center_changed",
  "click",
  "dblclick",
  "drag",
  "dragend",
  "dragstart",
  "heading_changed",
  "idle",
  "maptypeid_changed",
  "mousemove",
  "mouseout",
  "mouseover",
  "projection_changed",
  "resize",
  "rightclick",
  "tilesloaded",
  "tilt_changed",
  "zoom_changed"
];

// jQuery Plugin
$.fn.gmaps = function(options) {

  // No element found, skip.
  if (this.length < 1) return;

  // Only the first element
  var el          = $(this[0]),
	  map         = el.data("gmaps"),
	  newInstance = (map===undefined),
	  autodetect  = (options===undefined);

  // Normalize options
  if ($.isString(options)) {
	options = {
	  address: options
	};
  }

  // New instance
  if (newInstance) {

	var id = $.uid("gmaps-"),

		defaultOptions = {
		  lat: 0,
		  lng: 0
		};

	if ($.isPlainObject(options)) {
	  options = $.extend({}, defaultOptions, options);
	}

	// Set id
	el.attr("id", id);
	options.div = '#' + id;

	// Override events
	$.each($.GMaps.mapEvents, function(i, eventName){

	  var originalEvent =
			($.isFunction(options[eventName])) ?
			  options[eventName] :
			  $.noop;

	  options[eventName] = function(){

		var args = $.makeArray(arguments);

		// Trigger original event
		originalEvent.apply(map, arguments);

		// Trigger jQuery event
		el.trigger.apply(el, ["map_" + eventName].concat(args));
	  }
	});

	// Instantiate gmaps
	map = new GMaps(options);
	el.data("gmaps", map);

	// Extend with go method
	map.go = function(lat, lng) {
	  map.setCenter(lat, lng);
	  map.addMarker({lat: lat, lng: lng});
	}

	// Auto-detect location
	if (autodetect) {
	  GMaps.geolocate({
		success: function(position) {
		  map.go(position.coords.latitude, position.coords.longitude);
		}
	  });
	}

	return map;

  // Existing instance
  } else {

	var lat = options.lat,
		lng = options.lng;

	// Update location
	if ($.isNumber(lat) || $.isNumber(lng)) {
	  map.go(lat, lng);
	}

	return map;
  }

  // Resolve lat/lng from address
  if (options.address) {

	GMaps.geocode({
	  address: options.address,
	  callback: function(results, status) {
		if (status=="OK") {
		  var coords = results[0].geometry.location;
		  map.go(coords.lat(), coords.lng());
		}
	  }
	});

	return map;
  }
};

  module.resolveWith(GMaps);

});

var language = window.es.locationLanguage;
var apiKey = window.es.gmapsApiKey;
var requireGmaps = window.es.requireGmaps;
var key = '';

if (apiKey) {
	key = "key=" + apiKey + "&";
}

if (requireGmaps) {

	if (window.google && window.google.maps){
		window[callbackId]();

	} else {
		// Load google maps api
		$.require()
			.script($.uri(window.location).protocol() + "://maps.google.com/maps/api/js?" + key + "callback=" + callbackId + "&language=" + language)
			.done()
	}
}


};
// module factory: end

FD40.module("gmaps", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var jQuery = $;
var exports = function() {

/**
 * History.js jQuery Adapter
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

// Closure
(function(window,undefined){
	"use strict";

	// Localise Globals
	var History = window.History = window.History||{};

	// Check Existence
	if ( typeof History.Adapter !== 'undefined' ) {
		throw new Error('History.js Adapter has already been loaded...');
	}

	// Add the Adapter
	History.Adapter = {
		/**
		 * History.Adapter.bind(el,event,callback)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {function} callback
		 * @return {void}
		 */
		bind: function(el,event,callback){
			jQuery(el).bind(event,callback);
		},

		/**
		 * History.Adapter.trigger(el,event)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {void}
		 */
		trigger: function(el,event,extra){
			jQuery(el).trigger(event,extra);
		},

		/**
		 * History.Adapter.extractEventData(key,event,extra)
		 * @param {string} key - key for the event data to extract
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {mixed}
		 */
		extractEventData: function(key,event,extra){
			// jQuery Native then jQuery Custom
			var result = (event && event.originalEvent && event.originalEvent[key]) || (extra && extra[key]) || undefined;

			// Return
			return result;
		},

		/**
		 * History.Adapter.onDomLoad(callback)
		 * @param {function} callback
		 * @return {void}
		 */
		onDomLoad: function(callback) {
			jQuery(callback);
		}
	};

	// Try and Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);

/**
 * History.js HTML4 Support
 * Depends on the HTML5 Support
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		document = window.document, // Make sure we are using the correct document
		setTimeout = window.setTimeout||setTimeout,
		clearTimeout = window.clearTimeout||clearTimeout,
		setInterval = window.setInterval||setInterval,
		History = window.History = window.History||{}; // Public History Object

	// Check Existence
	if ( typeof History.initHtml4 !== 'undefined' ) {
		throw new Error('History.js HTML4 Support has already been loaded...');
	}


	// ========================================================================
	// Initialise HTML4 Support

	// Initialise HTML4 Support
	History.initHtml4 = function(){
		// Initialise
		if ( typeof History.initHtml4.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initHtml4.initialized = true;
		}


		// ====================================================================
		// Properties

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = true;


		// ====================================================================
		// Hash Storage

		/**
		 * History.savedHashes
		 * Store the hashes in an array
		 */
		History.savedHashes = [];

		/**
		 * History.isLastHash(newHash)
		 * Checks if the hash is the last hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.isLastHash = function(newHash){
			// Prepare
			var oldHash = History.getHashByIndex(),
				isLast;

			// Check
			isLast = newHash === oldHash;

			// Return isLast
			return isLast;
		};

		/**
		 * History.saveHash(newHash)
		 * Push a Hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.saveHash = function(newHash){
			// Check Hash
			if ( History.isLastHash(newHash) ) {
				return false;
			}

			// Push the Hash
			History.savedHashes.push(newHash);

			// Return true
			return true;
		};

		/**
		 * History.getHashByIndex()
		 * Gets a hash by the index
		 * @param {integer} index
		 * @return {string}
		 */
		History.getHashByIndex = function(index){
			// Prepare
			var hash = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				hash = History.savedHashes[History.savedHashes.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				hash = History.savedHashes[History.savedHashes.length+index];
			}
			else {
				// Get from the beginning
				hash = History.savedHashes[index];
			}

			// Return hash
			return hash;
		};


		// ====================================================================
		// Discarded States

		/**
		 * History.discardedHashes
		 * A hashed array of discarded hashes
		 */
		History.discardedHashes = {};

		/**
		 * History.discardedStates
		 * A hashed array of discarded states
		 */
		History.discardedStates = {};

		/**
		 * History.discardState(State)
		 * Discards the state by ignoring it through History
		 * @param {object} State
		 * @return {true}
		 */
		History.discardState = function(discardedState,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Prepare
			var discardedStateHash = History.getHashByState(discardedState),
				discardObject;

			// Create Discard Object
			discardObject = {
				'discardedState': discardedState,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to DiscardedStates
			History.discardedStates[discardedStateHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardHash(hash)
		 * Discards the hash by ignoring it through History
		 * @param {string} hash
		 * @return {true}
		 */
		History.discardHash = function(discardedHash,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Create Discard Object
			var discardObject = {
				'discardedHash': discardedHash,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to discardedHash
			History.discardedHashes[discardedHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardState(State)
		 * Checks to see if the state is discarded
		 * @param {object} State
		 * @return {bool}
		 */
		History.discardedState = function(State){
			// Prepare
			var StateHash = History.getHashByState(State),
				discarded;

			// Check
			discarded = History.discardedStates[StateHash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.discardedHash(hash)
		 * Checks to see if the state is discarded
		 * @param {string} State
		 * @return {bool}
		 */
		History.discardedHash = function(hash){
			// Check
			var discarded = History.discardedHashes[hash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.recycleState(State)
		 * Allows a discarded state to be used again
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {true}
		 */
		History.recycleState = function(State){
			//History.debug('History.recycleState', arguments);
			// Prepare
			var StateHash = History.getHashByState(State);

			// Remove from DiscardedStates
			if ( History.discardedState(State) ) {
				delete History.discardedStates[StateHash];
			}

			// Return true
			return true;
		};


		// ====================================================================
		// HTML4 HashChange Support

		if ( History.emulated.hashChange ) {
			/*
			 * We must emulate the HTML4 HashChange Support by manually checking for hash changes
			 */

			/**
			 * History.hashChangeInit()
			 * Init the HashChange Emulation
			 */
			History.hashChangeInit = function(){
				// Define our Checker Function
				History.checkerFunction = null;

				// Define some variables that will help in our checker function
				var lastDocumentHash = '',
					iframeId, iframe,
					lastIframeHash, checkerRunning;

				// Handle depending on the browser
				if ( History.isInternetExplorer() ) {
					// IE6 and IE7
					// We need to use an iframe to emulate the back and forward buttons

					// Create iFrame
					iframeId = 'historyjs-iframe';
					iframe = document.createElement('iframe');

					// Adjust iFarme
					iframe.setAttribute('id', iframeId);
					iframe.style.display = 'none';

					// Append iFrame
					document.body.appendChild(iframe);

					// Create initial history entry
					iframe.contentWindow.document.open();
					iframe.contentWindow.document.close();

					// Define some variables that will help in our checker function
					lastIframeHash = '';
					checkerRunning = false;

					// Define the checker function
					History.checkerFunction = function(){
						// Check Running
						if ( checkerRunning ) {
							return false;
						}

						// Update Running
						checkerRunning = true;

						// Fetch
						var documentHash = History.getHash()||'',
							iframeHash = History.unescapeHash(iframe.contentWindow.document.location.hash)||'';

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Create a history entry in the iframe
							if ( iframeHash !== documentHash ) {
								//History.debug('hashchange.checker: iframe hash change', 'documentHash (new):', documentHash, 'iframeHash (old):', iframeHash);

								// Equalise
								lastIframeHash = iframeHash = documentHash;

								// Create History Entry
								iframe.contentWindow.document.open();
								iframe.contentWindow.document.close();

								// Update the iframe's hash
								iframe.contentWindow.document.location.hash = History.escapeHash(documentHash);
							}

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// The iFrame Hash has changed (back button caused)
						else if ( iframeHash !== lastIframeHash ) {
							//History.debug('hashchange.checker: iframe hash out of sync', 'iframeHash (new):', iframeHash, 'documentHash (old):', documentHash);

							// Equalise
							lastIframeHash = iframeHash;

							// Update the Hash
							History.setHash(iframeHash,false);
						}

						// Reset Running
						checkerRunning = false;

						// Return true
						return true;
					};
				}
				else {
					// We are not IE
					// Firefox 1 or 2, Opera

					// Define the checker function
					History.checkerFunction = function(){
						// Prepare
						var documentHash = History.getHash();

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// Return true
						return true;
					};
				}

				// Apply the checker function
				History.intervalList.push(setInterval(History.checkerFunction, History.options.hashChangeInterval));

				// Done
				return true;
			}; // History.hashChangeInit

			// Bind hashChangeInit
			History.Adapter.onDomLoad(History.hashChangeInit);

		} // History.emulated.hashChange


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * We must emulate the HTML5 State Management by using HTML4 HashChange
			 */

			/**
			 * History.onHashChange(event)
			 * Trigger HTML5's window.onpopstate via HTML4 HashChange Support
			 */
			History.onHashChange = function(event){
				//History.debug('History.onHashChange', arguments);

				// Prepare
				var currentUrl = ((event && event.newURL) || document.location.href),
					currentHash = History.getHashByUrl(currentUrl),
					currentState = null,
					currentStateHash = null,
					currentStateHashExits = null,
					discardObject;

				// Check if we are the same state
				if ( History.isLastHash(currentHash) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onHashChange: no change');
					History.busy(false);
					return false;
				}

				// Reset the double check
				History.doubleCheckComplete();

				// Store our location for use in detecting back/forward direction
				History.saveHash(currentHash);

				// Expand Hash
				if ( currentHash && History.isTraditionalAnchor(currentHash) ) {
					//History.debug('History.onHashChange: traditional anchor', currentHash);
					// Traditional Anchor Hash
					History.Adapter.trigger(window,'anchorchange');
					History.busy(false);
					return false;
				}

				// Create State
				currentState = History.extractState(History.getFullUrl(currentHash||document.location.href,false),true);

				// Check if we are the same state
				if ( History.isLastSavedState(currentState) ) {
					//History.debug('History.onHashChange: no change');
					// There has been no change (just the page's hash has finally propagated)
					History.busy(false);
					return false;
				}

				// Create the state Hash
				currentStateHash = History.getHashByState(currentState);

				// Check if we are DiscardedState
				discardObject = History.discardedState(currentState);
				if ( discardObject ) {
					// Ignore this state as it has been discarded and go back to the state before it
					if ( History.getHashByIndex(-2) === History.getHashByState(discardObject.forwardState) ) {
						// We are going backwards
						//History.debug('History.onHashChange: go backwards');
						History.back(false);
					} else {
						// We are going forwards
						//History.debug('History.onHashChange: go forwards');
						History.forward(false);
					}
					return false;
				}

				// Push the new HTML5 State
				//History.debug('History.onHashChange: success hashchange');
				History.pushState(currentState.data,currentState.title,currentState.url,false);

				// End onHashChange closure
				return true;
			};
			History.Adapter.bind(window,'hashchange',History.onHashChange);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Object
				var newState = History.createStateObject(data,title,url),
					newStateHash = History.getHashByState(newState),
					oldState = History.getState(false),
					oldStateHash = History.getHashByState(oldState),
					html4Hash = History.getHash();

				// Store the newState
				History.storeState(newState);
				History.expectedStateId = newState.id;

				// Recycle the State
				History.recycleState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Check if we are the same State
				if ( newStateHash === oldStateHash ) {
					//History.debug('History.pushState: no change', newStateHash);
					History.busy(false);
					return false;
				}

				// Update HTML4 Hash
				if ( newStateHash !== html4Hash && newStateHash !== History.getShortUrl(document.location.href) ) {
					//History.debug('History.pushState: update hash', newStateHash, html4Hash);
					History.setHash(newStateHash,false);
					return false;
				}

				// Update HTML5 State
				History.saveState(newState);

				// Fire HTML5 Event
				//History.debug('History.pushState: trigger popstate');
				History.Adapter.trigger(window,'statechange');
				History.busy(false);

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Objects
				var newState        = History.createStateObject(data,title,url),
					oldState        = History.getState(false),
					previousState   = History.getStateByIndex(-2);

				// Discard Old State
				History.discardState(oldState,newState,previousState);

				// Alias to PushState
				History.pushState(newState.data,newState.title,newState.url,false);

				// End replaceState closure
				return true;
			};

		} // History.emulated.pushState



		// ====================================================================
		// Initialise

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/**
			 * Ensure initial state is handled correctly
			 */
			if ( History.getHash() && !History.emulated.hashChange ) {
				History.Adapter.onDomLoad(function(){
					History.Adapter.trigger(window,'hashchange');
				});
			}

		} // History.emulated.pushState

	}; // History.initHtml4

	// Try and Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);
/**
 * History.js Core
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		console = window.console||undefined, // Prevent a JSLint complain
		document = window.document, // Make sure we are using the correct document
		navigator = window.navigator, // Make sure we are using the correct navigator
		sessionStorage = window.sessionStorage||false, // sessionStorage
		setTimeout = window.setTimeout,
		clearTimeout = window.clearTimeout,
		setInterval = window.setInterval,
		clearInterval = window.clearInterval,
		JSON = window.JSON,
		alert = window.alert,
		History = window.History = window.History||{}, // Public History Object
		history = window.history; // Old History Object

	// MooTools Compatibility
	JSON.stringify = JSON.stringify||JSON.encode;
	JSON.parse = JSON.parse||JSON.decode;

	// Check Existence
	if ( typeof History.init !== 'undefined' ) {
		throw new Error('History.js Core has already been loaded...');
	}

	// Initialise History
	History.init = function(){
		// Check Load Status of Adapter
		if ( typeof History.Adapter === 'undefined' ) {
			return false;
		}

		// Check Load Status of Core
		if ( typeof History.initCore !== 'undefined' ) {
			History.initCore();
		}

		// Check Load Status of HTML4 Support
		if ( typeof History.initHtml4 !== 'undefined' ) {
			History.initHtml4();
		}

		// Return true
		return true;
	};


	// ========================================================================
	// Initialise Core

	// Initialise Core
	History.initCore = function(){
		// Initialise
		if ( typeof History.initCore.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initCore.initialized = true;
		}


		// ====================================================================
		// Options

		/**
		 * History.options
		 * Configurable options
		 */
		History.options = History.options||{};

		/**
		 * History.options.hashChangeInterval
		 * How long should the interval be before hashchange checks
		 */
		History.options.hashChangeInterval = History.options.hashChangeInterval || 100;

		/**
		 * History.options.safariPollInterval
		 * How long should the interval be before safari poll checks
		 */
		History.options.safariPollInterval = History.options.safariPollInterval || 500;

		/**
		 * History.options.doubleCheckInterval
		 * How long should the interval be before we perform a double check
		 */
		History.options.doubleCheckInterval = History.options.doubleCheckInterval || 500;

		/**
		 * History.options.storeInterval
		 * How long should we wait between store calls
		 */
		History.options.storeInterval = History.options.storeInterval || 1000;

		/**
		 * History.options.busyDelay
		 * How long should we wait between busy events
		 */
		History.options.busyDelay = History.options.busyDelay || 250;

		/**
		 * History.options.debug
		 * If true will enable debug messages to be logged
		 */
		History.options.debug = History.options.debug || false;

		/**
		 * History.options.initialTitle
		 * What is the title of the initial state
		 */
		History.options.initialTitle = History.options.initialTitle || document.title;


		// ====================================================================
		// Interval record

		/**
		 * History.intervalList
		 * List of intervals set, to be cleared when document is unloaded.
		 */
		History.intervalList = [];

		/**
		 * History.clearAllIntervals
		 * Clears all setInterval instances.
		 */
		History.clearAllIntervals = function(){
			var i, il = History.intervalList;
			if (typeof il !== "undefined" && il !== null) {
				for (i = 0; i < il.length; i++) {
					clearInterval(il[i]);
				}
				History.intervalList = null;
			}
		};


		// ====================================================================
		// Debug

		/**
		 * History.debug(message,...)
		 * Logs the passed arguments if debug enabled
		 */
		History.debug = function(){
			if ( (History.options.debug||false) ) {
				History.log.apply(History,arguments);
			}
		};

		/**
		 * History.log(message,...)
		 * Logs the passed arguments
		 */
		History.log = function(){
			// Prepare
			var
				consoleExists = !(typeof console === 'undefined' || typeof console.log === 'undefined' || typeof console.log.apply === 'undefined'),
				textarea = document.getElementById('log'),
				message,
				i,n,
				args,arg
				;

			// Write to Console
			if ( consoleExists ) {
				args = Array.prototype.slice.call(arguments);
				message = args.shift();
				if ( typeof console.debug !== 'undefined' ) {
					console.debug.apply(console,[message,args]);
				}
				else {
					console.log.apply(console,[message,args]);
				}
			}
			else {
				message = ("\n"+arguments[0]+"\n");
			}

			// Write to log
			for ( i=1,n=arguments.length; i<n; ++i ) {
				arg = arguments[i];
				if ( typeof arg === 'object' && typeof JSON !== 'undefined' ) {
					try {
						arg = JSON.stringify(arg);
					}
					catch ( Exception ) {
						// Recursive Object
					}
				}
				message += "\n"+arg+"\n";
			}

			// Textarea
			if ( textarea ) {
				textarea.value += message+"\n-----\n";
				textarea.scrollTop = textarea.scrollHeight - textarea.clientHeight;
			}
			// No Textarea, No Console
			else if ( !consoleExists ) {
				alert(message);
			}

			// Return true
			return true;
		};


		// ====================================================================
		// Emulated Status

		/**
		 * History.getInternetExplorerMajorVersion()
		 * Get's the major version of Internet Explorer
		 * @return {integer}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 * @author James Padolsey <https://gist.github.com/527683>
		 */
		History.getInternetExplorerMajorVersion = function(){
			var result = History.getInternetExplorerMajorVersion.cached =
					(typeof History.getInternetExplorerMajorVersion.cached !== 'undefined')
				?	History.getInternetExplorerMajorVersion.cached
				:	(function(){
						var v = 3,
								div = document.createElement('div'),
								all = div.getElementsByTagName('i');
						while ( (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->') && all[0] ) {}
						return (v > 4) ? v : false;
					})()
				;
			return result;
		};

		/**
		 * History.isInternetExplorer()
		 * Are we using Internet Explorer?
		 * @return {boolean}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 */
		History.isInternetExplorer = function(){
			var result =
				History.isInternetExplorer.cached =
				(typeof History.isInternetExplorer.cached !== 'undefined')
					?	History.isInternetExplorer.cached
					:	Boolean(History.getInternetExplorerMajorVersion())
				;
			return result;
		};

		/**
		 * History.emulated
		 * Which features require emulating?
		 */
		History.emulated = {
			pushState: !Boolean(
				window.history && window.history.pushState && window.history.replaceState
				&& !(
					(/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i).test(navigator.userAgent) /* disable for versions of iOS before version 4.3 (8F190) */
					|| (/AppleWebKit\/5([0-2]|3[0-2])/i).test(navigator.userAgent) /* disable for the mercury iOS browser, or at least older versions of the webkit engine */
				)
			),
			hashChange: Boolean(
				!(('onhashchange' in window) || ('onhashchange' in document))
				||
				(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8)
			)
		};

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = !History.emulated.pushState;

		/**
		 * History.bugs
		 * Which bugs are present
		 */
		History.bugs = {
			/**
			 * Safari 5 and Safari iOS 4 fail to return to the correct state once a hash is replaced by a `replaceState` call
			 * https://bugs.webkit.org/show_bug.cgi?id=56249
			 */
			setHash: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * Safari 5 and Safari iOS 4 sometimes fail to apply the state change under busy conditions
			 * https://bugs.webkit.org/show_bug.cgi?id=42940
			 */
			safariPoll: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * MSIE 6 and 7 sometimes do not apply a hash even it was told to (requiring a second call to the apply function)
			 */
			ieDoubleCheck: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8),

			/**
			 * MSIE 6 requires the entire hash to be encoded for the hashes to trigger the onHashChange event
			 */
			hashEscape: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 7)
		};

		/**
		 * History.isEmptyObject(obj)
		 * Checks to see if the Object is Empty
		 * @param {Object} obj
		 * @return {boolean}
		 */
		History.isEmptyObject = function(obj) {
			for ( var name in obj ) {
				return false;
			}
			return true;
		};

		/**
		 * History.cloneObject(obj)
		 * Clones a object and eliminate all references to the original contexts
		 * @param {Object} obj
		 * @return {Object}
		 */
		History.cloneObject = function(obj) {
			var hash,newObj;
			if ( obj ) {
				hash = JSON.stringify(obj);
				newObj = JSON.parse(hash);
			}
			else {
				newObj = {};
			}
			return newObj;
		};


		// ====================================================================
		// URL Helpers

		/**
		 * History.getRootUrl()
		 * Turns "http://mysite.com/dir/page.html?asd" into "http://mysite.com"
		 * @return {String} rootUrl
		 */
		History.getRootUrl = function(){
			// Create
			var rootUrl = document.location.protocol+'//'+(document.location.hostname||document.location.host);
			if ( document.location.port||false ) {
				rootUrl += ':'+document.location.port;
			}
			rootUrl += '/';

			// Return
			return rootUrl;
		};

		/**
		 * History.getBaseHref()
		 * Fetches the `href` attribute of the `<base href="...">` element if it exists
		 * @return {String} baseHref
		 */
		History.getBaseHref = function(){
			// Create
			var
				baseElements = document.getElementsByTagName('base'),
				baseElement = null,
				baseHref = '';

			// Test for Base Element
			if ( baseElements.length === 1 ) {
				// Prepare for Base Element
				baseElement = baseElements[0];
				baseHref = baseElement.href.replace(/[^\/]+$/,'');
			}

			// Adjust trailing slash
			baseHref = baseHref.replace(/\/+$/,'');
			if ( baseHref ) baseHref += '/';

			// Return
			return baseHref;
		};

		/**
		 * History.getBaseUrl()
		 * Fetches the baseHref or basePageUrl or rootUrl (whichever one exists first)
		 * @return {String} baseUrl
		 */
		History.getBaseUrl = function(){
			// Create
			var baseUrl = History.getBaseHref()||History.getBasePageUrl()||History.getRootUrl();

			// Return
			return baseUrl;
		};

		/**
		 * History.getPageUrl()
		 * Fetches the URL of the current page
		 * @return {String} pageUrl
		 */
		History.getPageUrl = function(){
			// Fetch
			var
				State = History.getState(false,false),
				stateUrl = (State||{}).url||document.location.href,
				pageUrl;

			// Create
			pageUrl = stateUrl.replace(/\/+$/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/\./).test(part) ? part : part+'/';
			});

			// Return
			return pageUrl;
		};

		/**
		 * History.getBasePageUrl()
		 * Fetches the Url of the directory of the current page
		 * @return {String} basePageUrl
		 */
		History.getBasePageUrl = function(){
			// Create
			var basePageUrl = document.location.href.replace(/[#\?].*/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/[^\/]$/).test(part) ? '' : part;
			}).replace(/\/+$/,'')+'/';

			// Return
			return basePageUrl;
		};

		/**
		 * History.getFullUrl(url)
		 * Ensures that we have an absolute URL and not a relative URL
		 * @param {string} url
		 * @param {Boolean} allowBaseHref
		 * @return {string} fullUrl
		 */
		History.getFullUrl = function(url,allowBaseHref){
			// Prepare
			var fullUrl = url, firstChar = url.substring(0,1);
			allowBaseHref = (typeof allowBaseHref === 'undefined') ? true : allowBaseHref;

			// Check
			if ( /[a-z]+\:\/\//.test(url) ) {
				// Full URL
			}
			else if ( firstChar === '/' ) {
				// Root URL
				fullUrl = History.getRootUrl()+url.replace(/^\/+/,'');
			}
			else if ( firstChar === '#' ) {
				// Anchor URL
				fullUrl = History.getPageUrl().replace(/#.*/,'')+url;
			}
			else if ( firstChar === '?' ) {
				// Query URL
				fullUrl = History.getPageUrl().replace(/[\?#].*/,'')+url;
			}
			else {
				// Relative URL
				if ( allowBaseHref ) {
					fullUrl = History.getBaseUrl()+url.replace(/^(\.\/)+/,'');
				} else {
					fullUrl = History.getBasePageUrl()+url.replace(/^(\.\/)+/,'');
				}
				// We have an if condition above as we do not want hashes
				// which are relative to the baseHref in our URLs
				// as if the baseHref changes, then all our bookmarks
				// would now point to different locations
				// whereas the basePageUrl will always stay the same
			}

			// Return
			return fullUrl.replace(/\#$/,'');
		};

		/**
		 * History.getShortUrl(url)
		 * Ensures that we have a relative URL and not a absolute URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getShortUrl = function(url){
			// Prepare
			var shortUrl = url, baseUrl = History.getBaseUrl(), rootUrl = History.getRootUrl();

			// Trim baseUrl
			if ( History.emulated.pushState ) {
				// We are in a if statement as when pushState is not emulated
				// The actual url these short urls are relative to can change
				// So within the same session, we the url may end up somewhere different
				shortUrl = shortUrl.replace(baseUrl,'');
			}

			// Trim rootUrl
			shortUrl = shortUrl.replace(rootUrl,'/');

			// Ensure we can still detect it as a state
			if ( History.isTraditionalAnchor(shortUrl) ) {
				shortUrl = './'+shortUrl;
			}

			// Clean It
			shortUrl = shortUrl.replace(/^(\.\/)+/g,'./').replace(/\#$/,'');

			// Return
			return shortUrl;
		};


		// ====================================================================
		// State Storage

		/**
		 * History.store
		 * The store for all session specific data
		 */
		History.store = {};

		/**
		 * History.idToState
		 * 1-1: State ID to State Object
		 */
		History.idToState = History.idToState||{};

		/**
		 * History.stateToId
		 * 1-1: State String to State ID
		 */
		History.stateToId = History.stateToId||{};

		/**
		 * History.urlToId
		 * 1-1: State URL to State ID
		 */
		History.urlToId = History.urlToId||{};

		/**
		 * History.storedStates
		 * Store the states in an array
		 */
		History.storedStates = History.storedStates||[];

		/**
		 * History.savedStates
		 * Saved the states in an array
		 */
		History.savedStates = History.savedStates||[];

		/**
		 * History.noramlizeStore()
		 * Noramlize the store by adding necessary values
		 */
		History.normalizeStore = function(){
			History.store.idToState = History.store.idToState||{};
			History.store.urlToId = History.store.urlToId||{};
			History.store.stateToId = History.store.stateToId||{};
		};

		/**
		 * History.getState()
		 * Get an object containing the data, title and url of the current state
		 * @param {Boolean} friendly
		 * @param {Boolean} create
		 * @return {Object} State
		 */
		History.getState = function(friendly,create){
			// Prepare
			if ( typeof friendly === 'undefined' ) { friendly = true; }
			if ( typeof create === 'undefined' ) { create = true; }

			// Fetch
			var State = History.getLastSavedState();

			// Create
			if ( !State && create ) {
				State = History.createStateObject();
			}

			// Adjust
			if ( friendly ) {
				State = History.cloneObject(State);
				State.url = State.cleanUrl||State.url;
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByState(State)
		 * Gets a ID for a State
		 * @param {State} newState
		 * @return {String} id
		 */
		History.getIdByState = function(newState){

			// Fetch ID
			var id = History.extractId(newState.url),
				str;

			if ( !id ) {
				// Find ID via State String
				str = History.getStateString(newState);
				if ( typeof History.stateToId[str] !== 'undefined' ) {
					id = History.stateToId[str];
				}
				else if ( typeof History.store.stateToId[str] !== 'undefined' ) {
					id = History.store.stateToId[str];
				}
				else {
					// Generate a new ID
					while ( true ) {
						id = (new Date()).getTime() + String(Math.random()).replace(/\D/g,'');
						if ( typeof History.idToState[id] === 'undefined' && typeof History.store.idToState[id] === 'undefined' ) {
							break;
						}
					}

					// Apply the new State to the ID
					History.stateToId[str] = id;
					History.idToState[id] = newState;
				}
			}

			// Return ID
			return id;
		};

		/**
		 * History.normalizeState(State)
		 * Expands a State Object
		 * @param {object} State
		 * @return {object}
		 */
		History.normalizeState = function(oldState){
			// Variables
			var newState, dataNotEmpty;

			// Prepare
			if ( !oldState || (typeof oldState !== 'object') ) {
				oldState = {};
			}

			// Check
			if ( typeof oldState.normalized !== 'undefined' ) {
				return oldState;
			}

			// Adjust
			if ( !oldState.data || (typeof oldState.data !== 'object') ) {
				oldState.data = {};
			}

			// ----------------------------------------------------------------

			// Create
			newState = {};
			newState.normalized = true;
			newState.title = oldState.title||'';
			newState.url = History.getFullUrl(History.unescapeString(oldState.url||document.location.href));
			newState.hash = History.getShortUrl(newState.url);
			newState.data = History.cloneObject(oldState.data);

			// Fetch ID
			newState.id = History.getIdByState(newState);

			// ----------------------------------------------------------------

			// Clean the URL
			newState.cleanUrl = newState.url.replace(/\??\&_suid.*/,'');
			newState.url = newState.cleanUrl;

			// Check to see if we have more than just a url
			dataNotEmpty = !History.isEmptyObject(newState.data);

			// Apply
			if ( newState.title || dataNotEmpty ) {
				// Add ID to Hash
				newState.hash = History.getShortUrl(newState.url).replace(/\??\&_suid.*/,'');
				if ( !/\?/.test(newState.hash) ) {
					newState.hash += '?';
				}
				newState.hash += '&_suid='+newState.id;
			}

			// Create the Hashed URL
			newState.hashedUrl = History.getFullUrl(newState.hash);

			// ----------------------------------------------------------------

			// Update the URL if we have a duplicate
			if ( (History.emulated.pushState || History.bugs.safariPoll) && History.hasUrlDuplicate(newState) ) {
				newState.url = newState.hashedUrl;
			}

			// ----------------------------------------------------------------

			// Return
			return newState;
		};

		/**
		 * History.createStateObject(data,title,url)
		 * Creates a object based on the data, title and url state params
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {object}
		 */
		History.createStateObject = function(data,title,url){
			// Hashify
			var State = {
				'data': data,
				'title': title,
				'url': url
			};

			// Expand the State
			State = History.normalizeState(State);

			// Return object
			return State;
		};

		/**
		 * History.getStateById(id)
		 * Get a state by it's UID
		 * @param {String} id
		 */
		History.getStateById = function(id){
			// Prepare
			id = String(id);

			// Retrieve
			var State = History.idToState[id] || History.store.idToState[id] || undefined;

			// Return State
			return State;
		};

		/**
		 * Get a State's String
		 * @param {State} passedState
		 */
		History.getStateString = function(passedState){
			// Prepare
			var State, cleanedState, str;

			// Fetch
			State = History.normalizeState(passedState);

			// Clean
			cleanedState = {
				data: State.data,
				title: passedState.title,
				url: passedState.url
			};

			// Fetch
			str = JSON.stringify(cleanedState);

			// Return
			return str;
		};

		/**
		 * Get a State's ID
		 * @param {State} passedState
		 * @return {String} id
		 */
		History.getStateId = function(passedState){
			// Prepare
			var State, id;

			// Fetch
			State = History.normalizeState(passedState);

			// Fetch
			id = State.id;

			// Return
			return id;
		};

		/**
		 * History.getHashByState(State)
		 * Creates a Hash for the State Object
		 * @param {State} passedState
		 * @return {String} hash
		 */
		History.getHashByState = function(passedState){
			// Prepare
			var State, hash;

			// Fetch
			State = History.normalizeState(passedState);

			// Hash
			hash = State.hash;

			// Return
			return hash;
		};

		/**
		 * History.extractId(url_or_hash)
		 * Get a State ID by it's URL or Hash
		 * @param {string} url_or_hash
		 * @return {string} id
		 */
		History.extractId = function ( url_or_hash ) {
			// Prepare
			var id,parts,url;

			// Extract
			parts = /(.*)\&_suid=([0-9]+)$/.exec(url_or_hash);
			url = parts ? (parts[1]||url_or_hash) : url_or_hash;
			id = parts ? String(parts[2]||'') : '';

			// Return
			return id||false;
		};

		/**
		 * History.isTraditionalAnchor
		 * Checks to see if the url is a traditional anchor or not
		 * @param {String} url_or_hash
		 * @return {Boolean}
		 */
		History.isTraditionalAnchor = function(url_or_hash){
			// Check
			var isTraditional = !(/[\/\?\.]/.test(url_or_hash));

			// Return
			return isTraditional;
		};

		/**
		 * History.extractState
		 * Get a State by it's URL or Hash
		 * @param {String} url_or_hash
		 * @return {State|null}
		 */
		History.extractState = function(url_or_hash,create){
			// Prepare
			var State = null, id, url;
			create = create||false;

			// Fetch SUID
			id = History.extractId(url_or_hash);
			if ( id ) {
				State = History.getStateById(id);
			}

			// Fetch SUID returned no State
			if ( !State ) {
				// Fetch URL
				url = History.getFullUrl(url_or_hash);

				// Check URL
				id = History.getIdByUrl(url)||false;
				if ( id ) {
					State = History.getStateById(id);
				}

				// Create State
				if ( !State && create && !History.isTraditionalAnchor(url_or_hash) ) {
					State = History.createStateObject(null,null,url);
				}
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByUrl()
		 * Get a State ID by a State URL
		 */
		History.getIdByUrl = function(url){
			// Fetch
			var id = History.urlToId[url] || History.store.urlToId[url] || undefined;

			// Return
			return id;
		};

		/**
		 * History.getLastSavedState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastSavedState = function(){
			return History.savedStates[History.savedStates.length-1]||undefined;
		};

		/**
		 * History.getLastStoredState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastStoredState = function(){
			return History.storedStates[History.storedStates.length-1]||undefined;
		};

		/**
		 * History.hasUrlDuplicate
		 * Checks if a Url will have a url conflict
		 * @param {Object} newState
		 * @return {Boolean} hasDuplicate
		 */
		History.hasUrlDuplicate = function(newState) {
			// Prepare
			var hasDuplicate = false,
				oldState;

			// Fetch
			oldState = History.extractState(newState.url);

			// Check
			hasDuplicate = oldState && oldState.id !== newState.id;

			// Return
			return hasDuplicate;
		};

		/**
		 * History.storeState
		 * Store a State
		 * @param {Object} newState
		 * @return {Object} newState
		 */
		History.storeState = function(newState){
			// Store the State
			History.urlToId[newState.url] = newState.id;

			// Push the State
			History.storedStates.push(History.cloneObject(newState));

			// Return newState
			return newState;
		};

		/**
		 * History.isLastSavedState(newState)
		 * Tests to see if the state is the last state
		 * @param {Object} newState
		 * @return {boolean} isLast
		 */
		History.isLastSavedState = function(newState){
			// Prepare
			var isLast = false,
				newId, oldState, oldId;

			// Check
			if ( History.savedStates.length ) {
				newId = newState.id;
				oldState = History.getLastSavedState();
				oldId = oldState.id;

				// Check
				isLast = (newId === oldId);
			}

			// Return
			return isLast;
		};

		/**
		 * History.saveState
		 * Push a State
		 * @param {Object} newState
		 * @return {boolean} changed
		 */
		History.saveState = function(newState){
			// Check Hash
			if ( History.isLastSavedState(newState) ) {
				return false;
			}

			// Push the State
			History.savedStates.push(History.cloneObject(newState));

			// Return true
			return true;
		};

		/**
		 * History.getStateByIndex()
		 * Gets a state by the index
		 * @param {integer} index
		 * @return {Object}
		 */
		History.getStateByIndex = function(index){
			// Prepare
			var State = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				State = History.savedStates[History.savedStates.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				State = History.savedStates[History.savedStates.length+index];
			}
			else {
				// Get from the beginning
				State = History.savedStates[index];
			}

			// Return State
			return State;
		};


		// ====================================================================
		// Hash Helpers

		/**
		 * History.getHash()
		 * Gets the current document hash
		 * @return {string}
		 */
		History.getHash = function(){
			var hash = History.unescapeHash(document.location.hash);
			return hash;
		};

		/**
		 * History.unescapeString()
		 * Unescape a string
		 * @param {String} str
		 * @return {string}
		 */
		History.unescapeString = function(str){
			// Prepare
			var result = str,
				tmp;

			// Unescape hash
			while ( true ) {
				tmp = window.unescape(result);
				if ( tmp === result ) {
					break;
				}
				result = tmp;
			}

			// Return result
			return result;
		};

		/**
		 * History.unescapeHash()
		 * normalize and Unescape a Hash
		 * @param {String} hash
		 * @return {string}
		 */
		History.unescapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Unescape hash
			result = History.unescapeString(result);

			// Return result
			return result;
		};

		/**
		 * History.normalizeHash()
		 * normalize a hash across browsers
		 * @return {string}
		 */
		History.normalizeHash = function(hash){
			// Prepare
			var result = hash.replace(/[^#]*#/,'').replace(/#.*/, '');

			// Return result
			return result;
		};

		/**
		 * History.setHash(hash)
		 * Sets the document hash
		 * @param {string} hash
		 * @return {History}
		 */
		History.setHash = function(hash,queue){
			// Prepare
			var adjustedHash, State, pageUrl;

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.setHash: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.setHash,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Log
			//History.debug('History.setHash: called',hash);

			// Prepare
			adjustedHash = History.escapeHash(hash);

			// Make Busy + Continue
			History.busy(true);

			// Check if hash is a state
			State = History.extractState(hash,true);
			if ( State && !History.emulated.pushState ) {
				// Hash is a state so skip the setHash
				//History.debug('History.setHash: Hash is a state so skipping the hash set with a direct pushState call',arguments);

				// PushState
				History.pushState(State.data,State.title,State.url,false);
			}
			else if ( document.location.hash !== adjustedHash ) {
				// Hash is a proper hash, so apply it

				// Handle browser bugs
				if ( History.bugs.setHash ) {
					// Fix Safari Bug https://bugs.webkit.org/show_bug.cgi?id=56249

					// Fetch the base page
					pageUrl = History.getPageUrl();

					// Safari hash apply
					History.pushState(null,null,pageUrl+'#'+adjustedHash,false);
				}
				else {
					// Normal hash apply
					document.location.hash = adjustedHash;
				}
			}

			// Chain
			return History;
		};

		/**
		 * History.escape()
		 * normalize and Escape a Hash
		 * @return {string}
		 */
		History.escapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Escape hash
			result = window.escape(result);

			// IE6 Escape Bug
			if ( !History.bugs.hashEscape ) {
				// Restore common parts
				result = result
					.replace(/\%21/g,'!')
					.replace(/\%26/g,'&')
					.replace(/\%3D/g,'=')
					.replace(/\%3F/g,'?');
			}

			// Return result
			return result;
		};

		/**
		 * History.getHashByUrl(url)
		 * Extracts the Hash from a URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getHashByUrl = function(url){
			// Extract the hash
			var hash = String(url)
				.replace(/([^#]*)#?([^#]*)#?(.*)/, '$2')
				;

			// Unescape hash
			hash = History.unescapeHash(hash);

			// Return hash
			return hash;
		};

		/**
		 * History.setTitle(title)
		 * Applies the title to the document
		 * @param {State} newState
		 * @return {Boolean}
		 */
		History.setTitle = function(newState){
			// Prepare
			var title = newState.title,
				firstState;

			// Initial
			if ( !title ) {
				firstState = History.getStateByIndex(0);
				if ( firstState && firstState.url === newState.url ) {
					title = firstState.title||History.options.initialTitle;
				}
			}

			// Apply
			try {
				document.getElementsByTagName('title')[0].innerHTML = title.replace('<','&lt;').replace('>','&gt;').replace(' & ',' &amp; ');
			}
			catch ( Exception ) { }
			document.title = title;

			// Chain
			return History;
		};


		// ====================================================================
		// Queueing

		/**
		 * History.queues
		 * The list of queues to use
		 * First In, First Out
		 */
		History.queues = [];

		/**
		 * History.busy(value)
		 * @param {boolean} value [optional]
		 * @return {boolean} busy
		 */
		History.busy = function(value){
			// Apply
			if ( typeof value !== 'undefined' ) {
				//History.debug('History.busy: changing ['+(History.busy.flag||false)+'] to ['+(value||false)+']', History.queues.length);
				History.busy.flag = value;
			}
			// Default
			else if ( typeof History.busy.flag === 'undefined' ) {
				History.busy.flag = false;
			}

			// Queue
			if ( !History.busy.flag ) {
				// Execute the next item in the queue
				clearTimeout(History.busy.timeout);
				var fireNext = function(){
					var i, queue, item;
					if ( History.busy.flag ) return;
					for ( i=History.queues.length-1; i >= 0; --i ) {
						queue = History.queues[i];
						if ( queue.length === 0 ) continue;
						item = queue.shift();
						History.fireQueueItem(item);
						History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
					}
				};
				History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
			}

			// Return
			return History.busy.flag;
		};

		/**
		 * History.busy.flag
		 */
		History.busy.flag = false;

		/**
		 * History.fireQueueItem(item)
		 * Fire a Queue Item
		 * @param {Object} item
		 * @return {Mixed} result
		 */
		History.fireQueueItem = function(item){
			return item.callback.apply(item.scope||History,item.args||[]);
		};

		/**
		 * History.pushQueue(callback,args)
		 * Add an item to the queue
		 * @param {Object} item [scope,callback,args,queue]
		 */
		History.pushQueue = function(item){
			// Prepare the queue
			History.queues[item.queue||0] = History.queues[item.queue||0]||[];

			// Add to the queue
			History.queues[item.queue||0].push(item);

			// Chain
			return History;
		};

		/**
		 * History.queue (item,queue), (func,queue), (func), (item)
		 * Either firs the item now if not busy, or adds it to the queue
		 */
		History.queue = function(item,queue){
			// Prepare
			if ( typeof item === 'function' ) {
				item = {
					callback: item
				};
			}
			if ( typeof queue !== 'undefined' ) {
				item.queue = queue;
			}

			// Handle
			if ( History.busy() ) {
				History.pushQueue(item);
			} else {
				History.fireQueueItem(item);
			}

			// Chain
			return History;
		};

		/**
		 * History.clearQueue()
		 * Clears the Queue
		 */
		History.clearQueue = function(){
			History.busy.flag = false;
			History.queues = [];
			return History;
		};


		// ====================================================================
		// IE Bug Fix

		/**
		 * History.stateChanged
		 * States whether or not the state has changed since the last double check was initialised
		 */
		History.stateChanged = false;

		/**
		 * History.doubleChecker
		 * Contains the timeout used for the double checks
		 */
		History.doubleChecker = false;

		/**
		 * History.doubleCheckComplete()
		 * Complete a double check
		 * @return {History}
		 */
		History.doubleCheckComplete = function(){
			// Update
			History.stateChanged = true;

			// Clear
			History.doubleCheckClear();

			// Chain
			return History;
		};

		/**
		 * History.doubleCheckClear()
		 * Clear a double check
		 * @return {History}
		 */
		History.doubleCheckClear = function(){
			// Clear
			if ( History.doubleChecker ) {
				clearTimeout(History.doubleChecker);
				History.doubleChecker = false;
			}

			// Chain
			return History;
		};

		/**
		 * History.doubleCheck()
		 * Create a double check
		 * @return {History}
		 */
		History.doubleCheck = function(tryAgain){
			// Reset
			History.stateChanged = false;
			History.doubleCheckClear();

			// Fix IE6,IE7 bug where calling history.back or history.forward does not actually change the hash (whereas doing it manually does)
			// Fix Safari 5 bug where sometimes the state does not change: https://bugs.webkit.org/show_bug.cgi?id=42940
			if ( History.bugs.ieDoubleCheck ) {
				// Apply Check
				History.doubleChecker = setTimeout(
					function(){
						History.doubleCheckClear();
						if ( !History.stateChanged ) {
							//History.debug('History.doubleCheck: State has not yet changed, trying again', arguments);
							// Re-Attempt
							tryAgain();
						}
						return true;
					},
					History.options.doubleCheckInterval
				);
			}

			// Chain
			return History;
		};


		// ====================================================================
		// Safari Bug Fix

		/**
		 * History.safariStatePoll()
		 * Poll the current state
		 * @return {History}
		 */
		History.safariStatePoll = function(){
			// Poll the URL

			// Get the Last State which has the new URL
			var
				urlState = History.extractState(document.location.href),
				newState;

			// Check for a difference
			if ( !History.isLastSavedState(urlState) ) {
				newState = urlState;
			}
			else {
				return;
			}

			// Check if we have a state with that url
			// If not create it
			if ( !newState ) {
				//History.debug('History.safariStatePoll: new');
				newState = History.createStateObject();
			}

			// Apply the New State
			//History.debug('History.safariStatePoll: trigger');
			History.Adapter.trigger(window,'popstate');

			// Chain
			return History;
		};


		// ====================================================================
		// State Aliases

		/**
		 * History.back(queue)
		 * Send the browser history back one item
		 * @param {Integer} queue [optional]
		 */
		History.back = function(queue){
			//History.debug('History.back: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.back: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.back,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.back(false);
			});

			// Go back
			history.go(-1);

			// End back closure
			return true;
		};

		/**
		 * History.forward(queue)
		 * Send the browser history forward one item
		 * @param {Integer} queue [optional]
		 */
		History.forward = function(queue){
			//History.debug('History.forward: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.forward: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.forward,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.forward(false);
			});

			// Go forward
			history.go(1);

			// End forward closure
			return true;
		};

		/**
		 * History.go(index,queue)
		 * Send the browser history back or forward index times
		 * @param {Integer} queue [optional]
		 */
		History.go = function(index,queue){
			//History.debug('History.go: called', arguments);

			// Prepare
			var i;

			// Handle
			if ( index > 0 ) {
				// Forward
				for ( i=1; i<=index; ++i ) {
					History.forward(queue);
				}
			}
			else if ( index < 0 ) {
				// Backward
				for ( i=-1; i>=index; --i ) {
					History.back(queue);
				}
			}
			else {
				throw new Error('History.go: History.go requires a positive or negative integer passed.');
			}

			// Chain
			return History;
		};


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * Provide Skeleton for HTML4 Browsers
			 */

			// Prepare
			var emptyFunction = function(){};
			History.pushState = History.pushState||emptyFunction;
			History.replaceState = History.replaceState||emptyFunction;
		} // History.emulated.pushState

		// Native pushState Implementation
		else {
			/*
			 * Use native HTML5 History API Implementation
			 */

			/**
			 * History.onPopState(event,extra)
			 * Refresh the Current State
			 */
			History.onPopState = function(event,extra){
				// Prepare
				var stateId = false, newState = false, currentHash, currentState;

				// Reset the double check
				History.doubleCheckComplete();

				// Check for a Hash, and handle apporiatly
				currentHash	= History.getHash();
				if ( currentHash ) {
					// Expand Hash
					currentState = History.extractState(currentHash||document.location.href,true);
					if ( currentState ) {
						// We were able to parse it, it must be a State!
						// Let's forward to replaceState
						//History.debug('History.onPopState: state anchor', currentHash, currentState);
						History.replaceState(currentState.data, currentState.title, currentState.url, false);
					}
					else {
						// Traditional Anchor
						//History.debug('History.onPopState: traditional anchor', currentHash);
						History.Adapter.trigger(window,'anchorchange');
						History.busy(false);
					}

					// We don't care for hashes
					History.expectedStateId = false;
					return false;
				}

				// Ensure
				stateId = History.Adapter.extractEventData('state',event,extra) || false;

				// Fetch State
				if ( stateId ) {
					// Vanilla: Back/forward button was used
					newState = History.getStateById(stateId);
				}
				else if ( History.expectedStateId ) {
					// Vanilla: A new state was pushed, and popstate was called manually
					newState = History.getStateById(History.expectedStateId);
				}
				else {
					// Initial State
					newState = History.extractState(document.location.href);
				}

				// The State did not exist in our store
				if ( !newState ) {
					// Regenerate the State
					newState = History.createStateObject(null,null,document.location.href);
				}

				// Clean
				History.expectedStateId = false;

				// Check if we are the same state
				if ( History.isLastSavedState(newState) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onPopState: no change', newState, History.savedStates);
					History.busy(false);
					return false;
				}

				// Store the State
				History.storeState(newState);
				History.saveState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Fire Our Event
				History.Adapter.trigger(window,'statechange');
				History.busy(false);

				// Return true
				return true;
			};
			History.Adapter.bind(window,'popstate',History.onPopState);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.pushState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.replaceState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End replaceState closure
				return true;
			};

		} // !History.emulated.pushState


		// ====================================================================
		// Initialise

		/**
		 * Load the Store
		 */
		if ( sessionStorage ) {
			// Fetch
			try {
				History.store = JSON.parse(sessionStorage.getItem('History.store'))||{};
			}
			catch ( err ) {
				History.store = {};
			}

			// Normalize
			History.normalizeStore();
		}
		else {
			// Default Load
			History.store = {};
			History.normalizeStore();
		}

		/**
		 * Clear Intervals on exit to prevent memory leaks
		 */
		History.Adapter.bind(window,"beforeunload",History.clearAllIntervals);
		History.Adapter.bind(window,"unload",History.clearAllIntervals);

		/**
		 * Create the initial State
		 */
		History.saveState(History.storeState(History.extractState(document.location.href,true)));

		/**
		 * Bind for Saving Store
		 */
		if ( sessionStorage ) {
			// When the page is closed
			History.onUnload = function(){
				// Prepare
				var	currentStore, item;

				// Fetch
				try {
					currentStore = JSON.parse(sessionStorage.getItem('History.store'))||{};
				}
				catch ( err ) {
					currentStore = {};
				}

				// Ensure
				currentStore.idToState = currentStore.idToState || {};
				currentStore.urlToId = currentStore.urlToId || {};
				currentStore.stateToId = currentStore.stateToId || {};

				// Sync
				for ( item in History.idToState ) {
					if ( !History.idToState.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.idToState[item] = History.idToState[item];
				}
				for ( item in History.urlToId ) {
					if ( !History.urlToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.urlToId[item] = History.urlToId[item];
				}
				for ( item in History.stateToId ) {
					if ( !History.stateToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.stateToId[item] = History.stateToId[item];
				}

				// Update
				History.store = currentStore;
				History.normalizeStore();

				// Store
				sessionStorage.setItem('History.store',JSON.stringify(currentStore));
			};

			// For Internet Explorer
			History.intervalList.push(setInterval(History.onUnload,History.options.storeInterval));

			// For Other Browsers
			History.Adapter.bind(window,'beforeunload',History.onUnload);
			History.Adapter.bind(window,'unload',History.onUnload);

			// Both are enabled for consistency
		}

		// Non-Native pushState Implementation
		if ( !History.emulated.pushState ) {
			// Be aware, the following is only for native pushState implementations
			// If you are wanting to include something for all browsers
			// Then include it above this if block

			/**
			 * Setup Safari Fix
			 */
			if ( History.bugs.safariPoll ) {
				History.intervalList.push(setInterval(History.safariStatePoll, History.options.safariPollInterval));
			}

			/**
			 * Ensure Cross Browser Compatibility
			 */
			if ( navigator.vendor === 'Apple Computer, Inc.' || (navigator.appCodeName||'') === 'Mozilla' ) {
				/**
				 * Fix Safari HashChange Issue
				 */

				// Setup Alias
				History.Adapter.bind(window,'hashchange',function(){
					History.Adapter.trigger(window,'popstate');
				});

				// Initialise Alias
				if ( History.getHash() ) {
					History.Adapter.onDomLoad(function(){
						History.Adapter.trigger(window,'hashchange');
					});
				}
			}

		} // !History.emulated.pushState


	}; // History.initCore

	// Try and Initialise History
	History.init();

})(window);
var timestamps = []; // Array of unique timestamps.

$.fn.route = function(options) {

	if (this.is("a")) {

		var customTitle = this.attr('custom-title');
		var title = this.attr('title');

		// Override title
		if (customTitle) {
			title = customTitle;
		}

		if (title) {
			var appendTitle = $.joomla.appendTitle;

			if (appendTitle === "before") {
				title = $.joomla.sitename + ((title) ? " - " + title : "");
			}

			if (appendTitle === "after") {
				title = ((title) ? title + " - " : "") + $.joomla.sitename;
			}
		} else {

			// Try to get the page title from document
			title = $(document).find('title').text();
		}

		// Creating a unique timestamp that will be associated with the state.
		var t = new Date().getTime();
		timestamps[t] = t;

		History.pushState($.extend({timestamp: t, refresh: true}, options), title , this.attr("href"));
	}

	return this;
}

History.Adapter.bind(window,'statechange',function(){

	var state = History.getState();

	// Fixed back button not refreshing when
	// state is in the first state in navigation history.
	if (state.id===History.savedStates[0].id) {
		window.location = state.url;
	}

	if(state.data.timestamp in timestamps) {
		// Deleting the unique timestamp associated with the state
		delete timestamps[state.data.timestamp];
	}
	else{
		if (state.data.refresh) {
			window.location = state.url;
		}
	}
});
};

exports();
module.resolveWith(exports);

// module body: end

};
// module factory: end

FD40.module("history", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

/**
* jquery.Image
* Image helper for jQuery.
* https://github.com/jstonne/jquery.Image
*
* Copyright (c) 2012 Jensen Tonne
* www.jstonne.com
*
* Dual licensed under the MIT and GPL licenses:
* http://www.opensource.org/licenses/mit-license.php
* http://www.gnu.org/licenses/gpl.html
*
*/

$.fn.image = function(method) {
	var method = $.Image[method];
	return method && method.apply(this[0], $.makeArray(arguments).slice(1));
}

$.Image = {

	get: function(url) {

		var existingImage = this.nodeName==="IMG";

		var image = $(existingImage ? this : new Image()),
			imageLoader = $.Deferred();

		image
			.load(function() {

				var w, h, r, o;

				if (!existingImage) { image.appendTo("body"); }

				var data = {
					width: w = image.width(),
					height: h = image.height(),
					aspectRatio: r = w / h,
					orientation: o = (r===1) ? "square" : (r<1) ? "tall" : "wide"
				}	

				image
					.css({
						position: "absolute",
						left: "-99999px"
					})
					.data(data)
					.addClass("orientation-" + o)
					.removeAttr("style");

				if (!existingImage) {
					image.detach();
				}

				imageLoader.resolve(image, data);
			})
			.error(function(){

				imageLoader.reject();
			})
			.attr("src", url);

		return imageLoader;
	},

	aspectRatio: function(width, height) {

		// Normalize values
		if ($.isPlainObject(width)) {
			width  = width.width;
			height = width.height;
		}

		return width / height;
	},

	orientation: function(width, height) {

		// Normalize values
		if ($.isPlainObject(width)) {
			width  = width.width;
			height = width.height;
		}

		if (width===height) return "square";

		if (width > height) return "wide";

		return "tall";
	},

	resizeProportionate: function(sourceWidth, sourceHeight, maxWidth, maxHeight, mode) {

		var targetWidth = sourceWidth,
			targetHeight = sourceHeight;

		// Resize the width first
		var ratio        = maxWidth / sourceWidth;
			targetWidth  = sourceWidth  * ratio;
			targetHeight = sourceHeight * ratio;


		// inner resize (default)
		var condition = targetHeight > maxHeight;

		// outer resize
		if (mode=="outer") {
			condition = targetHeight < maxHeight;
		}

		if (condition) {
			ratio        = maxHeight / sourceHeight;
			targetWidth  = sourceWidth  * ratio;
			targetHeight = sourceHeight * ratio;
		}

		return {
			top   : (maxHeight - targetHeight) / 2,
			left  : (maxWidth - targetWidth) / 2,
			width : targetWidth,
			height: targetHeight
		};
	},

	resizeWithin: function(sourceWidth, sourceHeight, maxWidth, maxHeight) {

		return $.Image.resizeProportionate(
			sourceWidth,
			sourceHeight,
			maxWidth,
			maxHeight,
			"inner"
		);
	},

	resizeToFill: function(sourceWidth, sourceHeight, maxWidth, maxHeight) {

		return $.Image.resizeProportionate(
			sourceWidth,
			sourceHeight,
			maxWidth,
			maxHeight,
			"outer"
		);
	}
};

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("image", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var jQuery = $;
var exports = function() {

/* @preserve
 * Leaflet 1.4.0+Detached: 3337f36d2a2d2b33946779057619b31f674ff5dc.3337f36, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2018 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['leaflet'], factory);
	} else if (typeof modules === 'object' && module.exports) {
		// define a Common JS module that relies on 'leaflet'
		module.exports = factory(require('leaflet'));
	} else {
		// Assume Leaflet is loaded into global object L already
		factory(L);
	}
}(this, function (L) {
	'use strict';

	L.TileLayer.Provider = L.TileLayer.extend({
		initialize: function (arg, options) {
			var providers = L.TileLayer.Provider.providers;

			var parts = arg.split('.');

			var providerName = parts[0];
			var variantName = parts[1];

			if (!providers[providerName]) {
				throw 'No such provider (' + providerName + ')';
			}

			var provider = {
				url: providers[providerName].url,
				options: providers[providerName].options
			};

			// overwrite values in provider from variant.
			if (variantName && 'variants' in providers[providerName]) {
				if (!(variantName in providers[providerName].variants)) {
					throw 'No such variant of ' + providerName + ' (' + variantName + ')';
				}
				var variant = providers[providerName].variants[variantName];
				var variantOptions;
				if (typeof variant === 'string') {
					variantOptions = {
						variant: variant
					};
				} else {
					variantOptions = variant.options;
				}
				provider = {
					url: variant.url || provider.url,
					options: L.Util.extend({}, provider.options, variantOptions)
				};
			}

			// replace attribution placeholders with their values from toplevel provider attribution,
			// recursively
			var attributionReplacer = function (attr) {
				if (attr.indexOf('{attribution.') === -1) {
					return attr;
				}
				return attr.replace(/\{attribution.(\w*)\}/,
					function (match, attributionName) {
						return attributionReplacer(providers[attributionName].options.attribution);
					}
				);
			};
			provider.options.attribution = attributionReplacer(provider.options.attribution);

			// Compute final options combining provider options with any user overrides
			var layerOpts = L.Util.extend({}, provider.options, options);
			L.TileLayer.prototype.initialize.call(this, provider.url, layerOpts);
		}
	});

	/**
	 * Definition of providers.
	 * see http://leafletjs.com/reference.html#tilelayer for options in the options map.
	 */

	L.TileLayer.Provider.providers = {
		OpenStreetMap: {
			url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution:
					'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
			},
			variants: {
				Mapnik: {},
				BlackAndWhite: {
					url: 'https://tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png',
					options: {
						maxZoom: 18
					}
				},
				DE: {
					url: 'https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png',
					options: {
						maxZoom: 18
					}
				},
				CH: {
					url: 'https://tile.osm.ch/switzerland/{z}/{x}/{y}.png',
					options: {
						maxZoom: 18,
						bounds: [[45, 5], [48, 11]]
					}
				},
				France: {
					url: 'https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
					options: {
						maxZoom: 20,
						attribution: '&copy; Openstreetmap France | {attribution.OpenStreetMap}'
					}
				},
				HOT: {
					url: 'https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png',
					options: {
						attribution:
							'{attribution.OpenStreetMap}, ' +
							'Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> ' +
							'hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>'
					}
				},
				BZH: {
					url: 'https://tile.openstreetmap.bzh/br/{z}/{x}/{y}.png',
					options: {
						attribution: '{attribution.OpenStreetMap}, Tiles courtesy of <a href="http://www.openstreetmap.bzh/" target="_blank">Breton OpenStreetMap Team</a>',
						bounds: [[46.2, -5.5], [50, 0.7]]
					}
				}
			}
		},
		OpenSeaMap: {
			url: 'https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png',
			options: {
				attribution: 'Map data: &copy; <a href="http://www.openseamap.org">OpenSeaMap</a> contributors'
			}
		},
		OpenPtMap: {
			url: 'http://openptmap.org/tiles/{z}/{x}/{y}.png',
			options: {
				maxZoom: 17,
				attribution: 'Map data: &copy; <a href="http://www.openptmap.org">OpenPtMap</a> contributors'
			}
		},
		OpenTopoMap: {
			url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
			options: {
				maxZoom: 17,
				attribution: 'Map data: {attribution.OpenStreetMap}, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		OpenRailwayMap: {
			url: 'https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution: 'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="https://www.OpenRailwayMap.org">OpenRailwayMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		OpenFireMap: {
			url: 'http://openfiremap.org/hytiles/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution: 'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="http://www.openfiremap.org">OpenFireMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		SafeCast: {
			url: 'https://s3.amazonaws.com/te512.safecast.org/{z}/{x}/{y}.png',
			options: {
				maxZoom: 16,
				attribution: 'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="https://blog.safecast.org/about/">SafeCast</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		Thunderforest: {
			url: 'https://{s}.tile.thunderforest.com/{variant}/{z}/{x}/{y}.png?apikey={apikey}',
			options: {
				attribution:
					'&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, {attribution.OpenStreetMap}',
				variant: 'cycle',
				apikey: '<insert your api key here>',
				maxZoom: 22
			},
			variants: {
				OpenCycleMap: 'cycle',
				Transport: {
					options: {
						variant: 'transport'
					}
				},
				TransportDark: {
					options: {
						variant: 'transport-dark'
					}
				},
				SpinalMap: {
					options: {
						variant: 'spinal-map'
					}
				},
				Landscape: 'landscape',
				Outdoors: 'outdoors',
				Pioneer: 'pioneer'
			}
		},
		OpenMapSurfer: {
			url: 'https://maps.heigit.org/openmapsurfer/tiles/{variant}/webmercator/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				variant: 'roads',
				attribution: 'Imagery from <a href="http://giscience.uni-hd.de/">GIScience Research Group @ University of Heidelberg</a> &mdash; Map data {attribution.OpenStreetMap}'
			},
			variants: {
				Roads: 'roads',
				AdminBounds: {
					options: {
						variant: 'adminb',
						maxZoom: 18
					}
				}
			}
		},
		Hydda: {
			url: 'https://{s}.tile.openstreetmap.se/hydda/{variant}/{z}/{x}/{y}.png',
			options: {
				maxZoom: 18,
				variant: 'full',
				attribution: 'Tiles courtesy of <a href="http://openstreetmap.se/" target="_blank">OpenStreetMap Sweden</a> &mdash; Map data {attribution.OpenStreetMap}'
			},
			variants: {
				Full: 'full',
				Base: 'base',
				RoadsAndLabels: 'roads_and_labels'
			}
		},
		MapBox: {
			url: 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}{r}.png?access_token={accessToken}',
			options: {
				attribution:
					'<a href="https://www.mapbox.com/about/maps/" target="_blank">&copy; Mapbox</a> ' +
					'{attribution.OpenStreetMap} ' +
					'<a href="https://www.mapbox.com/map-feedback/" target="_blank">Improve this map</a>',
				subdomains: 'abcd',
				id: 'mapbox.streets',
				accessToken: '<insert your access token here>',
			}
		},
		Stamen: {
			url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/{variant}/{z}/{x}/{y}{r}.{ext}',
			options: {
				attribution:
					'Map tiles by <a href="http://stamen.com">Stamen Design</a>, ' +
					'<a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; ' +
					'Map data {attribution.OpenStreetMap}',
				subdomains: 'abcd',
				minZoom: 0,
				maxZoom: 20,
				variant: 'toner',
				ext: 'png'
			},
			variants: {
				Toner: 'toner',
				TonerBackground: 'toner-background',
				TonerHybrid: 'toner-hybrid',
				TonerLines: 'toner-lines',
				TonerLabels: 'toner-labels',
				TonerLite: 'toner-lite',
				Watercolor: {
					url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/{variant}/{z}/{x}/{y}.{ext}',
					options: {
						variant: 'watercolor',
						ext: 'jpg',
						minZoom: 1,
						maxZoom: 16
					}
				},
				Terrain: {
					options: {
						variant: 'terrain',
						minZoom: 0,
						maxZoom: 18
					}
				},
				TerrainBackground: {
					options: {
						variant: 'terrain-background',
						minZoom: 0,
						maxZoom: 18
					}
				},
				TopOSMRelief: {
					url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/{variant}/{z}/{x}/{y}.{ext}',
					options: {
						variant: 'toposm-color-relief',
						ext: 'jpg',
						bounds: [[22, -132], [51, -56]]
					}
				},
				TopOSMFeatures: {
					options: {
						variant: 'toposm-features',
						bounds: [[22, -132], [51, -56]],
						opacity: 0.9
					}
				}
			}
		},
		Esri: {
			url: 'https://server.arcgisonline.com/ArcGIS/rest/services/{variant}/MapServer/tile/{z}/{y}/{x}',
			options: {
				variant: 'World_Street_Map',
				attribution: 'Tiles &copy; Esri'
			},
			variants: {
				WorldStreetMap: {
					options: {
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012'
					}
				},
				DeLorme: {
					options: {
						variant: 'Specialty/DeLorme_World_Base_Map',
						minZoom: 1,
						maxZoom: 11,
						attribution: '{attribution.Esri} &mdash; Copyright: &copy;2012 DeLorme'
					}
				},
				WorldTopoMap: {
					options: {
						variant: 'World_Topo_Map',
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
					}
				},
				WorldImagery: {
					options: {
						variant: 'World_Imagery',
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
					}
				},
				WorldTerrain: {
					options: {
						variant: 'World_Terrain_Base',
						maxZoom: 13,
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Source: USGS, Esri, TANA, DeLorme, and NPS'
					}
				},
				WorldShadedRelief: {
					options: {
						variant: 'World_Shaded_Relief',
						maxZoom: 13,
						attribution: '{attribution.Esri} &mdash; Source: Esri'
					}
				},
				WorldPhysical: {
					options: {
						variant: 'World_Physical_Map',
						maxZoom: 8,
						attribution: '{attribution.Esri} &mdash; Source: US National Park Service'
					}
				},
				OceanBasemap: {
					options: {
						variant: 'Ocean_Basemap',
						maxZoom: 13,
						attribution: '{attribution.Esri} &mdash; Sources: GEBCO, NOAA, CHS, OSU, UNH, CSUMB, National Geographic, DeLorme, NAVTEQ, and Esri'
					}
				},
				NatGeoWorldMap: {
					options: {
						variant: 'NatGeo_World_Map',
						maxZoom: 16,
						attribution: '{attribution.Esri} &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC'
					}
				},
				WorldGrayCanvas: {
					options: {
						variant: 'Canvas/World_Light_Gray_Base',
						maxZoom: 16,
						attribution: '{attribution.Esri} &mdash; Esri, DeLorme, NAVTEQ'
					}
				}
			}
		},
		OpenWeatherMap: {
			url: 'http://{s}.tile.openweathermap.org/map/{variant}/{z}/{x}/{y}.png?appid={apiKey}',
			options: {
				maxZoom: 19,
				attribution: 'Map data &copy; <a href="http://openweathermap.org">OpenWeatherMap</a>',
				apiKey:'<insert your api key here>',
				opacity: 0.5
			},
			variants: {
				Clouds: 'clouds',
				CloudsClassic: 'clouds_cls',
				Precipitation: 'precipitation',
				PrecipitationClassic: 'precipitation_cls',
				Rain: 'rain',
				RainClassic: 'rain_cls',
				Pressure: 'pressure',
				PressureContour: 'pressure_cntr',
				Wind: 'wind',
				Temperature: 'temp',
				Snow: 'snow'
			}
		},
		HERE: {
			/*
			 * HERE maps, formerly Nokia maps.
			 * These basemaps are free, but you need an API key. Please sign up at
			 * https://developer.here.com/plans
			 */
			url:
				'https://{s}.{base}.maps.api.here.com/maptile/2.1/' +
				'{type}/{mapID}/{variant}/{z}/{x}/{y}/{size}/{format}?' +
				'app_id={app_id}&app_code={app_code}&lg={language}',
			options: {
				attribution:
					'Map &copy; 1987-' + new Date().getFullYear() + ' <a href="http://developer.here.com">HERE</a>',
				subdomains: '1234',
				mapID: 'newest',
				'app_id': '<insert your app_id here>',
				'app_code': '<insert your app_code here>',
				base: 'base',
				variant: 'normal.day',
				maxZoom: 20,
				type: 'maptile',
				language: 'eng',
				format: 'png8',
				size: '256'
			},
			variants: {
				normalDay: 'normal.day',
				normalDayCustom: 'normal.day.custom',
				normalDayGrey: 'normal.day.grey',
				normalDayMobile: 'normal.day.mobile',
				normalDayGreyMobile: 'normal.day.grey.mobile',
				normalDayTransit: 'normal.day.transit',
				normalDayTransitMobile: 'normal.day.transit.mobile',
				normalNight: 'normal.night',
				normalNightMobile: 'normal.night.mobile',
				normalNightGrey: 'normal.night.grey',
				normalNightGreyMobile: 'normal.night.grey.mobile',
				normalNightTransit: 'normal.night.transit',
				normalNightTransitMobile: 'normal.night.transit.mobile',
				reducedDay: 'reduced.day',
				reducedNight: 'reduced.night',
				basicMap: {
					options: {
						type: 'basetile'
					}
				},
				mapLabels: {
					options: {
						type: 'labeltile',
						format: 'png'
					}
				},
				trafficFlow: {
					options: {
						base: 'traffic',
						type: 'flowtile'
					}
				},
				carnavDayGrey: 'carnav.day.grey',
				hybridDay: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day'
					}
				},
				hybridDayMobile: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day.mobile'
					}
				},
				hybridDayTransit: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day.transit'
					}
				},
				hybridDayGrey: {
					options: {
						base: 'aerial',
						variant: 'hybrid.grey.day'
					}
				},
				pedestrianDay: 'pedestrian.day',
				pedestrianNight: 'pedestrian.night',
				satelliteDay: {
					options: {
						base: 'aerial',
						variant: 'satellite.day'
					}
				},
				terrainDay: {
					options: {
						base: 'aerial',
						variant: 'terrain.day'
					}
				},
				terrainDayMobile: {
					options: {
						base: 'aerial',
						variant: 'terrain.day.mobile'
					}
				}
			}
		},
		FreeMapSK: {
			url: 'http://t{s}.freemap.sk/T/{z}/{x}/{y}.jpeg',
			options: {
				minZoom: 8,
				maxZoom: 16,
				subdomains: '1234',
				bounds: [[47.204642, 15.996093], [49.830896, 22.576904]],
				attribution:
					'{attribution.OpenStreetMap}, vizualization CC-By-SA 2.0 <a href="http://freemap.sk">Freemap.sk</a>'
			}
		},
		MtbMap: {
			url: 'http://tile.mtbmap.cz/mtbmap_tiles/{z}/{x}/{y}.png',
			options: {
				attribution:
					'{attribution.OpenStreetMap} &amp; USGS'
			}
		},
		CartoDB: {
			url: 'https://{s}.basemaps.cartocdn.com/{variant}/{z}/{x}/{y}{r}.png',
			options: {
				attribution: '{attribution.OpenStreetMap} &copy; <a href="https://carto.com/attributions">CARTO</a>',
				subdomains: 'abcd',
				maxZoom: 19,
				variant: 'light_all'
			},
			variants: {
				Positron: 'light_all',
				PositronNoLabels: 'light_nolabels',
				PositronOnlyLabels: 'light_only_labels',
				DarkMatter: 'dark_all',
				DarkMatterNoLabels: 'dark_nolabels',
				DarkMatterOnlyLabels: 'dark_only_labels',
				Voyager: 'rastertiles/voyager',
				VoyagerNoLabels: 'rastertiles/voyager_nolabels',
				VoyagerOnlyLabels: 'rastertiles/voyager_only_labels',
				VoyagerLabelsUnder: 'rastertiles/voyager_labels_under'
			}
		},
		HikeBike: {
			url: 'https://tiles.wmflabs.org/{variant}/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution: '{attribution.OpenStreetMap}',
				variant: 'hikebike'
			},
			variants: {
				HikeBike: {},
				HillShading: {
					options: {
						maxZoom: 15,
						variant: 'hillshading'
					}
				}
			}
		},
		BasemapAT: {
			url: 'https://maps{s}.wien.gv.at/basemap/{variant}/normal/google3857/{z}/{y}/{x}.{format}',
			options: {
				maxZoom: 19,
				attribution: 'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
				subdomains: ['', '1', '2', '3', '4'],
				format: 'png',
				bounds: [[46.358770, 8.782379], [49.037872, 17.189532]],
				variant: 'geolandbasemap'
			},
			variants: {
				basemap: {
					options: {
						maxZoom: 20, // currently only in Vienna
						variant: 'geolandbasemap'
					}
				},
				grau: 'bmapgrau',
				overlay: 'bmapoverlay',
				highdpi: {
					options: {
						variant: 'bmaphidpi',
						format: 'jpeg'
					}
				},
				orthofoto: {
					options: {
						maxZoom: 20, // currently only in Vienna
						variant: 'bmaporthofoto30cm',
						format: 'jpeg'
					}
				}
			}
		},
		nlmaps: {
			url: 'https://geodata.nationaalgeoregister.nl/tiles/service/wmts/{variant}/EPSG:3857/{z}/{x}/{y}.png',
			options: {
				minZoom: 6,
				maxZoom: 19,
				bounds: [[50.5, 3.25], [54, 7.6]],
				attribution: 'Kaartgegevens &copy; <a href="kadaster.nl">Kadaster</a>'
			},
			variants: {
				'standaard': 'brtachtergrondkaart',
				'pastel': 'brtachtergrondkaartpastel',
				'grijs': 'brtachtergrondkaartgrijs',
				'luchtfoto': {
					'url': 'https://geodata.nationaalgeoregister.nl/luchtfoto/rgb/wmts/1.0.0/2016_ortho25/EPSG:3857/{z}/{x}/{y}.png',
				}
			}
		},
		NASAGIBS: {
			url: 'https://map1.vis.earthdata.nasa.gov/wmts-webmerc/{variant}/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}',
			options: {
				attribution:
					'Imagery provided by services from the Global Imagery Browse Services (GIBS), operated by the NASA/GSFC/Earth Science Data and Information System ' +
					'(<a href="https://earthdata.nasa.gov">ESDIS</a>) with funding provided by NASA/HQ.',
				bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
				minZoom: 1,
				maxZoom: 9,
				format: 'jpg',
				time: '',
				tilematrixset: 'GoogleMapsCompatible_Level'
			},
			variants: {
				ModisTerraTrueColorCR: 'MODIS_Terra_CorrectedReflectance_TrueColor',
				ModisTerraBands367CR: 'MODIS_Terra_CorrectedReflectance_Bands367',
				ViirsEarthAtNight2012: {
					options: {
						variant: 'VIIRS_CityLights_2012',
						maxZoom: 8
					}
				},
				ModisTerraLSTDay: {
					options: {
						variant: 'MODIS_Terra_Land_Surface_Temp_Day',
						format: 'png',
						maxZoom: 7,
						opacity: 0.75
					}
				},
				ModisTerraSnowCover: {
					options: {
						variant: 'MODIS_Terra_Snow_Cover',
						format: 'png',
						maxZoom: 8,
						opacity: 0.75
					}
				},
				ModisTerraAOD: {
					options: {
						variant: 'MODIS_Terra_Aerosol',
						format: 'png',
						maxZoom: 6,
						opacity: 0.75
					}
				},
				ModisTerraChlorophyll: {
					options: {
						variant: 'MODIS_Terra_Chlorophyll_A',
						format: 'png',
						maxZoom: 7,
						opacity: 0.75
					}
				}
			}
		},
		NLS: {
			// NLS maps are copyright National library of Scotland.
			// http://maps.nls.uk/projects/api/index.html
			// Please contact NLS for anything other than non-commercial low volume usage
			//
			// Map sources: Ordnance Survey 1:1m to 1:63K, 1920s-1940s
			//   z0-9  - 1:1m
			//  z10-11 - quarter inch (1:253440)
			//  z12-18 - one inch (1:63360)
			url: 'https://nls-{s}.tileserver.com/nls/{z}/{x}/{y}.jpg',
			options: {
				attribution: '<a href="http://geo.nls.uk/maps/">National Library of Scotland Historic Maps</a>',
				bounds: [[49.6, -12], [61.7, 3]],
				minZoom: 1,
				maxZoom: 18,
				subdomains: '0123',
			}
		},
		JusticeMap: {
			// Justice Map (http://www.justicemap.org/)
			// Visualize race and income data for your community, county and country.
			// Includes tools for data journalists, bloggers and community activists.
			url: 'http://www.justicemap.org/tile/{size}/{variant}/{z}/{x}/{y}.png',
			options: {
				attribution: '<a href="http://www.justicemap.org/terms.php">Justice Map</a>',
				// one of 'county', 'tract', 'block'
				size: 'county',
				// Bounds for USA, including Alaska and Hawaii
				bounds: [[14, -180], [72, -56]]
			},
			variants: {
				income: 'income',
				americanIndian: 'indian',
				asian: 'asian',
				black: 'black',
				hispanic: 'hispanic',
				multi: 'multi',
				nonWhite: 'nonwhite',
				white: 'white',
				plurality: 'plural'
			}
		},
		Wikimedia: {
			url: 'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}{r}.png',
			options: {
				attribution: '<a href="https://wikimediafoundation.org/wiki/Maps_Terms_of_Use">Wikimedia</a>',
				minZoom: 1,
				maxZoom: 19
			}
		},
		GeoportailFrance: {
			url: 'https://wxs.ign.fr/{apikey}/geoportail/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE={style}&TILEMATRIXSET=PM&FORMAT={format}&LAYER={variant}&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}',
			options: {
				attribution: '<a target="_blank" href="https://www.geoportail.gouv.fr/">Geoportail France</a>',
				bounds: [[-75, -180], [81, 180]],
				minZoom: 2,
				maxZoom: 18,
				// Get your own geoportail apikey here : http://professionnels.ign.fr/ign/contrats/
				// NB : 'choisirgeoportail' is a demonstration key that comes with no guarantee
				apikey: 'choisirgeoportail',
				format: 'image/jpeg',
				style : 'normal',
				variant: 'GEOGRAPHICALGRIDSYSTEMS.MAPS.SCAN-EXPRESS.STANDARD'
			},
			variants: {
				parcels: {
					options : {
						variant: 'CADASTRALPARCELS.PARCELS',
						maxZoom: 20,
						style : 'bdparcellaire',
						format: 'image/png'
					}
				},
				ignMaps: 'GEOGRAPHICALGRIDSYSTEMS.MAPS',
				maps: 'GEOGRAPHICALGRIDSYSTEMS.MAPS.SCAN-EXPRESS.STANDARD',
				orthos: {
					options: {
						maxZoom: 19,
						variant: 'ORTHOIMAGERY.ORTHOPHOTOS'
					}
				}
			}
		},
		OneMapSG: {
			url: 'https://maps-{s}.onemap.sg/v3/{variant}/{z}/{x}/{y}.png',
			options: {
				variant: 'Default',
				minZoom: 11,
				maxZoom: 18,
				bounds: [[1.56073, 104.11475], [1.16, 103.502]],
				attribution: '<img src="https://docs.onemap.sg/maps/images/oneMap64-01.png" style="height:20px;width:20px;"/> New OneMap | Map data &copy; contributors, <a href="http://SLA.gov.sg">Singapore Land Authority</a>'
			},
			variants: {
				Default: 'Default',
				Night: 'Night',
				Original: 'Original',
				Grey: 'Grey',
				LandLot: 'LandLot'
			}
		}
	};

	L.tileLayer.provider = function (provider, options) {
		return new L.TileLayer.Provider(provider, options);
	};

	return L;
}));

};

exports();
module.resolveWith(exports);
};
// module factory: end

FD40.module("leaflet-providers", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var jQuery = $;
var exports = function() {

/* @preserve
 * Leaflet 1.4.0+Detached: 3337f36d2a2d2b33946779057619b31f674ff5dc.3337f36, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2018 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.L = {})));
}(this, (function (exports) { 'use strict';

var version = "1.4.0+HEAD.3337f36";

/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

var freeze = Object.freeze;
Object.freeze = function (obj) { return obj; };

// @function extend(dest: Object, src?: Object): Object
// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
function extend(dest) {
	var i, j, len, src;

	for (j = 1, len = arguments.length; j < len; j++) {
		src = arguments[j];
		for (i in src) {
			dest[i] = src[i];
		}
	}
	return dest;
}

// @function create(proto: Object, properties?: Object): Object
// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
var create = Object.create || (function () {
	function F() {}
	return function (proto) {
		F.prototype = proto;
		return new F();
	};
})();

// @function bind(fn: Function, ): Function
// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
// Has a `L.bind()` shortcut.
function bind(fn, obj) {
	var slice = Array.prototype.slice;

	if (fn.bind) {
		return fn.bind.apply(fn, slice.call(arguments, 1));
	}

	var args = slice.call(arguments, 2);

	return function () {
		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
	};
}

// @property lastId: Number
// Last unique ID used by [`stamp()`](#util-stamp)
var lastId = 0;

// @function stamp(obj: Object): Number
// Returns the unique ID of an object, assigning it one if it doesn't have it.
function stamp(obj) {
	/*eslint-disable */
	obj._leaflet_id = obj._leaflet_id || ++lastId;
	return obj._leaflet_id;
	/* eslint-enable */
}

// @function throttle(fn: Function, time: Number, context: Object): Function
// Returns a function which executes function `fn` with the given scope `context`
// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
// `fn` will be called no more than one time per given amount of `time`. The arguments
// received by the bound function will be any arguments passed when binding the
// function, followed by any arguments passed when invoking the bound function.
// Has an `L.throttle` shortcut.
function throttle(fn, time, context) {
	var lock, args, wrapperFn, later;

	later = function () {
		// reset lock and call if queued
		lock = false;
		if (args) {
			wrapperFn.apply(context, args);
			args = false;
		}
	};

	wrapperFn = function () {
		if (lock) {
			// called too soon, queue to call later
			args = arguments;

		} else {
			// call and lock until later
			fn.apply(context, arguments);
			setTimeout(later, time);
			lock = true;
		}
	};

	return wrapperFn;
}

// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
// Returns the number `num` modulo `range` in such a way so it lies within
// `range[0]` and `range[1]`. The returned value will be always smaller than
// `range[1]` unless `includeMax` is set to `true`.
function wrapNum(x, range, includeMax) {
	var max = range[1],
		min = range[0],
		d = max - min;
	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
}

// @function falseFn(): Function
// Returns a function which always returns `false`.
function falseFn() { return false; }

// @function formatNum(num: Number, digits?: Number): Number
// Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
function formatNum(num, digits) {
	var pow = Math.pow(10, (digits === undefined ? 6 : digits));
	return Math.round(num * pow) / pow;
}

// @function trim(str: String): String
// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
function trim(str) {
	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
function splitWords(str) {
	return trim(str).split(/\s+/);
}

// @function setOptions(obj: Object, options: Object): Object
// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
function setOptions(obj, options) {
	if (!obj.hasOwnProperty('options')) {
		obj.options = obj.options ? create(obj.options) : {};
	}
	for (var i in options) {
		obj.options[i] = options[i];
	}
	return obj.options;
}

// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
// be appended at the end. If `uppercase` is `true`, the parameter names will
// be uppercased (e.g. `'?A=foo&B=bar'`)
function getParamString(obj, existingUrl, uppercase) {
	var params = [];
	for (var i in obj) {
		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
	}
	return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
}

var templateRe = /\{ *([\w_-]+) *\}/g;

// @function template(str: String, data: Object): String
// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
// `('Hello foo, bar')`. You can also specify functions instead of strings for
// data values  they will be evaluated passing `data` as an argument.
function template(str, data) {
	return str.replace(templateRe, function (str, key) {
		var value = data[key];

		if (value === undefined) {
			throw new Error('No value provided for variable ' + str);

		} else if (typeof value === 'function') {
			value = value(data);
		}
		return value;
	});
}

// @function isArray(obj): Boolean
// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
var isArray = Array.isArray || function (obj) {
	return (Object.prototype.toString.call(obj) === '[object Array]');
};

// @function indexOf(array: Array, el: Object): Number
// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
function indexOf(array, el) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] === el) { return i; }
	}
	return -1;
}

// @property emptyImageUrl: String
// Data URI string containing a base64-encoded empty GIF image.
// Used as a hack to free memory from unused images on WebKit-powered
// mobile devices (by setting image `src` to this string).
var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

function getPrefixed(name) {
	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
}

var lastTime = 0;

// fallback for IE 7-8
function timeoutDefer(fn) {
	var time = +new Date(),
		timeToCall = Math.max(0, 16 - (time - lastTime));

	lastTime = time + timeToCall;
	return window.setTimeout(fn, timeToCall);
}

var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
		getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
// `context` if given. When `immediate` is set, `fn` is called immediately if
// the browser doesn't have native support for
// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
function requestAnimFrame(fn, context, immediate) {
	if (immediate && requestFn === timeoutDefer) {
		fn.call(context);
	} else {
		return requestFn.call(window, bind(fn, context));
	}
}

// @function cancelAnimFrame(id: Number): undefined
// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
function cancelAnimFrame(id) {
	if (id) {
		cancelFn.call(window, id);
	}
}


var Util = (Object.freeze || Object)({
	freeze: freeze,
	extend: extend,
	create: create,
	bind: bind,
	lastId: lastId,
	stamp: stamp,
	throttle: throttle,
	wrapNum: wrapNum,
	falseFn: falseFn,
	formatNum: formatNum,
	trim: trim,
	splitWords: splitWords,
	setOptions: setOptions,
	getParamString: getParamString,
	template: template,
	isArray: isArray,
	indexOf: indexOf,
	emptyImageUrl: emptyImageUrl,
	requestFn: requestFn,
	cancelFn: cancelFn,
	requestAnimFrame: requestAnimFrame,
	cancelAnimFrame: cancelAnimFrame
});

// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

function Class() {}

Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		checkDeprecatedMixinEvents(props.includes);
		extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = extend(create(proto.options), props.options);
	}

	// mix given properties into the prototype
	extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
Class.include = function (props) {
	extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
Class.mergeOptions = function (options) {
	extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};

function checkDeprecatedMixinEvents(includes) {
	if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

	includes = isArray(includes) ? includes : [includes];

	for (var i = 0; i < includes.length; i++) {
		if (includes[i] === L.Mixin.Events) {
			console.warn('Deprecated include of L.Mixin.Events: ' +
				'this property will be removed in future releases, ' +
				'please inherit from L.Evented instead.', new Error().stack);
		}
	}
}

/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */

var Events = {
	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = {fn: fn, ctx: context},
			listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
	},

	_off: function (type, fn, context) {
		var listeners,
			i,
			len;

		if (!this._events) { return; }

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) { continue; }
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object  the first argument of the listener function will contain its
	// properties. The event can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = extend({}, data, {
			type: type,
			target: this,
			sourceTarget: data && data.sourceTarget || this
		});

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = (this._firingCount + 1) || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(): this
	// Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = bind(function () {
			this
				.off(types, fn, context)
				.off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
			.on(types, fn, context)
			.on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, extend({
				layer: e.target,
				propagatedFrom: e.target
			}, e), true);
		}
	}
};

// aliases; we should ditch those eventually

// @method addEventListener(): this
// Alias to [`on()`](#evented-on)
Events.addEventListener = Events.on;

// @method removeEventListener(): this
// Alias to [`off()`](#evented-off)

// @method clearAllEventListeners(): this
// Alias to [`off()`](#evented-off)
Events.removeEventListener = Events.clearAllEventListeners = Events.off;

// @method addOneTimeEventListener(): this
// Alias to [`once()`](#evented-once)
Events.addOneTimeEventListener = Events.once;

// @method fireEvent(): this
// Alias to [`fire()`](#evented-fire)
Events.fireEvent = Events.fire;

// @method hasEventListeners(): Boolean
// Alias to [`listens()`](#evented-listens)
Events.hasEventListeners = Events.listens;

var Evented = Class.extend(Events);

/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 *
 * Note that `Point` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Point(x, y, round) {
	// @property x: Number; The `x` coordinate of the point
	this.x = (round ? Math.round(x) : x);
	// @property y: Number; The `y` coordinate of the point
	this.y = (round ? Math.round(y) : y);
}

var trunc = Math.trunc || function (v) {
	return v > 0 ? Math.floor(v) : Math.ceil(v);
};

Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(toPoint(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(toPoint(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method trunc(): Point
	// Returns a copy of the current point with truncated coordinates (rounded towards zero).
	trunc: function () {
		return this.clone()._trunc();
	},

	_trunc: function () {
		this.x = trunc(this.x);
		this.y = trunc(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = toPoint(point);

		var x = point.x - this.x,
			y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = toPoint(point);

		return point.x === this.x &&
			   point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = toPoint(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
			   Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
				formatNum(this.x) + ', ' +
				formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
function toPoint(x, y, round) {
	if (x instanceof Point) {
		return x;
	}
	if (isArray(x)) {
		return new Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new Point(x.x, x.y);
	}
	return new Point(x, y, round);
}

/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 *
 * Note that `Bounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Bounds(a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
}

Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = toPoint(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new Point(
				(this.min.x + this.max.x) / 2,
				(this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new Point(this.max.x, this.min.y);
	},

	// @method getTopLeft(): Point
	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
	getTopLeft: function () {
		return this.min; // left, top
	},

	// @method getBottomRight(): Point
	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
	getBottomRight: function () {
		return this.max; // right, bottom
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof Point) {
			obj = toPoint(obj);
		} else {
			obj = toBounds(obj);
		}

		if (obj instanceof Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
			   (max.x <= this.max.x) &&
			   (min.y >= this.min.y) &&
			   (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
			max = this.max,
			min2 = bounds.min,
			max2 = bounds.max,
			xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
			yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
			max = this.max,
			min2 = bounds.min,
			max2 = bounds.max,
			xOverlaps = (max2.x > min.x) && (min2.x < max.x),
			yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(corner1: Point, corner2: Point)
// Creates a Bounds object from two corners coordinate pairs.
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the given array of points.
function toBounds(a, b) {
	if (!a || a instanceof Bounds) {
		return a;
	}
	return new Bounds(a, b);
}

/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var corner1 = L.latLng(40.712, -74.227),
 * corner2 = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(corner1, corner2);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 *
 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
 *
 * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
	if (!corner1) { return; }

	var latlngs = corner2 ? [corner1, corner2] : corner1;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
}

LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
			ne = this._northEast,
			sw2, ne2;

		if (obj instanceof LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new LatLng(sw2.lat, sw2.lng);
			this._northEast = new LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
	// Negative values will retract the bounds.
	pad: function (bufferRatio) {
		var sw = this._southWest,
			ne = this._northEast,
			heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
			widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new LatLngBounds(
				new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
				new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new LatLng(
				(this._southWest.lat + this._northEast.lat) / 2,
				(this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
			obj = toLatLng(obj);
		} else {
			obj = toLatLngBounds(obj);
		}

		var sw = this._southWest,
			ne = this._northEast,
			sw2, ne2;

		if (obj instanceof LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
			   (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
			ne = this._northEast,
			sw2 = bounds.getSouthWest(),
			ne2 = bounds.getNorthEast(),

			latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
			lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
			ne = this._northEast,
			sw2 = bounds.getSouthWest(),
			ne2 = bounds.getNorthEast(),

			latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
			lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function (bounds, maxMargin) {
		if (!bounds) { return false; }

		bounds = toLatLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
			   this._northEast.equals(bounds.getNorthEast(), maxMargin);
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
function toLatLngBounds(a, b) {
	if (a instanceof LatLngBounds) {
		return a;
	}
	return new LatLngBounds(a, b);
}

/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 *
 * Note that `LatLng` does not inherit from Leaflet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLng(lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
}

LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = toLatLng(obj);

		var margin = Math.max(
				Math.abs(this.lat - obj.lat),
				Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
				formatNum(this.lat, precision) + ', ' +
				formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
	distanceTo: function (other) {
		return Earth.distance(this, toLatLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
			lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return toLatLngBounds(
				[this.lat - latAccuracy, this.lng - lngAccuracy],
				[this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

function toLatLng(a, b, c) {
	if (a instanceof LatLng) {
		return a;
	}
	if (isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new LatLng(a, b, c);
}

/*
 * @namespace CRS
 * @crs L.CRS.Base
 * Object that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 *
 * Note that the CRS instances do not inherit from Leafet's `Class` object,
 * and can't be instantiated. Also, new classes can't inherit from them,
 * and methods can't be added to them with the `include` function.
 */

var CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
			scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
			untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
			s = this.scale(zoom),
			min = this.transformation.transform(b.min, s),
			max = this.transformation.transform(b.max, s);

		return new Bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
			lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
			alt = latlng.alt;

		return new LatLng(lat, lng, alt);
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring
	// that its center is within the CRS's bounds.
	// Only accepts actual `L.LatLngBounds` instances, not arrays.
	wrapLatLngBounds: function (bounds) {
		var center = bounds.getCenter(),
			newCenter = this.wrapLatLng(center),
			latShift = center.lat - newCenter.lat,
			lngShift = center.lng - newCenter.lng;

		if (latShift === 0 && lngShift === 0) {
			return bounds;
		}

		var sw = bounds.getSouthWest(),
			ne = bounds.getNorthEast(),
			newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
			newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

		return new LatLngBounds(newSw, newNe);
	}
};

/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

var Earth = extend({}, CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
			lat1 = latlng1.lat * rad,
			lat2 = latlng2.lat * rad,
			sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
			sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
			a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
			c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		return this.R * c;
	}
});

/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection  the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

var SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
			max = this.MAX_LATITUDE,
			lat = Math.max(Math.min(max, latlng.lat), -max),
			sin = Math.sin(lat * d);

		return new Point(
			this.R * latlng.lng * d,
			this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return new Bounds([-d, -d], [d, d]);
	})()
};

/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = L.transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
function Transformation(a, b, c, d) {
	if (isArray(a)) {
		// use array properties
		this._a = a[0];
		this._b = a[1];
		this._c = a[2];
		this._d = a[3];
		return;
	}
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
}

Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts actual `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new Point(
				(point.x / scale - this._b) / this._a,
				(point.y / scale - this._d) / this._c);
	}
};

// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
// Instantiates a Transformation object with the given coefficients.

// @alternative
// @factory L.transformation(coefficients: Array): Transformation
// Expects an coefficients array of the form
// `[a: Number, b: Number, c: Number, d: Number]`.

function toTransformation(a, b, c, d) {
	return new Transformation(a, b, c, d);
}

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

var EPSG3857 = extend({}, Earth, {
	code: 'EPSG:3857',
	projection: SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * SphericalMercator.R);
		return toTransformation(scale, 0.5, -scale, 0.5);
	}())
});

var EPSG900913 = extend({}, EPSG3857, {
	code: 'EPSG:900913'
});

// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:

// @function create(name: String): SVGElement
// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
// corresponding to the class name passed. For example, using 'line' will return
// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
function svgCreate(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

// @function pointsToPath(rings: Point[], closed: Boolean): String
// Generates a SVG path string for multiple rings, with each ring turning
// into "M..L..L.." instructions
function pointsToPath(rings, closed) {
	var str = '',
	i, j, len, len2, points, p;

	for (i = 0, len = rings.length; i < len; i++) {
		points = rings[i];

		for (j = 0, len2 = points.length; j < len2; j++) {
			p = points[j];
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}

		// closes the ring for polygons; "x" is VML syntax
		str += closed ? (svg ? 'z' : 'x') : '';
	}

	// SVG complains about empty path strings
	return str || 'M0 0';
}

/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

var style$1 = document.documentElement.style;

// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
var ie = 'ActiveXObject' in window;

// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
var ielt9 = ie && !document.addEventListener;

// @property edge: Boolean; `true` for the Edge web browser.
var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

// @property webkit: Boolean;
// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
var webkit = userAgentContains('webkit');

// @property android: Boolean
// `true` for any browser running on an Android platform.
var android = userAgentContains('android');

// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
var android23 = userAgentContains('android 2') || userAgentContains('android 3');

/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
// @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)
var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

// @property opera: Boolean; `true` for the Opera browser
var opera = !!window.opera;

// @property chrome: Boolean; `true` for the Chrome browser.
var chrome = userAgentContains('chrome');

// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

// @property safari: Boolean; `true` for the Safari browser.
var safari = !chrome && userAgentContains('safari');

var phantom = userAgentContains('phantom');

// @property opera12: Boolean
// `true` for the Opera browser supporting CSS transforms (version 12 or later).
var opera12 = 'OTransition' in style$1;

// @property win: Boolean; `true` when the browser is running in a Windows platform
var win = navigator.platform.indexOf('Win') === 0;

// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
var ie3d = ie && ('transition' in style$1);

// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
var gecko3d = 'MozPerspective' in style$1;

// @property any3d: Boolean
// `true` for all browsers supporting CSS transforms.
var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

// @property mobile: Boolean; `true` for all browsers running in a mobile device.
var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
var mobileWebkit = mobile && webkit;

// @property mobileWebkit3d: Boolean
// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
var mobileWebkit3d = mobile && webkit3d;

// @property msPointer: Boolean
// `true` for browsers implementing the Microsoft touch events model (notably IE10).
var msPointer = !window.PointerEvent && window.MSPointerEvent;

// @property pointer: Boolean
// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
var pointer = !!(window.PointerEvent || msPointer);

// @property touch: Boolean
// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
// This does not necessarily mean that the browser is running in a computer with
// a touchscreen, it only means that the browser is capable of understanding
// touch events.
var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
		(window.DocumentTouch && document instanceof window.DocumentTouch));

// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
var mobileOpera = mobile && opera;

// @property mobileGecko: Boolean
// `true` for gecko-based browsers running in a mobile device.
var mobileGecko = mobile && gecko;

// @property retina: Boolean
// `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;


// @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
var canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect);

// @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
var vml = !svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());


function userAgentContains(str) {
	return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
}


var Browser = (Object.freeze || Object)({
	ie: ie,
	ielt9: ielt9,
	edge: edge,
	webkit: webkit,
	android: android,
	android23: android23,
	androidStock: androidStock,
	opera: opera,
	chrome: chrome,
	gecko: gecko,
	safari: safari,
	phantom: phantom,
	opera12: opera12,
	win: win,
	ie3d: ie3d,
	webkit3d: webkit3d,
	gecko3d: gecko3d,
	any3d: any3d,
	mobile: mobile,
	mobileWebkit: mobileWebkit,
	mobileWebkit3d: mobileWebkit3d,
	msPointer: msPointer,
	pointer: pointer,
	touch: touch,
	mobileOpera: mobileOpera,
	mobileGecko: mobileGecko,
	retina: retina,
	canvas: canvas,
	svg: svg,
	vml: vml
});

/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */


var POINTER_DOWN =   msPointer ? 'MSPointerDown'   : 'pointerdown';
var POINTER_MOVE =   msPointer ? 'MSPointerMove'   : 'pointermove';
var POINTER_UP =     msPointer ? 'MSPointerUp'     : 'pointerup';
var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];

var _pointers = {};
var _pointerDocListener = false;

// DomEvent.DoubleTap needs to know about this
var _pointersCount = 0;

// Provides a touch events wrapper for (ms)pointer events.
// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

function addPointerListener(obj, type, handler, id) {
	if (type === 'touchstart') {
		_addPointerStart(obj, handler, id);

	} else if (type === 'touchmove') {
		_addPointerMove(obj, handler, id);

	} else if (type === 'touchend') {
		_addPointerEnd(obj, handler, id);
	}

	return this;
}

function removePointerListener(obj, type, id) {
	var handler = obj['_leaflet_' + type + id];

	if (type === 'touchstart') {
		obj.removeEventListener(POINTER_DOWN, handler, false);

	} else if (type === 'touchmove') {
		obj.removeEventListener(POINTER_MOVE, handler, false);

	} else if (type === 'touchend') {
		obj.removeEventListener(POINTER_UP, handler, false);
		obj.removeEventListener(POINTER_CANCEL, handler, false);
	}

	return this;
}

function _addPointerStart(obj, handler, id) {
	var onDown = bind(function (e) {
		if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
			// In IE11, some touch events needs to fire for form controls, or
			// the controls will stop working. We keep a whitelist of tag names that
			// need these events. For other target tags, we prevent default on the event.
			if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
				preventDefault(e);
			} else {
				return;
			}
		}

		_handlePointer(e, handler);
	});

	obj['_leaflet_touchstart' + id] = onDown;
	obj.addEventListener(POINTER_DOWN, onDown, false);

	// need to keep track of what pointers and how many are active to provide e.touches emulation
	if (!_pointerDocListener) {
		// we listen documentElement as any drags that end by moving the touch off the screen get fired there
		document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
		document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
		document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
		document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

		_pointerDocListener = true;
	}
}

function _globalPointerDown(e) {
	_pointers[e.pointerId] = e;
	_pointersCount++;
}

function _globalPointerMove(e) {
	if (_pointers[e.pointerId]) {
		_pointers[e.pointerId] = e;
	}
}

function _globalPointerUp(e) {
	delete _pointers[e.pointerId];
	_pointersCount--;
}

function _handlePointer(e, handler) {
	e.touches = [];
	for (var i in _pointers) {
		e.touches.push(_pointers[i]);
	}
	e.changedTouches = [e];

	handler(e);
}

function _addPointerMove(obj, handler, id) {
	var onMove = function (e) {
		// don't fire touch moves when mouse isn't down
		if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

		_handlePointer(e, handler);
	};

	obj['_leaflet_touchmove' + id] = onMove;
	obj.addEventListener(POINTER_MOVE, onMove, false);
}

function _addPointerEnd(obj, handler, id) {
	var onUp = function (e) {
		_handlePointer(e, handler);
	};

	obj['_leaflet_touchend' + id] = onUp;
	obj.addEventListener(POINTER_UP, onUp, false);
	obj.addEventListener(POINTER_CANCEL, onUp, false);
}

/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';
var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';
var _pre = '_leaflet_';

// inspired by Zepto touch code by Thomas Fuchs
function addDoubleTapListener(obj, handler, id) {
	var last, touch$$1,
		doubleTap = false,
		delay = 250;

	function onTouchStart(e) {
		var count;

		if (pointer) {
			if ((!edge) || e.pointerType === 'mouse') { return; }
			count = _pointersCount;
		} else {
			count = e.touches.length;
		}

		if (count > 1) { return; }

		var now = Date.now(),
			delta = now - (last || now);

		touch$$1 = e.touches ? e.touches[0] : e;
		doubleTap = (delta > 0 && delta <= delay);
		last = now;
	}

	function onTouchEnd(e) {
		if (doubleTap && !touch$$1.cancelBubble) {
			if (pointer) {
				if ((!edge) || e.pointerType === 'mouse') { return; }
				// work around .type being readonly with MSPointer* events
				var newTouch = {},
					prop, i;

				for (i in touch$$1) {
					prop = touch$$1[i];
					newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
				}
				touch$$1 = newTouch;
			}
			touch$$1.type = 'dblclick';
			handler(touch$$1);
			last = null;
		}
	}

	obj[_pre + _touchstart + id] = onTouchStart;
	obj[_pre + _touchend + id] = onTouchEnd;
	obj[_pre + 'dblclick' + id] = handler;

	obj.addEventListener(_touchstart, onTouchStart, false);
	obj.addEventListener(_touchend, onTouchEnd, false);

	// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
	// the browser doesn't fire touchend/pointerup events but does fire
	// native dblclicks. See #4127.
	// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
	obj.addEventListener('dblclick', handler, false);

	return this;
}

function removeDoubleTapListener(obj, id) {
	var touchstart = obj[_pre + _touchstart + id],
		touchend = obj[_pre + _touchend + id],
		dblclick = obj[_pre + 'dblclick' + id];

	obj.removeEventListener(_touchstart, touchstart, false);
	obj.removeEventListener(_touchend, touchend, false);
	if (!edge) {
		obj.removeEventListener('dblclick', dblclick, false);
	}

	return this;
}

/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */


// @property TRANSFORM: String
// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
var TRANSFORM = testProp(
	['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

// @property TRANSITION: String
// Vendor-prefixed transition style name.
var TRANSITION = testProp(
	['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

// @property TRANSITION_END: String
// Vendor-prefixed transitionend event name.
var TRANSITION_END =
	TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


// @function get(id: String|HTMLElement): HTMLElement
// Returns an element given its DOM id, or returns the element itself
// if it was passed directly.
function get(id) {
	return typeof id === 'string' ? document.getElementById(id) : id;
}

// @function getStyle(el: HTMLElement, styleAttrib: String): String
// Returns the value for a certain style attribute on an element,
// including computed values or values set through CSS.
function getStyle(el, style) {
	var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

	if ((!value || value === 'auto') && document.defaultView) {
		var css = document.defaultView.getComputedStyle(el, null);
		value = css ? css[style] : null;
	}
	return value === 'auto' ? null : value;
}

// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
function create$1(tagName, className, container) {
	var el = document.createElement(tagName);
	el.className = className || '';

	if (container) {
		container.appendChild(el);
	}
	return el;
}

// @function remove(el: HTMLElement)
// Removes `el` from its parent element
function remove(el) {
	var parent = el.parentNode;
	if (parent) {
		parent.removeChild(el);
	}
}

// @function empty(el: HTMLElement)
// Removes all of `el`'s children elements from `el`
function empty(el) {
	while (el.firstChild) {
		el.removeChild(el.firstChild);
	}
}

// @function toFront(el: HTMLElement)
// Makes `el` the last child of its parent, so it renders in front of the other children.
function toFront(el) {
	var parent = el.parentNode;
	if (parent && parent.lastChild !== el) {
		parent.appendChild(el);
	}
}

// @function toBack(el: HTMLElement)
// Makes `el` the first child of its parent, so it renders behind the other children.
function toBack(el) {
	var parent = el.parentNode;
	if (parent && parent.firstChild !== el) {
		parent.insertBefore(el, parent.firstChild);
	}
}

// @function hasClass(el: HTMLElement, name: String): Boolean
// Returns `true` if the element's class attribute contains `name`.
function hasClass(el, name) {
	if (el.classList !== undefined) {
		return el.classList.contains(name);
	}
	var className = getClass(el);
	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
}

// @function addClass(el: HTMLElement, name: String)
// Adds `name` to the element's class attribute.
function addClass(el, name) {
	if (el.classList !== undefined) {
		var classes = splitWords(name);
		for (var i = 0, len = classes.length; i < len; i++) {
			el.classList.add(classes[i]);
		}
	} else if (!hasClass(el, name)) {
		var className = getClass(el);
		setClass(el, (className ? className + ' ' : '') + name);
	}
}

// @function removeClass(el: HTMLElement, name: String)
// Removes `name` from the element's class attribute.
function removeClass(el, name) {
	if (el.classList !== undefined) {
		el.classList.remove(name);
	} else {
		setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
	}
}

// @function setClass(el: HTMLElement, name: String)
// Sets the element's class.
function setClass(el, name) {
	if (el.className.baseVal === undefined) {
		el.className = name;
	} else {
		// in case of SVG element
		el.className.baseVal = name;
	}
}

// @function getClass(el: HTMLElement): String
// Returns the element's class.
function getClass(el) {
	// Check if the element is an SVGElementInstance and use the correspondingElement instead
	// (Required for linked SVG elements in IE11.)
	if (el.correspondingElement) {
		el = el.correspondingElement;
	}
	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
}

// @function setOpacity(el: HTMLElement, opacity: Number)
// Set the opacity of an element (including old IE support).
// `opacity` must be a number from `0` to `1`.
function setOpacity(el, value) {
	if ('opacity' in el.style) {
		el.style.opacity = value;
	} else if ('filter' in el.style) {
		_setOpacityIE(el, value);
	}
}

function _setOpacityIE(el, value) {
	var filter = false,
		filterName = 'DXImageTransform.Microsoft.Alpha';

	// filters collection throws an error if we try to retrieve a filter that doesn't exist
	try {
		filter = el.filters.item(filterName);
	} catch (e) {
		// don't set opacity to 1 if we haven't already set an opacity,
		// it isn't needed and breaks transparent pngs.
		if (value === 1) { return; }
	}

	value = Math.round(value * 100);

	if (filter) {
		filter.Enabled = (value !== 100);
		filter.Opacity = value;
	} else {
		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
	}
}

// @function testProp(props: String[]): String|false
// Goes through the array of style names and returns the first name
// that is a valid style name for an element. If no such name is found,
// it returns false. Useful for vendor-prefixed styles like `transform`.
function testProp(props) {
	var style = document.documentElement.style;

	for (var i = 0; i < props.length; i++) {
		if (props[i] in style) {
			return props[i];
		}
	}
	return false;
}

// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
// and optionally scaled by `scale`. Does not have an effect if the
// browser doesn't support 3D CSS transforms.
function setTransform(el, offset, scale) {
	var pos = offset || new Point(0, 0);

	el.style[TRANSFORM] =
		(ie3d ?
			'translate(' + pos.x + 'px,' + pos.y + 'px)' :
			'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
		(scale ? ' scale(' + scale + ')' : '');
}

// @function setPosition(el: HTMLElement, position: Point)
// Sets the position of `el` to coordinates specified by `position`,
// using CSS translate or top/left positioning depending on the browser
// (used by Leaflet internally to position its layers).
function setPosition(el, point) {

	/*eslint-disable */
	el._leaflet_pos = point;
	/* eslint-enable */

	if (any3d) {
		setTransform(el, point);
	} else {
		el.style.left = point.x + 'px';
		el.style.top = point.y + 'px';
	}
}

// @function getPosition(el: HTMLElement): Point
// Returns the coordinates of an element previously positioned with setPosition.
function getPosition(el) {
	// this method is only used for elements previously positioned using setPosition,
	// so it's safe to cache the position for performance

	return el._leaflet_pos || new Point(0, 0);
}

// @function disableTextSelection()
// Prevents the user from generating `selectstart` DOM events, usually generated
// when the user drags the mouse through a page with text. Used internally
// by Leaflet to override the behaviour of any click-and-drag interaction on
// the map. Affects drag interactions on the whole document.

// @function enableTextSelection()
// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
var disableTextSelection;
var enableTextSelection;
var _userSelect;
if ('onselectstart' in document) {
	disableTextSelection = function () {
		on(window, 'selectstart', preventDefault);
	};
	enableTextSelection = function () {
		off(window, 'selectstart', preventDefault);
	};
} else {
	var userSelectProperty = testProp(
		['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

	disableTextSelection = function () {
		if (userSelectProperty) {
			var style = document.documentElement.style;
			_userSelect = style[userSelectProperty];
			style[userSelectProperty] = 'none';
		}
	};
	enableTextSelection = function () {
		if (userSelectProperty) {
			document.documentElement.style[userSelectProperty] = _userSelect;
			_userSelect = undefined;
		}
	};
}

// @function disableImageDrag()
// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
// for `dragstart` DOM events, usually generated when the user drags an image.
function disableImageDrag() {
	on(window, 'dragstart', preventDefault);
}

// @function enableImageDrag()
// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
function enableImageDrag() {
	off(window, 'dragstart', preventDefault);
}

var _outlineElement;
var _outlineStyle;
// @function preventOutline(el: HTMLElement)
// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
// of the element `el` invisible. Used internally by Leaflet to prevent
// focusable elements from displaying an outline when the user performs a
// drag interaction on them.
function preventOutline(element) {
	while (element.tabIndex === -1) {
		element = element.parentNode;
	}
	if (!element.style) { return; }
	restoreOutline();
	_outlineElement = element;
	_outlineStyle = element.style.outline;
	element.style.outline = 'none';
	on(window, 'keydown', restoreOutline);
}

// @function restoreOutline()
// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
function restoreOutline() {
	if (!_outlineElement) { return; }
	_outlineElement.style.outline = _outlineStyle;
	_outlineElement = undefined;
	_outlineStyle = undefined;
	off(window, 'keydown', restoreOutline);
}

// @function getSizedParentNode(el: HTMLElement): HTMLElement
// Finds the closest parent node which size (width and height) is not null.
function getSizedParentNode(element) {
	do {
		element = element.parentNode;
	} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
	return element;
}

// @function getScale(el: HTMLElement): Object
// Computes the CSS scale currently applied on the element.
// Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
// and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
function getScale(element) {
	var rect = element.getBoundingClientRect(); // Read-only in old browsers.

	return {
		x: rect.width / element.offsetWidth || 1,
		y: rect.height / element.offsetHeight || 1,
		boundingClientRect: rect
	};
}


var DomUtil = (Object.freeze || Object)({
	TRANSFORM: TRANSFORM,
	TRANSITION: TRANSITION,
	TRANSITION_END: TRANSITION_END,
	get: get,
	getStyle: getStyle,
	create: create$1,
	remove: remove,
	empty: empty,
	toFront: toFront,
	toBack: toBack,
	hasClass: hasClass,
	addClass: addClass,
	removeClass: removeClass,
	setClass: setClass,
	getClass: getClass,
	setOpacity: setOpacity,
	testProp: testProp,
	setTransform: setTransform,
	setPosition: setPosition,
	getPosition: getPosition,
	disableTextSelection: disableTextSelection,
	enableTextSelection: enableTextSelection,
	disableImageDrag: disableImageDrag,
	enableImageDrag: enableImageDrag,
	preventOutline: preventOutline,
	restoreOutline: restoreOutline,
	getSizedParentNode: getSizedParentNode,
	getScale: getScale
});

/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Adds a listener function (`fn`) to a particular DOM event type of the
// element `el`. You can optionally specify the context of the listener
// (object the `this` keyword will point to). You can also pass several
// space-separated types (e.g. `'click dblclick'`).

// @alternative
// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function on(obj, types, fn, context) {

	if (typeof types === 'object') {
		for (var type in types) {
			addOne(obj, type, types[type], fn);
		}
	} else {
		types = splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			addOne(obj, types[i], fn, context);
		}
	}

	return this;
}

var eventsKey = '_leaflet_events';

// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Removes a previously added listener function.
// Note that if you passed a custom context to on, you must pass the same
// context to `off` in order to remove the listener.

// @alternative
// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function off(obj, types, fn, context) {

	if (typeof types === 'object') {
		for (var type in types) {
			removeOne(obj, type, types[type], fn);
		}
	} else if (types) {
		types = splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			removeOne(obj, types[i], fn, context);
		}
	} else {
		for (var j in obj[eventsKey]) {
			removeOne(obj, j, obj[eventsKey][j]);
		}
		delete obj[eventsKey];
	}

	return this;
}

function addOne(obj, type, fn, context) {
	var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

	if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

	var handler = function (e) {
		return fn.call(context || obj, e || window.event);
	};

	var originalHandler = handler;

	if (pointer && type.indexOf('touch') === 0) {
		// Needs DomEvent.Pointer.js
		addPointerListener(obj, type, handler, id);

	} else if (touch && (type === 'dblclick') && addDoubleTapListener &&
			   !(pointer && chrome)) {
		// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
		// See #5180
		addDoubleTapListener(obj, handler, id);

	} else if ('addEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

		} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
			handler = function (e) {
				e = e || window.event;
				if (isExternalTarget(obj, e)) {
					originalHandler(e);
				}
			};
			obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

		} else {
			if (type === 'click' && android) {
				handler = function (e) {
					filterClick(e, originalHandler);
				};
			}
			obj.addEventListener(type, handler, false);
		}

	} else if ('attachEvent' in obj) {
		obj.attachEvent('on' + type, handler);
	}

	obj[eventsKey] = obj[eventsKey] || {};
	obj[eventsKey][id] = handler;
}

function removeOne(obj, type, fn, context) {

	var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
		handler = obj[eventsKey] && obj[eventsKey][id];

	if (!handler) { return this; }

	if (pointer && type.indexOf('touch') === 0) {
		removePointerListener(obj, type, id);

	} else if (touch && (type === 'dblclick') && removeDoubleTapListener &&
			   !(pointer && chrome)) {
		removeDoubleTapListener(obj, id);

	} else if ('removeEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

		} else {
			obj.removeEventListener(
				type === 'mouseenter' ? 'mouseover' :
				type === 'mouseleave' ? 'mouseout' : type, handler, false);
		}

	} else if ('detachEvent' in obj) {
		obj.detachEvent('on' + type, handler);
	}

	obj[eventsKey][id] = null;
}

// @function stopPropagation(ev: DOMEvent): this
// Stop the given event from propagation to parent elements. Used inside the listener functions:
// ```js
// L.DomEvent.on(div, 'click', function (ev) {
// 	L.DomEvent.stopPropagation(ev);
// });
// ```
function stopPropagation(e) {

	if (e.stopPropagation) {
		e.stopPropagation();
	} else if (e.originalEvent) {  // In case of Leaflet event.
		e.originalEvent._stopped = true;
	} else {
		e.cancelBubble = true;
	}
	skipped(e);

	return this;
}

// @function disableScrollPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
function disableScrollPropagation(el) {
	addOne(el, 'mousewheel', stopPropagation);
	return this;
}

// @function disableClickPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
// `'mousedown'` and `'touchstart'` events (plus browser variants).
function disableClickPropagation(el) {
	on(el, 'mousedown touchstart dblclick', stopPropagation);
	addOne(el, 'click', fakeStop);
	return this;
}

// @function preventDefault(ev: DOMEvent): this
// Prevents the default action of the DOM Event `ev` from happening (such as
// following a link in the href of the a element, or doing a POST request
// with page reload when a `<form>` is submitted).
// Use it inside listener functions.
function preventDefault(e) {
	if (e.preventDefault) {
		e.preventDefault();
	} else {
		e.returnValue = false;
	}
	return this;
}

// @function stop(ev: DOMEvent): this
// Does `stopPropagation` and `preventDefault` at the same time.
function stop(e) {
	preventDefault(e);
	stopPropagation(e);
	return this;
}

// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
// Gets normalized mouse position from a DOM event relative to the
// `container` (border excluded) or to the whole page if not specified.
function getMousePosition(e, container) {
	if (!container) {
		return new Point(e.clientX, e.clientY);
	}

	var scale = getScale(container),
		offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

	return new Point(
		// offset.left/top values are in page scale (like clientX/Y),
		// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
		(e.clientX - offset.left) / scale.x - container.clientLeft,
		(e.clientY - offset.top) / scale.y - container.clientTop
	);
}

// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
// and Firefox scrolls device pixels, not CSS pixels
var wheelPxFactor =
	(win && chrome) ? 2 * window.devicePixelRatio :
	gecko ? window.devicePixelRatio : 1;

// @function getWheelDelta(ev: DOMEvent): Number
// Gets normalized wheel delta from a mousewheel DOM event, in vertical
// pixels scrolled (negative if scrolling down).
// Events from pointing devices without precise scrolling are mapped to
// a best guess of 60 pixels.
function getWheelDelta(e) {
	return (edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		   (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
		   (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		   (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		   (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		   e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		   (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		   e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		   0;
}

var skipEvents = {};

function fakeStop(e) {
	// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
	skipEvents[e.type] = true;
}

function skipped(e) {
	var events = skipEvents[e.type];
	// reset when checking, as it's only used in map container and propagates outside of the map
	skipEvents[e.type] = false;
	return events;
}

// check if element really left/entered the event target (for mouseenter/mouseleave)
function isExternalTarget(el, e) {

	var related = e.relatedTarget;

	if (!related) { return true; }

	try {
		while (related && (related !== el)) {
			related = related.parentNode;
		}
	} catch (err) {
		return false;
	}
	return (related !== el);
}

var lastClick;

// this is a horrible workaround for a bug in Android where a single touch triggers two click events
function filterClick(e, handler) {
	var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		elapsed = lastClick && (timeStamp - lastClick);

	// are they closer together than 500ms yet more than 100ms?
	// Android typically triggers them ~300ms apart while multiple listeners
	// on the same event should be triggered far faster;
	// or check if click is simulated on the element, and if it is, reject any non-simulated events

	if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
		stop(e);
		return;
	}
	lastClick = timeStamp;

	handler(e);
}




var DomEvent = (Object.freeze || Object)({
	on: on,
	off: off,
	stopPropagation: stopPropagation,
	disableScrollPropagation: disableScrollPropagation,
	disableClickPropagation: disableClickPropagation,
	preventDefault: preventDefault,
	stop: stop,
	getMousePosition: getMousePosition,
	getWheelDelta: getWheelDelta,
	fakeStop: fakeStop,
	skipped: skipped,
	isExternalTarget: isExternalTarget,
	addListener: on,
	removeListener: off
});

/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

var PosAnimation = Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
			duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});

/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API  it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

var Map = Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = *
		// Minimum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the lowest of their `minZoom` options will be used instead.
		minZoom: undefined,

		// @option maxZoom: Number = *
		// Maximum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the highest of their `maxZoom` options will be used instead.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back if the user tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option zoomAnimation: Boolean = true
		// Whether the map zoom animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		zoomAnimation: true,

		// @option zoomAnimationThreshold: Number = 4
		// Won't animate zoom if the zoom difference exceeds this value.
		zoomAnimationThreshold: 4,

		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = setOptions(this, options);

		// Make sure to assign internal flags at the beginning,
		// to avoid inconsistent state in some edge cases.
		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(toLatLng(options.center), options.zoom, {reset: true});
		}

		this.callInitHooks();

		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = TRANSITION && any3d && !mobileOpera &&
				this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			this._createAnimProxy();
			on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
		}

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = extend({animate: options.animate}, options.zoom);
				options.pan = extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
			viewHalf = this.getSize().divideBy(2),
			containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

			centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
			newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
			paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

			zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		if (zoom === Infinity) {
			return {
				center: bounds.getCenter(),
				zoom: zoom
			};
		}

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

			swPoint = this.project(bounds.getSouthWest(), zoom),
			nePoint = this.project(bounds.getNorthEast(), zoom),
			center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = toLatLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point, options?: Pan options): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset, options) {
		offset = toPoint(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
			to = this.project(targetCenter),
			size = this.getSize(),
			startZoom = this._zoom;

		targetCenter = toLatLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
			w1 = w0 * this.getZoomScale(startZoom, targetZoom),
			u1 = (to.distanceTo(from)) || 1,
			rho = 1.42,
			rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
				s2 = i ? w1 : w0,
				t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
				b1 = 2 * s2 * rho2 * u1,
				b = t1 / b1,
				sq = Math.sqrt(b * b + 1) - b;

				// workaround for floating point precision bug when sq = 0, log = -Infinite,
				// thus triggering an infinite loop in flyTo
				var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
			S = (r(1) - r0) / rho,
			duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
				s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true, options.noMoveStart);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = toLatLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		var oldZoom = this.options.minZoom;
		this.options.minZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() < this.options.minZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		var oldZoom = this.options.maxZoom;
		this.options.maxZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() > this.options.maxZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
			newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method panInside(latlng: LatLng, options?: options): this
	// Pans the map the minimum amount to make the `latlng` visible. Use
	// `padding`, `paddingTopLeft` and `paddingTopRight` options to fit
	// the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).
	// If `latlng` is already within the (optionally padded) display bounds,
	// the map will not be panned.
	panInside: function (latlng, options) {
		options = options || {};

		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
			paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
			center = this.getCenter(),
			pixelCenter = this.project(center),
			pixelPoint = this.project(latlng),
			pixelBounds = this.getPixelBounds(),
			halfPixelBounds = pixelBounds.getSize().divideBy(2),
			paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);

		if (!paddedBounds.contains(pixelPoint)) {
			this._enforcingBounds = true;
			var diff = pixelCenter.subtract(pixelPoint),
				newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);

			if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
				newCenter.x = pixelCenter.x - diff.x;
				if (diff.x > 0) {
					newCenter.x += halfPixelBounds.x - paddingTL.x;
				} else {
					newCenter.x -= halfPixelBounds.x - paddingBR.x;
				}
			}
			if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
				newCenter.y = pixelCenter.y - diff.y;
				if (diff.y > 0) {
					newCenter.y += halfPixelBounds.y - paddingTL.y;
				} else {
					newCenter.y -= halfPixelBounds.y - paddingBR.y;
				}
			}
			this.panTo(this.unproject(newCenter), options);
			this._enforcingBounds = false;
		}
		return this;
	},

	// @method invalidateSize(options: Zoom/pan options): this
	// Checks if the map container size changed and updates the map if so 
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so 
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
			oldCenter = oldSize.divideBy(2).round(),
			newCenter = newSize.divideBy(2).round(),
			offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},

	// @section Geolocation methods
	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = extend({
			timeout: 10000,
			watch: false
			// setView: false
			// maxZoom: <Number>
			// maximumAge: 0
			// enableHighAccuracy: false
		}, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = bind(this._handleGeolocationResponse, this),
			onError = bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
					navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
			message = error.message ||
					(c === 1 ? 'permission denied' :
					(c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
			lng = pos.coords.longitude,
			latlng = new LatLng(lat, lng),
			bounds = latlng.toBounds(pos.coords.accuracy * 2),
			options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	},

	// TODO Appropriate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/* eslint-enable */
			this._containerId = undefined;
		}

		if (this._locationWatchId !== undefined) {
			this.stopLocate();
		}

		this._stop();

		remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}
		if (this._resizeRequest) {
			cancelAnimFrame(this._resizeRequest);
			this._resizeRequest = null;
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		var i;
		for (i in this._layers) {
			this._layers[i].remove();
		}
		for (i in this._panes) {
			remove(this._panes[i]);
		}

		this._layers = [];
		this._panes = [];
		delete this._mapPane;
		delete this._renderer;

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a child of `container`, or
	// as a child of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
			pane = create$1('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
			sw = this.unproject(bounds.getBottomLeft()),
			ne = this.unproject(bounds.getTopRight());

		return new LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = toLatLngBounds(bounds);
		padding = toPoint(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
			min = this.getMinZoom(),
			max = this.getMaxZoom(),
			nw = bounds.getNorthWest(),
			se = bounds.getSouthEast(),
			size = this.getSize().subtract(padding),
			boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
			snap = any3d ? this.options.zoomSnap : 1,
			scalex = size.x / boundsSize.x,
			scaley = size.y / boundsSize.y,
			scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new Point(
				this._container.clientWidth || 0,
				this._container.clientHeight || 0);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(toPoint(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = toPoint(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(toLatLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(toLatLng(latlng));
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
	// its center is within the CRS's bounds.
	// By default this means the center longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees, and the majority of the bounds
	// overlaps the CRS's bounds.
	wrapLatLngBounds: function (latlng) {
		return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return toPoint(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return toPoint(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(toPoint(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		on(container, 'scroll', this._onScroll, this);
		this._containerId = stamp(container);
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && any3d;

		addClass(container, 'leaflet-container' +
			(touch ? ' leaflet-touch' : '') +
			(retina ? ' leaflet-retina' : '') +
			(ielt9 ? ' leaflet-oldie' : '') +
			(safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		setPosition(this._mapPane, new Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for `Tooltip`s.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			addClass(panes.markerPane, 'leaflet-zoom-hide');
			addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		setPosition(this._mapPane, new Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged, false)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged, noMoveStart) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		if (!noMoveStart) {
			this.fire('movestart');
		}
		return this;
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove$$1) {
		this._targets = {};
		this._targets[stamp(this._container)] = this;

		var onOff = remove$$1 ? off : on;

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused.
		onOff(this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			onOff(window, 'resize', this._onResize, this);
		}

		if (any3d && this.options.transform3DLimit) {
			(remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = requestAnimFrame(
				function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
			target,
			isHover = type === 'mouseout' || type === 'mouseover',
			src = e.target || e.srcElement,
			dragging = false;

		while (src) {
			target = this._targets[stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || skipped(e)) { return; }

		var type = e.type;

		if (type === 'mousedown' || type === 'keypress') {
			// prevents outline when clicking on keyboard-focusable element
			preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
			data.containerPoint = isMarker ?
				this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return getPosition(this._mapPane) || new Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return toBounds([
			this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
		]);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
			viewHalf = this.getSize().divideBy(2),
			viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
			offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
			newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = toBounds(
				this.project(maxBounds.getNorthEast(), zoom),
				this.project(maxBounds.getSouthWest(), zoom)
			),
			minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
			maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

			dx = this._rebound(minOffset.x, -maxOffset.x),
			dy = this._rebound(minOffset.y, -maxOffset.y);

		return new Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
			max = this.getMaxZoom(),
			snap = any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._trunc();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	},

	_createAnimProxy: function () {

		var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = TRANSFORM,
				transform = this._proxy.style[prop];

			setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === this._proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
				z = this.getZoom();
			setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);

		this._on('unload', this._destroyAnimProxy, this);
	},

	_destroyAnimProxy: function () {
		remove(this._proxy);
		delete this._proxy;
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
				Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
			offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		requestAnimFrame(function () {
			this
				._moveStart(true, false)
				._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (!this._mapPane) { return; }

		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired at least once per zoom animation. For continous zoom, like pinch zooming, fired once per frame during zoom.
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		if (this._mapPane) {
			removeClass(this._mapPane, 'leaflet-zoom-anim');
		}

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
function createMap(id, options) {
	return new Map(id, options);
}

/*
 * @class Control
 * @aka L.Control
 * @inherits Class
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

var Control = Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
			pos = this.getPosition(),
			corner = map._controlCorners[pos];

		addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

var control = function (options) {
	return new Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
			l = 'leaflet-',
			container = this._controlContainer =
					create$1('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = create$1('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		for (var i in this._controlCorners) {
			remove(this._controlCorners[i]);
		}
		remove(this._controlContainer);
		delete this._controlCorners;
		delete this._controlContainer;
	}
});

/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */

var Layers = Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false,

		// @option sortLayers: Boolean = false
		// Whether to sort the layers. When `false`, layers will keep the order
		// in which they were added to the control.
		sortLayers: false,

		// @option sortFunction: Function = *
		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
		// that will be used for sorting the layers, when `sortLayers` is `true`.
		// The function receives both the `L.Layer` instances and their names, as in
		// `sortFunction(layerA, layerB, nameA, nameB)`.
		// By default, it sorts layers alphabetically by their name.
		sortFunction: function (layerA, layerB, nameA, nameB) {
			return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
		}
	},

	initialize: function (baseLayers, overlays, options) {
		setOptions(this, options);

		this._layerControlInputs = [];
		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.on('add remove', this._onLayerChange, this);
		}

		return this._container;
	},

	addTo: function (map) {
		Control.prototype.addTo.call(this, map);
		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
		return this._expandIfNotCollapsed();
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		addClass(this._container, 'leaflet-control-layers-expanded');
		this._section.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._section.clientHeight) {
			addClass(this._section, 'leaflet-control-layers-scrollbar');
			this._section.style.height = acceptableHeight + 'px';
		} else {
			removeClass(this._section, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
			container = this._container = create$1('div', className),
			collapsed = this.options.collapsed;

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		disableClickPropagation(container);
		disableScrollPropagation(container);

		var section = this._section = create$1('section', className + '-list');

		if (collapsed) {
			this._map.on('click', this.collapse, this);

			if (!android) {
				on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}
		}

		var link = this._layersLink = create$1('a', className + '-toggle', container);
		link.href = '#';
		link.title = 'Layers';

		if (touch) {
			on(link, 'click', stop);
			on(link, 'click', this.expand, this);
		} else {
			on(link, 'focus', this.expand, this);
		}

		if (!collapsed) {
			this.expand();
		}

		this._baseLayersList = create$1('div', className + '-base', section);
		this._separator = create$1('div', className + '-separator', section);
		this._overlaysList = create$1('div', className + '-overlays', section);

		container.appendChild(section);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		if (this._map) {
			layer.on('add remove', this._onLayerChange, this);
		}

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.sortLayers) {
			this._layers.sort(bind(function (a, b) {
				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
			}, this));
		}

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}

		this._expandIfNotCollapsed();
	},

	_update: function () {
		if (!this._container) { return this; }

		empty(this._baseLayersList);
		empty(this._overlaysList);

		this._layerControlInputs = [];
		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
			checked = this._map.hasLayer(obj.layer),
			input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		this._layerControlInputs.push(input);
		input.layerId = stamp(obj.layer);

		on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._layerControlInputs,
			input, layer;
		var addedLayers = [],
			removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;

			if (input.checked) {
				addedLayers.push(layer);
			} else if (!input.checked) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			if (this._map.hasLayer(removedLayers[i])) {
				this._map.removeLayer(removedLayers[i]);
			}
		}
		for (i = 0; i < addedLayers.length; i++) {
			if (!this._map.hasLayer(addedLayers[i])) {
				this._map.addLayer(addedLayers[i]);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._layerControlInputs,
			input,
			layer,
			zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
							 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expandIfNotCollapsed: function () {
		if (this._map && !this.options.collapsed) {
			this.expand();
		}
		return this;
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
var layers = function (baseLayers, overlays, options) {
	return new Layers(baseLayers, overlays, options);
};

/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

var Zoom = Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '&#x2212;'
		// The text set on the 'zoom out' button.
		zoomOutText: '&#x2212;',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
			container = create$1('div', zoomName + ' leaflet-bar'),
			options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
				zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
				zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = create$1('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		/*
		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
		 */
		link.setAttribute('role', 'button');
		link.setAttribute('aria-label', title);

		disableClickPropagation(link);
		on(link, 'click', stop);
		on(link, 'click', fn, this);
		on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
			className = 'leaflet-disabled';

		removeClass(this._zoomInButton, className);
		removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
Map.mergeOptions({
	zoomControl: true
});

Map.addInitHook(function () {
	if (this.options.zoomControl) {
		// @section Controls
		// @property zoomControl: Control.Zoom
		// The default zoom control (only available if the
		// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
		this.zoomControl = new Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
var zoom = function (options) {
	return new Zoom(options);
};

/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

var Scale = Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
			container = create$1('div', className),
			options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = create$1('div', className, container);
		}
		if (options.imperial) {
			this._iScale = create$1('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
			y = map.getSize().y / 2;

		var maxMeters = map.distance(
			map.containerPointToLatLng([0, y]),
			map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
			label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
			maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
			d = num / pow10;

		d = d >= 10 ? 10 :
			d >= 5 ? 5 :
			d >= 3 ? 3 :
			d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
var scale = function (options) {
	return new Scale(options);
};

/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

var Attribution = Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = create$1('div', 'leaflet-control-attribution');
		disableClickPropagation(this._container);

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
Map.mergeOptions({
	attributionControl: true
});

Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
var attribution = function (options) {
	return new Attribution(options);
};

Control.Layers = Layers;
Control.Zoom = Zoom;
Control.Scale = Scale;
Control.Attribution = Attribution;

control.layers = layers;
control.zoom = zoom;
control.scale = scale;
control.attribution = attribution;

/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

var Handler = Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});

// @section There is static function which can be called without instantiating L.Handler:
// @function addTo(map: Map, name: String): this
// Adds a new Handler to the given map with the given name.
Handler.addTo = function (map, name) {
	map.addHandler(name, this);
	return this;
};

var Mixin = {Events: Events};

/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

var START = touch ? 'touchstart mousedown' : 'mousedown';
var END = {
	mousedown: 'mouseup',
	touchstart: 'touchend',
	pointerdown: 'touchend',
	MSPointerDown: 'touchend'
};
var MOVE = {
	mousedown: 'mousemove',
	touchstart: 'touchmove',
	pointerdown: 'touchmove',
	MSPointerDown: 'touchmove'
};


var Draggable = Evented.extend({

	options: {
		// @section
		// @aka Draggable options
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline$$1, options) {
		setOptions(this, options);

		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline$$1;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		on(this._dragStartTarget, START, this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		// If we're currently dragging this draggable,
		// disabling it counts as first ending the drag.
		if (Draggable._dragging === this) {
			this.finishDrag();
		}

		off(this._dragStartTarget, START, this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
		Draggable._dragging = this;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			preventOutline(this._element);
		}

		disableImageDrag();
		disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e,
			sizedParent = getSizedParentNode(this._element);

		this._startPoint = new Point(first.clientX, first.clientY);

		// Cache the scale, so that we can continuously compensate for it during drag (_onMove).
		this._parentScale = getScale(sizedParent);

		on(document, MOVE[e.type], this._onMove, this);
		on(document, END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
			offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		// We assume that the parent container's position, border and scale do not change for the duration of the drag.
		// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
		// and we can use the cached value for the scale.
		offset.x /= this._parentScale.x;
		offset.y /= this._parentScale.y;

		preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = getPosition(this._element).subtract(offset);

			addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }
		this.finishDrag();
	},

	finishDrag: function () {
		removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in MOVE) {
			off(document, MOVE[i], this._onMove, this);
			off(document, END[i], this._onUp, this);
		}

		enableImageDrag();
		enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		Draggable._dragging = false;
	}

});

/*
 * @namespace LineUtil
 *
 * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
 */

// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
// Improves rendering performance dramatically by lessening the number of points to draw.

// @function simplify(points: Point[], tolerance: Number): Point[]
// Dramatically reduces the number of points in a polyline while retaining
// its shape and returns a new array of simplified points, using the
// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
// Used for a huge performance boost when processing/displaying Leaflet polylines for
// each zoom level and also reducing visual noise. tolerance affects the amount of
// simplification (lesser value means higher quality but slower and with more points).
// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
function simplify(points, tolerance) {
	if (!tolerance || !points.length) {
		return points.slice();
	}

	var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = _reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = _simplifyDP(points, sqTolerance);

	return points;
}

// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
// Returns the distance between point `p` and segment `p1` to `p2`.
function pointToSegmentDistance(p, p1, p2) {
	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
}

// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
// Returns the closest point from a point `p` on a segment `p1` to `p2`.
function closestPointOnSegment(p, p1, p2) {
	return _sqClosestPointOnSegment(p, p1, p2);
}

// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
function _simplifyDP(points, sqTolerance) {

	var len = points.length,
		ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

	var i,
		newPoints = [];

	for (i = 0; i < len; i++) {
		if (markers[i]) {
			newPoints.push(points[i]);
		}
	}

	return newPoints;
}

function _simplifyDPStep(points, markers, sqTolerance, first, last) {

	var maxSqDist = 0,
	index, i, sqDist;

	for (i = first + 1; i <= last - 1; i++) {
		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

		if (sqDist > maxSqDist) {
			index = i;
			maxSqDist = sqDist;
		}
	}

	if (maxSqDist > sqTolerance) {
		markers[index] = 1;

		_simplifyDPStep(points, markers, sqTolerance, first, index);
		_simplifyDPStep(points, markers, sqTolerance, index, last);
	}
}

// reduce points that are too close to each other to a single point
function _reducePoints(points, sqTolerance) {
	var reducedPoints = [points[0]];

	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
		if (_sqDist(points[i], points[prev]) > sqTolerance) {
			reducedPoints.push(points[i]);
			prev = i;
		}
	}
	if (prev < len - 1) {
		reducedPoints.push(points[len - 1]);
	}
	return reducedPoints;
}

var _lastCode;

// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
// Clips the segment a to b by rectangular bounds with the
// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
// (modifying the segment points directly!). Used by Leaflet to only show polyline
// points that are on the screen or near, increasing performance.
function clipSegment(a, b, bounds, useLastCode, round) {
	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
		codeB = _getBitCode(b, bounds),

		codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		_lastCode = codeB;

	while (true) {
		// if a,b is inside the clip window (trivial accept)
		if (!(codeA | codeB)) {
			return [a, b];
		}

		// if a,b is outside the clip window (trivial reject)
		if (codeA & codeB) {
			return false;
		}

		// other cases
		codeOut = codeA || codeB;
		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
		newCode = _getBitCode(p, bounds);

		if (codeOut === codeA) {
			a = p;
			codeA = newCode;
		} else {
			b = p;
			codeB = newCode;
		}
	}
}

function _getEdgeIntersection(a, b, code, bounds, round) {
	var dx = b.x - a.x,
		dy = b.y - a.y,
		min = bounds.min,
		max = bounds.max,
		x, y;

	if (code & 8) { // top
		x = a.x + dx * (max.y - a.y) / dy;
		y = max.y;

	} else if (code & 4) { // bottom
		x = a.x + dx * (min.y - a.y) / dy;
		y = min.y;

	} else if (code & 2) { // right
		x = max.x;
		y = a.y + dy * (max.x - a.x) / dx;

	} else if (code & 1) { // left
		x = min.x;
		y = a.y + dy * (min.x - a.x) / dx;
	}

	return new Point(x, y, round);
}

function _getBitCode(p, bounds) {
	var code = 0;

	if (p.x < bounds.min.x) { // left
		code |= 1;
	} else if (p.x > bounds.max.x) { // right
		code |= 2;
	}

	if (p.y < bounds.min.y) { // bottom
		code |= 4;
	} else if (p.y > bounds.max.y) { // top
		code |= 8;
	}

	return code;
}

// square distance (to avoid unnecessary Math.sqrt calls)
function _sqDist(p1, p2) {
	var dx = p2.x - p1.x,
		dy = p2.y - p1.y;
	return dx * dx + dy * dy;
}

// return closest point on segment or distance to that point
function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
	var x = p1.x,
		y = p1.y,
		dx = p2.x - x,
		dy = p2.y - y,
		dot = dx * dx + dy * dy,
		t;

	if (dot > 0) {
		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

		if (t > 1) {
			x = p2.x;
			y = p2.y;
		} else if (t > 0) {
			x += dx * t;
			y += dy * t;
		}
	}

	dx = p.x - x;
	dy = p.y - y;

	return sqDist ? dx * dx + dy * dy : new Point(x, y);
}


// @function isFlat(latlngs: LatLng[]): Boolean
// Returns true if `latlngs` is a flat array, false is nested.
function isFlat(latlngs) {
	return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
}

function _flat(latlngs) {
	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
	return isFlat(latlngs);
}


var LineUtil = (Object.freeze || Object)({
	simplify: simplify,
	pointToSegmentDistance: pointToSegmentDistance,
	closestPointOnSegment: closestPointOnSegment,
	clipSegment: clipSegment,
	_getEdgeIntersection: _getEdgeIntersection,
	_getBitCode: _getBitCode,
	_sqClosestPointOnSegment: _sqClosestPointOnSegment,
	isFlat: isFlat,
	_flat: _flat
});

/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a separate method for it.
 */
function clipPolygon(points, bounds, round) {
	var clippedPoints,
		edges = [1, 4, 2, 8],
		i, j, k,
		a, b,
		len, edge, p;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = _getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = _getEdgeIntersection(b, a, edge, bounds, round);
					p._code = _getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = _getEdgeIntersection(b, a, edge, bounds, round);
				p._code = _getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
}


var PolyUtil = (Object.freeze || Object)({
	clipPolygon: clipPolygon
});

/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection  the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:4326` and `Simple` CRS.
 */

var LonLat = {
	project: function (latlng) {
		return new Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new LatLng(point.y, point.x);
	},

	bounds: new Bounds([-180, -90], [180, 90])
};

/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection  more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

var Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
			r = this.R,
			y = latlng.lat * d,
			tmp = this.R_MINOR / r,
			e = Math.sqrt(1 - tmp * tmp),
			con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
			r = this.R,
			tmp = this.R_MINOR / r,
			e = Math.sqrt(1 - tmp * tmp),
			ts = Math.exp(-point.y / r),
			phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new LatLng(phi * d, point.x * d / r);
	}
};

/*
 * @class Projection

 * An object with methods for projecting geographical coordinates of the world onto
 * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).

 * @property bounds: Bounds
 * The bounds (specified in CRS units) where the projection is valid

 * @method project(latlng: LatLng): Point
 * Projects geographical coordinates into a 2D point.
 * Only accepts actual `L.LatLng` instances, not arrays.

 * @method unproject(point: Point): LatLng
 * The inverse of `project`. Projects a 2D point into a geographical location.
 * Only accepts actual `L.Point` instances, not arrays.

 * Note that the projection instances do not inherit from Leafet's `Class` object,
 * and can't be instantiated. Also, new classes can't inherit from them,
 * and methods can't be added to them with the `include` function.

 */




var index = (Object.freeze || Object)({
	LonLat: LonLat,
	Mercator: Mercator,
	SphericalMercator: SphericalMercator
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */
var EPSG3395 = extend({}, Earth, {
	code: 'EPSG:3395',
	projection: Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * Mercator.R);
		return toTransformation(scale, 0.5, -scale, 0.5);
	}())
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 *
 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
 */

var EPSG4326 = extend({}, Earth, {
	code: 'EPSG:4326',
	projection: LonLat,
	transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
});

/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

var Simple = extend({}, CRS, {
	projection: LonLat,
	transformation: toTransformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
			dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});

CRS.Earth = Earth;
CRS.EPSG3395 = EPSG3395;
CRS.EPSG3857 = EPSG3857;
CRS.EPSG900913 = EPSG900913;
CRS.EPSG4326 = EPSG4326;
CRS.Simple = Simple;

/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


var Layer = Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',

		// @option attribution: String = null
		// String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
		attribution: null,

		bubblingMouseEvents: true
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map|LayerGroup): this
	 * Adds the layer to the given map or layer group.
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[stamp(targetEl)];
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && map.attributionControl) {
			map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		if (!layer._layerAdd) {
			throw new Error('The provided object is not a Layer.');
		}

		var id = stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
			maxZoom = -Infinity,
			oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}

		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
			this.setZoom(this._layersMaxZoom);
		}
		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
			this.setZoom(this._layersMinZoom);
		}
	}
});

/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

var LayerGroup = Layer.extend({

	initialize: function (layers, options) {
		setOptions(this, options);

		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	// @alternative
	// @method hasLayer(id: Number): Boolean
	// Returns `true` if the given internal ID is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		return this.eachLayer(this.removeLayer, this);
	},

	// @method invoke(methodName: String, ): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
			i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		this.eachLayer(map.addLayer, map);
	},

	onRemove: function (map) {
		this.eachLayer(map.removeLayer, map);
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];
		this.eachLayer(layers.push, layers);
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return stamp(layer);
	}
});


// @factory L.layerGroup(layers?: Layer[], options?: Object)
// Create a layer group, optionally given an initial set of layers and an `options` object.
var layerGroup = function (layers, options) {
	return new LayerGroup(layers, options);
};

/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

var FeatureGroup = LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the back of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
var featureGroup = function (layers) {
	return new FeatureGroup(layers);
};

/*
 * @class Icon
 * @aka L.Icon
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

var Icon = Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = [0, 0]
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option tooltipAnchor: Point = [0, 0]
	 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	options: {
		popupAnchor: [0, 0],
		tooltipAnchor: [0, 0]
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = toPoint(sizeOption),
			anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
					size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
function icon(options) {
	return new Icon(options);
}

/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 *
 * If you want to _completely_ replace the default icon, override the
 * `L.Marker.prototype.options.icon` with your own icon instead.
 */

var IconDefault = Icon.extend({

	options: {
		iconUrl:       'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl:     'marker-shadow.png',
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		if (!IconDefault.imagePath) {	// Deprecated, backwards-compatibility only
			IconDefault.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `Icon.Default` will try to auto-detect the location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right path.
		return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function () {
		var el = create$1('div',  'leaflet-default-icon-path', document.body);
		var path = getStyle(el, 'background-image') ||
				   getStyle(el, 'backgroundImage');	// IE8

		document.body.removeChild(el);

		if (path === null || path.indexOf('url') !== 0) {
			path = '';
		} else {
			path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
		}

		return path;
	}
});

/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
 */

var MarkerDrag = Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_adjustPan: function (e) {
		var marker = this._marker,
			map = marker._map,
			speed = this._marker.options.autoPanSpeed,
			padding = this._marker.options.autoPanPadding,
			iconPos = getPosition(marker._icon),
			bounds = map.getPixelBounds(),
			origin = map.getPixelOrigin();

		var panBounds = toBounds(
			bounds.min._subtract(origin).add(padding),
			bounds.max._subtract(origin).subtract(padding)
		);

		if (!panBounds.contains(iconPos)) {
			// Compute incremental movement
			var movement = toPoint(
				(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
				(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

				(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
				(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
			).multiplyBy(speed);

			map.panBy(movement, {animate: false});

			this._draggable._newPos._add(movement);
			this._draggable._startPos._add(movement);

			setPosition(marker._icon, this._draggable._newPos);
			this._onDrag(e);

			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
		}
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker
			.closePopup()
			.fire('movestart')
			.fire('dragstart');
	},

	_onPreDrag: function (e) {
		if (this._marker.options.autoPan) {
			cancelAnimFrame(this._panRequest);
			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
		}
	},

	_onDrag: function (e) {
		var marker = this._marker,
			shadow = marker._shadow,
			iconPos = getPosition(marker._icon),
			latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
			.fire('move', e)
			.fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		 cancelAnimFrame(this._panRequest);

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker
			.fire('moveend')
			.fire('dragend', e);
	}
});

/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

var Marker = Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon instance to use for rendering the marker.
		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
		// If not specified, a common instance of `L.Icon.Default` is used.
		icon: new IconDefault(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// @option bubblingMouseEvents: Boolean = false
		// When `true`, a mouse event on this marker will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: false,

		// @section Draggable marker options
		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option autoPan: Boolean = false
		// Whether to pan the map when dragging this marker near its edge or not.
		autoPan: false,

		// @option autoPanPadding: Point = Point(50, 50)
		// Distance (in pixels to the left/right and to the top/bottom) of the
		// map edge to start panning the map.
		autoPanPadding: [50, 50],

		// @option autoPanSpeed: Number = 10
		// Number of pixels the map should pan by.
		autoPanSpeed: 10
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		setOptions(this, options);
		this._latlng = toLatLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}
		delete this.dragging;

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = toLatLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon && this._map) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
			classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
			addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}

			if (icon.tagName === 'IMG') {
				icon.alt = options.alt || '';
			}
		}

		addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
			addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			addClass(newShadow, classToAdd);
			newShadow.alt = '';
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		setPosition(this._icon, pos);

		if (this._shadow) {
			setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		setOpacity(this._icon, opacity);

		if (this._shadow) {
			setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	},

	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor;
	},

	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor;
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
function marker(latlng, options) {
	return new Marker(latlng, options);
}

/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

var Path = Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option bubblingMouseEvents: Boolean = true
		// When `true`, a mouse event on this path will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in child classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
	}
});

/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

var CircleMarker = Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		setOptions(this, options);
		this._latlng = toLatLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		this._latlng = toLatLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
			r2 = this._radiusY || r,
			w = this._clickTolerance(),
			p = [r + w, r2 + w];
		this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p) {
		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
function circleMarker(latlng, options) {
	return new CircleMarker(latlng, options);
}

/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

var Circle = CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = extend({}, legacyOptions, {radius: options});
		}
		setOptions(this, options);
		this._latlng = toLatLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
			lat = this._latlng.lat,
			map = this._map,
			crs = map.options.crs;

		if (crs.distance === Earth.distance) {
			var d = Math.PI / 180,
				latR = (this._mRadius / Earth.R) / d,
				top = map.project([lat + latR, lng]),
				bottom = map.project([lat - latR, lng]),
				p = top.add(bottom).divideBy(2),
				lat2 = map.unproject(p).lat,
				lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
						(Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
			this._radiusY = p.y - top.y;

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
function circle(latlng, options, legacyOptions) {
	return new Circle(latlng, options, legacyOptions);
}

/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[45.51, -122.68],
 * 	[37.77, -122.43],
 * 	[34.04, -118.2]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[45.51, -122.68],
 * 	 [37.77, -122.43],
 * 	 [34.04, -118.2]],
 * 	[[40.78, -73.91],
 * 	 [41.83, -87.62],
 * 	 [32.76, -96.72]]
 * ];
 * ```
 */


var Polyline = Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	// @method closestLayerPoint(p: Point): Point
	// Returns the point closest to `p` on the Polyline.
	closestLayerPoint: function (p) {
		var minDistance = Infinity,
			minPoint = null,
			closest = _sqClosestPointOnSegment,
			p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, halfDist, segDist, dist, p1, p2, ratio,
			points = this._rings[0],
			len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = toLatLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
			flat = isFlat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = toLatLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
			p = new Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof LatLng,
			len = latlngs.length,
			i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
			i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
			tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p, closed) {
		var i, j, k, len, len2, part,
			w = this._clickTolerance();

		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

		// hit detection for polylines
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && (j === 0)) { continue; }

				if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
					return true;
				}
			}
		}
		return false;
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
function polyline(latlngs, options) {
	return new Polyline(latlngs, options);
}

// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
Polyline._flat = _flat;

/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 *   ],
 *   [ // second polygon
 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
 *   ]
 * ];
 * ```
 */

var Polygon = Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, j, p1, p2, f, area, x, y, center,
			points = this._rings[0],
			len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
			len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		Polyline.prototype._setLatLngs.call(this, latlngs);
		if (isFlat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
			w = this.options.weight,
			p = new Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p) {
		var inside = false,
			part, p1, p2, i, j, k, len, len2;

		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

		// ray casting algorithm for detecting if point is in polygon
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
					inside = !inside;
				}
			}
		}

		// also check if it's on polygon stroke
		return inside || Polyline.prototype._containsPoint.call(this, p, true);
	}

});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
function polygon(latlngs, options) {
	return new Polygon(latlngs, options);
}

/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

var GeoJSON = FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to include a feature or not.
	 * The default is to include all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 * Note: dynamically changing the `filter` option will have effect only on newly
	 * added data. It will _not_ re-evaluate already included features.
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 */

	initialize: function (geojson, options) {
		setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): this
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = isArray(geojson) ? geojson : geojson.features,
			i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer ): this
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): this
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:

// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
// Creates a `Layer` from a given GeoJSON feature. Can use a custom
// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
// functions if provided as options.
function geometryToLayer(geojson, options) {

	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		coords = geometry ? geometry.coordinates : null,
		layers = [],
		pointToLayer = options && options.pointToLayer,
		_coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
		latlng, latlngs, i, len;

	if (!coords && !geometry) {
		return null;
	}

	switch (geometry.type) {
	case 'Point':
		latlng = _coordsToLatLng(coords);
		return pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng);

	case 'MultiPoint':
		for (i = 0, len = coords.length; i < len; i++) {
			latlng = _coordsToLatLng(coords[i]);
			layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng));
		}
		return new FeatureGroup(layers);

	case 'LineString':
	case 'MultiLineString':
		latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
		return new Polyline(latlngs, options);

	case 'Polygon':
	case 'MultiPolygon':
		latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
		return new Polygon(latlngs, options);

	case 'GeometryCollection':
		for (i = 0, len = geometry.geometries.length; i < len; i++) {
			var layer = geometryToLayer({
				geometry: geometry.geometries[i],
				type: 'Feature',
				properties: geojson.properties
			}, options);

			if (layer) {
				layers.push(layer);
			}
		}
		return new FeatureGroup(layers);

	default:
		throw new Error('Invalid GeoJSON object.');
	}
}

// @function coordsToLatLng(coords: Array): LatLng
// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
function coordsToLatLng(coords) {
	return new LatLng(coords[1], coords[0], coords[2]);
}

// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
	var latlngs = [];

	for (var i = 0, len = coords.length, latlng; i < len; i++) {
		latlng = levelsDeep ?
			coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
			(_coordsToLatLng || coordsToLatLng)(coords[i]);

		latlngs.push(latlng);
	}

	return latlngs;
}

// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
function latLngToCoords(latlng, precision) {
	precision = typeof precision === 'number' ? precision : 6;
	return latlng.alt !== undefined ?
		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
}

// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
	var coords = [];

	for (var i = 0, len = latlngs.length; i < len; i++) {
		coords.push(levelsDeep ?
			latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) :
			latLngToCoords(latlngs[i], precision));
	}

	if (!levelsDeep && closed) {
		coords.push(coords[0]);
	}

	return coords;
}

function getFeature(layer, newGeometry) {
	return layer.feature ?
		extend({}, layer.feature, {geometry: newGeometry}) :
		asFeature(newGeometry);
}

// @function asFeature(geojson: Object): Object
// Normalize GeoJSON geometries/features into GeoJSON features.
function asFeature(geojson) {
	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
		return geojson;
	}

	return {
		type: 'Feature',
		properties: {},
		geometry: geojson
	};
}

var PointToGeoJSON = {
	toGeoJSON: function (precision) {
		return getFeature(this, {
			type: 'Point',
			coordinates: latLngToCoords(this.getLatLng(), precision)
		});
	}
};

// @namespace Marker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
Circle.include(PointToGeoJSON);
CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
Polyline.include({
	toGeoJSON: function (precision) {
		var multi = !isFlat(this._latlngs);

		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'LineString',
			coordinates: coords
		});
	}
});

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
Polygon.include({
	toGeoJSON: function (precision) {
		var holes = !isFlat(this._latlngs),
			multi = holes && !isFlat(this._latlngs[0]);

		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

		if (!holes) {
			coords = [coords];
		}

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'Polygon',
			coordinates: coords
		});
	}
});


// @namespace LayerGroup
LayerGroup.include({
	toMultiPoint: function (precision) {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
		});

		return getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
	toGeoJSON: function (precision) {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint(precision);
		}

		var isGeometryCollection = type === 'GeometryCollection',
			jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON(precision);
				if (isGeometryCollection) {
					jsons.push(json.geometry);
				} else {
					var feature = asFeature(json);
					// Squash nested feature collections
					if (feature.type === 'FeatureCollection') {
						jsons.push.apply(jsons, feature.features);
					} else {
						jsons.push(feature);
					}
				}
			}
		});

		if (isGeometryCollection) {
			return getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
function geoJSON(geojson, options) {
	return new GeoJSON(geojson, options);
}

// Backward compatibility.
var geoJson = geoJSON;

/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

var ImageOverlay = Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option crossOrigin: Boolean|String = false
		// Whether the crossOrigin attribute will be added to the image.
		// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
		crossOrigin: false,

		// @option errorOverlayUrl: String = ''
		// URL to the overlay image to show in place of the overlay that failed to load.
		errorOverlayUrl: '',

		// @option zIndex: Number = 1
		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
		zIndex: 1,

		// @option className: String = ''
		// A custom class name to assign to the image. Empty by default.
		className: ''
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = toLatLngBounds(bounds);

		setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	// @method setBounds(bounds: LatLngBounds): this
	// Update the bounds that this ImageOverlay covers
	setBounds: function (bounds) {
		this._bounds = toLatLngBounds(bounds);

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @method setZIndex(value: Number): this
	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
	setZIndex: function (value) {
		this.options.zIndex = value;
		this._updateZIndex();
		return this;
	},

	// @method getBounds(): LatLngBounds
	// Get the bounds that this ImageOverlay covers
	getBounds: function () {
		return this._bounds;
	},

	// @method getElement(): HTMLElement
	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
	// used by this overlay.
	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var wasElementSupplied = this._url.tagName === 'IMG';
		var img = this._image = wasElementSupplied ? this._url : create$1('img');

		addClass(img, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
		if (this.options.className) { addClass(img, this.options.className); }

		img.onselectstart = falseFn;
		img.onmousemove = falseFn;

		// @event load: Event
		// Fired when the ImageOverlay layer has loaded its image
		img.onload = bind(this.fire, this, 'load');
		img.onerror = bind(this._overlayOnError, this, 'error');

		if (this.options.crossOrigin || this.options.crossOrigin === '') {
			img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
		}

		if (this.options.zIndex) {
			this._updateZIndex();
		}

		if (wasElementSupplied) {
			this._url = img.src;
			return;
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
			offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

		setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
			bounds = new Bounds(
				this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
				this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
			size = bounds.getSize();

		setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		setOpacity(this._image, this.options.opacity);
	},

	_updateZIndex: function () {
		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._image.style.zIndex = this.options.zIndex;
		}
	},

	_overlayOnError: function () {
		// @event error: Event
		// Fired when the ImageOverlay layer fails to load its image
		this.fire('error');

		var errorUrl = this.options.errorOverlayUrl;
		if (errorUrl && this._url !== errorUrl) {
			this._url = errorUrl;
			this._image.src = errorUrl;
		}
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
var imageOverlay = function (url, bounds, options) {
	return new ImageOverlay(url, bounds, options);
};

/*
 * @class VideoOverlay
 * @aka L.VideoOverlay
 * @inherits ImageOverlay
 *
 * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
 *
 * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
 * HTML5 element.
 *
 * @example
 *
 * ```js
 * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
 * 	videoBounds = [[ 32, -130], [ 13, -100]];
 * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
 * ```
 */

var VideoOverlay = ImageOverlay.extend({

	// @section
	// @aka VideoOverlay options
	options: {
		// @option autoplay: Boolean = true
		// Whether the video starts playing automatically when loaded.
		autoplay: true,

		// @option loop: Boolean = true
		// Whether the video will loop back to the beginning when played.
		loop: true
	},

	_initImage: function () {
		var wasElementSupplied = this._url.tagName === 'VIDEO';
		var vid = this._image = wasElementSupplied ? this._url : create$1('video');

		addClass(vid, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }

		vid.onselectstart = falseFn;
		vid.onmousemove = falseFn;

		// @event load: Event
		// Fired when the video has finished loading the first frame
		vid.onloadeddata = bind(this.fire, this, 'load');

		if (wasElementSupplied) {
			var sourceElements = vid.getElementsByTagName('source');
			var sources = [];
			for (var j = 0; j < sourceElements.length; j++) {
				sources.push(sourceElements[j].src);
			}

			this._url = (sourceElements.length > 0) ? sources : [vid.src];
			return;
		}

		if (!isArray(this._url)) { this._url = [this._url]; }

		vid.autoplay = !!this.options.autoplay;
		vid.loop = !!this.options.loop;
		for (var i = 0; i < this._url.length; i++) {
			var source = create$1('source');
			source.src = this._url[i];
			vid.appendChild(source);
		}
	}

	// @method getElement(): HTMLVideoElement
	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
	// used by this overlay.
});


// @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
// Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
// geographical bounds it is tied to.

function videoOverlay(video, bounds, options) {
	return new VideoOverlay(video, bounds, options);
}

/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
var DivOverlay = Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
		} else {
			remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = toLatLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			toBack(this._container);
		}
		return this;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
			offset = toPoint(this.options.offset),
			anchor = this._getAnchor();

		if (this._zoomAnimated) {
			setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
			left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});

/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
var Popup = DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when another popup is opened.
		autoClose: true,

		// @option closeOnEscapeKey: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the ESC key for closing of the popup.
		closeOnEscapeKey: true,

		// @option closeOnClick: Boolean = *
		// Set it if you want to override the default behavior of the popup closing when user clicks
		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof Path)) {
				this._source.on('preclick', stopPropagation);
			}
		}
	},

	onRemove: function (map) {
		DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			if (!(this._source instanceof Path)) {
				this._source.off('preclick', stopPropagation);
			}
		}
	},

	getEvents: function () {
		var events = DivOverlay.prototype.getEvents.call(this);

		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
			container = this._container = create$1('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-animated');

		var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
		this._contentNode = create$1('div', prefix + '-content', wrapper);

		disableClickPropagation(wrapper);
		disableScrollPropagation(this._contentNode);
		on(wrapper, 'contextmenu', stopPropagation);

		this._tipContainer = create$1('div', prefix + '-tip-container', container);
		this._tip = create$1('div', prefix + '-tip', this._tipContainer);

		if (this.options.closeButton) {
			var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			on(closeButton, 'click', this._onCloseButtonClick, this);
		}
	},

	_updateLayout: function () {
		var container = this._contentNode,
			style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
			maxHeight = this.options.maxHeight,
			scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			addClass(container, scrolledClass);
		} else {
			removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
			anchor = this._getAnchor();
		setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan) { return; }
		if (this._map._panAnim) { this._map._panAnim.stop(); }

		var map = this._map,
			marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
			containerHeight = this._container.offsetHeight + marginBottom,
			containerWidth = this._containerWidth,
			layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
			padding = toPoint(this.options.autoPanPadding),
			paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
			paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
			size = map.getSize(),
			dx = 0,
			dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
				.fire('autopanstart')
				.panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
var popup = function (options, source) {
	return new Popup(options, source);
};


/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
Map.mergeOptions({
	closePopupOnClick: true
});


// @namespace Map
// @section Methods for Layers and Controls
Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof Popup)) {
			popup = new Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof Popup) {
			setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (!(layer instanceof Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return (this._popup ? this._popup.isOpen() : false);
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	},

	_onKeyPress: function (e) {
		if (e.originalEvent.keyCode === 13) {
			this._openPopup(e);
		}
	}
});

/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offsetting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
var Tooltip = DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamically switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	getEvents: function () {
		var events = DivOverlay.prototype.getEvents.call(this);

		if (touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
			className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = create$1('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_setPosition: function (pos) {
		var map = this._map,
			container = this._container,
			centerPoint = map.latLngToContainerPoint(map.getCenter()),
			tooltipPoint = map.layerPointToContainerPoint(pos),
			direction = this.options.direction,
			tooltipWidth = container.offsetWidth,
			tooltipHeight = container.offsetHeight,
			offset = toPoint(this.options.offset),
			anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
		} else if (direction === 'bottom') {
			pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));
		} else if (direction === 'center') {
			pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
		} else {
			direction = 'left';
			pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
		}

		removeClass(container, 'leaflet-tooltip-right');
		removeClass(container, 'leaflet-tooltip-left');
		removeClass(container, 'leaflet-tooltip-top');
		removeClass(container, 'leaflet-tooltip-bottom');
		addClass(container, 'leaflet-tooltip-' + direction);
		setPosition(container, pos);
	},

	_updatePosition: function () {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
var tooltip = function (options, source) {
	return new Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof Tooltip)) {
			tooltip = new Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof Tooltip) {
			setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = new Tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove$$1) {
		if (!remove$$1 && this._tooltipHandlersAdded) { return; }
		var onOff = remove$$1 ? 'off' : 'on',
			events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
			};
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove$$1;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (!(layer instanceof Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});

/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

var DivIcon = Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
			options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = toPoint(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
function divIcon(options) {
	return new DivIcon(options);
}

Icon.Default = IconDefault;

/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


var GridLayer = Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = (depends)
		// Load new tiles only when panning ends.
		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
		updateWhenIdle: mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: undefined,

		// @option maxNativeZoom: Number = undefined
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: undefined,

		// @option minNativeZoom: Number = undefined
		// Minimum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
		// from `minNativeZoom` level and auto-scaled.
		minNativeZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
		// tiles outside the CRS limits.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = undefined;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overridden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof Point ? s : new Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
			edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (ielt9) { return; }

		setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
			nextFrame = false,
			willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) {
					willPrune = true;
				} else {
					this._onOpaqueTile(tile);
				}
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
		}
	},

	_onOpaqueTile: falseFn,

	_initContainer: function () {
		if (this._container) { return; }

		this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
			maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
				this._onUpdateLevel(z);
			} else {
				remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				this._onRemoveLevel(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
			map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			falseFn(level.el.offsetWidth);

			this._onCreateLevel(level);
		}

		this._level = level;

		return level;
	},

	_onUpdateLevel: falseFn,

	_onRemoveLevel: falseFn,

	_onCreateLevel: falseFn,

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			remove(this._levels[z].el);
			this._onRemoveLevel(z);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = undefined;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
			y2 = Math.floor(y / 2),
			z2 = z - 1,
			coords2 = new Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
			tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
					tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_clampZoom: function (zoom) {
		var options = this.options;

		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
			return options.minNativeZoom;
		}

		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
			return options.maxNativeZoom;
		}

		return zoom;
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = this._clampZoom(Math.round(zoom));
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
			(this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
			translate = level.origin.multiplyBy(scale)
				.subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (any3d) {
			setTransform(level.el, translate, scale);
		} else {
			setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
			crs = map.options.crs,
			tileSize = this._tileSize = this.getTileSize(),
			tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
			mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
			scale = map.getZoomScale(mapZoom, this._tileZoom),
			pixelCenter = map.project(center, this._tileZoom).floor(),
			halfSize = map.getSize().divideBy(scale * 2);

		return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = this._clampZoom(map.getZoom());

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
			tileRange = this._pxBoundsToTileRange(pixelBounds),
			tileCenter = tileRange.getCenter(),
			queue = [],
			margin = this.options.keepBuffer,
			noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
									  tileRange.getTopRight().add([margin, -margin]));

		// Sanity check: panic if the tile range contains Infinity somewhere.
		if (!(isFinite(tileRange.min.x) &&
			  isFinite(tileRange.min.y) &&
			  isFinite(tileRange.max.x) &&
			  isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
				(!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	_tileCoordsToNwSe: function (coords) {
		var map = this._map,
			tileSize = this.getTileSize(),
			nwPoint = coords.scaleBy(tileSize),
			sePoint = nwPoint.add(tileSize),
			nw = map.unproject(nwPoint, coords.z),
			se = map.unproject(sePoint, coords.z);
		return [nw, se];
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {
		var bp = this._tileCoordsToNwSe(coords),
			bounds = new LatLngBounds(bp[0], bp[1]);

		if (!this.options.noWrap) {
			bounds = this._map.wrapLatLngBounds(bounds);
		}
		return bounds;
	},
	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
			coords = new Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = falseFn;
		tile.onmousemove = falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (ielt9 && this.options.opacity < 1) {
			setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (android && !android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
			key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
		}

		setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			setOpacity(tile.el, 0);
			cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (ielt9 || !this._map._fadeAnimated) {
				requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new Point(
			this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
function gridLayer(options) {
	return new GridLayer(options);
}

/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


var TileLayer = GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = 18
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: 18,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean|String = false
		// Whether the crossOrigin attribute will be added to the tiles.
		// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	// If the URL does not change, the layer will not be redrawn unless
	// the noRedraw parameter is set to false.
	setUrl: function (url, noRedraw) {
		if (this._url === url && noRedraw === undefined) {
			noRedraw = true;
		}

		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
		on(tile, 'error', bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin || this.options.crossOrigin === '') {
			tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		/*
		 Set role="presentation" to force screen readers to ignore this
		 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
		*/
		tile.setAttribute('role', 'presentation');

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return template(this._url, extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (ielt9) {
			setTimeout(bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl && tile.getAttribute('src') !== errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {
		var zoom = this._tileZoom,
		maxZoom = this.options.maxZoom,
		zoomReverse = this.options.zoomReverse,
		zoomOffset = this.options.zoomOffset;

		if (zoomReverse) {
			zoom = maxZoom - zoom;
		}

		return zoom + zoomOffset;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = falseFn;
				tile.onerror = falseFn;

				if (!tile.complete) {
					tile.src = emptyImageUrl;
					remove(tile);
					delete this._tiles[i];
				}
			}
		}
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		// Cancels any pending http requests associated with the tile
		// unless we're on Android's stock browser,
		// see https://github.com/Leaflet/Leaflet/issues/137
		if (!androidStock) {
			tile.el.setAttribute('src', emptyImageUrl);
		}

		return GridLayer.prototype._removeTile.call(this, key);
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {
			return;
		}

		return GridLayer.prototype._tileReady.call(this, coords, err, tile);
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

function tileLayer(url, options) {
	return new TileLayer(url, options);
}

/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data  2012 IEM Nexrad"
 * });
 * ```
 */

var TileLayerWMS = TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = setOptions(this, options);

		var realRetina = options.detectRetina && retina ? 2 : 1;
		var tileSize = this.getTileSize();
		wmsParams.width = tileSize.x * realRetina;
		wmsParams.height = tileSize.y * realRetina;

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToNwSe(coords),
			crs = this._crs,
			bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
			min = bounds.min,
			max = bounds.max,
			bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
			[min.y, min.x, max.y, max.x] :
			[min.x, min.y, max.x, max.y]).join(','),
			url = TileLayer.prototype.getTileUrl.call(this, coords);
		return url +
			getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
function tileLayerWMS(url, options) {
	return new TileLayerWMS(url, options);
}

TileLayer.WMS = TileLayerWMS;
tileLayer.wms = tileLayerWMS;

/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

var Renderer = Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1,

		// @option tolerance: Number = 0
		// How much to extend click tolerance round a path/object on the map
		tolerance : 0
	},

	initialize: function (options) {
		setOptions(this, options);
		stamp(this);
		this._layers = this._layers || {};
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
		this.on('update', this._updatePaths, this);
	},

	onRemove: function () {
		this.off('update', this._updatePaths, this);
		this._destroyContainer();
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update,
			zoomend: this._onZoomEnd
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
			position = getPosition(this._container),
			viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
			currentCenterPoint = this._map.project(this._center, zoom),
			destCenterPoint = this._map.project(center, zoom),
			centerOffset = destCenterPoint.subtract(currentCenterPoint),

			topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (any3d) {
			setTransform(this._container, topLeftOffset, scale);
		} else {
			setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);

		for (var id in this._layers) {
			this._layers[id]._reset();
		}
	},

	_onZoomEnd: function () {
		for (var id in this._layers) {
			this._layers[id]._project();
		}
	},

	_updatePaths: function () {
		for (var id in this._layers) {
			this._layers[id]._update();
		}
	},

	_update: function () {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
			size = this._map.getSize(),
			min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});

/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var Canvas = Renderer.extend({
	getEvents: function () {
		var events = Renderer.prototype.getEvents.call(this);
		events.viewprereset = this._onViewPreReset;
		return events;
	},

	_onViewPreReset: function () {
		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
		this._postponeUpdatePaths = true;
	},

	onAdd: function () {
		Renderer.prototype.onAdd.call(this);

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		on(container, 'mousemove', throttle(this._onMouseMove, 32, this), this);
		on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
		on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_destroyContainer: function () {
		cancelAnimFrame(this._redrawRequest);
		delete this._ctx;
		remove(this._container);
		off(this._container);
		delete this._container;
	},

	_updatePaths: function () {
		if (this._postponeUpdatePaths) { return; }

		var layer;
		this._redrawBounds = null;
		for (var id in this._layers) {
			layer = this._layers[id];
			layer._update();
		}
		this._redraw();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		Renderer.prototype._update.call(this);

		var b = this._bounds,
			container = this._container,
			size = b.getSize(),
			m = retina ? 2 : 1;

		setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_reset: function () {
		Renderer.prototype._reset.call(this);

		if (this._postponeUpdatePaths) {
			this._postponeUpdatePaths = false;
			this._updatePaths();
		}
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[stamp(layer)] = layer;

		var order = layer._order = {
			layer: layer,
			prev: this._drawLast,
			next: null
		};
		if (this._drawLast) { this._drawLast.next = order; }
		this._drawLast = order;
		this._drawFirst = this._drawFirst || this._drawLast;
	},

	_addPath: function (layer) {
		this._requestRedraw(layer);
	},

	_removePath: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			this._drawLast = prev;
		}
		if (prev) {
			prev.next = next;
		} else {
			this._drawFirst = next;
		}

		delete layer._order;

		delete this._layers[stamp(layer)];

		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		// Redraw the union of the layer's old pixel
		// bounds and the new pixel bounds.
		this._extendRedrawBounds(layer);
		layer._project();
		layer._update();
		// The redraw will extend the redraw bounds
		// with the new pixel bounds.
		this._requestRedraw(layer);
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (typeof layer.options.dashArray === 'string') {
			var parts = layer.options.dashArray.split(/[, ]+/),
				dashArray = [],
				dashValue,
				i;
			for (i = 0; i < parts.length; i++) {
				dashValue = Number(parts[i]);
				// Ignore dash array containing invalid lengths
				if (isNaN(dashValue)) { return; }
				dashArray.push(dashValue);
			}
			layer.options._dashArray = dashArray;
		} else {
			layer.options._dashArray = layer.options.dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		this._extendRedrawBounds(layer);
		this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
	},

	_extendRedrawBounds: function (layer) {
		if (layer._pxBounds) {
			var padding = (layer.options.weight || 0) + 1;
			this._redrawBounds = this._redrawBounds || new Bounds();
			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
		}
	},

	_redraw: function () {
		this._redrawRequest = null;

		if (this._redrawBounds) {
			this._redrawBounds.min._floor();
			this._redrawBounds.max._ceil();
		}

		this._clear(); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_clear: function () {
		var bounds = this._redrawBounds;
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
		} else {
			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
		}
	},

	_draw: function () {
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
			this._ctx.clip();
		}

		this._drawing = true;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
		}

		this._drawing = false;

		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {
		if (!this._drawing) { return; }

		var i, j, len2, p,
			parts = layer._parts,
			len = parts.length,
			ctx = this._ctx;

		if (!len) { return; }

		ctx.beginPath();

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (!this._drawing || layer._empty()) { return; }

		var p = layer._point,
			ctx = this._ctx,
			r = Math.max(Math.round(layer._radius), 1),
			s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var options = layer.options;

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			if (ctx.setLineDash) {
				ctx.setLineDash(layer.options && layer.options._dashArray || []);
			}
			ctx.globalAlpha = options.opacity;
			ctx.lineWidth = options.weight;
			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer)  {
			fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e) {
		var layer = this._hoveredLayer;
		if (layer) {
			// if we're leaving the layer, fire mouseout
			removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function (e, point) {
		var layer, candidateHoveredLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point)) {
				candidateHoveredLayer = layer;
			}
		}

		if (candidateHoveredLayer !== this._hoveredLayer) {
			this._handleMouseOut(e);

			if (candidateHoveredLayer) {
				addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
				this._hoveredLayer = candidateHoveredLayer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	_bringToFront: function (layer) {
		var order = layer._order;

		if (!order) { return; }

		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			// Already last
			return;
		}
		if (prev) {
			prev.next = next;
		} else if (next) {
			// Update first entry unless this is the
			// single entry
			this._drawFirst = next;
		}

		order.prev = this._drawLast;
		this._drawLast.next = order;

		order.next = null;
		this._drawLast = order;

		this._requestRedraw(layer);
	},

	_bringToBack: function (layer) {
		var order = layer._order;

		if (!order) { return; }

		var next = order.next;
		var prev = order.prev;

		if (prev) {
			prev.next = next;
		} else {
			// Already first
			return;
		}
		if (next) {
			next.prev = prev;
		} else if (prev) {
			// Update last entry unless this is the
			// single entry
			this._drawLast = prev;
		}

		order.prev = null;

		order.next = this._drawFirst;
		this._drawFirst.prev = order;
		this._drawFirst = order;

		this._requestRedraw(layer);
	}
});

// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
function canvas$1(options) {
	return canvas ? new Canvas(options) : null;
}

/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */


var vmlCreate = (function () {
	try {
		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
		return function (name) {
			return document.createElement('<lvml:' + name + ' class="lvml">');
		};
	} catch (e) {
		return function (name) {
			return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
		};
	}
})();


/*
 * @class SVG
 *
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
var vmlMixin = {

	_initContainer: function () {
		this._container = create$1('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function (layer) {
		var container = layer._container = vmlCreate('shape');

		addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = vmlCreate('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
		this._layers[stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		remove(container);
		layer.removeInteractiveTarget(container);
		delete this._layers[stamp(layer)];
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
			fill = layer._fill,
			options = layer.options,
			container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = vmlCreate('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = isArray(options.dashArray) ?
					options.dashArray.join(' ') :
					options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = vmlCreate('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
			r = Math.round(layer._radius),
			r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
			'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		toFront(layer._container);
	},

	_bringToBack: function (layer) {
		toBack(layer._container);
	}
};

var create$2 = vml ? vmlCreate : svgCreate;

/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var SVG = Renderer.extend({

	getEvents: function () {
		var events = Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = create$2('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = create$2('g');
		this._container.appendChild(this._rootGroup);
	},

	_destroyContainer: function () {
		remove(this._container);
		off(this._container);
		delete this._container;
		delete this._rootGroup;
		delete this._svgSize;
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		Renderer.prototype._update.call(this);

		var b = this._bounds,
			size = b.getSize(),
			container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = create$2('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
		this._layers[stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		if (!this._rootGroup) { this._initContainer(); }
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
		delete this._layers[stamp(layer)];
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
			options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
			r = Math.max(Math.round(layer._radius), 1),
			r2 = Math.max(Math.round(layer._radiusY), 1) || r,
			arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
			'M' + (p.x - r) + ',' + p.y +
			arc + (r * 2) + ',0 ' +
			arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		toFront(layer._path);
	},

	_bringToBack: function (layer) {
		toBack(layer._path);
	}
});

if (vml) {
	SVG.include(vmlMixin);
}

// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
function svg$1(options) {
	return svg || vml ? new SVG(options) : null;
}

Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			renderer = this._renderer = this._createRenderer();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = this._createRenderer({pane: name});
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	},

	_createRenderer: function (options) {
		// @namespace Map; @option preferCanvas: Boolean = false
		// Whether `Path`s should be rendered on a `Canvas` renderer.
		// By default, all `Path`s are rendered in a `SVG` renderer.
		return (this.options.preferCanvas && canvas$1(options)) || svg$1(options);
	}
});

/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Rectangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


var Rectangle = Polygon.extend({
	initialize: function (latLngBounds, options) {
		Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = toLatLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
function rectangle(latLngBounds, options) {
	return new Rectangle(latLngBounds, options);
}

SVG.create = create$2;
SVG.pointsToPath = pointsToPath;

GeoJSON.geometryToLayer = geometryToLayer;
GeoJSON.coordsToLatLng = coordsToLatLng;
GeoJSON.coordsToLatLngs = coordsToLatLngs;
GeoJSON.latLngToCoords = latLngToCoords;
GeoJSON.latLngsToCoords = latLngsToCoords;
GeoJSON.getFeature = getFeature;
GeoJSON.asFeature = asFeature;

/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

var BoxZoom = Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._resetStateTimeout = 0;
		map.on('unload', this._destroy, this);
	},

	addHooks: function () {
		on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_destroy: function () {
		remove(this._pane);
		delete this._pane;
	},

	_resetState: function () {
		this._resetStateTimeout = 0;
		this._moved = false;
	},

	_clearDeferredResetState: function () {
		if (this._resetStateTimeout !== 0) {
			clearTimeout(this._resetStateTimeout);
			this._resetStateTimeout = 0;
		}
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		// Clear the deferred resetState if it hasn't executed yet, otherwise it
		// will interrupt the interaction and orphan a box element in the container.
		this._clearDeferredResetState();
		this._resetState();

		disableTextSelection();
		disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		on(document, {
			contextmenu: stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = create$1('div', 'leaflet-zoom-box', this._container);
			addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new Bounds(this._point, this._startPoint),
			size = bounds.getSize();

		setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			remove(this._box);
			removeClass(this._container, 'leaflet-crosshair');
		}

		enableTextSelection();
		enableImageDrag();

		off(document, {
			contextmenu: stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		this._clearDeferredResetState();
		this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

		var bounds = new LatLngBounds(
				this._map.containerPointToLatLng(this._startPoint),
				this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

var DoubleClickZoom = Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
			oldZoom = map.getZoom(),
			delta = map.options.zoomDelta,
			zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second.
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

var Drag = Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new Draggable(map._mapPane, map._container);

			this._draggable.on({
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		removeClass(this._map._container, 'leaflet-grab');
		removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDragStart: function () {
		var map = this._map;

		map._stop();
		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = toLatLngBounds(this._map.options.maxBounds);

			this._offsetLimit = toBounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
			.fire('movestart')
			.fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
				pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			this._prunePositions(time);
		}

		this._map
			.fire('move', e)
			.fire('drag', e);
	},

	_prunePositions: function (time) {
		while (this._positions.length > 1 && time - this._times[0] > 50) {
			this._positions.shift();
			this._times.shift();
		}
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
			pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
			halfWidth = Math.round(worldWidth / 2),
			dx = this._initialWorldOffset,
			x = this._draggable._newPos.x,
			newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
			newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
			newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
			options = map.options,

			noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {
			this._prunePositions(+new Date());

			var direction = this._lastPos.subtract(this._positions[0]),
				duration = (this._lastTime - this._times[0]) / 1000,
				ease = options.easeLinearity,

				speedVector = direction.multiplyBy(ease / duration),
				speed = speedVector.distanceTo([0, 0]),

				limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
				limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

				decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
				offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
Map.addInitHook('addHandler', 'dragging', Drag);

/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

var Keyboard = Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
			docEl = document.documentElement,
			top = body.scrollTop || docEl.scrollTop,
			left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
			codes = this.keyCodes,
			i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
			codes = this.keyCodes,
			i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
			map = this._map,
			offset;

		if (key in this._panKeys) {
			if (!map._panAnim || !map._panAnim._inProgress) {
				offset = this._panKeys[key];
				if (e.shiftKey) {
					offset = toPoint(offset).multiplyBy(3);
				}

				map.panBy(offset);

				if (map.options.maxBounds) {
					map.panInsideBounds(map.options.maxBounds);
				}
			}
		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
			map.closePopup();

		} else {
			return;
		}

		stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
Map.addInitHook('addHandler', 'keyboard', Keyboard);

/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

var ScrollWheelZoom = Handler.extend({
	addHooks: function () {
		on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(bind(this._performZoom, this), left);

		stop(e);
	},

	_performZoom: function () {
		var map = this._map,
			zoom = map.getZoom(),
			snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
			d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
			d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
			delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

var Tap = Handler.extend({
	addHooks: function () {
		on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
			el = first.target;

		this._startPos = this._newPos = new Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
				el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
				type, true, true, window, 1,
				e.screenX, e.screenY,
				e.clientX, e.clientY,
				false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (touch && !pointer) {
	Map.addInitHook('addHandler', 'tap', Tap);
}

/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: touch && !android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

var TouchZoom = Handler.extend({
	addHooks: function () {
		addClass(this._map._container, 'leaflet-touch-zoom');
		on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		removeClass(this._map._container, 'leaflet-touch-zoom');
		off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
			p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		on(document, 'touchmove', this._onTouchMove, this);
		on(document, 'touchend', this._onTouchEnd, this);

		preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
			p1 = map.mouseEventToContainerPoint(e.touches[0]),
			p2 = map.mouseEventToContainerPoint(e.touches[1]),
			scale = p1.distanceTo(p2) / this._startDist;

		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true, false);
			this._moved = true;
		}

		cancelAnimFrame(this._animRequest);

		var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = requestAnimFrame(moveFn, this, true);

		preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		cancelAnimFrame(this._animRequest);

		off(document, 'touchmove', this._onTouchMove);
		off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

Map.BoxZoom = BoxZoom;
Map.DoubleClickZoom = DoubleClickZoom;
Map.Drag = Drag;
Map.Keyboard = Keyboard;
Map.ScrollWheelZoom = ScrollWheelZoom;
Map.Tap = Tap;
Map.TouchZoom = TouchZoom;

Object.freeze = freeze;

exports.version = version;
exports.Control = Control;
exports.control = control;
exports.Browser = Browser;
exports.Evented = Evented;
exports.Mixin = Mixin;
exports.Util = Util;
exports.Class = Class;
exports.Handler = Handler;
exports.extend = extend;
exports.bind = bind;
exports.stamp = stamp;
exports.setOptions = setOptions;
exports.DomEvent = DomEvent;
exports.DomUtil = DomUtil;
exports.PosAnimation = PosAnimation;
exports.Draggable = Draggable;
exports.LineUtil = LineUtil;
exports.PolyUtil = PolyUtil;
exports.Point = Point;
exports.point = toPoint;
exports.Bounds = Bounds;
exports.bounds = toBounds;
exports.Transformation = Transformation;
exports.transformation = toTransformation;
exports.Projection = index;
exports.LatLng = LatLng;
exports.latLng = toLatLng;
exports.LatLngBounds = LatLngBounds;
exports.latLngBounds = toLatLngBounds;
exports.CRS = CRS;
exports.GeoJSON = GeoJSON;
exports.geoJSON = geoJSON;
exports.geoJson = geoJson;
exports.Layer = Layer;
exports.LayerGroup = LayerGroup;
exports.layerGroup = layerGroup;
exports.FeatureGroup = FeatureGroup;
exports.featureGroup = featureGroup;
exports.ImageOverlay = ImageOverlay;
exports.imageOverlay = imageOverlay;
exports.VideoOverlay = VideoOverlay;
exports.videoOverlay = videoOverlay;
exports.DivOverlay = DivOverlay;
exports.Popup = Popup;
exports.popup = popup;
exports.Tooltip = Tooltip;
exports.tooltip = tooltip;
exports.Icon = Icon;
exports.icon = icon;
exports.DivIcon = DivIcon;
exports.divIcon = divIcon;
exports.Marker = Marker;
exports.marker = marker;
exports.TileLayer = TileLayer;
exports.tileLayer = tileLayer;
exports.GridLayer = GridLayer;
exports.gridLayer = gridLayer;
exports.SVG = SVG;
exports.svg = svg$1;
exports.Renderer = Renderer;
exports.Canvas = Canvas;
exports.canvas = canvas$1;
exports.Path = Path;
exports.CircleMarker = CircleMarker;
exports.circleMarker = circleMarker;
exports.Circle = Circle;
exports.circle = circle;
exports.Polyline = Polyline;
exports.polyline = polyline;
exports.Polygon = Polygon;
exports.polygon = polygon;
exports.Rectangle = Rectangle;
exports.rectangle = rectangle;
exports.Map = Map;
exports.map = createMap;

var oldL = window.L;
exports.noConflict = function() {
	window.L = oldL;
	return this;
}

// Always export us to window global (see #2364)
window.L = exports;

})));
//# sourceMappingURL=leaflet-src.js.map
};

exports();
module.resolveWith(exports);
};
// module factory: end

FD40.module("leaflet", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

// ----------------------------------------------------------------------------
// markItUp! Universal MarkUp Engine, JQuery plugin
// v 1.1.x
// Dual licensed under the MIT and GPL licenses.
// ----------------------------------------------------------------------------
// Copyright (C) 2007-2012 Jay Salvat
// http://markitup.jaysalvat.com/
// ----------------------------------------------------------------------------
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// ----------------------------------------------------------------------------

(function($) {
	$.fn.markItUp = function(settings, extraSettings) {
		var method, params, options, ctrlKey, shiftKey, altKey; ctrlKey = shiftKey = altKey = false;

		if (typeof settings == 'string') {
			method = settings;
			params = extraSettings;
		}

		options = {	id:						'',
					nameSpace:				'',
					root:					'',
					previewHandler:			false,
					previewInWindow:		'', // 'width=800, height=600, resizable=yes, scrollbars=yes'
					previewInElement:		'',
					previewAutoRefresh:		true,
					previewPosition:		'after',
					previewTemplatePath:	'~/templates/preview.html',
					previewParser:			false,
					previewParserPath:		'',
					previewParserVar:		'data',
					resizeHandle:			true,
					beforeInsert:			'',
					afterInsert:			'',
					onEnter:				{},
					onShiftEnter:			{},
					onCtrlEnter:			{},
					onTab:					{},
					markupSet:			[	{ /* set */ } ]
				};

		$.extend(options, settings, $.markItUp.sets[(extraSettings || settings || {}).set], extraSettings);

		// compute markItUp! path
		if (!options.root) {
			$('script').each(function(a, tag) {
				miuScript = $(tag).get(0).src.match(/(.*)jquery\.markitup(\.pack)?\.js$/);
				if (miuScript !== null) {
					options.root = miuScript[1];
				}
			});
		}

		return this.each(function() {
			var $$, textarea, levels, scrollPosition, caretPosition, caretOffset,
				clicked, hash, header, footer, previewWindow, template, iFrame, abort;
			$$ = $(this);
			textarea = this;
			levels = [];
			abort = false;
			scrollPosition = caretPosition = 0;
			caretOffset = -1;

			options.previewParserPath = localize(options.previewParserPath);
			options.previewTemplatePath = localize(options.previewTemplatePath);

			if (method) {
				switch(method) {
					case 'remove':
						remove();
					break;
					case 'insert':
						markup(params);
					break;
					default:
						$.error('Method ' +  method + ' does not exist on jQuery.markItUp');
				}
				return;
			}

			// apply the computed path to ~/
			function localize(data, inText) {
				if (inText) {
					return 	data.replace(/("|')~\//g, "$1"+options.root);
				}
				return 	data.replace(/^~\//, options.root);
			}

			// init and build editor
			function init() {
				id = ''; nameSpace = '';
				if (options.id) {
					id = 'id="'+options.id+'"';
				} else if ($$.attr("id")) {
					id = 'id="markItUp'+($$.attr("id").substr(0, 1).toUpperCase())+($$.attr("id").substr(1))+'"';

				}
				if (options.nameSpace) {
					nameSpace = 'class="'+options.nameSpace+'"';
				}
				$$.wrap('<div '+nameSpace+'></div>');
				$$.wrap('<div '+id+' class="markItUp"></div>');
				$$.wrap('<div class="markItUpContainer"></div>');
				$$.addClass("markItUpEditor");

				// add the header before the textarea
				header = $('<div class="markItUpHeader"></div>').insertBefore($$);
				$(dropMenus(options.markupSet)).appendTo(header);

				// add the footer after the textarea
				footer = $('<div class="markItUpFooter"></div>').insertAfter($$);

				// Wrapper for expandingTextarea
				$$.wrap('<div class="markItUpExpanding"></div>');

				// add the resize handle after textarea
				if (options.resizeHandle === true && $.browser.safari !== true) {
					resizeHandle = $('<div class="markItUpResizeHandle"></div>')
						.insertAfter($$)
						.bind("mousedown.markItUp", function(e) {
							var h = $$.height(), y = e.clientY, mouseMove, mouseUp;
							mouseMove = function(e) {
								$$.css("height", Math.max(20, e.clientY+h-y)+"px");
								return false;
							};
							mouseUp = function(e) {
								$("html").unbind("mousemove.markItUp", mouseMove).unbind("mouseup.markItUp", mouseUp);
								return false;
							};
							$("html").bind("mousemove.markItUp", mouseMove).bind("mouseup.markItUp", mouseUp);
					});
					footer.append(resizeHandle);
				}

				// listen key events
				$$.bind('keydown.markItUp', keyPressed).bind('keyup', keyPressed);

				// bind an event to catch external calls
				$$.bind("insertion.markItUp", function(e, settings) {
					if (settings.target !== false) {
						get();
					}
					if (textarea === $.markItUp.focused) {
						markup(settings);
					}
				});

				// remember the last focus
				$$.bind('focus.markItUp', function() {
					$.markItUp.focused = this;
				});

				if (options.previewInElement) {
					refreshPreview();
				}
			}

			// recursively build header with dropMenus from markupset
			function dropMenus(markupSet) {
				var ul = $('<ul></ul>'), i = 0;
				$('li:hover > ul', ul).css('display', 'block');
				$.each(markupSet, function() {
					var button = this, t = '', title, li, j;
					title = (button.key) ? (button.name||'')+' [Ctrl+'+button.key+']' : (button.name||'');
					key   = (button.key) ? 'accesskey="'+button.key+'"' : '';
					if (button.separator) {
						li = $('<li class="markItUpSeparator">'+(button.separator||'')+'</li>').appendTo(ul);
					} else {
						i++;
						for (j = levels.length -1; j >= 0; j--) {
							t += levels[j]+"-";
						}
						li = $('<li class="markItUpButton markItUpButton'+t+(i)+' '+(button.className||'')+'"><a href="" '+key+' title="'+title+'">'+(button.name||'')+'</a></li>')
						.bind("contextmenu.markItUp", function() { // prevent contextmenu on mac and allow ctrl+click
							return false;
						}).bind('click.markItUp', function() {
							return false;
						}).bind("focusin.markItUp", function(){
                            $$.focus();
						}).bind('mouseup', function() {
							if (button.call) {
								eval(button.call)();
							}
							setTimeout(function() { markup(button) },1);
							return false;
						}).bind('mouseenter.markItUp', function() {
								$('> ul', this).show();
								$(document).one('click', function() { // close dropmenu if click outside
										$('ul ul', header).hide();
									}
								);
						}).bind('mouseleave.markItUp', function() {
								$('> ul', this).hide();
						}).appendTo(ul);
						if (button.dropMenu) {
							levels.push(i);
							$(li).addClass('markItUpDropMenu').append(dropMenus(button.dropMenu));
						}
					}
				});
				levels.pop();
				return ul;
			}

			// markItUp! markups
			function magicMarkups(string) {
				if (string) {
					string = string.toString();
					string = string.replace(/\(\!\(([\s\S]*?)\)\!\)/g,
						function(x, a) {
							var b = a.split('|!|');
							if (altKey === true) {
								return (b[1] !== undefined) ? b[1] : b[0];
							} else {
								return (b[1] === undefined) ? "" : b[0];
							}
						}
					);
					// [![prompt]!], [![prompt:!:value]!]
					string = string.replace(/\[\!\[([\s\S]*?)\]\!\]/g,
						function(x, a) {
							var b = a.split(':!:');
							if (abort === true) {
								return false;
							}
							value = prompt(b[0], (b[1]) ? b[1] : '');
							if (value === null) {
								abort = true;
							}
							return value;
						}
					);
					return string;
				}
				return "";
			}

			// prepare action
			function prepare(action) {
				if ($.isFunction(action)) {
					action = action(hash);
				}
				return magicMarkups(action);
			}

			// build block to insert
			function build(string) {
				var openWith 			= prepare(clicked.openWith);
				var placeHolder 		= prepare(clicked.placeHolder);
				var replaceWith 		= prepare(clicked.replaceWith);
				var closeWith 			= prepare(clicked.closeWith);
				var openBlockWith 		= prepare(clicked.openBlockWith);
				var closeBlockWith 		= prepare(clicked.closeBlockWith);
				var multiline 			= clicked.multiline;

				if (replaceWith !== "") {
					block = openWith + replaceWith + closeWith;
				} else if (selection === '' && placeHolder !== '') {
					block = openWith + placeHolder + closeWith;
				} else {
					string = string || selection;

					var lines = [string], blocks = [];

					if (multiline === true) {
						lines = string.split(/\r?\n/);
					}

					for (var l = 0; l < lines.length; l++) {
						line = lines[l];
						var trailingSpaces;
						if (trailingSpaces = line.match(/ *$/)) {
							blocks.push(openWith + line.replace(/ *$/g, '') + closeWith + trailingSpaces);
						} else {
							blocks.push(openWith + line + closeWith);
						}
					}

					block = blocks.join("\n");
				}

				block = openBlockWith + block + closeBlockWith;

				return {	block:block,
							openWith:openWith,
							replaceWith:replaceWith,
							placeHolder:placeHolder,
							closeWith:closeWith
					};
			}

			// define markup to insert
			function markup(button) {
				var len, j, n, i;
				hash = clicked = button;
				get();
				$.extend(hash, {	line:"",
						 			root:options.root,
									textarea:textarea,
									selection:(selection||''),
									caretPosition:caretPosition,
									ctrlKey:ctrlKey,
									shiftKey:shiftKey,
									altKey:altKey
								}
							);
				// callbacks before insertion
				prepare(options.beforeInsert);
				prepare(clicked.beforeInsert);
				if ((ctrlKey === true && shiftKey === true) || button.multiline === true) {
					prepare(clicked.beforeMultiInsert);
				}
				$.extend(hash, { line:1 });

				if ((ctrlKey === true && shiftKey === true)) {
					lines = selection.split(/\r?\n/);
					for (j = 0, n = lines.length, i = 0; i < n; i++) {
						if ($.trim(lines[i]) !== '') {
							$.extend(hash, { line:++j, selection:lines[i] } );
							lines[i] = build(lines[i]).block;
						} else {
							lines[i] = "";
						}
					}

					string = { block:lines.join('\n')};
					start = caretPosition;
					len = string.block.length + (($.browser.opera) ? n-1 : 0);
				} else if (ctrlKey === true) {
					string = build(selection);
					start = caretPosition + string.openWith.length;
					len = string.block.length - string.openWith.length - string.closeWith.length;
					len = len - (string.block.match(/ $/) ? 1 : 0);
					len -= fixIeBug(string.block);
				} else if (shiftKey === true) {
					string = build(selection);
					start = caretPosition;
					len = string.block.length;
					len -= fixIeBug(string.block);
				} else {
					string = build(selection);
					start = caretPosition + string.block.length ;
					len = 0;
					start -= fixIeBug(string.block);
				}
				if ((selection === '' && string.replaceWith === '')) {
					caretOffset += fixOperaBug(string.block);

					start = caretPosition + string.openWith.length;
					len = string.block.length - string.openWith.length - string.closeWith.length;

					caretOffset = $$.val().substring(caretPosition,  $$.val().length).length;
					caretOffset -= fixOperaBug($$.val().substring(0, caretPosition));
				}
				$.extend(hash, { caretPosition:caretPosition, scrollPosition:scrollPosition } );

				if (string.block !== selection && abort === false) {
					insert(string.block);
					set(start, len);
				} else {
					caretOffset = -1;
				}
				get();

				$.extend(hash, { line:'', selection:selection });

				// callbacks after insertion
				if ((ctrlKey === true && shiftKey === true) || button.multiline === true) {
					prepare(clicked.afterMultiInsert);
				}
				prepare(clicked.afterInsert);
				prepare(options.afterInsert);

				// refresh preview if opened
				if (previewWindow && options.previewAutoRefresh) {
					refreshPreview();
				}

				// reinit keyevent
				shiftKey = altKey = ctrlKey = abort = false;
			}

			// Substract linefeed in Opera
			function fixOperaBug(string) {
				if ($.browser.opera) {
					return string.length - string.replace(/\n*/g, '').length;
				}
				return 0;
			}
			// Substract linefeed in IE
			function fixIeBug(string) {
				if ($.browser.msie) {
					return string.length - string.replace(/\r*/g, '').length;
				}
				return 0;
			}

			// add markup
			function insert(block) {
				if (document.selection) {
					var newSelection = document.selection.createRange();
					newSelection.text = block;
				} else {
					textarea.value =  textarea.value.substring(0, caretPosition)  + block + textarea.value.substring(caretPosition + selection.length, textarea.value.length);
				}
			}

			// set a selection
			function set(start, len) {
				if (textarea.createTextRange){
					// quick fix to make it work on Opera 9.5
					if ($.browser.opera && $.browser.version >= 9.5 && len == 0) {
						return false;
					}
					range = textarea.createTextRange();
					range.collapse(true);
					range.moveStart('character', start);
					range.moveEnd('character', len);
					range.select();
				} else if (textarea.setSelectionRange ){
					textarea.setSelectionRange(start, start + len);
				}
				textarea.scrollTop = scrollPosition;
				textarea.focus();
			}

			// get the selection
			function get() {
				textarea.focus();

				scrollPosition = textarea.scrollTop;
				if (document.selection) {
					selection = document.selection.createRange().text;
					if ($.browser.msie) { // ie
						var range = document.selection.createRange(), rangeCopy = range.duplicate();
						rangeCopy.moveToElementText(textarea);
						caretPosition = -1;
						while(rangeCopy.inRange(range)) {
							rangeCopy.moveStart('character');
							caretPosition ++;
						}
					} else { // opera
						caretPosition = textarea.selectionStart;
					}
				} else { // gecko & webkit
					caretPosition = textarea.selectionStart;

					selection = textarea.value.substring(caretPosition, textarea.selectionEnd);
				}
				return selection;
			}

			// open preview window
			function preview() {
				if (typeof options.previewHandler === 'function') {
					previewWindow = true;
				} else if (options.previewInElement) {
					previewWindow = $(options.previewInElement);
				} else if (!previewWindow || previewWindow.closed) {
					if (options.previewInWindow) {
						previewWindow = window.open('', 'preview', options.previewInWindow);
						$(window).unload(function() {
							previewWindow.close();
						});
					} else {
						iFrame = $('<iframe class="markItUpPreviewFrame"></iframe>');
						if (options.previewPosition == 'after') {
							iFrame.insertAfter(footer);
						} else {
							iFrame.insertBefore(header);
						}
						previewWindow = iFrame[iFrame.length - 1].contentWindow || frame[iFrame.length - 1];
					}
				} else if (altKey === true) {
					if (iFrame) {
						iFrame.remove();
					} else {
						previewWindow.close();
					}
					previewWindow = iFrame = false;
				}
				if (!options.previewAutoRefresh) {
					refreshPreview();
				}
				if (options.previewInWindow) {
					previewWindow.focus();
				}
			}

			// refresh Preview window
			function refreshPreview() {
 				renderPreview();
			}

			function renderPreview() {
				var phtml;
				if (options.previewHandler && typeof options.previewHandler === 'function') {
					options.previewHandler( $$.val() );
				} else if (options.previewParser && typeof options.previewParser === 'function') {
					var data = options.previewParser( $$.val() );
					writeInPreview(localize(data, 1) );
				} else if (options.previewParserPath !== '') {
					$.ajax({
						type: 'POST',
						dataType: 'text',
						global: false,
						url: options.previewParserPath,
						data: options.previewParserVar+'='+encodeURIComponent($$.val()),
						success: function(data) {
							writeInPreview( localize(data, 1) );
						}
					});
				} else {
					if (!template) {
						$.ajax({
							url: options.previewTemplatePath,
							dataType: 'text',
							global: false,
							success: function(data) {
								writeInPreview( localize(data, 1).replace(/<!-- content -->/g, $$.val()) );
							}
						});
					}
				}
				return false;
			}

			function writeInPreview(data) {
				if (options.previewInElement) {
					$(options.previewInElement).html(data);
				} else if (previewWindow && previewWindow.document) {
					try {
						sp = previewWindow.document.documentElement.scrollTop
					} catch(e) {
						sp = 0;
					}
					previewWindow.document.open();
					previewWindow.document.write(data);
					previewWindow.document.close();
					previewWindow.document.documentElement.scrollTop = sp;
				}
			}

			// set keys pressed
			function keyPressed(e) {
				shiftKey = e.shiftKey;
				altKey = e.altKey;
				ctrlKey = (!(e.altKey && e.ctrlKey)) ? (e.ctrlKey || e.metaKey) : false;

				if (e.type === 'keydown') {
					if (ctrlKey === true) {
						li = $('a[accesskey="'+((e.keyCode == 13) ? '\\n' : String.fromCharCode(e.keyCode))+'"]', header).parent('li');
						if (li.length !== 0) {
							ctrlKey = false;
							setTimeout(function() {
								li.triggerHandler('mouseup');
							},1);
							return false;
						}
					}
					if (e.keyCode === 13 || e.keyCode === 10) { // Enter key
						if (ctrlKey === true) {  // Enter + Ctrl
							ctrlKey = false;
							markup(options.onCtrlEnter);
							return options.onCtrlEnter.keepDefault;
						} else if (shiftKey === true) { // Enter + Shift
							shiftKey = false;
							markup(options.onShiftEnter);
							return options.onShiftEnter.keepDefault;
						} else { // only Enter
							markup(options.onEnter);
							return options.onEnter.keepDefault;
						}
					}
					if (e.keyCode === 9) { // Tab key
						if (shiftKey == true || ctrlKey == true || altKey == true) {
							return false;
						}
						if (caretOffset !== -1) {
							get();
							caretOffset = $$.val().length - caretOffset;
							set(caretOffset, 0);
							caretOffset = -1;
							return false;
						} else {
							markup(options.onTab);
							return options.onTab.keepDefault;
						}
					}
				}
			}

			function remove() {
				$$.unbind(".markItUp").removeClass('markItUpEditor');
				$$.parents('div.markItUp').parent('div').replaceWith($$);
				$$.data('markItUp', null);
			}

			init();
		});
	};

	$.fn.markItUpRemove = function() {
		return this.each(function() {
				$(this).markItUp('remove');
			}
		);
	};

	var sets;

	if (typeof $.markItUp === "object") {
		sets = $.markItUp.sets;
	}

	$.markItUp = function(settings) {
		var options = { target:false };
		$.extend(options, settings);
		if (options.target) {
			return $(options.target).each(function() {
				$(this).focus();
				$(this).trigger('insertion', [options]);
			});
		} else {
			$('textarea').trigger('insertion', [options]);
		}
	};

	$.markItUp.sets = {};

	if (sets) {
		$.extend($.markItUp.sets, sets);
	}

})(jQuery);

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("markitup", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var exports = function() {

/**
 * jquery.mentions.
 * Textarea with ability to highlight text blocks
 * Includes built-in autogrow and autocomplete
 * and a inspector utility for debugging purposes.
 *
 * Customizable trigger keys allows you to create
 * mentions, hashtags and nything else that fit your needs.
 *
 * Copyright (c) 2013 Jensen Tonne
 * http://www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Trigger configuration:
 *
 * type
 *   Name for the trigger type.
 *
 * wrap
 *   Whether or not hitting a trigger key before existing
 *   characters will wrap these characters into the block
 *   marker until a stop character is found. Space will
 *   always be a stop character whether or not it is
 *   specified in allowSpace or stop option. (default: false)
 *
 * stop
 *   A string of characters that will end the block. (default: "")
 *
 * allowSpace
 *   If true, hitting on a space in a block marker
 *   will not end the block marker until a consecutive
 *   space is pressed. (default: false)
 *
 * query
 *   Accepts a url string, an array of objects or
 *   a function that returns a deferred object that
 *   resolves with an array of objects. Also accept a
 *   query configuration object (advanced users only!).
 *
 * finalize
 *    If true, after selecting an item from the
 *    autocomplete menu, the block marker is finalized
 *    and any further changes to within the block marker
 *    will simply destroy the entire marker. (default: false)
 *
 * triggers: {
 *     "@": {
 *         type: "entity",
 *         wrap: false,
 *         stop: "",
 *         allowSpace: true,
 *         query: http://json/rest/api?q=
 *     },
 *     "#": {
 *         type: "hashtag",
 *         wrap: true,
 *         stop: " #",
 *         allowSpace: false
 *     }
 * }
 *
 */var _backspace = "",
	_space     = " ",
	_nbsp      = "\u00a0",
	_newline   = "\n",
	_typeAttr  = "data-type",
	_valueAttr = "data-value",
	KEYCODE = {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		ENTER: 13,
		ESCAPE: 27,
		LEFT: 37,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	};

// TODO: Put this elsewhere
$.fn.caret = function(start, end) {

	if (this.length == 0) {
		return;
	}

	if (typeof start == 'number') {

		end = (typeof end == 'number') ? end : start;

		return this.each(function() {

			if (this.setSelectionRange) {
				var obj = this;

				// window.setTimout is a walkaround to address the chrome bug.
				window.setTimeout(function() {
					obj.setSelectionRange(start, end);
				}, 0);

			} else if (this.createTextRange) {
				var range = this.createTextRange();
				range.collapse(true);
				range.moveEnd('character', end);
				range.moveStart('character', start);
				try { range.select(); } catch (ex) { }
			}
		});

	} else {
		if (this[0].setSelectionRange)
		{
			start = this[0].selectionStart;
			end = this[0].selectionEnd;
		} else if (document.selection && document.selection.createRange)
		{
			var range = document.selection.createRange();
			start = 0 - range.duplicate().moveStart('character', -100000);
			end = start + range.text.length;
		}
		return { start: start, end: end };
	}
};
var Marker = function(options) {
	$.extend(this, options);
}

$.extend(Marker.prototype, {

	val: function(str) {

		var marker = this;

		if (str===undefined) {
			return marker.text.nodeValue;
		}

		// Update text value
		marker.text.nodeValue = str;

		// Update end & length
		marker.end = marker.start + (marker.length = str.length);

		return marker;
	},

	nextSibling: function(node) {

		var next = node.nextSibling;

		while (next && next.nodeType===1 && next.hasAttribute("data-ignore")) {
			next = next.nextSibling;
		}

		return next;
	},

	insert: function(str, start, end) {

		// Marker
		var marker     = this,
			block      = marker.block,
			text       = marker.text,
			parent     = marker.parent,
			br         = marker.br,
			val        = marker.val(),
			length     = marker.length,

			// Character flags
			newline    = str==_newline,
			space      = str==_space,
			backspace  = str==_backspace,

			// Trigger
			trigger = marker.trigger || {},
			finalize = trigger.finalize,
			finalized = marker.finalized,

			// Spaces
			// We need to insert space in a spawned marker when:
			//  - space is not allowed in block marker
			//  - space is allowed in block marker
			//    but there's already a trailing space.
			trailingSpace = val.charCodeAt(start - 1) == 32,
			allowSpace = trigger.allowSpace || marker.allowSpace,
			spawnSpace = space && (!allowSpace || (allowSpace && trailingSpace));

		// If no start position was given,
		// assume want to insert at the end of the text.
		if (start===undefined) start = length;

		// If no end position was given,
		// assume we want to insert in a single position.
		if (end===undefined) end = start;

		// If this block marker already has a trailing space
		// but the block marker hasn't been finalized yet.
		if (block && trailingSpace && !allowSpace && !finalized) {

			// Reverse the insertion on textarea
			if (space) {

				var $textarea = $(marker.textarea),
					wholeText = $textarea.val(),
					pos = $textarea.caret().end - 1,
					offset = marker.start + start;

				$textarea
					.val(wholeText.substring(0, offset) + wholeText.slice(offset + 1))
					.caret(pos);
			}

			// Convert to text marker
			marker.toTextMarker();

			// TODO: Refactor this
			if (space) {
				// Trigger marker for post processing
				$(parent).trigger("markerInsert", [marker, nodes, str, start, end]);
				return marker;
			// For other characters, restart text insertion process.
			} else {
				return marker.insert(str, start, end);
			}
		}

		// If we are at the end of a block marker OR this is a newline block marker,
		// space & newline should be added to beginning of the next marker.
		if (block && end==length && !backspace && (spawnSpace || newline || br || finalized)) {
			var spawn = marker.spawn().insert(str, 0);
			$(parent).trigger("markerExit", [marker, nodes, spawn, str, start, end]);
			return spawn;
		}

		// Quick monkey patch for typing before a block marker
		// in the beginning of the textarea.
		if (block && marker.index===0 && end===0 && str.length===1) {
			var textnode = document.createTextNode(str);
			parent.insertBefore(textnode, block);

			var newMarker = new Marker({
				index: 0,
				start: 0,
				end: str.length,
				text: textnode,
				parent: parent,
				textarea: marker.textarea,
				allowSpace: true,
			});

			// Trigger marker for post processing
			$(parent).trigger("markerInsert", [newMarker, nodes, str, start, end]);

			return newMarker;
		}

		// Nodes
		var next   = block ? block.nextSibling : text.nextSibling,

			// Text
			prefix = val.substring(0, start),
			suffix = val.slice(end),

			// Chunks
			// Replace double space with one space and one nbsp to ensure
			// overlay is rendered proper spacing + identical word-wrap.
			chunks = str.replace(/  /g, " " + _nbsp).split(_newline),
			nodes  = [],
			node   = block || text,
			i      = chunks.length;

		// Add the prefix/suffix to the first/last chunk.
		// If this is a single chunk, the suffix is
		// actually added to the same chunk. :)
		chunks[0] = prefix + chunks[0];
		chunks[i-1] += suffix;

		// If this is a single chunk, this loop won't execute
		// but we still benefit from having the correct index. :)
		while (--i) {

			var node = document.createTextNode(chunks[i]),
				br = document.createElement("BR");

			nodes.push(parent.insertBefore(node, next));
			nodes.push(parent.insertBefore(br, node));

			next = br;
		}

		// Update the text value in the current marker
		marker.val(chunks[i]);

		// Trigger marker for post processing
		$(parent).trigger("markerInsert", [marker, nodes, str, start, end]);

		return marker;
	},

	remove: function() {

		var marker = this,
			parent = marker.parent,
			block = marker.block,
			text = marker.text;

		if (block) $(block).trigger("triggerDestroy", [marker]);

		parent.removeChild(block || text);

		marker.removed = true;

		$(parent).trigger("markerRemove", [marker]);

		return marker;
	},

	toTextMarker: function() {

		var marker = this,
			block  = marker.block,
			parent = marker.parent;

		if (!block) return marker;

		// Create a copy of the old marker
		var old = marker.clone();

		if (block) $(block).trigger("triggerDestroy", [marker]);

		// Move the text node out and
		// place it before the next marker.
		// Note: This doesn't need marker.nextSibling();
		parent.insertBefore(marker.text, block.nextSibling);

		// Remove the block node
		parent.removeChild(block);
		delete marker.block;
		delete marker.trigger;

		$(marker.parent).trigger("markerConvert", [marker, old, "text"]);

		return marker;
	},

	toBlockMarker: function(normalize) {

		var marker = this;

		// If this is a block marker, skip.
		if (marker.block) return;

		var old = marker.clone(),
			parent = marker.parent,
			block = marker.block = document.createElement("SPAN"),
			text  = marker.text;

		// Insert block before the next marker
		// Note: This doesn't need marker.nextSibling();
		parent.insertBefore(block, text.nextSibling);

		// Move text inside block marker
		block.appendChild(text);

		// Create empty marker data
		$(block).data("marker", {});

		$(marker.parent).trigger("markerConvert", [marker, old, "block"]);

		return marker;
	},

	spawn: function(start, end) {

		var marker = this,
			text   = marker.text,
			parent = marker.parent,
			block  = marker.block,
			// Note: This doesn't need marker.nextSibling();
			next   = block ? block.nextSibling : text.nextSibling;

		// If not start and end position was given, assume that
		// we're spawning an empty marker next to the current marker.
		// [hello] --> [hello[]
		if (start===undefined) {
			start = end = marker.length;
		}

		// If we're spawning in text in the middle,
		// split out the end marker and insert it before the next marker.
		// [he*ll*o] --> [he*ll*][o]
		if (end < marker.length) {
			next = parent.insertBefore(text.splitText(end), next);
		}

		// Split out the text
		// [he*ll*][o] --> [he][ll][o]
		text = parent.insertBefore(text.splitText(start), next);

		// Create marker object from new text object
		var spawn = new Marker({
			index     : marker.index + 1,
			start     : (start = marker.start + start),
			end       : (end = marker.start + end),
			length    : end - start,
			text      : text,
			parent    : parent,
			textarea  : marker.textarea,
			before    : marker,
			after     : marker.after,
			br        : false,
			allowSpace: true,
			finalized : false
		});

		// Update current marker
		marker.end    = start,
		marker.length = marker.end - marker.start;
		marker.after  = spawn;

		return spawn;
	},

	clone: function() {

		return new Marker(
			$.pick(this, "index,start,end,length,text,parent,textarea,before,after,br,allowSpace,trigger,value,finalized".split(","))
		);
	},

	finalize: function(value) {

		var marker = this,
			block = marker.block;

		// Text marker cannot be finalized
		if (!block) return;

		var data = $(block).data("marker");
			data.value = value;
			data.finalized = true;

		$.extend(marker, data);
	},

	updateValue: function(value) {

		var marker = this,
			block = marker.block;

		// Text marker cannot be finalized
		if (!block) return;

		var data = $(block).data("marker");
			data.value = value;

		$.extend(marker, data);
	}
});

$.Controller("Mentions", {
	pluginName: "mentions",
	hostname: "mentions",
	defaultOptions: {

		cssCloneProps: [
			'lineHeight', 'textDecoration', 'letterSpacing',
			'fontSize', 'fontFamily', 'fontStyle',
			'fontWeight', 'textTransform', 'textAlign',
			'direction', 'wordSpacing', 'fontSizeAdjust'
		],

		triggers: {},

		"{textarea}": "[data-mentions-textarea]",
		"{overlay}" : "[data-mentions-overlay]",
		"{block}"   : "[data-mentions-overlay] > span"
	}
}, function(self) { return {

	init: function() {

		// Speed up access to overlay
		self._overlay  = self.overlay()[0];
		self._textarea = self.textarea()[0];

		// Put this in a non-blocking thread
		setTimeout(function(){
			self.cloneLayout();
		}, 15);

		self.addPlugin("autocomplete");

		self.initialCaret = self.textarea().data("initial") || 0;
	},

	setLayout: function() {

		self.normalize();
	},

	cloneLayout: function() {

		var $overlay = self.overlay(),
			overlay = $overlay.detach()[0],
			textarea = self.textarea(),
			props = self.options.cssCloneProps,
			i = 0;

		while (prop = props[i++]) {
			overlay.style[prop] = textarea.css(prop);
		}

		overlay.style.opacity = 1;

		$overlay.insertBefore(textarea);

		self.setLayout();
	},

	reset: function() {

		// Overlay
		var overlay = self.overlay(),
			overlayDefault = overlay.data("default");

		if (overlayDefault !== undefined) {
			// TODO: Use $.toHTML() in the future
			// after all is on 3.1.11.
			overlay.html($('<div>').html(overlayDefault).html());
		} else {
			overlay.empty();
		}

		// Textarea
		var textarea = self.textarea(),
			textareaDefault = textarea.data("default");

		if (textareaDefault !== undefined) {
			textarea.val($('<div>').html(textareaDefault).text());
		} else {
			textarea.val("");
		}

		self.caretBefore = self.caretAfter = {start: 0, end: 0};
		self.previousMarker = null;

		self.normalize();

		self.initialFocus = true;

		self.trigger("triggerClear");

		self.previousCursorPosition = 0;
	},

	moveCursor: function(pos) {
		self.textarea().trigger('focus');
		self.textarea().caret(pos);
	},

	//--- Triggers ----//

	getTrigger: function(key) {

		var triggers = self.options.triggers;
		if (triggers.hasOwnProperty(key)) {
			var trigger = triggers[key];
			trigger.key = key;
			return trigger;
		}
	},

	getTriggerFromType: function(type) {

		var triggers = self.options.triggers,
			found;

		$.each(triggers, function(key, trigger) {
			if (trigger.type===type) {
				found = trigger;
				return false;
			}
		});

		return found;
	},

	getStopIndex: function(str, stop) {

		var i = stop.length,
			idx = str.length;

		// Find the first earliest stop character, that's where the string ends
		while (i--) {
			var chr = stop.substr(i, 1),
				pos = str.indexOf(chr);
			idx = (pos < 0) ? idx : Math.min(idx, pos);
		}

		return idx;
	},

	//--- Marker traversal ----//

	getMarkers: function(callback) {

		var textarea = self._textarea,
			overlay = self._overlay,
			nodes = $.makeArray(overlay.childNodes),
			node,
			i = 0,
			start = 0,
			before = null,
			skip = false,
			results = [],
			iterator = function(marker) {

				var ret;

				// Execute callback while passing in marker object
				if (callback) ret = callback.apply(marker, [marker]);

				// If callback returned:
				// false     - stop the loop
				// null      - don't add anything to the result list
				// undefined - add the same marker object to the result list
				// value     - add the value to the result list
				if (ret!==null && ret!==false) results.push(ret!==undefined ? ret : marker);

				return ret; // if ret is false, the parent loop will stop
			};

		// Filter out nodes to ignore
		$.remove(nodes, function(node){
			return node.nodeType===1 && node.hasAttribute('data-ignore');
		});

		while (node = nodes[i++]) {

			// Nodes
			var nodeType = node.nodeType,
				nodeName = node.nodeName,
				text, block = null,

				// Marker positions
				end, length,

				// Marker behaviour
				br = false, allowSpace = false;

			// If this is a text node, assign this node as marker text
			if (nodeType==3) {
				text = node;
				allowSpace = true;
			// else assign this node as marker block,
			// then test if node is <br/>, create a detached text node contaning a line break,
			} else if ((block = node) && nodeName=="BR") {
				text = document.createTextNode(_newline);
				br = true;
			// if this is an invalid node, e.g. node not element, node not span, span has no text child node,
			// remove code from overlay and skip this loop.
			} else if (nodeType!==1 || nodeName!=="SPAN" || !(text = node.childNodes[0]) || text.nodeType!==3) {
				overlay.removeChild(node);
				continue;
			}

			// Create marker props
			var props = {
				index     : i - 1,
				start     : start,
				end       : (end = start + (length = text.length)),
				length    : length,
				text      : text,
				block     : block,
				parent    : overlay,
				textarea  : textarea,
				before    : before,
				br        : br,
				allowSpace: allowSpace,
				finalized : false
			};

			// Create marker data
			if (block) {
				var $node = $(node), data = $node.data("marker");
				if (!data) (data = {}) && $node.data("marker", data);

				// Restore trigger from data attribute
				if (node.hasAttribute(_typeAttr)) {

					var type = $node.attr(_typeAttr),
						trigger = self.getTriggerFromType(type);

					if (trigger) data.trigger = trigger;
					$node.removeAttr(_typeAttr);
				}

				// Restore value from data attribute
				if (node.hasAttribute(_valueAttr)) {

					data.value = $node.attr(_valueAttr);
					data.finalized = true;
					$node.removeAttr(_valueAttr);
				}

				$.extend(props, data);
			}

			// Create marker
			var marker = new Marker(props);

			// If this is the second iteration, decorate the marker the after property
			// of the marker before this with the current marker.
			if (i > 1 && before !== null) {
				before.after = marker;
				// Execute iterator for the marker before this
				// If iterator returned false, stop the loop.
				if (skip = (iterator(before)===false)) break;
			}

			// Else reset start position and
			// continue with next child node.
			start = end;
			before = marker;
		}

		// Execute iterator one more time for the last marker
		if (!skip) iterator(before);

		return results;
	},

	getMarkerAt: function(pos) {

		if (pos===undefined) return;

		var marker;

		self.getMarkers(function(){

			// If position is inside current node,
			// stop and return marker.
			if (pos >= this.start && pos <= this.end) {
				marker = this;
				return false;
			}
		});

		return marker;
	},

	getMarkersBetween: function(start, end) {

		if (start===undefined) return;

		return self.getMarkers(function(){

			return (this.start > end) ? false : (this.end < start) ? null : this;
		});
	},

	toArray: function(stringify, asc) {

		var results = self.getMarkers(function(){

			var marker = this;

			if (!marker.block || marker.br) return null;

			// If there's no trigger, try to find it.
			if (!marker.trigger) {

				// Identify the trigger being used
				var wholeText = marker.text.nodeValue,
					key = wholeText.slice(0, 1),
					trigger = self.getTrigger(key);

				if (!trigger) return null;

				marker.trigger = trigger;
				marker.value = wholeText.slice(1);
			}

			// Default start value
			var markerStart = marker.start;

			// We try to detect if there is any newline before the first word
			var text = self._textarea.value;
			var matches = text.match(/^\n+/g);

			// If there is, we need to re-adjust the marker.start
			if (matches != null) {
				var lines = matches[0].split(/\r*\n/);
				var newLineCount = lines.length - 1;

				if (newLineCount > 0) {
					var markerStart = marker.start - newLineCount;
				}
			}

			var data = {
				start  : markerStart,
				length : marker.length,
				type   : marker.trigger.type,
				value  : marker.value
			};

			return (stringify) ? JSON.stringify(data) : data;
		});

		return (asc) ? results : results.reverse();
	},

	//--- Marker/overlay/text manipulation ---//

	insert: function(str, start, end) {

		var marker, offset;

		// If we are inserting character(s)
		if (start===end || end===undefined) {

			// Get marker & offset
			marker = self.getMarkerAt(start);
			offset = marker.start;

			// Insert character
			marker.insert(str, start - offset, end - offset);

		} else {

			// If we are replacing character(s)

			// Identify affected markers
			var markers = self.getMarkersBetween(start, end),
				length = markers.length;

			// If there are no marker, stop.
			if (length < 1) return;

			// If we're modifying a single marker
			// e.g. he*llo* --> he*y*
			if (length==1) {

				// Get marker & offset
				marker = markers[0];
				offset = marker.start;

				// Insert character
				marker.insert(str, start - offset, end - offset);
			} else {

				// If we're modifying multiple markers
				// e.g. he*llo [john] [do*e] --> he*xxx*e

				// Deal with markers in reverse
				var i = length - 1,
					marker = markers[i];

				// Convert block marker into text marker
				// [doe] --> doe
				// hello [john] [doe] --> hello [john] doe
				if (marker.block && end > marker.start) marker.toTextMarker();

				// Remove characters from text marker
				// doe --> e
				// hello [john] doe --> hello [john] e

				// Do not perform this operation if it does
				// not changes the value of the marker.
				if ((end - marker.start) > 0) {
					marker.insert("", 0, end - marker.start);
				}

				// Remove all markers in between
				// [john] --> (removed)
				// hello [john] --> hello
				while ((marker = markers[--i]) && i > 0) {
					marker.remove();
				}

				// If we're in the beginning of the textarea,
				// convert block into text marker.
				if (marker.block && marker.index===0 && start===0) marker.toTextMarker();

				// Insert characters in the first marker
				// hello -> hexxxe
				marker.insert(str, start - marker.start, marker.length);

				// Special case for handling br tag in the beginning of the textarea
				if (start===0 && marker.br) {
					marker.remove();
				}
			}
		}

		// Normalize all text markers
		self.normalize();

		return marker;
	},

	textareaInsert: function(str, start, end) {

		var textarea = self._textarea,
			val = textarea.value;

		return textarea.value = val.substring(0, start) + str + val.slice(end);
	},

	normalize: function() {

		var overlay = self._overlay,
			textarea = self._textarea;

		// This clean up empty text nodes in the beginning and
		// the end of the overlay and join disjointed text nodes
		// that are supposed to be a single text node.
		overlay.normalize();

		// This is a double-edged workaround.
		// - When there is no child element (empty textarea),
		//   an empty text node ensure overlay has a minimum
		//   single line-height.
		// - If there is a newline at the end of the overlay,
		//   an empty text node ensure overlay accomodates
		//   the height of the newline.
		var first = overlay.firstChild,
			last = overlay.lastChild,
			textNode = document.createTextNode("");

		if (!last || last.nodeName==="BR") {
			overlay.appendChild(textNode);
		}

		if (last && last==first && last.nodeType===1 && last.hasAttribute("data-ignore")) {
			overlay.insertBefore(textNode, last);
		}

		// Chrome, Opera & IE doesn't accomodate height of
		// newline after an empty text node, so reset the
		// overlay height to auto, and retrieve the textarea
		// scrollHeight again.
		overlay.style.height = "auto";
		overlay.style.height = textarea.scrollHeight + "px";

		// IE & Opera textarea's scrollTop may jump position
		// from time to time so we need to reset it back.
		textarea.scrollTop = 0;

		// Remember the current textarea length.
		// We do it here instead of keydown event
		// because Opera returns the length of the
		// textarea after it has been changed.
		self.lengthBefore = textarea.value.length;

		// console.log("after", overlay.childNodes);
	},

	//--- Key events & caret handling ---//

	/*
	List of input patterns to test:

	0. Meta-characters via alt + shift + (any key).

	1. Holding arrow key + pressing another character.

	2. Select a range of characters (covering single/multiple marker)
	   - and press any key
	   - and press enter
	   - and press backspace

	3. Repeat step 2 with range starting at a block marker where caret is at:
	   - the beginning
	   - the middle
	   - the end
	   of the block marker and also when block marker is at:
	   - the beginning
	   - the middle
	   - the end
	   of the textarea.

	4. Typing accented character.
	   Hold a key until candidate window shows up, then:
	   - Press a number
	   - Release key, then press a number
	   - Navigate using arrow keys
	   - Press enter to select a character
	   - Click on a candidate to select a character
	   - Press backspace until candidate window dissappears

	5. Typing romanized-to-unicode (Chinese/Japanese/Arabian/etc) characters.
	   Type multiple characters in the candidate window, then proceed with
	   the next course of action at test no. 4.

	6. Pressing enter continously to create multiple newlines:
	   - at the beginning of the textarea
	   - at the middle of marker/text
	   - at the end of textarea
	   then:
	   - enter a key at the newline
	   - press backspace to remove those newlines
	   - select a range of newlines, then proceed with
		 the next course of action at test no. 2.
	*/

	lengthBefore: 0,
	caretBefore: {start: 0, end: 0},
	caretAfter: {start: 0, end: 0},
	skipKeydown: false,
	previousMarker: null,

	initialFocus: true,

	isPasting: false,
	smileyLength: 0,
	tagToProcess: [],
	previousCursorPosition: 0,

	"{textarea} focus": function() {

		if (self.initialFocus) {
			self.textarea().caret(self.initialCaret || 0);
		}
	},

	"{textarea} focusout": function() {
		self.previousCursorPosition = self.textarea().prop('selectionEnd');
	},

	"{textarea} keydown": function(textarea, event) {

		self.initialFocus = false;

		// If keydown event has been fired multiple times
		// this might mean the user has entered candidate
		// window and we should not do anything.
		if (self.skipKeydown) return;

		var caret = self.caretBefore = textarea.caret();

		if (event.keyCode===8 && $.IE < 10) {
			self.overlay().css('opacity', 0);
		}

		self.skipKeydown = true;
	},

	// Keypress event will not trigger when meta keys are pressed,
	// it will trigger on well-formed characters.
	"{textarea} keypress": function(textarea, event) {

		// This will help on situations where user
		// holds an arrow key + presses another character.
		self.caretBefore = textarea.caret();

		// FF fires keypress on backspace, while Chrome & IE doesn't.
		// We normalize this behaviour by not doing anything on backspace.
		if (event.keyCode===8) return;
	},

	"convertHashTag": function(textarea) {

		// Get current hashtag overlay
		var newHtml = self.overlay().html();

		// Remove all span tags from the overlay
		// newHtml = newHtml.replace(/<\/?span[^>]*>/g, '');
		newHtml = newHtml.replace(/<span[^>]*>(#.*?)<\/span[^>]*>/g, '$1');

		// Replace <br> with \n
		newHtml = newHtml.replace(/<br\s*[\/]?>/gi, '\n');

		// Match if there is any hashtag or not
		// In the future we should use lookbehind method as it is more accurate.
		// Too bad Firefox don't have support for lookbehind yet..
		// http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Lookbehind_Assertions
		// var tags = newHtml.match(/(?<=\s|^)#[^\s]+[\w]/g);

		// Alternative for lookbehind match.
		var tags = newHtml.match(/(\s|^)(#[^\s]+[\w])/g);

		if (tags && tags.length > 0) {

			// Ensure that the tags is unique.
			var results = [];

			$.each(tags, function(i, e) {

				// Can remove this once lookbehind regex is supported.
				e = e.trim();

				if ($.inArray(e, results) == -1) results.push(e);
			});

			$(results).each(function(i, tag) {

				// check if this is a valid hashtag or not.
				var testSubject = tag.replace('#', '');
				var invalidChars = testSubject.match(/[&=\?]/g);

				if (invalidChars) {
					return;
				}

				spanEle = '<span>$1</span>';

				// Wrap the selected tag with <span>
				var expression = new RegExp('(' + tag + ')($|^|\\b)', 'gm');

				newHtml = newHtml.replace(expression, spanEle);
			});

			// Replace the overlay
			self.overlay().html(newHtml);
		}
	},

	"convertEmoticon": function(textarea) {

		// Get current overlay
		var newHtml = self.overlay().html();

		// Remove all span tags from the overlay
		// newHtml = newHtml.replace(/<\/?span[^>]*>/g, '');
		newHtml = newHtml.replace(/<span[^>]*>(:.*?)<\/span[^>]*>/g, '$1');

		// Divide the regex in 2 part
		// newHtml = newHtml.replace(/<span>/g, '');
		// newHtml = newHtml.replace(/<\/span>/g, '');

		// Trim any excess whitespaces
		newHtml = newHtml.trim();

		// Replace <br> with \n
		newHtml = newHtml.replace(/<br\s*[\/]?>/gi, '\n');

		// match if there is any emoticons or not
		var emoticons = newHtml.match(/:\([^\s]+[\w]\)/g);

		if (emoticons && emoticons.length > 0) {

			// Ensure that the emoticons is unique.
			var results = [];

			$.each(emoticons, function(i, e) {
				if ($.inArray(e, results) == -1) results.push(e);
			});

			$(results).each(function(i, tag) {

				// check if this is a valid hashtag or not.
				// var testSubject = tag.replace('#', '');
				// var invalidChars = testSubject.match(/[&=\?]/g);

				// if (invalidChars) {
				// 	return;
				// }

				tag = tag.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
				spanEle = '<span>$1</span> ';

				// Wrap the selected tag with <span>
				var expression = new RegExp('(' + tag + ')($|^| |\\b)', 'gm');

				newHtml = newHtml.replace(expression, spanEle);
			});

			// Replace the overlay
			self.overlay().html(newHtml);
		}
	},

	"{textarea} input": function(textarea) {

		// Reflect the overlay with current input
		self.reflect();

		if (self.isPasting) {
			self.convertHashTag();
			self.convertEmoticon();

			self.isPasting = false;
		}

		// Extra precaution in case overlay goes wrong,
		// user can start all over again by reseting mentions.
		if (textarea.val().length < 1) {
			self.reset();
		}
	},

	"{textarea} paste": function(textarea, event) {

		// Set pasting flag
		self.isPasting = true;
	},

	"{textarea} keyup": function(textarea, event) {

		self.skipKeydown = false;

		// Listen to backspace during keydown because
		// it is not fired on input/keypress on IE9.
		if (event.keyCode === 8 && $.IE < 10) {

			var caretBefore = self.caretBefore,
				caretAfter  = self.caretAfter = self.textarea().caret();

			self.insert("", caretAfter.end, caretBefore.end);

			self.caretBefore = caretAfter;

			self.overlay().css('opacity', 1);
		}

		// reset pasting flag
		if (self.isPasting) {
			self.isPasting = false;
		}
	},

	"{textarea} click": function(textarea, event) {
		self.caretBefore = textarea.caret();
	},

	reflect: function() {
		var textarea = self._textarea,

			wholeText = textarea.value,

			// Caret position retrieved on previous input event
			// is the position before the character is inserted
			caretBefore = self.caretBefore,

			// Caret position retrieved on current input event
			// is the position after the character is inserted.
			caretAfter = self.caretAfter = $(textarea).caret(),

			// Determine if user is on Opera + candidate window.
			operaCandidateWindow = ($.browser.opera && caretAfter.end > caretAfter.start),

			marker = self.getMarkerAt(caretBefore.start),

			diff = self.lengthBefore - wholeText.length,

			replace = false;


		// Ensure Opera follows the caretBefore behaviour of other
		// browsers when typing inside the candidate window.
		if (operaCandidateWindow) {
			if (caretBefore.start!==caretBefore.end) {
				caretBefore.end += diff;
			}
		}

		if (self.smileyLength > 0) {
			var t = self.previousCursorPosition + self.smileyLength;
			caretAfter.start = t;
			caretAfter.end = t;

			// reset for the next input
			self.smileyLength = 0;
		}

		// In case there was an issue retrieving marker.
		// TODO: Figure out the pattern, usually when typed too early.
		if (!marker) return;

		var previousMarker = self.previousMarker,
			block = marker.block;

		// If the previous marker hasn't been finalized, convert back to text block.
		if (previousMarker) {

			var previousBlock = previousMarker.block,
				finalize = (previousMarker.trigger || {}).finalize;

			if (previousBlock && finalize && !previousMarker.finalized && previousBlock!==block) {
				try {
					previousMarker.toTextMarker();
				} catch(e) {
					self.previousMarker = null;
				}
			}
		}

		// If there is a change in the text content but the length of the
		// text content is the same length as before, it is impossible to
		// tell what has changed, so we replace the entire text in the marker
		// where the caret is at. This happens when:
		// - User holds a character + presses a number to select a
		//   character from the candidate window.
		// - User navigates between characters using arrow keys
		//   within the candidate window.
		//
		// The caretAfter could be earlier than the caretBefore when:
		// - User enters backspace to remove a character.
		// - User finalizes a selection from the candidate window where characters
		//   are shorter than being typed, e.g. "ni hao" --> "".

		if (!marker.br && (diff===0 || caretAfter.end < caretBefore.start)) {

			var textStart  = marker.start,
				textEnd    = marker.end - diff,
				rangeStart = caretAfter.end,
				rangeEnd   = caretBefore.start,
				replace    = textStart!==textEnd;

		 // If user is inserting text as usual.
		} else {

			// In Chrome, the caretAfter has a range if the user is typing within the
			// candidate window. The characters may change due to fuzzy logic suggestions.
			// You can test this by using Chinese pinyin input and typing "a" then
			// "asdasdasd" one at a time slowly until you see the difference.

			// So, we give prefential treatment to start positions which are earlier
			// whether it is coming from caretBefore or caretAfter.
			var rangeStart = textStart = Math.min(caretBefore.start, caretAfter.start),
				rangeEnd = caretBefore.end,
				textEnd = caretAfter.end;


		}

		// Extract text from the given start and end position
		var text = wholeText.substring(textStart, textEnd);

		// If the strategy is to replace a single marker
		if (replace) {

			// If text being replaced is not identical on
			// a finalized marker, then convert to text marker.
			if (marker.val() !== text && marker.finalized) {
				marker.toTextMarker();
			}

			marker.val(text);

			// Emulate markerInsert event
			self.overlay().trigger("markerInsert", [marker, [], text, textStart, textEnd]);

			self.normalize();

		// If the strategy is to insert chracters onto single/multiple markers
		} else {
			self.insert(text, rangeStart, rangeEnd);
		}

		// Ensure Opera follows the caretAfter behaviour of other
		// browsers when typing inside the candidate window.
		if (operaCandidateWindow) {
			caretAfter.start = caretAfter.end;
		}

		// Set caretBefore as current caret
		// This is used to track text range when exiting candidate window.
		self.caretBefore = self.caretAfter;
	},

	//--- Marker Events ----//

	"{overlay} markerInsert": function(overlay, event, marker, nodes, str, start, end) {

		var text = marker.text,
			wholeText = text.nodeValue,
			trigger;

		self.previousMarker = null;

		// If a trigger key was entered
		if (trigger = self.getTrigger(str)) {

			// Ensure the character before is a space, e.g.
			// we don't want to listen to @ in an email address.
			// or a # that is not intended to be a hashtag.
			var charBefore = wholeText.charCodeAt(start - 1),
				brBefore = marker.before && marker.before.br;

			// Before triggering, we need to make sure there is no text before the trigger
			// 32 = space
			if (charBefore !== 32 && !isNaN(charBefore)) {
				return;
			}

			if (marker.index===0 || (charBefore===32 || brBefore)) {

				// Extract the remaining string after the trigger key
				// coding #js --> #js
				var remainingText = wholeText.slice(start),
					content = remainingText.slice(1);

				// If this trigger allows wrapping and
				// there are remaining characters to wrap.
				// *#js and*    --> *#js* and
				// *#js#foobar* --> *#js*#foobar
				if (trigger.wrap && remainingText.length > 1 && content.charCodeAt() != 32) {

					// Get stop position, add start offset and trigger key offset.
					end = self.getStopIndex(content, trigger.stop) + start + 1;

				// If trigger does not allow wrapping
				// *@foobar* --> *@*foobar
				} else {
					end = start + 1;
				}

				// Spawn a new marker from this string
				// and convert this marker into a block marker
				// *#*          --> [#]
				// *#js* and    --> [#js] and
				// *#js*#foobar --> [#js]#foobar
				// *@*foobar    --> [@]foobar
				var spawn = marker.spawn(start, end).toBlockMarker(),
					content = spawn.val().slice(1);

				// Update data
				var data = $(spawn.block).data("marker");
					data.value = content;
					data.trigger = trigger;

				self.previousMarker = spawn;

				// Trigger triggerCreate event
				self.trigger("triggerCreate", [spawn, trigger, content]);
			}
		}

		// If we're inside an existing block marker,
		// determine if we need to mutate the block.
		if (marker.block && !marker.br) {

			// If this marker is finalized, any changes to the
			// text content will convert it to a text marker.
			// [Jensen *#*Tonne] --> Jensen #Tonne
			// [Jensen Tonn`e`]  --> Jensen Tonn
			if (marker.finalized) {

				var length = marker.length;

				if (end < length - 1) marker.toTextMarker();

			} else {

				// Identify the trigger being used
				var key = wholeText.slice(0, 1),
					trigger = self.getTrigger(key);

				// If we could not identify the trigger, skip.
				if (!trigger) return;

				// Check for occurence of stop character
				var content = wholeText.slice(1),
					start = self.getStopIndex(content, trigger.stop) + 1,
					end = wholeText.length,
					spawn = false;

				// If the end position is shorter than content length
				if (start < end) {

					// Spawn out a new marker containing
					// the remaining text after the block marker.
					// [#foo* *bar] --> [#foo] bar
					spawn = marker.spawn(start, end);
				}

				// Trigger triggerChange event
				content = marker.val().slice(1);

				// Update data
				var data = $(marker.block).data("marker");
					data.value = content;
					data.trigger = trigger;

				self.previousMarker = marker;

				self.trigger("triggerChange", [marker, spawn, trigger, content]);
			}
		}
	},

	"{overlay} markerExit": function(overlay, event, marker, nodes, spawn, str, start, end) {

		var trigger = marker.trigger;

		if (!trigger) return;

		var allowSpace = trigger.allowSpace || marker.allowSpace,
			content = marker.val();

		if (!allowSpace && marker.val()===trigger.key) {
			marker.toTextMarker();
		}

		self.trigger("triggerExit", [marker, spawn, trigger, content]);
	}

	// Events available for use
	// "{overlay} markerRemove": function(overlay, event, marker) {},
	// "{overlay} markerConvert": function(overlay, event, marker, type) {},
	// "{overlay} markerExit": function(overlay, event, marker, nodes, str, start, end) {},
	// "{self} triggerCreate": function(el, event, marker, trigger, content) {},
	// "{self} triggerDestroy": function(el, event, marker) {},
	// "{self} triggerChange": function(el, event, marker, spawn, trigger) {},

	// TODO: Better support for cut & paste
	// "{textarea} beforecut": function() { console.log("BEFORECUT", arguments); },
	// "{textarea} beforepaste": function() { console.log("BEFOREPASTE", arguments); },
	// "{textarea} cut": function(el, event) { console.log("CUT", arguments); },
	// "{textarea} paste": function() { console.log("PASTE", arguments); }
}});

$.template("mentions/menu", '<div class="mentions-autocomplete" data-mentions-autocomplete><b><b></b></b><div class="mentions-autocomplete-inner" data-mentions-autocomplete-viewport><div class="mentions-autocomplete-loading" data-mentions-autocomplete-loading data-mentions-autocomplete-close></div><div class="mentions-autocomplete-empty" data-mentions-autocomplete-empty></div><div class="mentions-autocomplete-search" data-mentions-autocomplete-search></div><ul class="mentions-menu" data-mentions-menu></ul></div></div>');
$.template("mentions/menuItem", '<li class="mentions-menuItem" data-mentions-menuItem>[%== html %]</li>');
$.template("mentions/loadingHint", '<div class="mentions-autocomplete-loading-indicator"><div class="o-loader o-loader--top o-loader--sm is-active"></div></div>');
$.template("mentions/searchHint", '<span class="mentions-autocomplete-search-hint">Type a keyword to begin.</span>');
$.template("mentions/emptyHint", '<span class="mentions-autocomplete-empty-text">No items found.</span>');
/*
<div class="mentions-autocomplete" data-mentions-autocomplete>
	<b><b></b></b>
	<div class="mentions-autocomplete-inner" data-mentions-autocomplete-viewport>
		<div class="mentions-autocomplete-loading" data-mentions-autocomplete-loading></div>
		<div class="mentions-autocomplete-empty" data-mentions-autocomplete-empty></div>
		<div class="mentions-autocomplete-search" data-mentions-autocomplete-search></div>
		<ul class="mentions-menu" data-mentions-menu></ul>
	</div>
</div>
*/

$.Controller("Mentions.Autocomplete", {
	defaultOptions: {

		view: {
			menu: "mentions/menu",
			menuItem: "mentions/menuItem",
			searchHint: "mentions/searchHint",
			loadingHint: "mentions/loadingHint",
			emptyHint: "mentions/emptyHint"
		},

		id: "",
		component: "",
		modifier: "",
		shadow: false,
		sticky: false,
		animation: false,

		// This is the default query options
		// applied to all triggers unless
		// trigger override them.
		query: {
			data: null,
			cache: true,
			minLength: 1,
			limit: 10,
			highlight: true,
			caseSensitive: false,
			exclusive: false,
			searchHint: false,
			loadingHint: false,
			emptyHint: false,
			renderAll: false
		},

		position: {
			my: 'left top',
			at: 'left bottom',
			collision: 'none'
		},

		size: {
			width: "auto",
			height: "auto"
		},

		"{menu}": "[data-mentions-menu]",
		"{menuItem}": "[data-mentions-menuItem]",
		"{viewport}": "[data-mentions-autocomplete-viewport]",
		"{loadingHint}": "[data-mentions-autocomplete-loading]",
		"{emptyHint}": "[data-mentions-autocomplete-empty]",
		"{searchHint}": "[data-mentions-autocomplete-search]",
		"{closeButton}": "[data-mentions-autocomplete-close]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// This doesn't need to be immediately initialized.
		// Shaves off about 20ms.
		setTimeout(function(){

			// Destroy controller
			if (!self.element.data(self.Class.fullName)) {

				self.destroy();

				// And reimplement on the context menu we created ourselves
				var menu =
				self.view.menu()
					.attr("id", opts.id)
					.addClass(opts.component)
					.addClass(opts.modifier)
					.addClass(opts.shadow ? 'has-shadow' : '')
					.addClass(opts.animation ? 'has-animation' : '')
					.addClass(opts.sticky ? 'is-sticky' : '')
					.appendTo("body")
					.data(self.Class.fullName, true)
					.addController(self.Class, opts);

				return;
			}

			var mentions = self.mentions;

			self.uid = $.uid();

			mentions.autocomplete = self;
			mentions.pluginInstances["autocomplete"] = self;

			// Set the position to be relative to the mentions
			if (!opts.position.of) {
				opts.position.of = self.mentions.element;
			}

			// Prepare this in advance to speed things up
			self.defaultSearchHint = self.view.searchHint().toHTML();
			self.defaultEmptyHint = self.view.emptyHint().toHTML();
			self.defaultLoadingHint = self.view.loadingHint().toHTML();

			// Only reattach element when autocomplete is needed.
			self.element.detach();

		}, 50);
	},

	setLayout: function() {

		if (!self.hidden) {

			var options = self.options,
				size = options.size,
				width = self.mentions.element.outerWidth(),
				height = "auto";

			if ($.isFunction(size.width)) {
				width = size.width(width);
			}

			if ($.isFunction(size.height)) {
				height = size.height(height);
			}

			self.element
				.css({
					opacity: 1,
					width: width
				})
				.position(self.options.position);

			setTimeout(function(){
				self.viewport()
					.addClass("active");
			}, 1);
		}
	},

	"{window} resize": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} scroll": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} dialogTransitionStart": function() {
		self.hidden = true;
		self.element.css("opacity", 0);
	},

	"{window} dialogTransitionEnd": function() {
		self.hidden = false;
		self.setLayout();
	},

	currentMarker: null,

	"{mentions} triggerCreate": function(el, event, marker, trigger, content) {

		self.populate(marker, trigger, content);

		self.currentMarker = marker;
	},

	"{mentions} triggerChange": function(el, event, marker, spawn, trigger, content) {

		self.populate(marker, trigger, content);

		self.currentMarker = marker;
	},

	"{mentions} triggerExit": function(el, event, marker, spawn, trigger, content) {

		// Abort any running query
		var query = self.activeQuery;
		if (query) {
			query.aborted = true;
		}

		self.hide();
	},

	"{mentions.block} triggerDestroy": function(el, event, marker) {

		self.hide();
	},

	"{mentions} triggerClear": function() {

		self.hide();
	},

	hidden: true,

	show: function(duration) {

		clearTimeout(self.sleep);

		self.element
			.appendTo("body")
			.show();

		self.hidden = false;

		self.viewport().removeClass("active");

		self.setLayout();

		// Hide autocomplete on click.
		var doc = $(document),
			hideOnClick = "click.mentions." + self.uid;

		doc
			.off(hideOnClick)
			.on(hideOnClick, function(event){

				// Collect list of bubbled elements
				var targets = $(event.target).parents().andSelf();

				// Don't hide autocomplete if user is clicking on itself
				if (targets.filter(base).length > 0) return;

				// Unbind hiding
				doc.off(hideOnClick);

				self.hide();
			});

		if (duration) {

			self.sleep = setTimeout(function(){

				self.hide();

			}, duration);
		}
	},

	hide: function() {

		self.element.hide();

		var menuItem = self.menuItem(),
			activeMenuItem = menuItem.filter(".active");

		if (activeMenuItem.length > 0) {
			self.lastItem = {
				// keyword: $.trim(self.textboxlist.textField().val()),
				keyword: "", // TODO: Port this
				item   : activeMenuItem.data("item")
			};
		}

		self.viewport().removeClass("active");

		menuItem.removeClass("active");

		self.render.reset();

		self.hidden = true;

		// Clear any previous sleep timer first
		clearTimeout(self.sleep);

		// If no activity within 3000 seconds, detach myself.
		self.sleep = setTimeout(function(){
			self.element.detach();
		}, 3000);
	},

	query: function(options) {

		if (!options) return;

		// If options passed in is not an object
		var query = $.extend(
				{},
				self.options.query,
				($.isPlainObject(options) ? options : {data: options})
			),
			data = query.data;

		if (!data) return;

		// Query URL
		if ($.isUrl(data)) {
			var url = data;
			query.lookup = function() {
				return $.ajax(url + query.keyword);
			}
		}

		// Query function
		if ($.isFunction(data)) {
			var func = data;
			query.lookup = function() {
				return func.call(self, query.keyword);
			}
		}

		// Query dataset
		if ($.isArray(data)) {

			var dataset = data;
			query.lookup = function() {

				var task = $.Deferred(),
					keyword = query.keyword.toLowerCase();

				// Fork this process
				// so it won't choke on large dataset.
				setTimeout(function(){
					var result = $.grep(dataset, function(item){
						return item.title.toLowerCase().indexOf(keyword) > -1;
					});
					task.resolve(result);
				}, 0);

				return task;
			}
		}

		return query;
	},

	tasks: {},

	delayTask: null,

	activeQuery: null,

	renderAllItems: function(query, marker, trigger, keyword) {
		// Get mentions
		var mentions = self.mentions,
			autocomplete = self,
			element = self.element,
			menu = self.menu(),
			qkeyword = query.keyword;

			// Clear out menu items
			menu.empty();

			$.each(query.data, function(i, item){

				// Trigger menuCreateItem
				mentions.trigger("menuCreateItem", [item, query, autocomplete, mentions]);

				// If the item is not an object,
				// or item should be discarded, stop.
				if (!$.isPlainObject(item) || item.discard) return;

				var html = item.menuHtml || item.title;

				self.view.menuItem({html: html})
					.data("item", item)
					.appendTo(menu);
			});

			menu.data("keyword", qkeyword);

			// Get menu Items
			var menuItems = self.menuItem();

			// Trigger menuCreate event
			mentions.trigger("menuCreate", [menu, menuItems, query, autocomplete, mentions]);

			// If menu is empty, toggle empty classname
			if (menuItems.filter(":not(.hidden)").length < 1) {

				element.addClass("empty");

				// If we shouldn't show an empty hint
				if (!query.emptyHint) {

					// Hide menu straightaway
					return self.hide();
				}
			}

			// If we only allow adding item from suggestions
			if (query.exclusive) {

				// Automatically select the first item
				self.menuItem(":not(.hidden):first").addClass("active");
			}

			// Trigger renderMenu event
			mentions.trigger("renderMenu", [menu, query, autocomplete, mentions]);

			self.show();

			// Set current query as active query
			self.activeQuery = query;

			// Store data in query
			query.keyword = keyword;
			query.trigger = trigger;
			query.marker  = marker;

			// Trigger queryPrepare event
			// for event handlers to modify the query object.
			self.trigger("queryPrepare", [query]);

			// If no keyword given or keyword doesn't meet minimum query length, stop.
			var keyword = query.keyword;

			// Create a query id for this task based on the keyword
			// and retrieve existing query task for this keyword.
			var id    = query.id = trigger.key + "|" + (query.caseSensitive) ? keyword : keyword.toLowerCase(),
				tasks = self.tasks,
				task  = query.task = tasks[id],

				// This function runs the query task
				// We wrap it in a function because we may
				// want to debounce running of this task.
				runTask = function(){

					// Trigger keywordBeforeQuery event
					// If the event was prevented, don't query the keyword.
					var event = self.trigger("queryBeforeStart", [query]);
					if (event.isDefaultPrevented()) return;

					task = tasks[id] = query.task = query.lookup();

					// Trigger query event
					self.trigger("queryStart", [query]);
				};

			clearTimeout(self.delayTask);
			self.delayTask = setTimeout(runTask, 250);
	},

	populate: function(marker, trigger, keyword) {

		// var addclass = trigger.type == 'emoticon';
		// self.element.toggleClass('es-story-mentions-autocomplete-emoji', addclass);

		// Abort any running query
		var query = self.activeQuery;
		if (query) {
			query.aborted = true;
		}

		// Create query object
		var query = self.query(trigger.query);

		if (!query) return;

		// We try to simulate the render menu item for emoticons
		// so that it will load all emoticons when triggering the listing
		if (query.renderAll && keyword === "") {
			self.renderAllItems(query, marker, trigger, keyword);
			return;
		}

		// Set current query as active query
		self.activeQuery = query;

		// Store data in query
		query.keyword = keyword;
		query.trigger = trigger;
		query.marker  = marker;

		// Trigger queryPrepare event
		// for event handlers to modify the query object.
		self.trigger("queryPrepare", [query]);

		// If no keyword given or keyword doesn't meet minimum query length, stop.
		var keyword = query.keyword;

		if (keyword==="" || (keyword.length < query.minLength)) {

			var searchHint = query.searchHint;

			if (searchHint) {

				self.searchHint()
					.html(
						// If searchHint is a html string
						$.isString(searchHint) ?
							// use query-specific searchHint
							searchHint :
							// else use default searchHint
							self.defaultSearchHint
					);

				self.element.addClass("search");

				self.show();
			} else {
				self.hide();
			}
			return;
		}

		// Create a query id for this task based on the keyword
		// and retrieve existing query task for this keyword.
		var id    = query.id = trigger.key + "|" + (query.caseSensitive) ? keyword : keyword.toLowerCase(),
			tasks = self.tasks,
			task  = query.task = tasks[id],

			// Determine if this is a new or existing query task
			// If query caching is disabled, it will always be a new task.
			newTask = !$.isDeferred(task) || !query.cache,

			// This function runs the query task
			// We wrap it in a function because we may
			// want to debounce running of this task.
			runTask = function(){

				// Trigger keywordBeforeQuery event
				// If the event was prevented, don't query the keyword.
				var event = self.trigger("queryBeforeStart", [query]);
				if (event.isDefaultPrevented()) return;

				// Query the keyword if:
				// - The query hasn't been made.
				// - The query has been rejected.
				if (newTask || (!newTask && task.state()=="rejected")) {
					task = tasks[id] = query.task = query.lookup();
				}

				// When query lookup is done, render items;
				task.done(
					self.render(function(items){
						return [items, query];
					})
				);

				// Trigger query event
				self.trigger("queryStart", [query]);
			};

		// If this is a new query task
		// Don't run until we are sure that user has finished typing
		if (newTask) {

			clearTimeout(self.delayTask);
			self.delayTask = setTimeout(runTask, 250);

		// Else run it immediately
		} else {
			runTask();
		}
	},

	"{self} queryPrepare": function(el, event, query) {

		// Remove both loading & empty class
		el.removeClass("loading empty search");

		if (query.loadingHint) {
			self.hide();
		}
	},

	"{self} queryBeforeStart": function(el, event, query) {

		var loadingHint = query.loadingHint;

		// Show loading hint
		if (loadingHint) {

			self.loadingHint()
				.html(
					// If searchHint is a html string
					$.isString(loadingHint) ?
						// use query-specific loadingHint
						loadingHint :
						// else use default loadingHint
						self.defaultLoadingHint
				);

			el.addClass("loading");
			self.show();
		}
	},

	"{self} queryStart": function(el, event, query) {

		query.task
			.fail(function(){
				self.hide();
			})
			.always(function(){
				el.removeClass("loading");
			});
	},

	render: $.Enqueue(function(items, query){

		// If query has been aborted, hide menu and stop.
		if (query.aborted) {
			self.hide();
			return;
		}

		// If items passed in isn't an array,
		// fake an empty array.
		if (!$.isArray(items)) { items = [] };

		// Get mentions
		var mentions = self.mentions,
			autocomplete = self,
			element = self.element,
			menu = self.menu(),
			keyword = query.keyword;

		// If there are no items, hide menu.
		if (items.length < 1) {

			var emptyHint = query.emptyHint;

			// If we are supposed to show an empty hint
			if (emptyHint) {

				self.emptyHint()
					.html(
						// If searchHint is a html string
						$.isString(emptyHint) ?
							// use query-specific emptyHint
							emptyHint :
							// else use default emptyHint
							self.defaultEmptyHint
					);

				// Clear out menu
				menu.empty();

				// Add empty class
				element.addClass("empty");

				// Show menu for only 2 seconds
				self.show(2000);

			// Just hide straight away
			} else {

				self.hide();
			}

			// Trigger menuRender event
			mentions.trigger("menuRender", [menu, query, autocomplete, mentions]);

			return;
		}

		// Remove empty class
		element.removeClass("empty");

		// Generate menu items
		if (!query.cache || menu.data("keyword")!==keyword) {

			// Clear out menu items
			menu.empty();

			$.each(items, function(i, item){

				// Trigger menuCreateItem
				mentions.trigger("menuCreateItem", [item, query, autocomplete, mentions]);

				// If the item is not an object,
				// or item should be discarded, stop.
				if (!$.isPlainObject(item) || item.discard) return;

				var html = item.menuHtml || item.title;

				self.view.menuItem({html: html})
					.data("item", item)
					.appendTo(menu);
			});

			menu.data("keyword", keyword);
		}

		// Get menu Items
		var menuItems = self.menuItem();

		// Trigger menuCreate event
		mentions.trigger("menuCreate", [menu, menuItems, query, autocomplete, mentions]);

		// If menu is empty, toggle empty classname
		if (menuItems.filter(":not(.hidden)").length < 1) {

			element.addClass("empty");

			// If we shouldn't show an empty hint
			if (!query.emptyHint) {

				// Hide menu straightaway
				return self.hide();
			}
		}

		// If we only allow adding item from suggestions
		if (query.exclusive) {

			// Automatically select the first item
			self.menuItem(":not(.hidden):first").addClass("active");
		}

		// Trigger renderMenu event
		mentions.trigger("renderMenu", [menu, query, autocomplete, mentions]);

		self.show();
	}),

	"{mentions.textarea} keydown": function(textarea, event) {

		// Prevent autocomplete from falling asleep.
		clearTimeout(self.sleep);

		// Get active menu item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		if (activeMenuItem.length < 1) {
			activeMenuItem = false;
		}

		switch (event.keyCode) {

			// If up key is pressed
			case KEYCODE.UP:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the last one.
					self.menuItem(":not(.hidden):last").addClass("active");

				// Else find the menu item before it,
				} else {

					// and activate it.
					activeMenuItem.prev(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// Prevent up/down keys from changing textfield cursor position.
				if (!self.hidden) {
					event.preventDefault();
				}
				break;

			// If down key is pressed
			case KEYCODE.DOWN:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the first one.
					self.menuItem(":not(.hidden):first").addClass("active");

				// Else find the menu item after it,
				} else {

					// and activate it.
					activeMenuItem.next(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// Prevent up/down keys from changing textfield cursor position.
				if (!self.hidden) {
					event.preventDefault();
				}
				break;

			// If escape is pressed,
			case KEYCODE.ESCAPE:

				// hide menu.
				self.hide();
				break;

			// If enter is pressed, use item
			case KEYCODE.ENTER:

				if (!self.hidden && activeMenuItem) {
					var item = activeMenuItem.data("item");

					self.use(item);
					event.preventDefault();
				}
				break;
		}

		// Get newly activated item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		if (!self.hidden) {
			// Scroll menu viewport if it is out of visible area.
			self.viewport().scrollIntoView(activeMenuItem);
		}
	},

	"{menuItem} mouseup": function(menuItem) {

		// Hide context menu
		self.hide();

		// Add item
		var item = menuItem.data("item");

		self.use(item);

		// Refocus textarea
		setTimeout(function(){

			// Due to event delegation, this needs to be slightly delayed.
			self.mentions.textarea().focus();
		}, 150);
	},

	use: function(item) {

		// Get active query
		var query = self.activeQuery;

		// If there are no active query, stop.
		if (!query) return;

		var marker = query.marker,
			title = item.title;

		// Replace marker text
		marker.text.nodeValue = title;

		// delete item["menuHtml"];

		var value = item;

		if (query.use) {
			value = query.use(item);
		}

		// Finalize marker
		marker.finalize(value);

		// Replace textarea text
		self.mentions.textareaInsert(title, marker.start, marker.end);

		// Set caret position
		self.mentions.textarea().caret(marker.start + title.length);

		// Normalize is required so self.lengthBefore is correct.
		// Marker may run off when a user creates a block marker from
		// autocomplete, changes the cursor before/at the beginning of the
		// block marker, and presses backspace.
		self.mentions.normalize();

		// Quick hack to prevent repopulation
		self.hidden = true;

		self.hide();
	},

	"{menuItem} mouseover": function(menuItem) {

		self.menuItem().removeClass("active");

		menuItem.addClass("active");
	},

	"{menuItem} mouseout": function(menuItem) {

		self.menuItem().removeClass("active");
	},

	"{closeButton} click": function() {

		self.hide();
	},

	"{mentions} destroyed": function() {

		self.element.remove();
	}
}});


};

exports();
module.resolveWith(exports);

// module body: end

};
// module factory: end

FD40.module("mentions", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var jQuery = $;
var exports = function() {

/*!
 * jQuery Mobile Events
 * by Ben Major
 *
 * Copyright 2011-2017, Ben Major
 * Licensed under the MIT License:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

"use strict";

(function ($) {
	$.attrFn = $.attrFn || {};

	var touchCapable  = ('ontouchstart' in window),

		settings = {
			tap_pixel_range: 5,
			swipe_h_threshold: 50,
			swipe_v_threshold: 50,
			taphold_threshold: 750,
			doubletap_int: 500,
			shake_threshold: 15,

			touch_capable: touchCapable,
			orientation_support: ('orientation' in window && 'onorientationchange' in window),

			startevent:  (touchCapable) ? 'touchstart' : 'mousedown',
			endevent:    (touchCapable) ? 'touchend' : 'mouseup',
			moveevent:   (touchCapable) ? 'touchmove' : 'mousemove',
			tapevent:    (touchCapable) ? 'tap' : 'click',
			scrollevent: (touchCapable) ? 'touchmove' : 'scroll',

			hold_timer: null,
			tap_timer: null
		};

	// Declare touch namespace:
	$.touch = { };

	// Convenience functions:
	$.isTouchCapable = function() { return settings.touch_capable; };
	$.getStartEvent  = function() { return settings.startevent;    };
	$.getEndEvent    = function() { return settings.endevent;      };
	$.getMoveEvent   = function() { return settings.moveevent;     };
	$.getTapEvent    = function() { return settings.tapevent;      };
	$.getScrollEvent = function() { return settings.scrollevent;   };

	// SETTERS:
	// Set the X threshold of swipe events:
	$.touch.setSwipeThresholdX = function( threshold ) {
		if( typeof threshold !== 'number' ) { throw new Error('Threshold parameter must be a type of number'); }
		settings.swipe_h_threshold = threshold;
	};

	// Set the Y threshold of swipe events:
	$.touch.setSwipeThresholdY = function( threshold ) {
		if( typeof threshold !== 'number' ) { throw new Error('Threshold parameter must be a type of number'); }
		settings.swipe_v_threshold = threshold;
	};

	// Set the double tap interval:
	$.touch.setDoubleTapInt    = function( interval ) {
		if( typeof interval !== 'number' ) { throw new Error('Interval parameter must be a type of number'); }
		settings.doubletap_int = interval;
	};

	// Set the taphold threshold:
	$.touch.setTapHoldThreshold = function( threshold ) {
		if( typeof threshold !== 'number' ) { throw new Error('Threshold parameter must be a type of number'); }
		settings.taphold_threshold = threshold;
	};

	// Set the pixel range for tapas:
	$.touch.setTapRange = function( range ) {
		if( typeof range !== 'number' ) { throw new Error('Ranger parameter must be a type of number'); }
		settings.tap_pixel_range = threshold;
	};

	// Add Event shortcuts:
	$.each(['tapstart', 'tapend', 'tapmove', 'tap', 'singletap', 'doubletap', 'taphold', 'swipe', 'swipeup', 'swiperight', 'swipedown', 'swipeleft', 'swipeend', 'scrollstart', 'scrollend', 'orientationchange', 'tap2', 'taphold2'], function (i, name) {
		$.fn[name] = function (fn) {
			return fn ? this.on(name, fn) : this.trigger(name);
		};

		$.attrFn[name] = true;
	});

	// tapstart Event:
	$.event.special.tapstart = {
		setup: function () {

			var thisObject = this,
				$this = $(thisObject);

			$this.on(settings.startevent, function tapStartFunc(e) {

				$this.data('callee', tapStartFunc);
				if (e.which && e.which !== 1) {
					return false;
				}

				var origEvent = e.originalEvent,
					touchData = {
						'position': {
							'x': ((settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX),
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target
					};

				triggerCustomEvent(thisObject, 'tapstart', e, touchData);
				return true;
			});
		},

		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee);
		}
	};

	// tapmove Event:
	$.event.special.tapmove = {
		setup: function() {
			var thisObject = this,
			$this = $(thisObject);

			$this.on(settings.moveevent, function tapMoveFunc(e) {
				$this.data('callee', tapMoveFunc);

				var origEvent = e.originalEvent,
					touchData = {
						'position': {
							'x': ((settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX),
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target
					};

				triggerCustomEvent(thisObject, 'tapmove', e, touchData);
				return true;
			});
		},
		remove: function() {
			$(this).off(settings.moveevent, $(this).data.callee);
		}
	};

	// tapend Event:
	$.event.special.tapend = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject);

			$this.on(settings.endevent, function tapEndFunc(e) {
				// Touch event data:
				$this.data('callee', tapEndFunc);

				var origEvent = e.originalEvent;
				var touchData = {
					'position': {
						'x': (settings.touch_capable) ? origEvent.changedTouches[0].pageX : e.pageX,
						'y': (settings.touch_capable) ? origEvent.changedTouches[0].pageY : e.pageY
					},
					'offset': {
						'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
						'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
					},
					'time': Date.now(),
					'target': e.target
				};
				triggerCustomEvent(thisObject, 'tapend', e, touchData);
				return true;
			});
		},
		remove: function () {
			$(this).off(settings.endevent, $(this).data.callee);
		}
	};

	// taphold Event:
	$.event.special.taphold = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				origTarget,
				start_pos = {
					x: 0,
					y: 0
				},
				end_x = 0,
				end_y = 0;

			$this.on(settings.startevent, function tapHoldFunc1(e) {
				if (e.which && e.which !== 1) {
					return false;
				} else {
					$this.data('tapheld', false);
					origTarget = e.target;

					var origEvent = e.originalEvent;
					var start_time = Date.now(),
						startPosition = {
							'x': (settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX,
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
						},
						startOffset = {
							'x': (settings.touch_capable) ? origEvent.touches[0].pageX - origEvent.touches[0].target.offsetLeft : e.offsetX,
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY - origEvent.touches[0].target.offsetTop : e.offsetY
						};

					start_pos.x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
					start_pos.y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;

					end_x = start_pos.x;
					end_y = start_pos.y;

					// Get the element's threshold:
					var ele_threshold = ($this.parent().data('threshold')) ? $this.parent().data('threshold') : $this.data('threshold'),
						threshold = (typeof ele_threshold !== 'undefined' && ele_threshold !== false && parseInt(ele_threshold)) ? parseInt(ele_threshold) : settings.taphold_threshold;

					settings.hold_timer = window.setTimeout(function () {

						var diff_x = (start_pos.x - end_x),
							diff_y = (start_pos.y - end_y);

						if (e.target == origTarget && ((start_pos.x == end_x && start_pos.y == end_y) || (diff_x >= -(settings.tap_pixel_range) && diff_x <= settings.tap_pixel_range && diff_y >= -(settings.tap_pixel_range) && diff_y <= settings.tap_pixel_range))) {
							$this.data('tapheld', true);

							var end_time = Date.now();

							var duration  = end_time - start_time,
								touches   = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches : [ e ],
								touchData = [ ];

							for( var i = 0; i < touches.length; i++)
							{
								var touch = {
									'position': {
										'x': (settings.touch_capable) ? origEvent.changedTouches[i].pageX : e.pageX,
										'y': (settings.touch_capable) ? origEvent.changedTouches[i].pageY : e.pageY
									},
									'offset': {
										'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[i].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
										'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[i].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
									},
									'time': Date.now(),
									'target': e.target,
									'duration': duration
								};

								touchData.push( touch );
							}

							var evt_name = ( touches.length == 2 ) ? 'taphold2' : 'taphold';

							$this.data('callee1', tapHoldFunc1);

							triggerCustomEvent(thisObject, evt_name, e, touchData);
						}
					}, threshold);

					return true;
				}
			}).on(settings.endevent, function tapHoldFunc2() {
				$this.data('callee2', tapHoldFunc2);
				$this.data('tapheld', false);
				window.clearTimeout(settings.hold_timer);
			})
			.on(settings.moveevent, function tapHoldFunc3(e) {
				$this.data('callee3', tapHoldFunc3);

				end_x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
				end_y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;
			});
		},

		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee1).off(settings.endevent, $(this).data.callee2).off(settings.moveevent, $(this).data.callee3);
		}
	};

	// doubletap Event:
	$.event.special.doubletap = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				origTarget,
				action,
				firstTap = null,
				origEvent,
				cooloff,
				cooling = false;

			$this.on(settings.startevent, function doubleTapFunc1(e) {
				if (e.which && e.which !== 1) {
					return false;
				}

				$this.data('doubletapped', false);
				origTarget = e.target;
				$this.data('callee1', doubleTapFunc1);

				origEvent = e.originalEvent;
				if (!firstTap) {
					firstTap = {
						'position': {
							'x': (settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX,
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target,
						'element': e.originalEvent.srcElement,
						'index':   $(e.target).index()
					};
				}

				return true;
			}).on(settings.endevent, function doubleTapFunc2(e) {

				var now = Date.now();
				var lastTouch = $this.data('lastTouch') || now + 1;
				var delta = now - lastTouch;
				window.clearTimeout(action);
				$this.data('callee2', doubleTapFunc2);

				if (delta < settings.doubletap_int && ($(e.target).index() == firstTap.index) && delta > 100) {
					$this.data('doubletapped', true);
					window.clearTimeout(settings.tap_timer);

					// Now get the current event:
					var lastTap = {
						'position': {
							'x': (settings.touch_capable) ? e.originalEvent.changedTouches[0].pageX : e.pageX,
							'y': (settings.touch_capable) ? e.originalEvent.changedTouches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target,
						'element': e.originalEvent.srcElement,
						'index': $(e.target).index()
					};

					var touchData = {
						'firstTap': firstTap,
						'secondTap': lastTap,
						'interval': lastTap.time - firstTap.time
					};

					if (!cooling) {
						triggerCustomEvent(thisObject, 'doubletap', e, touchData);
						firstTap = null;
					}

					cooling = true;

					cooloff = window.setTimeout(function () {
						cooling = false;
					}, settings.doubletap_int);

				} else {
					$this.data('lastTouch', now);
					action = window.setTimeout(function () {
						firstTap = null;
						window.clearTimeout(action);
					}, settings.doubletap_int, [e]);
				}
				$this.data('lastTouch', now);
			});
		},
		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee1).off(settings.endevent, $(this).data.callee2);
		}
	};

	// singletap Event:
	// This is used in conjuction with doubletap when both events are needed on the same element
	$.event.special.singletap = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				origTarget = null,
				startTime = null,
				start_pos = {
					x: 0,
					y: 0
				};

			$this.on(settings.startevent, function singleTapFunc1(e) {
				if (e.which && e.which !== 1) {
					return false;
				} else {
					startTime = Date.now();
					origTarget = e.target;
					$this.data('callee1', singleTapFunc1);

					// Get the start x and y position:
					start_pos.x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
					start_pos.y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;

					return true;
				}
			}).on(settings.endevent, function singleTapFunc2(e) {
				$this.data('callee2', singleTapFunc2);
				if (e.target == origTarget) {

					// Get the end point:
					var end_pos_x = (e.originalEvent.changedTouches) ? e.originalEvent.changedTouches[0].pageX : e.pageX,
						end_pos_y = (e.originalEvent.changedTouches) ? e.originalEvent.changedTouches[0].pageY : e.pageY;

					// We need to check if it was a taphold:

					settings.tap_timer = window.setTimeout(function () {

						var diff_x = (start_pos.x - end_pos_x), diff_y = (start_pos.y - end_pos_y);

						if(!$this.data('doubletapped') && !$this.data('tapheld') && (((start_pos.x == end_pos_x) && (start_pos.y == end_pos_y)) || (diff_x >= -(settings.tap_pixel_range) && diff_x <= settings.tap_pixel_range && diff_y >= -(settings.tap_pixel_range) && diff_y <= settings.tap_pixel_range))) {

							var origEvent = e.originalEvent;
							var touchData = {
								'position': {
									'x': (settings.touch_capable) ? origEvent.changedTouches[0].pageX : e.pageX,
									'y': (settings.touch_capable) ? origEvent.changedTouches[0].pageY : e.pageY
								},
								'offset': {
									'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
									'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
								},
								'time': Date.now(),
								'target': e.target
							};

							// Was it a taphold?
							if((touchData.time - startTime) < settings.taphold_threshold)
							{
								triggerCustomEvent(thisObject, 'singletap', e, touchData);
							}
						}
					}, settings.doubletap_int);
				}
			});
		},

		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee1).off(settings.endevent, $(this).data.callee2);
		}
	};

	// tap Event:
	$.event.special.tap = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				started = false,
				origTarget = null,
				start_time,
				start_pos = {
					x: 0,
					y: 0
				},
				touches;

			$this.on(settings.startevent, function tapFunc1(e) {
				$this.data('callee1', tapFunc1);

				if( e.which && e.which !== 1 )
				{
					return false;
				}
				else
				{
					started = true;
					start_pos.x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
					start_pos.y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;
					start_time = Date.now();
					origTarget = e.target;

					touches = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches : [ e ];
					return true;
				}
			}).on(settings.endevent, function tapFunc2(e) {
				$this.data('callee2', tapFunc2);

				// Only trigger if they've started, and the target matches:
				var end_x = (e.originalEvent.targetTouches) ? e.originalEvent.changedTouches[0].pageX : e.pageX,
					end_y = (e.originalEvent.targetTouches) ? e.originalEvent.changedTouches[0].pageY : e.pageY,
					diff_x = (start_pos.x - end_x),
					diff_y = (start_pos.y - end_y),
					eventName;

				if (origTarget == e.target && started && ((Date.now() - start_time) < settings.taphold_threshold) && ((start_pos.x == end_x && start_pos.y == end_y) || (diff_x >= -(settings.tap_pixel_range) && diff_x <= settings.tap_pixel_range && diff_y >= -(settings.tap_pixel_range) && diff_y <= settings.tap_pixel_range))) {
					var origEvent = e.originalEvent;
					var touchData = [ ];

					for( var i = 0; i < touches.length; i++)
					{
						var touch = {
							'position': {
								'x': (settings.touch_capable) ? origEvent.changedTouches[i].pageX : e.pageX,
								'y': (settings.touch_capable) ? origEvent.changedTouches[i].pageY : e.pageY
							},
							'offset': {
								'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[i].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
								'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[i].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
							},
							'time': Date.now(),
							'target': e.target
						};

						touchData.push( touch );
					}

					var evt_name = ( touches.length == 2 ) ? 'tap2' : 'tap';

					triggerCustomEvent(thisObject, evt_name, e, touchData);
				}
			});
		},

		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee1).off(settings.endevent, $(this).data.callee2);
		}
	};

	// swipe Event (also handles swipeup, swiperight, swipedown and swipeleft):
	$.event.special.swipe = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				started = false,
				hasSwiped = false,
				originalCoord = {
					x: 0,
					y: 0
				},
				finalCoord = {
					x: 0,
					y: 0
				},
				startEvnt;

			// Screen touched, store the original coordinate

			function touchStart(e) {
				$this = $(e.currentTarget);
				$this.data('callee1', touchStart);
				originalCoord.x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
				originalCoord.y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;
				finalCoord.x = originalCoord.x;
				finalCoord.y = originalCoord.y;
				started = true;
				var origEvent = e.originalEvent;
				// Read event data into our startEvt:
				startEvnt = {
					'position': {
						'x': (settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX,
						'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
					},
					'offset': {
						'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
						'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
					},
					'time': Date.now(),
					'target': e.target
				};
			}

			// Store coordinates as finger is swiping

			function touchMove(e) {
				$this = $(e.currentTarget);
				$this.data('callee2', touchMove);
				finalCoord.x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
				finalCoord.y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;

				var swipedir;

				// We need to check if the element to which the event was bound contains a data-xthreshold | data-vthreshold:
				var ele_x_threshold = ($this.parent().data('xthreshold')) ? $this.parent().data('xthreshold') : $this.data('xthreshold'),
					ele_y_threshold = ($this.parent().data('ythreshold')) ? $this.parent().data('ythreshold') : $this.data('ythreshold'),
					h_threshold = (typeof ele_x_threshold !== 'undefined' && ele_x_threshold !== false && parseInt(ele_x_threshold)) ? parseInt(ele_x_threshold) : settings.swipe_h_threshold,
					v_threshold = (typeof ele_y_threshold !== 'undefined' && ele_y_threshold !== false && parseInt(ele_y_threshold)) ? parseInt(ele_y_threshold) : settings.swipe_v_threshold;

				if (originalCoord.y > finalCoord.y && (originalCoord.y - finalCoord.y > v_threshold)) {
					swipedir = 'swipeup';
				}
				if (originalCoord.x < finalCoord.x && (finalCoord.x - originalCoord.x > h_threshold)) {
					swipedir = 'swiperight';
				}
				if (originalCoord.y < finalCoord.y && (finalCoord.y - originalCoord.y > v_threshold)) {
					swipedir = 'swipedown';
				}
				if (originalCoord.x > finalCoord.x && (originalCoord.x - finalCoord.x > h_threshold)) {
					swipedir = 'swipeleft';
				}
				if (swipedir != undefined && started) {
					originalCoord.x = 0;
					originalCoord.y = 0;
					finalCoord.x = 0;
					finalCoord.y = 0;
					started = false;

					// Read event data into our endEvnt:
					var origEvent = e.originalEvent;
					var endEvnt = {
						'position': {
							'x': (settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX,
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target
					};

					// Calculate the swipe amount (normalized):
					var xAmount = Math.abs(startEvnt.position.x - endEvnt.position.x),
						yAmount = Math.abs(startEvnt.position.y - endEvnt.position.y);

					var touchData = {
						'startEvnt': startEvnt,
						'endEvnt': endEvnt,
						'direction': swipedir.replace('swipe', ''),
						'xAmount': xAmount,
						'yAmount': yAmount,
						'duration': endEvnt.time - startEvnt.time
					};
					hasSwiped = true;
					$this.trigger('swipe', touchData).trigger(swipedir, touchData);
				}
			}

			function touchEnd(e) {
				$this = $(e.currentTarget);
				var swipedir = "";
				$this.data('callee3', touchEnd);
				if (hasSwiped) {
					// We need to check if the element to which the event was bound contains a data-xthreshold | data-vthreshold:
					var ele_x_threshold = $this.data('xthreshold'),
						ele_y_threshold = $this.data('ythreshold'),
						h_threshold = (typeof ele_x_threshold !== 'undefined' && ele_x_threshold !== false && parseInt(ele_x_threshold)) ? parseInt(ele_x_threshold) : settings.swipe_h_threshold,
						v_threshold = (typeof ele_y_threshold !== 'undefined' && ele_y_threshold !== false && parseInt(ele_y_threshold)) ? parseInt(ele_y_threshold) : settings.swipe_v_threshold;

					var origEvent = e.originalEvent;
					var endEvnt = {
						'position': {
							'x': (settings.touch_capable) ? origEvent.changedTouches[0].pageX : e.pageX,
							'y': (settings.touch_capable) ? origEvent.changedTouches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target
					};

					// Read event data into our endEvnt:
					if (startEvnt.position.y > endEvnt.position.y && (startEvnt.position.y - endEvnt.position.y > v_threshold)) {
						swipedir = 'swipeup';
					}
					if (startEvnt.position.x < endEvnt.position.x && (endEvnt.position.x - startEvnt.position.x > h_threshold)) {
						swipedir = 'swiperight';
					}
					if (startEvnt.position.y < endEvnt.position.y && (endEvnt.position.y - startEvnt.position.y > v_threshold)) {
						swipedir = 'swipedown';
					}
					if (startEvnt.position.x > endEvnt.position.x && (startEvnt.position.x - endEvnt.position.x > h_threshold)) {
						swipedir = 'swipeleft';
					}

					// Calculate the swipe amount (normalized):
					var xAmount = Math.abs(startEvnt.position.x - endEvnt.position.x),
						yAmount = Math.abs(startEvnt.position.y - endEvnt.position.y);

					var touchData = {
						'startEvnt': startEvnt,
						'endEvnt': endEvnt,
						'direction': swipedir.replace('swipe', ''),
						'xAmount': xAmount,
						'yAmount': yAmount,
						'duration': endEvnt.time - startEvnt.time
					};
					$this.trigger('swipeend', touchData);
				}

				started = false;
				hasSwiped = false;
			}

			$this.on(settings.startevent, touchStart);
			$this.on(settings.moveevent, touchMove);
			$this.on(settings.endevent, touchEnd);
		},

		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee1).off(settings.moveevent, $(this).data.callee2).off(settings.endevent, $(this).data.callee3);
		}
	};

	// scrollstart Event (also handles scrollend):
	$.event.special.scrollstart = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				scrolling,
				timer;

			function trigger(event, state) {
				scrolling = state;
				triggerCustomEvent(thisObject, scrolling ? 'scrollstart' : 'scrollend', event);
			}

			// iPhone triggers scroll after a small delay; use touchmove instead
			$this.on(settings.scrollevent, function scrollFunc(event) {
				$this.data('callee', scrollFunc);

				if (!scrolling) {
					trigger(event, true);
				}

				clearTimeout(timer);
				timer = setTimeout(function () {
					trigger(event, false);
				}, 50);
			});
		},

		remove: function () {
			$(this).off(settings.scrollevent, $(this).data.callee);
		}
	};

	// This is the orientation change (largely borrowed from jQuery Mobile):
	var win = $(window),
		special_event,
		get_orientation,
		last_orientation,
		initial_orientation_is_landscape,
		initial_orientation_is_default,
		portrait_map = {
			'0': true,
			'180': true
		};

	if (settings.orientation_support) {
		var ww = window.innerWidth || win.width(),
			wh = window.innerHeight || win.height(),
			landscape_threshold = 50;

		initial_orientation_is_landscape = ww > wh && (ww - wh) > landscape_threshold;
		initial_orientation_is_default = portrait_map[window.orientation];

		if ((initial_orientation_is_landscape && initial_orientation_is_default) || (!initial_orientation_is_landscape && !initial_orientation_is_default)) {
			portrait_map = {
				'-90': true,
				'90': true
			};
		}
	}

	$.event.special.orientationchange = special_event = {
		setup: function () {
			// If the event is supported natively, return false so that jQuery
			// will on to the event using DOM methods.
			if (settings.orientation_support) {
				return false;
			}

			// Get the current orientation to avoid initial double-triggering.
			last_orientation = get_orientation();

			win.on('throttledresize', handler);
			return true;
		},
		teardown: function () {
			if (settings.orientation_support) {
				return false;
			}

			win.off('throttledresize', handler);
			return true;
		},
		add: function (handleObj) {
			// Save a reference to the bound event handler.
			var old_handler = handleObj.handler;

			handleObj.handler = function (event) {
				event.orientation = get_orientation();
				return old_handler.apply(this, arguments);
			};
		}
	};

	// If the event is not supported natively, this handler will be bound to
	// the window resize event to simulate the orientationchange event.

	function handler() {
		// Get the current orientation.
		var orientation = get_orientation();

		if (orientation !== last_orientation) {
			// The orientation has changed, so trigger the orientationchange event.
			last_orientation = orientation;
			win.trigger("orientationchange");
		}
	}

	$.event.special.orientationchange.orientation = get_orientation = function () {
		var isPortrait = true,
			elem = document.documentElement;

		if (settings.orientation_support) {
			isPortrait = portrait_map[window.orientation];
		} else {
			isPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;
		}

		return isPortrait ? 'portrait' : 'landscape';
	};

	// throttle Handler:
	$.event.special.throttledresize = {
		setup: function () {
			$(this).on('resize', throttle_handler);
		},
		teardown: function () {
			$(this).off('resize', throttle_handler);
		}
	};

	var throttle = 250,
		throttle_handler = function () {
			curr = Date.now();
			diff = curr - lastCall;

			if (diff >= throttle) {
				lastCall = curr;
				$(this).trigger('throttledresize');

			} else {
				if (heldCall) {
					window.clearTimeout(heldCall);
				}

				// Promise a held call will still execute
				heldCall = window.setTimeout(handler, throttle - diff);
			}
		},
		lastCall = 0,
		heldCall,
		curr,
		diff;

	// Trigger a custom event:

	function triggerCustomEvent(obj, eventType, event, touchData) {
		var originalType = event.type;
		event.type = eventType;

		$.event.dispatch.call(obj, event, touchData);
		event.type = originalType;
	}

	// Correctly on anything we've overloaded:
	$.each({
		scrollend: 'scrollstart',
		swipeup: 'swipe',
		swiperight: 'swipe',
		swipedown: 'swipe',
		swipeleft: 'swipe',
		swipeend: 'swipe',
		tap2:     'tap',
		taphold2: 'taphold'
	}, function (e, srcE) {
		$.event.special[e] = {
			setup: function () {
				$(this).on(srcE, $.noop);
			}
		};
	});

}(jQuery))};

exports();
module.resolveWith(exports);

// module body: end

};
// module factory: end

FD40.module("mobile-events", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

//! moment.js
//! version : 2.6.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.6.0",
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // moment internal properties
        momentProperties = {
            _isAMomentObject: null,
            _i : null,
            _f : null,
            _l : null,
            _strict : null,
            _isUTC : null,
            _offset : null,  // optional. Combine with _isUTC
            _pf : null,
            _lang : null  // optional
        },

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        function printMsg() {
            if (moment.suppressDeprecationWarnings === false &&
                    typeof console !== 'undefined' && console.warn) {
                console.warn("Deprecation warning: " + msg);
            }
        }
        return extend(function () {
            if (firstTime) {
                printMsg();
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function cloneMoment(m) {
        var result = {}, i;
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i];
            }
        }

        return result;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) { return parseTokenOneDigit; }
            /* falls through */
        case 'SS':
            if (strict) { return parseTokenTwoDigits; }
            /* falls through */
        case 'SSS':
            if (strict) { return parseTokenThreeDigits; }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return parseTokenOrdinal;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input, 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'dd':
        case 'ddd':
        case 'dddd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gg':
        case 'gggg':
        case 'GG':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = input;
            }
            break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var intVal = parseInt(val, 10);
                return val ?
                  (val.length < 3 ? (intVal > 68 ? 1900 + intVal : 2000 + intVal) : intVal) :
                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = cloneMoment(input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = lang;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
            "moment construction falls back to js Date. This is " +
            "discouraged and will be removed in upcoming major " +
            "release. Please refer to " +
            "https://github.com/moment/moment/issues/1407 for more info.",
            function (config) {
        config._d = new Date(config._i);
    });

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = lang;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        // keepTime = true means only change the timezone, without affecting
        // the local hour. So 5:31:26 +0300 --[zone(2, true)]--> 5:31:26 +0200
        // It is possible that 5:31:26 doesn't exist int zone +0200, so we
        // adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepTime) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    if (!keepTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this._lang._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.lang().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    $.moment = moment;

}).call(this);

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("moment", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

/*
 * Password Strength (0.1.2)
 * by Sagie Maoz (n0nick.net)
 * n0nick@php.net
 *
 * This plugin will check the value of a password field and evaluate the
 * strength of the typed password. This is done by checking for
 * the diversity of character types: numbers, lowercase and uppercase
 * letters and special characters.
 *
 * Copyright (c) 2010 Sagie Maoz <n0nick@php.net>
 * Licensed under the GPL license, see http://www.gnu.org/licenses/gpl-3.0.html
 *
 *
 * NOTE: This script requires jQuery to work.  Download jQuery at www.jquery.com
 *
 */

var passwordStrength = new function()
{
	this.countRegexp = function(val, rex)
	{
		var match = val.match(rex);
		return match ? match.length : 0;
	};

	this.getStrength = function(val, minLength)
	{
		var len = val.length;

		// too short =(
		if (len < minLength)
		{
			return 0;
		}

		var nums = this.countRegexp(val, /\d/g),
			lowers = this.countRegexp(val, /[a-z]/g),
			uppers = this.countRegexp(val, /[A-Z]/g),
			specials = len - nums - lowers - uppers;

		// just one type of characters =(
		if (nums == len || lowers == len || uppers == len || specials == len)
		{
			return 1;
		}

		var strength = 0;
		if (nums)	{ strength+= 2; }
		if (lowers)	{ strength+= uppers? 4 : 3; }
		if (uppers)	{ strength+= lowers? 4 : 3; }
		if (specials) { strength+= 5; }
		if (len > 10) { strength+= 1; }

		return strength;
	};

	this.getStrengthLevel = function(val, minLength)
	{
		var strength = this.getStrength(val, minLength),
				val = 1;
		if (strength <= 0) {
			val = 1;
		} else if (strength > 0 && strength <= 4) {
			val = 2;
		} else if (strength > 4 && strength <= 8) {
			val = 3;
		} else if (strength > 8 && strength <= 12) {
			val = 4;
		} else if (strength > 12) {
			val = 5;
		}

		return val;
	};
};

$.fn.password_strength = function(options)
{
	var settings = $.extend({
		'container' : null,
		'minLength' : 6,
		'texts' : {
			1 : 'Too weak',
			2 : 'Weak password',
			3 : 'Normal strength',
			4 : 'Strong password',
			5 : 'Very strong password'
		},
		'onCheck': null
	}, options);

	return this.each(function()
	{
		var container = null;
		if (settings.container)
		{
			container = $(settings.container);
		}
		else
		{
			container = $('<span/>').attr('class', 'password_strength');
			$(this).after(container);
		}

		$(this).keyup(function()
		{
			var val = $(this).val(),
					level = passwordStrength.getStrengthLevel(val, settings.minLength);

			if (val.length > 0)
			{
				var _class = 'password_strength_' + level;

				if (!container.hasClass(_class) && level in settings.texts)
				{
					container.text(settings.texts[level]).attr('class', 'password_strength ' + _class);
				}
			}
			else
			{
				container.text('').attr('class', 'password_strength');
			}
			if (settings.onCheck) {
				settings.onCheck.call(this, level);
			}
		});
	});
};
}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("passwordstrength", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*! http://mths.be/placeholder v2.0.7 by @mathias */
;(function(window, document, $) {

	var isInputSupported = 'placeholder' in document.createElement('input'),
	    isTextareaSupported = 'placeholder' in document.createElement('textarea'),
	    prototype = $.fn,
	    valHooks = $.valHooks,
	    hooks,
	    placeholder;

	if (isInputSupported && isTextareaSupported) {

		placeholder = prototype.placeholder = function() {
			return this;
		};

		placeholder.input = placeholder.textarea = true;

	} else {

		placeholder = prototype.placeholder = function() {
			var $this = this;
			$this
				.filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
				.not('.placeholder')
				.bind({
					'focus.placeholder': clearPlaceholder,
					'blur.placeholder': setPlaceholder
				})
				.data('placeholder-enabled', true)
				.trigger('blur.placeholder');
			return $this;
		};

		placeholder.input = isInputSupported;
		placeholder.textarea = isTextareaSupported;

		hooks = {
			'get': function(element) {
				var $element = $(element);
				return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
			},
			'set': function(element, value) {
				var $element = $(element);
				if (!$element.data('placeholder-enabled')) {
					return element.value = value;
				}
				if (value == '') {
					element.value = value;
					// Issue #56: Setting the placeholder causes problems if the element continues to have focus.
					if (element != document.activeElement) {
						// We can't use `triggerHandler` here because of dummy text/password inputs :(
						setPlaceholder.call(element);
					}
				} else if ($element.hasClass('placeholder')) {
					clearPlaceholder.call(element, true, value) || (element.value = value);
				} else {
					element.value = value;
				}
				// `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
				return $element;
			}
		};

		isInputSupported || (valHooks.input = hooks);
		isTextareaSupported || (valHooks.textarea = hooks);

		$(function() {
			// Look for forms
			$(document).delegate('form', 'submit.placeholder', function() {
				// Clear the placeholder values so they don't get submitted
				var $inputs = $('.placeholder', this).each(clearPlaceholder);
				setTimeout(function() {
					$inputs.each(setPlaceholder);
				}, 10);
			});
		});

		// Clear placeholder values upon page reload
		$(window).bind('beforeunload.placeholder', function() {
			$('.placeholder').each(function() {
				this.value = '';
			});
		});

	}

	function args(elem) {
		// Return an object of element attributes
		var newAttrs = {},
		    rinlinejQuery = /^jQuery\d+$/;
		$.each(elem.attributes, function(i, attr) {
			if (attr.specified && !rinlinejQuery.test(attr.name)) {
				newAttrs[attr.name] = attr.value;
			}
		});
		return newAttrs;
	}

	function clearPlaceholder(event, value) {
		var input = this,
		    $input = $(input);
		if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
			if ($input.data('placeholder-password')) {
				$input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
				// If `clearPlaceholder` was called from `$.valHooks.input.set`
				if (event === true) {
					return $input[0].value = value;
				}
				$input.focus();
			} else {
				input.value = '';
				$input.removeClass('placeholder');
				input == document.activeElement && input.select();
			}
		}
	}

	function setPlaceholder() {
		var $replacement,
		    input = this,
		    $input = $(input),
		    $origInput = $input,
		    id = this.id;
		if (input.value == '') {
			if (input.type == 'password') {
				if (!$input.data('placeholder-textinput')) {
					try {
						$replacement = $input.clone().attr({ 'type': 'text' });
					} catch(e) {
						$replacement = $('<input>').attr($.extend(args(this), { 'type': 'text' }));
					}
					$replacement
						.removeAttr('name')
						.data({
							'placeholder-password': true,
							'placeholder-id': id
						})
						.bind('focus.placeholder', clearPlaceholder);
					$input
						.data({
							'placeholder-textinput': $replacement,
							'placeholder-id': id
						})
						.before($replacement);
				}
				$input = $input.removeAttr('id').hide().prev().attr('id', id).show();
				// Note: `$input[0] != input` now!
			}
			$input.addClass('placeholder');
			$input[0].value = $input.attr('placeholder');
		} else {
			$input.removeClass('placeholder');
		}
	}

}(window, document, jQuery));

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("placeholder", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 
/**
 * plupload.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

// JSLint defined globals
/*global window:false, escape:false */

/*!@@version@@*/

(function() {
	var count = 0, runtimes = [], i18n = {}, mimes = {},
		xmlEncodeChars = {'<' : 'lt', '>' : 'gt', '&' : 'amp', '"' : 'quot', '\'' : '#39'},
		xmlEncodeRegExp = /[<>&\"\']/g, undef, delay = window.setTimeout,
		// A place to store references to event handlers
		eventhash = {},
		uid;

	// IE W3C like event funcs
	function preventDefault() {
		this.returnValue = false;
	}

	function stopPropagation() {
		this.cancelBubble = true;
	}

	// Parses the default mime types string into a mimes lookup map
	(function(mime_data) {
		var items = mime_data.split(/,/), i, y, ext;

		for (i = 0; i < items.length; i += 2) {
			ext = items[i + 1].split(/ /);

			for (y = 0; y < ext.length; y++) {
				mimes[ext[y]] = items[i];
			}
		}
	})(
		"application/msword,doc dot," +
		"application/pdf,pdf," +
		"application/pgp-signature,pgp," +
		"application/postscript,ps ai eps," +
		"application/rtf,rtf," +
		"application/vnd.ms-excel,xls xlb," +
		"application/vnd.ms-powerpoint,ppt pps pot," +
		"application/zip,zip," +
		"application/x-shockwave-flash,swf swfl," +
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document,docx," +
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template,dotx," +
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,xlsx," +
		"application/vnd.openxmlformats-officedocument.presentationml.presentation,pptx," + 
		"application/vnd.openxmlformats-officedocument.presentationml.template,potx," +
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow,ppsx," +
		"application/x-javascript,js," +
		"application/json,json," +
		"audio/mpeg,mpga mpega mp2 mp3," +
		"audio/x-wav,wav," +
		"audio/mp4,m4a," +
		"image/bmp,bmp," +
		"image/gif,gif," +
		"image/jpeg,jpeg jpg jpe," +
		"image/photoshop,psd," +
		"image/png,png," +
		"image/svg+xml,svg svgz," +
		"image/tiff,tiff tif," +
		"text/plain,asc txt text diff log," +
		"text/html,htm html xhtml," +
		"text/css,css," +
		"text/csv,csv," +
		"text/rtf,rtf," +
		"video/mpeg,mpeg mpg mpe m2v," +
		"video/quicktime,qt mov," +
		"video/mp4,mp4," +
		"video/x-m4v,m4v," +
		"video/x-flv,flv," +
		"video/x-ms-wmv,wmv," +
		"video/avi,avi," +
		"video/webm,webm," +
		"video/3gpp,3gp," +
		"video/3gpp2,3g2," +
		"video/vnd.rn-realvideo,rv," +
		"application/vnd.oasis.opendocument.formula-template,otf," +
		"application/octet-stream,exe"
	);

	/**
	 * Plupload class with some global constants and functions.
	 *
	 * @example
	 * // Encode entities
	 * console.log(plupload.xmlEncode("My string &lt;&gt;"));
	 *
	 * // Generate unique id
	 * console.log(plupload.guid());
	 *
	 * @static
	 * @class plupload
	 */
	var plupload = {
		/**
		 * Plupload version will be replaced on build.
		 */
		VERSION : '@@version@@',

		/**
		 * Inital state of the queue and also the state ones it's finished all it's uploads.
		 *
		 * @property STOPPED
		 * @final
		 */
		STOPPED : 1,

		/**
		 * Upload process is running
		 *
		 * @property STARTED
		 * @final
		 */
		STARTED : 2,

		/**
		 * File is queued for upload
		 *
		 * @property QUEUED
		 * @final
		 */
		QUEUED : 1,

		/**
		 * File is being uploaded
		 *
		 * @property UPLOADING
		 * @final
		 */
		UPLOADING : 2,

		/**
		 * File has failed to be uploaded
		 *
		 * @property FAILED
		 * @final
		 */
		FAILED : 4,

		/**
		 * File has been uploaded successfully
		 *
		 * @property DONE
		 * @final
		 */
		DONE : 5,

		// Error constants used by the Error event

		/**
		 * Generic error for example if an exception is thrown inside Silverlight.
		 *
		 * @property GENERIC_ERROR
		 * @final
		 */
		GENERIC_ERROR : -100,

		/**
		 * HTTP transport error. For example if the server produces a HTTP status other than 200.
		 *
		 * @property HTTP_ERROR
		 * @final
		 */
		HTTP_ERROR : -200,

		/**
		 * Generic I/O error. For exampe if it wasn't possible to open the file stream on local machine.
		 *
		 * @property IO_ERROR
		 * @final
		 */
		IO_ERROR : -300,

		/**
		 * Generic I/O error. For exampe if it wasn't possible to open the file stream on local machine.
		 *
		 * @property SECURITY_ERROR
		 * @final
		 */
		SECURITY_ERROR : -400,

		/**
		 * Initialization error. Will be triggered if no runtime was initialized.
		 *
		 * @property INIT_ERROR
		 * @final
		 */
		INIT_ERROR : -500,

		/**
		 * File size error. If the user selects a file that is too large it will be blocked and an error of this type will be triggered.
		 *
		 * @property FILE_SIZE_ERROR
		 * @final
		 */
		FILE_SIZE_ERROR : -600,

		/**
		 * File extension error. If the user selects a file that isn't valid according to the filters setting.
		 *
		 * @property FILE_EXTENSION_ERROR
		 * @final
		 */
		FILE_EXTENSION_ERROR : -601,
		
		/**
		 * Runtime will try to detect if image is proper one. Otherwise will throw this error.
		 *
		 * @property IMAGE_FORMAT_ERROR
		 * @final
		 */
		IMAGE_FORMAT_ERROR : -700,
		
		/**
		 * While working on the image runtime will try to detect if the operation may potentially run out of memeory and will throw this error.
		 *
		 * @property IMAGE_MEMORY_ERROR
		 * @final
		 */
		IMAGE_MEMORY_ERROR : -701,
		
		/**
		 * Each runtime has an upper limit on a dimension of the image it can handle. If bigger, will throw this error.
		 *
		 * @property IMAGE_DIMENSIONS_ERROR
		 * @final
		 */
		IMAGE_DIMENSIONS_ERROR : -702,
		

		/**
		 * Mime type lookup table.
		 *
		 * @property mimeTypes
		 * @type Object
		 * @final
		 */
		mimeTypes : mimes,
		
		/**
		 * In some cases sniffing is the only way around :(
		 */
		ua: (function() {
			var nav = navigator, userAgent = nav.userAgent, vendor = nav.vendor, webkit, opera, safari;
			
			webkit = /WebKit/.test(userAgent);
			safari = webkit && vendor.indexOf('Apple') !== -1;
			opera = window.opera && window.opera.buildNumber;
			
			return {
				windows: navigator.platform.indexOf('Win') !== -1,
				android: /Android/.test(userAgent),
				ie: !webkit && !opera && (/MSIE/gi).test(userAgent) && (/Explorer/gi).test(nav.appName),
				webkit: webkit,
				gecko: !webkit && /Gecko/.test(userAgent),
				safari: safari,
				opera: !!opera
			};
		}()),
		
		/**
		 * Gets the true type of the built-in object (better version of typeof).
		 * @credits Angus Croll (http://javascriptweblog.wordpress.com/)
		 *
		 * @param {Object} o Object to check.
		 * @return {String} Object [[Class]]
		 */
		typeOf: function(o) {
			return ({}).toString.call(o).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
		},

		/**
		 * Extends the specified object with another object.
		 *
		 * @method extend
		 * @param {Object} target Object to extend.
		 * @param {Object..} obj Multiple objects to extend with.
		 * @return {Object} Same as target, the extended object.
		 */
		extend : function(target) {
			plupload.each(arguments, function(arg, i) {
				if (i > 0) {
					plupload.each(arg, function(value, key) {
						target[key] = value;
					});
				}
			});

			return target;
		},

		/**
		 * Cleans the specified name from national characters (diacritics). The result will be a name with only a-z, 0-9 and _.
		 *
		 * @method cleanName
		 * @param {String} s String to clean up.
		 * @return {String} Cleaned string.
		 */
		cleanName : function(name) {
			var i, lookup;

			// Replace diacritics
			lookup = [
				/[\300-\306]/g, 'A', /[\340-\346]/g, 'a', 
				/\307/g, 'C', /\347/g, 'c',
				/[\310-\313]/g, 'E', /[\350-\353]/g, 'e',
				/[\314-\317]/g, 'I', /[\354-\357]/g, 'i',
				/\321/g, 'N', /\361/g, 'n',
				/[\322-\330]/g, 'O', /[\362-\370]/g, 'o',
				/[\331-\334]/g, 'U', /[\371-\374]/g, 'u'
			];

			for (i = 0; i < lookup.length; i += 2) {
				name = name.replace(lookup[i], lookup[i + 1]);
			}

			// Replace whitespace
			name = name.replace(/\s+/g, '_');

			// Remove anything else
			name = name.replace(/[^a-z0-9_\-\.]+/gi, '');

			return name;
		},

		/**
		 * Adds a specific upload runtime like for example flash or gears.
		 *
		 * @method addRuntime
		 * @param {String} name Runtime name for example flash.
		 * @param {Object} obj Object containing init/destroy method.
		 */
		addRuntime : function(name, runtime) {			
			runtime.name = name;
			runtimes[name] = runtime;
			runtimes.push(runtime);

			return runtime;
		},

		/**
		 * Generates an unique ID. This is 99.99% unique since it takes the current time and 5 random numbers.
		 * The only way a user would be able to get the same ID is if the two persons at the same exact milisecond manages
		 * to get 5 the same random numbers between 0-65535 it also uses a counter so each call will be guaranteed to be page unique.
		 * It's more probable for the earth to be hit with an ansteriod. You can also if you want to be 100% sure set the plupload.guidPrefix property
		 * to an user unique key.
		 *
		 * @method guid
		 * @return {String} Virtually unique id.
		 */
		guid : function() {
			var guid = new Date().getTime().toString(32), i;

			for (i = 0; i < 5; i++) {
				guid += Math.floor(Math.random() * 65535).toString(32);
			}

			return (plupload.guidPrefix || 'p') + guid + (count++).toString(32);
		},

		/**
		 * Builds a full url out of a base URL and an object with items to append as query string items.
		 *
		 * @param {String} url Base URL to append query string items to.
		 * @param {Object} items Name/value object to serialize as a querystring.
		 * @return {String} String with url + serialized query string items.
		 */
		buildUrl : function(url, items) {
			var query = '';

			plupload.each(items, function(value, name) {
				query += (query ? '&' : '') + encodeURIComponent(name) + '=' + encodeURIComponent(value);
			});

			if (query) {
				url += (url.indexOf('?') > 0 ? '&' : '?') + query;
			}

			return url;
		},

		/**
		 * Executes the callback function for each item in array/object. If you return false in the
		 * callback it will break the loop.
		 *
		 * @param {Object} obj Object to iterate.
		 * @param {function} callback Callback function to execute for each item.
		 */
		each : function(obj, callback) {
			var length, key, i;

			if (obj) {
				length = obj.length;

				if (length === undef) {
					// Loop object items
					for (key in obj) {
						if (obj.hasOwnProperty(key)) {
							if (callback(obj[key], key) === false) {
								return;
							}
						}
					}
				} else {
					// Loop array items
					for (i = 0; i < length; i++) {
						if (callback(obj[i], i) === false) {
							return;
						}
					}
				}
			}
		},

		/**
		 * Formats the specified number as a size string for example 1024 becomes 1 KB.
		 *
		 * @method formatSize
		 * @param {Number} size Size to format as string.
		 * @return {String} Formatted size string.
		 */
		formatSize : function(size) {
			if (size === undef || /\D/.test(size)) {
				return plupload.translate('N/A');
			}
			
			// GB
			if (size > 1073741824) {
				return Math.round(size / 1073741824, 1) + " GB";
			}

			// MB
			if (size > 1048576) {
				return Math.round(size / 1048576, 1) + " MB";
			}

			// KB
			if (size > 1024) {
				return Math.round(size / 1024, 1) + " KB";
			}

			return size + " b";
		},

		/**
		 * Returns the absolute x, y position of an Element. The position will be returned in a object with x, y fields.
		 *
		 * @method getPos
		 * @param {Element} node HTML element or element id to get x, y position from.
		 * @param {Element} root Optional root element to stop calculations at.
		 * @return {object} Absolute position of the specified element object with x, y fields.
		 */
		 getPos : function(node, root) {
			var x = 0, y = 0, parent, doc = document, nodeRect, rootRect;

			node = node;
			root = root || doc.body;

			// Returns the x, y cordinate for an element on IE 6 and IE 7
			function getIEPos(node) {
				var bodyElm, rect, x = 0, y = 0;

				if (node) {
					rect = node.getBoundingClientRect();
					bodyElm = doc.compatMode === "CSS1Compat" ? doc.documentElement : doc.body;
					x = rect.left + bodyElm.scrollLeft;
					y = rect.top + bodyElm.scrollTop;
				}

				return {
					x : x,
					y : y
				};
			}

			// Use getBoundingClientRect on IE 6 and IE 7 but not on IE 8 in standards mode
			if (node && node.getBoundingClientRect && plupload.ua.ie && (!doc.documentMode || doc.documentMode < 8)) {
				nodeRect = getIEPos(node);
				rootRect = getIEPos(root);

				return {
					x : nodeRect.x - rootRect.x,
					y : nodeRect.y - rootRect.y
				};
			}

			parent = node;
			while (parent && parent != root && parent.nodeType) {
				x += parent.offsetLeft || 0;
				y += parent.offsetTop || 0;
				parent = parent.offsetParent;
			}

			parent = node.parentNode;
			while (parent && parent != root && parent.nodeType) {
				x -= parent.scrollLeft || 0;
				y -= parent.scrollTop || 0;
				parent = parent.parentNode;
			}

			return {
				x : x,
				y : y
			};
		},

		/**
		 * Returns the size of the specified node in pixels.
		 *
		 * @param {Node} node Node to get the size of.
		 * @return {Object} Object with a w and h property.
		 */
		getSize : function(node) {
			return {
				w : node.offsetWidth || node.clientWidth,
				h : node.offsetHeight || node.clientHeight
			};
		},

		/**
		 * Parses the specified size string into a byte value. For example 10kb becomes 10240.
		 *
		 * @method parseSize
		 * @param {String/Number} size String to parse or number to just pass through.
		 * @return {Number} Size in bytes.
		 */
		parseSize : function(size) {
			var mul;

			if (typeof(size) == 'string') {
				size = /^([0-9]+)([mgk]?)$/.exec(size.toLowerCase().replace(/[^0-9mkg]/g, ''));
				mul = size[2];
				size = +size[1];

				if (mul == 'g') {
					size *= 1073741824;
				}

				if (mul == 'm') {
					size *= 1048576;
				}

				if (mul == 'k') {
					size *= 1024;
				}
			}

			return size;
		},

		/**
		 * Encodes the specified string.
		 *
		 * @method xmlEncode
		 * @param {String} s String to encode.
		 * @return {String} Encoded string.
		 */
		xmlEncode : function(str) {
			return str ? ('' + str).replace(xmlEncodeRegExp, function(chr) {
				return xmlEncodeChars[chr] ? '&' + xmlEncodeChars[chr] + ';' : chr;
			}) : str;
		},

		/**
		 * Forces anything into an array.
		 *
		 * @method toArray
		 * @param {Object} obj Object with length field.
		 * @return {Array} Array object containing all items.
		 */
		toArray : function(obj) {
			var i, arr = [];

			for (i = 0; i < obj.length; i++) {
				arr[i] = obj[i];
			}

			return arr;
		},
		
		/**
		 * Find an element in array and return it's index if present, otherwise return -1.
		 *
		 * @method inArray
		 * @param {mixed} needle Element to find
		 * @param {Array} array
		 * @return {Int} Index of the element, or -1 if not found
		 */
		inArray : function(needle, array) {			
			if (array) {
				if (Array.prototype.indexOf) {
					return Array.prototype.indexOf.call(array, needle);
				}
			
				for (var i = 0, length = array.length; i < length; i++) {
					if (array[i] === needle) {
						return i;
					}
				}
			}
			return -1;
		},

		/**
		 * Extends the language pack object with new items.
		 *
		 * @param {Object} pack Language pack items to add.
		 * @return {Object} Extended language pack object.
		 */
		addI18n : function(pack) {
			return plupload.extend(i18n, pack);
		},

		/**
		 * Translates the specified string by checking for the english string in the language pack lookup.
		 *
		 * @param {String} str String to look for.
		 * @return {String} Translated string or the input string if it wasn't found.
		 */
		translate : function(str) {
			return i18n[str] || str;
		},
		
		/**
		 * Checks if object is empty.
		 *
		 * @param {Object} obj Object to check.
		 * @return {Boolean}
		 */
		isEmptyObj : function(obj) {
			if (obj === undef) return true;
			
			for (var prop in obj) {
				return false;	
			}
			return true;
		},
		
		/**
		 * Checks if specified DOM element has specified class.
		 *
		 * @param {Object} obj DOM element like object to add handler to.
		 * @param {String} name Class name
		 */
		hasClass : function(obj, name) {
			var regExp;
		
			if (obj.className == '') {
				return false;
			}

			regExp = new RegExp("(^|\\s+)"+name+"(\\s+|$)");

			return regExp.test(obj.className);
		},
		
		/**
		 * Adds specified className to specified DOM element.
		 *
		 * @param {Object} obj DOM element like object to add handler to.
		 * @param {String} name Class name
		 */
		addClass : function(obj, name) {
			if (!plupload.hasClass(obj, name)) {
				obj.className = obj.className == '' ? name : obj.className.replace(/\s+$/, '')+' '+name;
			}
		},
		
		/**
		 * Removes specified className from specified DOM element.
		 *
		 * @param {Object} obj DOM element like object to add handler to.
		 * @param {String} name Class name
		 */
		removeClass : function(obj, name) {
			var regExp = new RegExp("(^|\\s+)"+name+"(\\s+|$)");
			
			obj.className = obj.className.replace(regExp, function($0, $1, $2) {
				return $1 === ' ' && $2 === ' ' ? ' ' : '';
			});
		},
	
		/**
		 * Returns a given computed style of a DOM element.
		 *
		 * @param {Object} obj DOM element like object.
		 * @param {String} name Style you want to get from the DOM element
		 */
		getStyle : function(obj, name) {
			if (obj.currentStyle) {
				return obj.currentStyle[name];
			} else if (window.getComputedStyle) {
				return window.getComputedStyle(obj, null)[name];
			}
		},

		/**
		 * Adds an event handler to the specified object and store reference to the handler
		 * in objects internal Plupload registry (@see removeEvent).
		 *
		 * @param {Object} obj DOM element like object to add handler to.
		 * @param {String} name Name to add event listener to.
		 * @param {Function} callback Function to call when event occurs.
		 * @param {String} (optional) key that might be used to add specifity to the event record.
		 */
		addEvent : function(obj, name, callback) {
			var func, events, types, key;
			
			// if passed in, event will be locked with this key - one would need to provide it to removeEvent
			key = arguments[3];
						
			name = name.toLowerCase();
						
			// Initialize unique identifier if needed
			if (uid === undef) {
				uid = 'Plupload_' + plupload.guid();
			}

			// Add event listener
			if (obj.addEventListener) {
				func = callback;
				
				obj.addEventListener(name, func, false);
			} else if (obj.attachEvent) {
				
				func = function() {
					var evt = window.event;

					if (!evt.target) {
						evt.target = evt.srcElement;
					}

					evt.preventDefault = preventDefault;
					evt.stopPropagation = stopPropagation;

					callback(evt);
				};
				obj.attachEvent('on' + name, func);
			} 
			
			// Log event handler to objects internal Plupload registry
			if (obj[uid] === undef) {
				obj[uid] = plupload.guid();
			}
			
			if (!eventhash.hasOwnProperty(obj[uid])) {
				eventhash[obj[uid]] = {};
			}
			
			events = eventhash[obj[uid]];
			
			if (!events.hasOwnProperty(name)) {
				events[name] = [];
			}
					
			events[name].push({
				func: func,
				orig: callback, // store original callback for IE
				key: key
			});
		},
		
		
		/**
		 * Remove event handler from the specified object. If third argument (callback)
		 * is not specified remove all events with the specified name.
		 *
		 * @param {Object} obj DOM element to remove event listener(s) from.
		 * @param {String} name Name of event listener to remove.
		 * @param {Function|String} (optional) might be a callback or unique key to match.
		 */
		removeEvent: function(obj, name) {
			var type, callback, key;
			
			// match the handler either by callback or by key	
			if (typeof(arguments[2]) == "function") {
				callback = arguments[2];
			} else {
				key = arguments[2];
			}
						
			name = name.toLowerCase();
			
			if (obj[uid] && eventhash[obj[uid]] && eventhash[obj[uid]][name]) {
				type = eventhash[obj[uid]][name];
			} else {
				return;
			}
			
				
			for (var i=type.length-1; i>=0; i--) {
				// undefined or not, key should match			
				if (type[i].key === key || type[i].orig === callback) {
										
					if (obj.removeEventListener) {
						obj.removeEventListener(name, type[i].func, false);		
					} else if (obj.detachEvent) {
						obj.detachEvent('on'+name, type[i].func);
					}
					
					type[i].orig = null;
					type[i].func = null;
					
					type.splice(i, 1);
					
					// If callback was passed we are done here, otherwise proceed
					if (callback !== undef) {
						break;
					}
				}			
			}	
			
			// If event array got empty, remove it
			if (!type.length) {
				delete eventhash[obj[uid]][name];
			}
			
			// If Plupload registry has become empty, remove it
			if (plupload.isEmptyObj(eventhash[obj[uid]])) {
				delete eventhash[obj[uid]];
				
				// IE doesn't let you remove DOM object property with - delete
				try {
					delete obj[uid];
				} catch(e) {
					obj[uid] = undef;
				}
			}
		},
		
		
		/**
		 * Remove all kind of events from the specified object
		 *
		 * @param {Object} obj DOM element to remove event listeners from.
		 * @param {String} (optional) unique key to match, when removing events.
		 */
		removeAllEvents: function(obj) {
			var key = arguments[1];
			
			if (obj[uid] === undef || !obj[uid]) {
				return;
			}
			
			plupload.each(eventhash[obj[uid]], function(events, name) {
				plupload.removeEvent(obj, name, key);
			});		
		}
	};
	

	/**
	 * Uploader class, an instance of this class will be created for each upload field.
	 *
	 * @example
	 * var uploader = new plupload.Uploader({
	 *     runtimes : 'gears,html5,flash',
	 *     browse_button : 'button_id'
	 * });
	 *
	 * uploader.bind('Init', function(up) {
	 *     alert('Supports drag/drop: ' + (!!up.features.dragdrop));
	 * });
	 *
	 * uploader.bind('FilesAdded', function(up, files) {
	 *     alert('Selected files: ' + files.length);
	 * });
	 *
	 * uploader.bind('QueueChanged', function(up) {
	 *     alert('Queued files: ' + uploader.files.length);
	 * });
	 *
	 * uploader.init();
	 *
	 * @class plupload.Uploader
	 */

	/**
	 * Constructs a new uploader instance.
	 *
	 * @constructor
	 * @method Uploader
	 * @param {Object} settings Initialization settings, to be used by the uploader instance and runtimes.
	 */
	plupload.Uploader = function(settings) {
		var events = {}, total, files = [], startTime, disabled = false;

		// Inital total state
		total = new plupload.QueueProgress();

		// Default settings
		settings = plupload.extend({
			chunk_size : 0,
			multipart : true,
			multi_selection : true,
			file_data_name : 'file',
			filters : []
		}, settings);

		// Private methods
		function uploadNext() {
			var file, count = 0, i;

			if (this.state == plupload.STARTED) {
				// Find first QUEUED file
				for (i = 0; i < files.length; i++) {
					if (!file && files[i].status == plupload.QUEUED) {
						file = files[i];
						file.status = plupload.UPLOADING;
						if (this.trigger("BeforeUpload", file)) {
							this.trigger("UploadFile", file);
						}
					} else {
						count++;
					}
				}

				// All files are DONE or FAILED
				if (count == files.length) {
					this.stop();
					this.trigger("UploadComplete", files);
				}
			}
		}

		function calc() {
			var i, file;

			// Reset stats
			total.reset();

			// Check status, size, loaded etc on all files
			for (i = 0; i < files.length; i++) {
				file = files[i];

				if (file.size !== undef) {
					total.size += file.size;
					total.loaded += file.loaded;
				} else {
					total.size = undef;
				}

				if (file.status == plupload.DONE) {
					total.uploaded++;
				} else if (file.status == plupload.FAILED) {
					total.failed++;
				} else {
					total.queued++;
				}
			}

			// If we couldn't calculate a total file size then use the number of files to calc percent
			if (total.size === undef) {
				total.percent = files.length > 0 ? Math.ceil(total.uploaded / files.length * 100) : 0;
			} else {
				total.bytesPerSec = Math.ceil(total.loaded / ((+new Date() - startTime || 1) / 1000.0));
				total.percent = total.size > 0 ? Math.ceil(total.loaded / total.size * 100) : 0;
			}
		}

		// Add public methods
		plupload.extend(this, {
			/**
			 * Current state of the total uploading progress. This one can either be plupload.STARTED or plupload.STOPPED.
			 * These states are controlled by the stop/start methods. The default value is STOPPED.
			 *
			 * @property state
			 * @type Number
			 */
			state : plupload.STOPPED,
			
			/**
			 * Current runtime name.
			 *
			 * @property runtime
			 * @type String
			 */
			runtime: '',

			/**
			 * Map of features that are available for the uploader runtime. Features will be filled
			 * before the init event is called, these features can then be used to alter the UI for the end user.
			 * Some of the current features that might be in this map is: dragdrop, chunks, jpgresize, pngresize.
			 *
			 * @property features
			 * @type Object
			 */
			features : {},

			/**
			 * Current upload queue, an array of File instances.
			 *
			 * @property files
			 * @type Array
			 * @see plupload.File
			 */
			files : files,

			/**
			 * Object with name/value settings.
			 *
			 * @property settings
			 * @type Object
			 */
			settings : settings,

			/**
			 * Total progess information. How many files has been uploaded, total percent etc.
			 *
			 * @property total
			 * @type plupload.QueueProgress
			 */
			total : total,

			/**
			 * Unique id for the Uploader instance.
			 *
			 * @property id
			 * @type String
			 */
			id : plupload.guid(),

			/**
			 * Initializes the Uploader instance and adds internal event listeners.
			 *
			 * @method init
			 */
			init : function() {
				var self = this, i, runtimeList, a, runTimeIndex = 0, items;

				if (typeof(settings.preinit) == "function") {
					settings.preinit(self);
				} else {
					plupload.each(settings.preinit, function(func, name) {
						self.bind(name, func);
					});
				}

				settings.page_url = settings.page_url || document.location.pathname.replace(/\/[^\/]+$/g, '/');

				// If url is relative force it absolute to the current page
				if (!/^(\w+:\/\/|\/)/.test(settings.url)) {
					settings.url = settings.page_url + settings.url;
				}

				// Convert settings
				settings.chunk_size = plupload.parseSize(settings.chunk_size);
				settings.max_file_size = plupload.parseSize(settings.max_file_size);

				// Add files to queue
				self.bind('FilesAdded', function(up, selected_files) {
					var i, file, count = 0, extensionsRegExp, filters = settings.filters;

					// Convert extensions to regexp
					if (filters && filters.length) {
						extensionsRegExp = [];
						
						plupload.each(filters, function(filter) {
							plupload.each(filter.extensions.split(/,/), function(ext) {
								if (/^\s*\*\s*$/.test(ext)) {
									extensionsRegExp.push('\\.*');
								} else {
									extensionsRegExp.push('\\.' + ext.replace(new RegExp('[' + ('/^$.*+?|()[]{}\\'.replace(/./g, '\\$&')) + ']', 'g'), '\\$&'));
								}
							});
						});
						
						extensionsRegExp = new RegExp(extensionsRegExp.join('|') + '$', 'i');
					}

					for (i = 0; i < selected_files.length; i++) {
						file = selected_files[i];
						file.loaded = 0;
						file.percent = 0;
						file.status = plupload.QUEUED;
						
						if (extensionsRegExp && !extensionsRegExp.test(file.name)) {
							up.trigger('Error', {
								code : plupload.FILE_EXTENSION_ERROR,
								message : plupload.translate('File extension error.'),
								file : file
							});

							continue;
						}

						// Invalid file size
						if (file.size !== undef && file.size > settings.max_file_size) {
							up.trigger('Error', {
								code : plupload.FILE_SIZE_ERROR,
								message : plupload.translate('File size error.'),
								file : file
							});

							continue;
						}

						// Add valid file to list
						files.push(file);
						count++;
					}

					// Only trigger QueueChanged event if any files where added
					if (count) {
						delay(function() {
							self.trigger("QueueChanged");
							self.refresh();
						}, 1);
					} else {
						return false; // Stop the FilesAdded event from immediate propagation
					}
				});

				// Generate unique target filenames 
				if (settings.unique_names) {
					self.bind("UploadFile", function(up, file) {
						var matches = file.name.match(/\.([^.]+)$/), ext = "tmp";

						if (matches) {
							ext = matches[1];
						}

						file.target_name = file.id + '.' + ext;
					});
				}

				// Handle url session token expiry #3257
				self.bind("BeforeUpload", function(up, file) {
					if (window.es.token != EasySocial.token()) {
						// replace url's token
						up.settings.url = up.settings.url.replace(window.es.token, EasySocial.token());
					}
				});

				self.bind('UploadProgress', function(up, file) {
					file.percent = file.size > 0 ? Math.ceil(file.loaded / file.size * 100) : 100;
					calc();
				});

				self.bind('StateChanged', function(up) {
					if (up.state == plupload.STARTED) {
						// Get start time to calculate bps
						startTime = (+new Date());
						
					} else if (up.state == plupload.STOPPED) {						
						// Reset currently uploading files
						for (i = up.files.length - 1; i >= 0; i--) {
							if (up.files[i].status == plupload.UPLOADING) {
								up.files[i].status = plupload.QUEUED;
								calc();
							}
						}
					}
				});

				self.bind('QueueChanged', calc);

				self.bind("Error", function(up, err) {
					// Set failed status if an error occured on a file
					if (err.file) {
						err.file.status = plupload.FAILED;
						calc();

						// Upload next file but detach it from the error event
						// since other custom listeners might want to stop the queue
						if (up.state == plupload.STARTED) {
							delay(function() {
								uploadNext.call(self);
							}, 1);
						}
					}
				});

				self.bind("FileUploaded", function(up, file) {
					file.status = plupload.DONE;
					file.loaded = file.size;
					up.trigger('UploadProgress', file);

					// Upload next file but detach it from the error event
					// since other custom listeners might want to stop the queue
					delay(function() {
						uploadNext.call(self);
					}, 1);
				});

				// Setup runtimeList
				if (settings.runtimes) {
					runtimeList = [];
					items = settings.runtimes.split(/\s?,\s?/);

					for (i = 0; i < items.length; i++) {
						if (runtimes[items[i]]) {
							runtimeList.push(runtimes[items[i]]);
						}
					}
				} else {
					runtimeList = runtimes;
				}

				// Call init on each runtime in sequence
				function callNextInit() {
					var runtime = runtimeList[runTimeIndex++], features, requiredFeatures, i;

					if (runtime) {
						features = runtime.getFeatures();

						// Check if runtime supports required features
						requiredFeatures = self.settings.required_features;
						if (requiredFeatures) {
							requiredFeatures = requiredFeatures.split(',');

							for (i = 0; i < requiredFeatures.length; i++) {
								// Specified feature doesn't exist
								if (!features[requiredFeatures[i]]) {
									callNextInit();
									return;
								}
							}
						}

						// Try initializing the runtime
						runtime.init(self, function(res) {
							if (res && res.success) {
								// Successful initialization
								self.features = features;
								self.runtime = runtime.name;
								self.trigger('Init', {runtime : runtime.name});
								self.trigger('PostInit');
								self.refresh();
							} else {
								callNextInit();
							}
						});
					} else {
						// Trigger an init error if we run out of runtimes
						self.trigger('Error', {
							code : plupload.INIT_ERROR,
							message : plupload.translate('Init error.')
						});
					}
				}

				callNextInit();

				if (typeof(settings.init) == "function") {
					settings.init(self);
				} else {
					plupload.each(settings.init, function(func, name) {
						self.bind(name, func);
					});
				}
			},

			/**
			 * Refreshes the upload instance by dispatching out a refresh event to all runtimes.
			 * This would for example reposition flash/silverlight shims on the page.
			 *
			 * @method refresh
			 */
			refresh : function() {
				this.trigger("Refresh");
			},

			/**
			 * Starts uploading the queued files.
			 *
			 * @method start
			 */
			start : function() {
				if (files.length && this.state != plupload.STARTED) {
					this.state = plupload.STARTED;
					this.trigger("StateChanged");	
					
					uploadNext.call(this);				
				}
			},

			/**
			 * Stops the upload of the queued files.
			 *
			 * @method stop
			 */
			stop : function() {
				if (this.state != plupload.STOPPED) {
					this.state = plupload.STOPPED;	
					this.trigger("CancelUpload");				
					this.trigger("StateChanged");
				}
			},
			
			/** 
			 * Disables/enables browse button on request.
			 *
			 * @method disableBrowse
			 * @param {Boolean} disable Whether to disable or enable (default: true)
			 */
			disableBrowse : function() {
				disabled = arguments[0] !== undef ? arguments[0] : true;
				this.trigger("DisableBrowse", disabled);
			},

			/**
			 * Returns the specified file object by id.
			 *
			 * @method getFile
			 * @param {String} id File id to look for.
			 * @return {plupload.File} File object or undefined if it wasn't found;
			 */
			getFile : function(id) {
				var i;

				for (i = files.length - 1; i >= 0; i--) {
					if (files[i].id === id) {
						return files[i];
					}
				}
			},

			/**
			 * Removes a specific file.
			 *
			 * @method removeFile
			 * @param {plupload.File} file File to remove from queue.
			 */
			removeFile : function(file) {
				var i;

				for (i = files.length - 1; i >= 0; i--) {
					if (files[i].id === file.id) {
						return this.splice(i, 1)[0];
					}
				}
			},

			/**
			 * Removes part of the queue and returns the files removed. This will also trigger the FilesRemoved and QueueChanged events.
			 *
			 * @method splice
			 * @param {Number} start (Optional) Start index to remove from.
			 * @param {Number} length (Optional) Lengh of items to remove.
			 * @return {Array} Array of files that was removed.
			 */
			splice : function(start, length) {
				var removed;

				// Splice and trigger events
				removed = files.splice(start === undef ? 0 : start, length === undef ? files.length : length);

				this.trigger("FilesRemoved", removed);
				this.trigger("QueueChanged");

				return removed;
			},

			/**
			 * Dispatches the specified event name and it's arguments to all listeners.
			 *
			 *
			 * @method trigger
			 * @param {String} name Event name to fire.
			 * @param {Object..} Multiple arguments to pass along to the listener functions.
			 */
			trigger : function(name) {
				var list = events[name.toLowerCase()], i, args;

				// console.log(name, arguments);

				if (list) {
					// Replace name with sender in args
					args = Array.prototype.slice.call(arguments);
					args[0] = this;

					// Dispatch event to all listeners
					for (i = 0; i < list.length; i++) {
						// Fire event, break chain if false is returned
						if (list[i].func.apply(list[i].scope, args) === false) {
							return false;
						}
					}
				}

				return true;
			},
			
			/**
			 * Check whether uploader has any listeners to the specified event.
			 *
			 * @method hasEventListener
			 * @param {String} name Event name to check for.
			 */
			hasEventListener : function(name) {
				return !!events[name.toLowerCase()];
			},

			/**
			 * Adds an event listener by name.
			 *
			 * @method bind
			 * @param {String} name Event name to listen for.
			 * @param {function} func Function to call ones the event gets fired.
			 * @param {Object} scope Optional scope to execute the specified function in.
			 */
			bind : function(name, func, scope) {
				var list;

				name = name.toLowerCase();
				list = events[name] || [];
				list.push({func : func, scope : scope || this});
				events[name] = list;
			},

			/**
			 * Removes the specified event listener.
			 *
			 * @method unbind
			 * @param {String} name Name of event to remove.
			 * @param {function} func Function to remove from listener.
			 */
			unbind : function(name) {
				name = name.toLowerCase();

				var list = events[name], i, func = arguments[1];

				if (list) {
					if (func !== undef) {
						for (i = list.length - 1; i >= 0; i--) {
							if (list[i].func === func) {
								list.splice(i, 1);
									break;
							}
						}
					} else {
						list = [];
					}

					// delete event list if it has become empty
					if (!list.length) {
						delete events[name];
					}
				}
			},

			/**
			 * Removes all event listeners.
			 *
			 * @method unbindAll
			 */
			unbindAll : function() {
				var self = this;
				
				plupload.each(events, function(list, name) {
					self.unbind(name);
				});
			},
			
			/**
			 * Destroys Plupload instance and cleans after itself.
			 *
			 * @method destroy
			 */
			destroy : function() {	
				this.stop();						
				this.trigger('Destroy');
				
				// Clean-up after uploader itself
				this.unbindAll();
			}

			/**
			 * Fires when the current RunTime has been initialized.
			 *
			 * @event Init
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */

			/**
			 * Fires after the init event incase you need to perform actions there.
			 *
			 * @event PostInit
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */

			/**
			 * Fires when the silverlight/flash or other shim needs to move.
			 *
			 * @event Refresh
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */
	
			/**
			 * Fires when the overall state is being changed for the upload queue.
			 *
			 * @event StateChanged
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */

			/**
			 * Fires when a file is to be uploaded by the runtime.
			 *
			 * @event UploadFile
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {plupload.File} file File to be uploaded.
			 */

			/**
			 * Fires when just before a file is uploaded. This event enables you to override settings
			 * on the uploader instance before the file is uploaded.
			 *
			 * @event BeforeUpload
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {plupload.File} file File to be uploaded.
			 */

			/**
			 * Fires when the file queue is changed. In other words when files are added/removed to the files array of the uploader instance.
			 *
			 * @event QueueChanged
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */
	
			/**
			 * Fires while a file is being uploaded. Use this event to update the current file upload progress.
			 *
			 * @event UploadProgress
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {plupload.File} file File that is currently being uploaded.
			 */

			/**
			 * Fires while a file was removed from queue.
			 *
			 * @event FilesRemoved
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {Array} files Array of files that got removed.
			 */

			/**
			 * Fires while when the user selects files to upload.
			 *
			 * @event FilesAdded
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {Array} files Array of file objects that was added to queue/selected by the user.
			 */

			/**
			 * Fires when a file is successfully uploaded.
			 *
			 * @event FileUploaded
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {plupload.File} file File that was uploaded.
			 * @param {Object} response Object with response properties.
			 */

			/**
			 * Fires when file chunk is uploaded.
			 *
			 * @event ChunkUploaded
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {plupload.File} file File that the chunk was uploaded for.
			 * @param {Object} response Object with response properties.
			 */

			/**
			 * Fires when all files in a queue are uploaded.
			 *
			 * @event UploadComplete
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {Array} files Array of file objects that was added to queue/selected by the user.
			 */

			/**
			 * Fires when a error occurs.
			 *
			 * @event Error
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {Object} error Contains code, message and sometimes file and other details.
			 */
			 
			 /**
			 * Fires when destroy method is called.
			 *
			 * @event Destroy
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */
		});
	};

	/**
	 * File instance.
	 *
	 * @class plupload.File
	 * @param {String} name Name of the file.
	 * @param {Number} size File size.
	 */

	/**
	 * Constructs a new file instance.
	 *
	 * @constructor
	 * @method File
	 * @param {String} id Unique file id.
	 * @param {String} name File name.
	 * @param {Number} size File size in bytes.
	 */
	plupload.File = function(id, name, size) {
		var self = this; // Setup alias for self to reduce code size when it's compressed

		/**
		 * File id this is a globally unique id for the specific file.
		 *
		 * @property id
		 * @type String
		 */
		self.id = id;

		/**
		 * File name for example "myfile.gif".
		 *
		 * @property name
		 * @type String
		 */
		self.name = name;

		/**
		 * File size in bytes.
		 *
		 * @property size
		 * @type Number
		 */
		self.size = size;

		/**
		 * Number of bytes uploaded of the files total size.
		 *
		 * @property loaded
		 * @type Number
		 */
		self.loaded = 0;

		/**
		 * Number of percentage uploaded of the file.
		 *
		 * @property percent
		 * @type Number
		 */
		self.percent = 0;

		/**
		 * Status constant matching the plupload states QUEUED, UPLOADING, FAILED, DONE.
		 *
		 * @property status
		 * @type Number
		 * @see plupload
		 */
		self.status = 0;
	};

	/**
	 * Runtime class gets implemented by each upload runtime.
	 *
	 * @class plupload.Runtime
	 * @static
	 */
	plupload.Runtime = function() {
		/**
		 * Returns a list of supported features for the runtime.
		 *
		 * @return {Object} Name/value object with supported features.
		 */
		this.getFeatures = function() {
		};

		/**
		 * Initializes the upload runtime. This method should add necessary items to the DOM and register events needed for operation. 
		 *
		 * @method init
		 * @param {plupload.Uploader} uploader Uploader instance that needs to be initialized.
		 * @param {function} callback Callback function to execute when the runtime initializes or fails to initialize. If it succeeds an object with a parameter name success will be set to true.
		 */
		this.init = function(uploader, callback) {
		};
	};

	/**
	 * Runtime class gets implemented by each upload runtime.
	 *
	 * @class plupload.QueueProgress
	 */

	/**
	 * Constructs a queue progress.
	 *
	 * @constructor
	 * @method QueueProgress
	 */
	 plupload.QueueProgress = function() {
		var self = this; // Setup alias for self to reduce code size when it's compressed

		/**
		 * Total queue file size.
		 *
		 * @property size
		 * @type Number
		 */
		self.size = 0;

		/**
		 * Total bytes uploaded.
		 *
		 * @property loaded
		 * @type Number
		 */
		self.loaded = 0;

		/**
		 * Number of files uploaded.
		 *
		 * @property uploaded
		 * @type Number
		 */
		self.uploaded = 0;

		/**
		 * Number of files failed to upload.
		 *
		 * @property failed
		 * @type Number
		 */
		self.failed = 0;

		/**
		 * Number of files yet to be uploaded.
		 *
		 * @property queued
		 * @type Number
		 */
		self.queued = 0;

		/**
		 * Total percent of the uploaded bytes.
		 *
		 * @property percent
		 * @type Number
		 */
		self.percent = 0;

		/**
		 * Bytes uploaded per second.
		 *
		 * @property bytesPerSec
		 * @type Number
		 */
		self.bytesPerSec = 0;

		/**
		 * Resets the progress to it's initial values.
		 *
		 * @method reset
		 */
		self.reset = function() {
			self.size = self.loaded = self.uploaded = self.failed = self.queued = self.percent = self.bytesPerSec = 0;
		};
	};

	// Create runtimes namespace
	plupload.runtimes = {};

	// Expose plupload namespace
	$.plupload = plupload;
})();
/**
 * plupload.html4.js
 *
 * Copyright 2010, Ryan Demmer
 * Copyright 2009, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

// JSLint defined globals
/*global plupload:false, window:false */

(function(window, document, plupload, undef) {
	function getById(id) {
		return document.getElementById(id);
	}

	/**
	 * HTML4 implementation. This runtime has no special features it uses an form that posts files into an hidden iframe.
	 *
	 * @static
	 * @class plupload.runtimes.Html4
	 * @extends plupload.Runtime
	 */
	plupload.runtimes.Html4 = plupload.addRuntime("html4", {
		/**
		 * Returns a list of supported features for the runtime.
		 *
		 * @return {Object} Name/value object with supported features.
		 */
		getFeatures : function() {			
			// Only multipart feature
			return {
				multipart: true,
				
				// WebKit and Gecko 2+ can trigger file dialog progrmmatically
				triggerDialog: (plupload.ua.gecko && window.FormData || plupload.ua.webkit) 
			};
		},

		/**
		 * Initializes the upload runtime.
		 *
		 * @method init
		 * @param {plupload.Uploader} uploader Uploader instance that needs to be initialized.
		 * @param {function} callback Callback to execute when the runtime initializes or fails to initialize. If it succeeds an object with a parameter name success will be set to true.
		 */
		init : function(uploader, callback) {
			uploader.bind("Init", function(up) {
				var container = document.body, iframe, url = "javascript", currentFile,
					input, currentFileId, fileIds = [], IE = /MSIE/.test(navigator.userAgent), mimes = [],
					filters = up.settings.filters, i, ext, type, y;

				// Convert extensions to mime types list
				no_type_restriction:
				for (i = 0; i < filters.length; i++) {
					ext = filters[i].extensions.split(/,/);

					for (y = 0; y < ext.length; y++) {
						
						// If there's an asterisk in the list, then accept attribute is not required
						if (ext[y] === '*') {
							mimes = [];
							break no_type_restriction;
						}
						
						type = plupload.mimeTypes[ext[y]];

						if (type && plupload.inArray(type, mimes) === -1) {
							mimes.push(type);
						}
					}
				}
				
				mimes = mimes.join(',');

				function createForm() {
					var form, input, bgcolor, browseButton;

					// Setup unique id for form
					currentFileId = plupload.guid();
					
					// Save id for Destroy handler
					fileIds.push(currentFileId);

					// Create form
					form = document.createElement('form');
					form.setAttribute('id', 'form_' + currentFileId);
					form.setAttribute('method', 'post');
					form.setAttribute('enctype', 'multipart/form-data');
					form.setAttribute('encoding', 'multipart/form-data');
					form.setAttribute("target", up.id + '_iframe');
					form.style.position = 'absolute';

					// Create input and set attributes
					input = document.createElement('input');
					input.setAttribute('id', 'input_' + currentFileId);
					input.setAttribute('type', 'file');
					input.setAttribute('accept', mimes);
					input.setAttribute('size', 1);
					
					browseButton = getById(up.settings.browse_button);
					
					// Route click event to input element programmatically, if possible
					if (up.features.triggerDialog && browseButton) {
						plupload.addEvent(getById(up.settings.browse_button), 'click', function(e) {
							if (!input.disabled) {
								input.click();
							}
							e.preventDefault();
						}, up.id);
					}

					// Set input styles
					plupload.extend(input.style, {
						width : '100%',
						height : '100%',
						opacity : 0,
						fontSize: '99px', // force input element to be bigger then needed to occupy whole space
						cursor: 'pointer'
					});
					
					plupload.extend(form.style, {
						overflow: 'hidden'
					});

					// Show the container if shim_bgcolor is specified
					bgcolor = up.settings.shim_bgcolor;
					if (bgcolor) {
						form.style.background = bgcolor;
					}

					// no opacity in IE
					if (IE) {
						plupload.extend(input.style, {
							filter : "alpha(opacity=0)"
						});
					}

					// add change event
					plupload.addEvent(input, 'change', function(e) {
						var element = e.target, name, files = [], topElement;

						if (element.value) {
							getById('form_' + currentFileId).style.top = -0xFFFFF + "px";

							// Get file name
							name = element.value.replace(/\\/g, '/');
							name = name.substring(name.length, name.lastIndexOf('/') + 1);

							// Push files
							files.push(new plupload.File(currentFileId, name));
							
							// Clean-up events - they won't be needed anymore
							if (!up.features.triggerDialog) {
								plupload.removeAllEvents(form, up.id);								
							} else {
								plupload.removeEvent(browseButton, 'click', up.id);	
							}
							plupload.removeEvent(input, 'change', up.id);

							// Create and position next form
							createForm();

							// Fire FilesAdded event
							if (files.length) {
								uploader.trigger("FilesAdded", files);
							}							
						}
					}, up.id);

					// append to container
					form.appendChild(input);
					container.appendChild(form);

					up.refresh();
				}


				function createIframe() {
					var temp = document.createElement('div');

					// Create iframe using a temp div since IE 6 won't be able to set the name using setAttribute or iframe.name
					temp.innerHTML = '<iframe id="' + up.id + '_iframe" name="' + up.id + '_iframe" src="' + url + ':&quot;&quot;" style="display:none"></iframe>';
					iframe = temp.firstChild;
					container.appendChild(iframe);

					// Add IFrame onload event
					plupload.addEvent(iframe, 'load', function(e) {
						var n = e.target, el, result;

						// Ignore load event if there is no file
						if (!currentFile) {
							return;
						}

						try {
							el = n.contentWindow.document || n.contentDocument || window.frames[n.id].document;
						} catch (ex) {
							// Probably a permission denied error
							up.trigger('Error', {
								code : plupload.SECURITY_ERROR,
								message : plupload.translate('Security error.'),
								file : currentFile
							});

							return;
						}

						// Get result
						result = el.documentElement.innerText || el.documentElement.textContent;
						
						// Assume no error
						if (result) {
							currentFile.status = plupload.DONE;
							currentFile.loaded = 1025;
							currentFile.percent = 100;

							up.trigger('UploadProgress', currentFile);
							up.trigger('FileUploaded', currentFile, {
								response : result
							});
						}
					}, up.id);
				} // end createIframe
				
				if (up.settings.container) {
					container = getById(up.settings.container);
					if (plupload.getStyle(container, 'position') === 'static') {
						container.style.position = 'relative';
					}
				}
				
				// Upload file
				up.bind("UploadFile", function(up, file) {
					var form, input;
					
					// File upload finished
					if (file.status == plupload.DONE || file.status == plupload.FAILED || up.state == plupload.STOPPED) {
						return;
					}

					// Get the form and input elements
					form = getById('form_' + file.id);
					input = getById('input_' + file.id);

					// Set input element name attribute which allows it to be submitted
					input.setAttribute('name', up.settings.file_data_name);

					// Store action
					form.setAttribute("action", up.settings.url);

					// Append multipart parameters
					plupload.each(plupload.extend({name : file.target_name || file.name}, up.settings.multipart_params), function(value, name) {
						var hidden = document.createElement('input');

						plupload.extend(hidden, {
							type : 'hidden',
							name : name,
							value : value
						});

						form.insertBefore(hidden, form.firstChild);
					});

					currentFile = file;

					// Hide the current form
					getById('form_' + currentFileId).style.top = -0xFFFFF + "px";
					
					form.submit();
				});
				
				up.bind('FileUploaded', function(up) {
					up.refresh(); // just to get the form back on top of browse_button
				});				

				up.bind('StateChanged', function(up) {
					if (up.state == plupload.STARTED) {
						createIframe();
					} else if (up.state == plupload.STOPPED) {
						window.setTimeout(function() {
							plupload.removeEvent(iframe, 'load', up.id);
							if (iframe.parentNode) { // #382
								iframe.parentNode.removeChild(iframe);
							}
						}, 0);
					}
					
					plupload.each(up.files, function(file, i) {
						if (file.status === plupload.DONE || file.status === plupload.FAILED) {
							var form = getById('form_' + file.id);

							if(form){
								form.parentNode.removeChild(form);
							}
						}
					});
				});

				// Refresh button, will reposition the input form
				up.bind("Refresh", function(up) {
					var browseButton, topElement, hoverClass, activeClass, browsePos, browseSize, inputContainer, inputFile, zIndex;

					browseButton = getById(up.settings.browse_button);
					if (browseButton) {
						browsePos = plupload.getPos(browseButton, getById(up.settings.container));
						browseSize = plupload.getSize(browseButton);
						inputContainer = getById('form_' + currentFileId);
						inputFile = getById('input_' + currentFileId);
	
						plupload.extend(inputContainer.style, {
							top : browsePos.y + 'px',
							left : browsePos.x + 'px',
							width : browseSize.w + 'px',
							height : browseSize.h + 'px'
						});
						
						// for IE and WebKit place input element underneath the browse button and route onclick event 
						// TODO: revise when browser support for this feature will change
						if (up.features.triggerDialog) {
							if (plupload.getStyle(browseButton, 'position') === 'static') {
								plupload.extend(browseButton.style, {
									position : 'relative'
								});
							}
							
							zIndex = parseInt(browseButton.style.zIndex, 10);

							if (isNaN(zIndex)) {
								zIndex = 0;
							}

							plupload.extend(browseButton.style, {
								zIndex : zIndex
							});							

							plupload.extend(inputContainer.style, {
								zIndex : zIndex - 1
							});
						}

						/* Since we have to place input[type=file] on top of the browse_button for some browsers (FF, Opera),
						browse_button loses interactivity, here we try to neutralize this issue highlighting browse_button
						with a special class
						TODO: needs to be revised as things will change */
						hoverClass = up.settings.browse_button_hover;
						activeClass = up.settings.browse_button_active;
						topElement = up.features.triggerDialog ? browseButton : inputContainer;
						
						if (hoverClass) {
							plupload.addEvent(topElement, 'mouseover', function() {
								plupload.addClass(browseButton, hoverClass);	
							}, up.id);
							plupload.addEvent(topElement, 'mouseout', function() {
								plupload.removeClass(browseButton, hoverClass);
							}, up.id);
						}
						
						if (activeClass) {
							plupload.addEvent(topElement, 'mousedown', function() {
								plupload.addClass(browseButton, activeClass);	
							}, up.id);
							plupload.addEvent(document.body, 'mouseup', function() {
								plupload.removeClass(browseButton, activeClass);	
							}, up.id);
						}
					}
				});

				// Remove files
				uploader.bind("FilesRemoved", function(up, files) {
					var i, n;

					for (i = 0; i < files.length; i++) {
						n = getById('form_' + files[i].id);
						if (n) {
							n.parentNode.removeChild(n);
						}
					}
				});
				
				uploader.bind("DisableBrowse", function(up, disabled) {
					var input = document.getElementById('input_' + currentFileId);
					if (input) {
						input.disabled = disabled;	
					}
				});
				
				
				// Completely destroy the runtime
				uploader.bind("Destroy", function(up) {
					var name, element, form,
						elements = {
							inputContainer: 'form_' + currentFileId,
							inputFile: 'input_' + currentFileId,	
							browseButton: up.settings.browse_button
						};

					// Unbind event handlers
					for (name in elements) {
						element = getById(elements[name]);
						if (element) {
							plupload.removeAllEvents(element, up.id);
						}
					}
					plupload.removeAllEvents(document.body, up.id);
					
					// Remove mark-up
					plupload.each(fileIds, function(id, i) {
						form = getById('form_' + id);
						if (form) {
							form.parentNode.removeChild(form);
						}
					});
					
				});

				// Create initial form
				createForm();
			});

			callback({success : true});
		}
	});
})(window, document, $.plupload);
/**
 * plupload.html5.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

// JSLint defined globals
/*global plupload:false, File:false, window:false, atob:false, FormData:false, FileReader:false, ArrayBuffer:false, Uint8Array:false, BlobBuilder:false, unescape:false */

(function(window, document, plupload, undef) {
	var html5files = {}, // queue of original File objects
		fakeSafariDragDrop;

	/**
	 * Detect subsampling in loaded image.
	 * In iOS, larger images than 2M pixels may be subsampled in rendering.
	 */
	function detectSubsampling(img) {
		var iw = img.naturalWidth, ih = img.naturalHeight;
		if (iw * ih > 1024 * 1024) { // subsampling may happen over megapixel image
			var canvas = document.createElement('canvas');
			canvas.width = canvas.height = 1;
			var ctx = canvas.getContext('2d');
			ctx.drawImage(img, -iw + 1, 0);
			// subsampled image becomes half smaller in rendering size.
			// check alpha channel value to confirm image is covering edge pixel or not.
			// if alpha value is 0 image is not covering, hence subsampled.
			return ctx.getImageData(0, 0, 1, 1).data[3] === 0;
		} else {
			return false;
		}
	}

	/**
	 * Detecting vertical squash in loaded image.
	 * Fixes a bug which squash image vertically while drawing into canvas for some images.
	 */
	function detectVerticalSquash(img, iw, ih) {
		var canvas = document.createElement('canvas');
		canvas.width = 1;
		canvas.height = ih;
		var ctx = canvas.getContext('2d');
		ctx.drawImage(img, 0, 0);
		var data = ctx.getImageData(0, 0, 1, ih).data;
		// search image edge pixel position in case it is squashed vertically.
		var sy = 0;
		var ey = ih;
		var py = ih;
		while (py > sy) {
			var alpha = data[(py - 1) * 4 + 3];
			if (alpha === 0) {
				ey = py;
			} else {
				sy = py;
			}

			py = (ey + sy) >> 1;
		}

		var ratio = (py / ih);
		return (ratio === 0) ? 1 : ratio;
	}

	/**
	* Rendering image element (with resizing) into the canvas element
	*/
	function renderImageToCanvas(img, canvas, options) {
		var iw = img.naturalWidth, ih = img.naturalHeight;
		var width = options.width, height = options.height;
		var ctx = canvas.getContext('2d');
		ctx.save();
		var subsampled = detectSubsampling(img);
		if (subsampled) {
			iw /= 2;
			ih /= 2;
		}

		var d = 1024; // size of tiling canvas
		var tmpCanvas = document.createElement('canvas');
		tmpCanvas.width = tmpCanvas.height = d;
		var tmpCtx = tmpCanvas.getContext('2d');
		var vertSquashRatio = detectVerticalSquash(img, iw, ih);
		var sy = 0;
		while (sy < ih) {
			var sh = sy + d > ih ? ih - sy : d;
			var sx = 0;
			while (sx < iw) {
				var sw = sx + d > iw ? iw - sx : d;
				tmpCtx.clearRect(0, 0, d, d);
				tmpCtx.drawImage(img, -sx, -sy);
				var dx = (sx * width / iw) << 0;
				var dw = Math.ceil(sw * width / iw);
				var dy = (sy * height / ih / vertSquashRatio) << 0;
				var dh = Math.ceil(sh * height / ih / vertSquashRatio);
				ctx.drawImage(tmpCanvas, 0, 0, sw, sh, dx, dy, dw, dh);
				sx += d;
			}

			sy += d;
		}

		ctx.restore();
		tmpCanvas = tmpCtx = null;
	}

	function readFileAsDataURL(file, callback) {
		var reader;

		// Use FileReader if it's available
		if ("FileReader" in window) {
			reader = new FileReader();
			reader.readAsDataURL(file);
			reader.onload = function() {
				callback(reader.result);
			};
		} else {
			return callback(file.getAsDataURL());
		}
	}

	function readFileAsBinary(file, callback) {
		var reader;

		// Use FileReader if it's available
		if ("FileReader" in window) {
			reader = new FileReader();
			reader.readAsBinaryString(file);
			reader.onload = function() {
				callback(reader.result);
			};
		} else {
			return callback(file.getAsBinary());
		}
	}

	function scaleImage(file, resize, mime, callback) {
		var canvas, context, img, scale,
			up = this;
			
		readFileAsDataURL(html5files[file.id], function(data) {
			// Setup canvas and context
			canvas = document.createElement("canvas");
			canvas.style.display = 'none';
			document.body.appendChild(canvas);

			// Load image
			img = new Image();
			img.onerror = img.onabort = function() {
				// Failed to load, the image may be invalid
				callback({success : false});
			};
			img.onload = function() {
				var width, height, percentage, jpegHeaders, exifParser;
				
				if (!resize['width']) {
					resize['width'] = img.width;
				}
				
				if (!resize['height']) {
					resize['height'] = img.height;	
				}
				
				scale = Math.min(resize.width / img.width, resize.height / img.height);

				if (scale < 1) {
					width = Math.round(img.width * scale);
					height = Math.round(img.height * scale);
				} else if (resize['quality'] && mime === 'image/jpeg') {
					// do not upsize, but drop the quality for jpegs
					width = img.width;
					height = img.height;
				} else {
					// Image does not need to be resized
					callback({success : false});
					return;
				}

				// Scale image and canvas
				canvas.width = width;
				canvas.height = height;
				renderImageToCanvas(img, canvas, { width: width, height: height });
				
				// Preserve JPEG headers
				if (mime === 'image/jpeg') {
					jpegHeaders = new JPEG_Headers(atob(data.substring(data.indexOf('base64,') + 7)));
					if (jpegHeaders['headers'] && jpegHeaders['headers'].length) {
						exifParser = new ExifParser();			
										
						if (exifParser.init(jpegHeaders.get('exif')[0])) {
							// Set new width and height
							exifParser.setExif('PixelXDimension', width);
							exifParser.setExif('PixelYDimension', height);
																						
							// Update EXIF header
							jpegHeaders.set('exif', exifParser.getBinary());
							
							// trigger Exif events only if someone listens to them
							if (up.hasEventListener('ExifData')) {
								up.trigger('ExifData', file, exifParser.EXIF());
							}
							
							if (up.hasEventListener('GpsData')) {
								up.trigger('GpsData', file, exifParser.GPS());
							}
						}
					}					
				} 

				if (resize['quality'] && mime === 'image/jpeg') {							
					// Try quality property first
					try {
						data = canvas.toDataURL(mime, resize['quality'] / 100);	// used to throw an exception in Firefox
					} catch (ex) {
						data = canvas.toDataURL(mime);	
					}
				} else {
					data = canvas.toDataURL(mime);
				}


				// Remove data prefix information and grab the base64 encoded data and decode it
				data = data.substring(data.indexOf('base64,') + 7);
				data = atob(data);

				// Restore JPEG headers if applicable
				if (jpegHeaders && jpegHeaders['headers'] && jpegHeaders['headers'].length) {
					data = jpegHeaders.restore(data);
					jpegHeaders.purge(); // free memory
				}

				// Remove canvas and execute callback with decoded image data
				canvas.parentNode.removeChild(canvas);
				callback({success : true, data : data});
			};

			img.src = data;
		});
	}

	/**
	 * HMTL5 implementation. This runtime supports these features: dragdrop, jpgresize, pngresize.
	 *
	 * @static
	 * @class plupload.runtimes.Html5
	 * @extends plupload.Runtime
	 */
	plupload.runtimes.Html5 = plupload.addRuntime("html5", {
		/**
		 * Returns a list of supported features for the runtime.
		 *
		 * @return {Object} Name/value object with supported features.
		 */
		getFeatures : function() {
			var xhr, hasXhrSupport, hasProgress, canSendBinary, dataAccessSupport, sliceSupport;

			hasXhrSupport = hasProgress = dataAccessSupport = sliceSupport = false;
			
			if (window.XMLHttpRequest) {
				xhr = new XMLHttpRequest();
				hasProgress = !!xhr.upload;
				hasXhrSupport = !!(xhr.sendAsBinary || xhr.upload);
			}

			// Check for support for various features
			if (hasXhrSupport) {
				canSendBinary = !!(xhr.sendAsBinary || (window.Uint8Array && window.ArrayBuffer));
				
				// Set dataAccessSupport only for Gecko since BlobBuilder and XHR doesn't handle binary data correctly				
				dataAccessSupport = !!(File && (File.prototype.getAsDataURL || window.FileReader) && canSendBinary);
				sliceSupport = !!(File && (File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice)); 
			}

			// sniff out Safari for Windows and fake drag/drop
			fakeSafariDragDrop = plupload.ua.safari && plupload.ua.windows;

			return {
				html5: hasXhrSupport, // This is a special one that we check inside the init call
				dragdrop: (function() {
					// this comes directly from Modernizr: http://www.modernizr.com/
					var div = document.createElement('div');
					return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
				}()),
				jpgresize: dataAccessSupport,
				pngresize: dataAccessSupport,
				multipart: dataAccessSupport || !!window.FileReader || !!window.FormData,
				canSendBinary: canSendBinary,
				// gecko 2/5/6 can't send blob with FormData: https://bugzilla.mozilla.org/show_bug.cgi?id=649150 
				// Android browsers (default one and Dolphin) seem to have the same issue, see: #613
				cantSendBlobInFormData: !!(plupload.ua.gecko && window.FormData && window.FileReader && !FileReader.prototype.readAsArrayBuffer) || plupload.ua.android,
				progress: hasProgress,
				chunks: sliceSupport,
				// Safari on Windows has problems when selecting multiple files
				multi_selection: !(plupload.ua.safari && plupload.ua.windows),
				// WebKit and Gecko 2+ can trigger file dialog progrmmatically
				triggerDialog: (plupload.ua.gecko && window.FormData || plupload.ua.webkit) 
			};
		},

		/**
		 * Initializes the upload runtime.
		 *
		 * @method init
		 * @param {plupload.Uploader} uploader Uploader instance that needs to be initialized.
		 * @param {function} callback Callback to execute when the runtime initializes or fails to initialize. If it succeeds an object with a parameter name success will be set to true.
		 */
		init : function(uploader, callback) {
			var features, xhr;

			function addSelectedFiles(native_files) {
				var file, i, files = [], id, fileNames = {};

				// Add the selected files to the file queue
				for (i = 0; i < native_files.length; i++) {
					file = native_files[i];
										
					// Safari on Windows will add first file from dragged set multiple times
					// @see: https://bugs.webkit.org/show_bug.cgi?id=37957
					if (fileNames[file.name] && plupload.ua.safari && plupload.ua.windows) {
						continue;
					}
					fileNames[file.name] = true;

					// Store away gears blob internally
					id = plupload.guid();
					html5files[id] = file;

					var pluploadFile = new plupload.File(id, file.fileName || file.name, file.fileSize || file.size);

					// If the file type not exist
					// we get from the file content
					if (file.type.length < 1) {

						if ("FileReader" in window) {

							reader = new FileReader();
							reader.readAsDataURL(file);
							
							reader.onload = function() {
								data = reader.result;

								data = data.substring(data.indexOf('base64,') + 7);
								data = atob(data);

								var format = data.substring(0,3);

								// This is to fix uploading audio file on android
								if (format == 'ID3') {
									pluploadFile.name = file.name + '.mp3';
								}

								files.push(pluploadFile);
							};
						}

					} else {
						files.push(pluploadFile);
					}
					
				}

				// Trigger FilesAdded event if we added any
				if (files.length) {
					uploader.trigger("FilesAdded", files);
				}
			}

			// No HTML5 upload support
			features = this.getFeatures();
			if (!features.html5) {
				callback({success : false});
				return;
			}

			uploader.bind("Init", function(up) {
				var inputContainer, browseButton, mimes = [], i, y, filters = up.settings.filters, ext, type, container = document.body, inputFile;

				// Create input container and insert it at an absolute position within the browse button
				inputContainer = document.createElement('div');
				inputContainer.id = up.id + '_html5_container';

				plupload.extend(inputContainer.style, {
					position : 'absolute',
					background : uploader.settings.shim_bgcolor || 'transparent',
					width : '100px',
					height : '100px',
					overflow : 'hidden',
					zIndex : 99999,
					opacity : uploader.settings.shim_bgcolor ? '' : 0 // Force transparent if bgcolor is undefined
				});
				inputContainer.className = 'plupload html5';

				if (uploader.settings.container) {
					container = document.getElementById(uploader.settings.container);
					if (plupload.getStyle(container, 'position') === 'static') {
						container.style.position = 'relative';
					}
				}

				container.appendChild(inputContainer);
				
				// Convert extensions to mime types list
				no_type_restriction:
				for (i = 0; i < filters.length; i++) {
					ext = filters[i].extensions.split(/,/);

					for (y = 0; y < ext.length; y++) {
						
						// If there's an asterisk in the list, then accept attribute is not required
						if (ext[y] === '*') {
							mimes = [];
							break no_type_restriction;
						}
						
						type = plupload.mimeTypes[ext[y]];

						if (type && plupload.inArray(type, mimes) === -1) {
							mimes.push(type);
						}
					}
				}


				// Insert the input inside the input container
				inputContainer.innerHTML = '<input id="' + uploader.id + '_html5" ' + ' style="font-size:999px"' +
											' type="file" accept="' + mimes.join(',') + '" ' +
											(uploader.settings.multi_selection && uploader.features.multi_selection ? 'multiple="multiple"' : '') + ' />';

				inputContainer.scrollTop = 100;
				inputFile = document.getElementById(uploader.id + '_html5');
				
				if (up.features.triggerDialog) {
					plupload.extend(inputFile.style, {
						position: 'absolute',
						width: '100%',
						height: '100%'
					});
				} else {
					// shows arrow cursor instead of the text one, bit more logical
					plupload.extend(inputFile.style, {
						cssFloat: 'right', 
						styleFloat: 'right'
					});
				}
				
				inputFile.onchange = function() {
					// Add the selected files from file input
					addSelectedFiles(this.files);
					
					// Clearing the value enables the user to select the same file again if they want to
					this.value = '';
				};
				
				/* Since we have to place input[type=file] on top of the browse_button for some browsers (FF, Opera),
				browse_button loses interactivity, here we try to neutralize this issue highlighting browse_button
				with a special classes
				TODO: needs to be revised as things will change */
				browseButton = document.getElementById(up.settings.browse_button);
				if (browseButton) {				
					var hoverClass = up.settings.browse_button_hover,
						activeClass = up.settings.browse_button_active,
						topElement = up.features.triggerDialog ? browseButton : inputContainer;
					
					if (hoverClass) {
						plupload.addEvent(topElement, 'mouseover', function() {
							plupload.addClass(browseButton, hoverClass);	
						}, up.id);
						plupload.addEvent(topElement, 'mouseout', function() {
							plupload.removeClass(browseButton, hoverClass);	
						}, up.id);
					}
					
					if (activeClass) {
						plupload.addEvent(topElement, 'mousedown', function() {
							plupload.addClass(browseButton, activeClass);	
						}, up.id);
						plupload.addEvent(document.body, 'mouseup', function() {
							plupload.removeClass(browseButton, activeClass);	
						}, up.id);
					}

					// Route click event to the input[type=file] element for supporting browsers
					if (up.features.triggerDialog) {
						plupload.addEvent(browseButton, 'click', function(e) {
							var input = document.getElementById(up.id + '_html5');
							if (input && !input.disabled) { // for some reason FF (up to 8.0.1 so far) lets to click disabled input[type=file]
								input.click();
							}
							e.preventDefault();
						}, up.id); 
					}
				}
			});

			// Add drop handler
			uploader.bind("PostInit", function() {
				var dropElm = document.getElementById(uploader.settings.drop_element);

				if (dropElm) {
					// Lets fake drag/drop on Safari by moving a input type file in front of the mouse pointer when we drag into the drop zone
					// TODO: Remove this logic once Safari has official drag/drop support
					if (fakeSafariDragDrop) {
						plupload.addEvent(dropElm, 'dragenter', function(e) {
							var dropInputElm, dropPos, dropSize;

							// Get or create drop zone
							dropInputElm = document.getElementById(uploader.id + "_drop");
							if (!dropInputElm) {
								dropInputElm = document.createElement("input");
								dropInputElm.setAttribute('type', "file");
								dropInputElm.setAttribute('id', uploader.id + "_drop");
								dropInputElm.setAttribute('multiple', 'multiple');

								plupload.addEvent(dropInputElm, 'change', function() {
									// Add the selected files from file input
									addSelectedFiles(this.files);
																		
									// Remove input element
									plupload.removeEvent(dropInputElm, 'change', uploader.id);
									dropInputElm.parentNode.removeChild(dropInputElm);									
								}, uploader.id);

								// avoid event propagation as Safari cancels the whole capability of dropping files if you are doing a preventDefault of this event on the document body
								plupload.addEvent(dropInputElm, 'dragover', function(e) {
									e.stopPropagation();
								}, uploader.id);
								
								dropElm.appendChild(dropInputElm);
							}

							dropPos = plupload.getPos(dropElm, document.getElementById(uploader.settings.container));
							dropSize = plupload.getSize(dropElm);
							
							if (plupload.getStyle(dropElm, 'position') === 'static') {
								plupload.extend(dropElm.style, {
									position : 'relative'
								});
							}
			  
							plupload.extend(dropInputElm.style, {
								position : 'absolute',
								display : 'block',
								top : 0,
								left : 0,
								width : dropSize.w + 'px',
								height : dropSize.h + 'px',
								opacity : 0
							});							
						}, uploader.id);

						return;
					}

					// Block browser default drag over
					plupload.addEvent(dropElm, 'dragover', function(e) {
						e.preventDefault();
					}, uploader.id);

					// Attach drop handler and grab files
					plupload.addEvent(dropElm, 'drop', function(e) {
						var dataTransfer = e.dataTransfer;

						// Add dropped files
						if (dataTransfer && dataTransfer.files) {
							addSelectedFiles(dataTransfer.files);
						}

						e.preventDefault();
					}, uploader.id);
				}
			});

			uploader.bind("Refresh", function(up) {
				var browseButton, browsePos, browseSize, inputContainer, zIndex;
					
				browseButton = document.getElementById(uploader.settings.browse_button);
				if (browseButton) {
					browsePos = plupload.getPos(browseButton, document.getElementById(up.settings.container));
					browseSize = plupload.getSize(browseButton);
					inputContainer = document.getElementById(uploader.id + '_html5_container');
	
					plupload.extend(inputContainer.style, {
						top : browsePos.y + 'px',
						left : browsePos.x + 'px',
						width : browseSize.w + 'px',
						height : browseSize.h + 'px'
					});
					
					// for WebKit place input element underneath the browse button and route onclick event 
					// TODO: revise when browser support for this feature will change
					if (uploader.features.triggerDialog) {
						if (plupload.getStyle(browseButton, 'position') === 'static') {
							plupload.extend(browseButton.style, {
								position : 'relative'
							});
						}
						
						zIndex = parseInt(plupload.getStyle(browseButton, 'zIndex'), 10);
						if (isNaN(zIndex)) {
							zIndex = 0;
						}						
							
						plupload.extend(browseButton.style, {
							zIndex : zIndex
						});						
											
						plupload.extend(inputContainer.style, {
							zIndex : zIndex - 1
						});
					}				
				}
			});
			
			uploader.bind("DisableBrowse", function(up, disabled) {
				var input = document.getElementById(up.id + '_html5');
				if (input) {
					input.disabled = disabled;	
				}
			});
			
			uploader.bind("CancelUpload", function() {
				if (xhr && xhr.abort) {
					xhr.abort();	
				}
			});

			uploader.bind("UploadFile", function(up, file) {
				var settings = up.settings, nativeFile, resize;
					
				function w3cBlobSlice(blob, start, end) {
					var blobSlice;
					
					if (File.prototype.slice) {
						try {
							blob.slice();	// depricated version will throw WRONG_ARGUMENTS_ERR exception
							return blob.slice(start, end);
						} catch (e) {
							// depricated slice method
							return blob.slice(start, end - start); 
						}
					// slice method got prefixed: https://bugzilla.mozilla.org/show_bug.cgi?id=649672	
					} else if (blobSlice = File.prototype.webkitSlice || File.prototype.mozSlice) {
						return blobSlice.call(blob, start, end);	
					} else {
						return null; // or throw some exception	
					}
				}	

				function sendBinaryBlob(blob) {
					var chunk = 0, loaded = 0;
						

					function uploadNextChunk() {
						var chunkBlob, br, chunks, args, chunkSize, curChunkSize, mimeType, url = up.settings.url;	

						function sendAsBinaryString(bin) {
							if (xhr.sendAsBinary) { // Gecko
								xhr.sendAsBinary(bin);
							} else if (up.features.canSendBinary) { // WebKit with typed arrays support
								var ui8a = new Uint8Array(bin.length);
								for (var i = 0; i < bin.length; i++) {
									ui8a[i] = (bin.charCodeAt(i) & 0xff);
								}
								xhr.send(ui8a.buffer);
							}
						}												
	
						function prepareAndSend(bin) {
							var multipartDeltaSize = 0,
								boundary = '----pluploadboundary' + plupload.guid(), formData, dashdash = '--', crlf = '\r\n', multipartBlob = '';
								
							xhr = new XMLHttpRequest;
															
							// Do we have upload progress support
							if (xhr.upload) {
								xhr.upload.onprogress = function(e) {
									file.loaded = Math.min(file.size, loaded + e.loaded - multipartDeltaSize); // Loaded can be larger than file size due to multipart encoding
									up.trigger('UploadProgress', file);
								};
							}
	
							xhr.onreadystatechange = function() {
								var httpStatus, chunkArgs;
																	
								if (xhr.readyState == 4 && up.state !== plupload.STOPPED) {
									// Getting the HTTP status might fail on some Gecko versions
									try {
										httpStatus = xhr.status;
									} catch (ex) {
										httpStatus = 0;
									}
	
									// Is error status
									if (httpStatus >= 400) {
										up.trigger('Error', {
											code : plupload.HTTP_ERROR,
											message : plupload.translate('HTTP Error.'),
											file : file,
											status : httpStatus
										});
									} else {
										// Handle chunk response
										if (chunks) {
											chunkArgs = {
												chunk : chunk,
												chunks : chunks,
												response : xhr.responseText,
												status : httpStatus
											};
	
											up.trigger('ChunkUploaded', file, chunkArgs);
											loaded += curChunkSize;
	
											// Stop upload
											if (chunkArgs.cancelled) {
												file.status = plupload.FAILED;
												return;
											}
	
											file.loaded = Math.min(file.size, (chunk + 1) * chunkSize);
										} else {
											file.loaded = file.size;
										}
	
										up.trigger('UploadProgress', file);
										
										bin = chunkBlob = formData = multipartBlob = null; // Free memory
										
										// Check if file is uploaded
										if (!chunks || ++chunk >= chunks) {
											file.status = plupload.DONE;
																						
											up.trigger('FileUploaded', file, {
												response : xhr.responseText,
												status : httpStatus
											});										
										} else {										
											// Still chunks left
											uploadNextChunk();
										}
									}																	
								}
							};
							
	
							// Build multipart request
							if (up.settings.multipart && features.multipart) {
								
								args.name = file.target_name || file.name;
								
								xhr.open("post", url, true);
								
								// Set custom headers
								plupload.each(up.settings.headers, function(value, name) {
									xhr.setRequestHeader(name, value);
								});
								
								
								// if has FormData support like Chrome 6+, Safari 5+, Firefox 4, use it
								if (typeof(bin) !== 'string' && !!window.FormData) {
									formData = new FormData();
	
									// Add multipart params
									plupload.each(plupload.extend(args, up.settings.multipart_params), function(value, name) {
										formData.append(name, value);
									});
	
									// Add file and send it
									formData.append(up.settings.file_data_name, bin);								
									xhr.send(formData);
	
									return;
								}  // if no FormData we can still try to send it directly as last resort (see below)
								
								
								if (typeof(bin) === 'string') {
									// Trying to send the whole thing as binary...
		
									// multipart request
									xhr.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary);
		
									// append multipart parameters
									plupload.each(plupload.extend(args, up.settings.multipart_params), function(value, name) {
										multipartBlob += dashdash + boundary + crlf +
											'Content-Disposition: form-data; name="' + name + '"' + crlf + crlf;
		
										multipartBlob += unescape(encodeURIComponent(value)) + crlf;
									});
		
									mimeType = plupload.mimeTypes[file.name.replace(/^.+\.([^.]+)/, '$1').toLowerCase()] || 'application/octet-stream';
		
									// Build RFC2388 blob
									multipartBlob += dashdash + boundary + crlf +
										'Content-Disposition: form-data; name="' + up.settings.file_data_name + '"; filename="' + unescape(encodeURIComponent(file.name)) + '"' + crlf +
										'Content-Type: ' + mimeType + crlf + crlf +
										bin + crlf +
										dashdash + boundary + dashdash + crlf;
		
									multipartDeltaSize = multipartBlob.length - bin.length;
									bin = multipartBlob;
							
									sendAsBinaryString(bin);
									return; // will return from here only if shouldn't send binary
								} 							
							}
							
							// if no multipart, or last resort, send as binary stream
							url = plupload.buildUrl(up.settings.url, plupload.extend(args, up.settings.multipart_params));
							
							xhr.open("post", url, true);
							
							xhr.setRequestHeader('Content-Type', 'application/octet-stream'); // Binary stream header
								
							// Set custom headers
							plupload.each(up.settings.headers, function(value, name) {
								xhr.setRequestHeader(name, value);
							});
							
							if (typeof(bin) === 'string') {	
								sendAsBinaryString(bin);
							} else {				
								xhr.send(bin); 
							}
						} // prepareAndSend


						// File upload finished
						if (file.status == plupload.DONE || file.status == plupload.FAILED || up.state == plupload.STOPPED) {
							return;
						}

						// Standard arguments
						args = {name : file.target_name || file.name};

						// Only add chunking args if needed
						if (settings.chunk_size && file.size > settings.chunk_size && (features.chunks || typeof(blob) == 'string')) { // blob will be of type string if it was loaded in memory 
							chunkSize = settings.chunk_size;
							chunks = Math.ceil(file.size / chunkSize);
							curChunkSize = Math.min(chunkSize, file.size - (chunk * chunkSize));

							// Blob is string so we need to fake chunking, this is not
							// ideal since the whole file is loaded into memory
							if (typeof(blob) == 'string') {
								chunkBlob = blob.substring(chunk * chunkSize, chunk * chunkSize + curChunkSize);
							} else {
								// Slice the chunk
								chunkBlob = w3cBlobSlice(blob, chunk * chunkSize, chunk * chunkSize + curChunkSize);
							}

							// Setup query string arguments
							args.chunk = chunk;
							args.chunks = chunks;
						} else {
							curChunkSize = file.size;
							chunkBlob = blob;
						}
						
						// workaround for Android and Gecko 2,5,6 FormData+Blob bug: https://bugzilla.mozilla.org/show_bug.cgi?id=649150
						if (up.settings.multipart && features.multipart && typeof(chunkBlob) !== 'string' && window.FileReader && features.cantSendBlobInFormData && features.chunks && up.settings.chunk_size) { // Gecko 2,5,6
							(function() {
								var fr = new FileReader(); // we need to recreate FileReader object in Android, otherwise it hangs
								fr.onload = function() {
									prepareAndSend(fr.result);
									fr = null; // maybe give a hand to GC (Gecko had problems with this)
								}
								fr.readAsBinaryString(chunkBlob);
							}());
						} else {
							prepareAndSend(chunkBlob);
						}	
					}

					// Start uploading chunks
					uploadNextChunk();
				}

				nativeFile = html5files[file.id];
								
				// Resize image if it's a supported format and resize is enabled
				if (features.jpgresize && up.settings.resize && /\.(png|jpg|jpeg)$/i.test(file.name)) {
					scaleImage.call(up, file, up.settings.resize, /\.png$/i.test(file.name) ? 'image/png' : 'image/jpeg', function(res) {
						// If it was scaled send the scaled image if it failed then
						// send the raw image and let the server do the scaling
						if (res.success) {
							file.size = res.data.length;
							sendBinaryBlob(res.data);
						} else if (features.chunks) {
							sendBinaryBlob(nativeFile); 
						} else {
							readFileAsBinary(nativeFile, sendBinaryBlob); // for browsers not supporting File.slice (e.g. FF3.6)
						}
					});
				// if there's no way to slice file without preloading it in memory, preload it
				} else if (!features.chunks && features.jpgresize) { 
					readFileAsBinary(nativeFile, sendBinaryBlob); 
				} else {
					sendBinaryBlob(nativeFile); 
				}
			});
			
			
			uploader.bind('Destroy', function(up) {
				var name, element, container = document.body,
					elements = {
						inputContainer: up.id + '_html5_container',
						inputFile: up.id + '_html5',
						browseButton: up.settings.browse_button,
						dropElm: up.settings.drop_element
					};

				// Unbind event handlers
				for (name in elements) {
					element = document.getElementById(elements[name]);
					if (element) {
						plupload.removeAllEvents(element, up.id);
					}
				}
				plupload.removeAllEvents(document.body, up.id);
				
				if (up.settings.container) {
					container = document.getElementById(up.settings.container);
				}
				
				// Remove mark-up
				container.removeChild(document.getElementById(elements.inputContainer));
			});

			callback({success : true});
		}
	});
	
	function BinaryReader() {
		var II = false, bin;

		// Private functions
		function read(idx, size) {
			var mv = II ? 0 : -8 * (size - 1), sum = 0, i;

			for (i = 0; i < size; i++) {
				sum |= (bin.charCodeAt(idx + i) << Math.abs(mv + i*8));
			}

			return sum;
		}

		function putstr(segment, idx, length) {
			var length = arguments.length === 3 ? length : bin.length - idx - 1;
			
			bin = bin.substr(0, idx) + segment + bin.substr(length + idx);
		}

		function write(idx, num, size) {
			var str = '', mv = II ? 0 : -8 * (size - 1), i;

			for (i = 0; i < size; i++) {
				str += String.fromCharCode((num >> Math.abs(mv + i*8)) & 255);
			}

			putstr(str, idx, size);
		}

		// Public functions
		return {
			II: function(order) {
				if (order === undef) {
					return II;
				} else {
					II = order;
				}
			},

			init: function(binData) {
				II = false;
				bin = binData;
			},

			SEGMENT: function(idx, length, segment) {				
				switch (arguments.length) {
					case 1: 
						return bin.substr(idx, bin.length - idx - 1);
					case 2: 
						return bin.substr(idx, length);
					case 3: 
						putstr(segment, idx, length);
						break;
					default: return bin;	
				}
			},

			BYTE: function(idx) {
				return read(idx, 1);
			},

			SHORT: function(idx) {
				return read(idx, 2);
			},

			LONG: function(idx, num) {
				if (num === undef) {
					return read(idx, 4);
				} else {
					write(idx, num, 4);
				}
			},

			SLONG: function(idx) { // 2's complement notation
				var num = read(idx, 4);

				return (num > 2147483647 ? num - 4294967296 : num);
			},

			STRING: function(idx, size) {
				var str = '';

				for (size += idx; idx < size; idx++) {
					str += String.fromCharCode(read(idx, 1));
				}

				return str;
			}
		};
	}
	
	function JPEG_Headers(data) {
		
		var markers = {
				0xFFE1: {
					app: 'EXIF',
					name: 'APP1',
					signature: "Exif\0" 
				},
				0xFFE2: {
					app: 'ICC',
					name: 'APP2',
					signature: "ICC_PROFILE\0" 
				},
				0xFFED: {
					app: 'IPTC',
					name: 'APP13',
					signature: "Photoshop 3.0\0" 
				}
			},
			headers = [], read, idx, marker = undef, length = 0, limit;
			
		
		read = new BinaryReader();
		read.init(data);
				
		// Check if data is jpeg
		if (read.SHORT(0) !== 0xFFD8) {
			return;
		}
		
		idx = 2;
		limit = Math.min(1048576, data.length);	
			
		while (idx <= limit) {
			marker = read.SHORT(idx);
			
			// omit RST (restart) markers
			if (marker >= 0xFFD0 && marker <= 0xFFD7) {
				idx += 2;
				continue;
			}
			
			// no headers allowed after SOS marker
			if (marker === 0xFFDA || marker === 0xFFD9) {
				break;	
			}	
			
			length = read.SHORT(idx + 2) + 2;	
			
			if (markers[marker] && 
				read.STRING(idx + 4, markers[marker].signature.length) === markers[marker].signature) {
				headers.push({ 
					hex: marker,
					app: markers[marker].app.toUpperCase(),
					name: markers[marker].name.toUpperCase(),
					start: idx,
					length: length,
					segment: read.SEGMENT(idx, length)
				});
			}
			idx += length;			
		}
					
		read.init(null); // free memory
						
		return {
			
			headers: headers,
			
			restore: function(data) {
				read.init(data);
				
				// Check if data is jpeg
				var jpegHeaders = new JPEG_Headers(data);
				
				if (!jpegHeaders['headers']) {
					return false;
				}	
				
				// Delete any existing headers that need to be replaced
				for (var i = jpegHeaders['headers'].length; i > 0; i--) {
					var hdr = jpegHeaders['headers'][i - 1];
					read.SEGMENT(hdr.start, hdr.length, '')
				}
				jpegHeaders.purge();
				
				idx = read.SHORT(2) == 0xFFE0 ? 4 + read.SHORT(4) : 2;
								
				for (var i = 0, max = headers.length; i < max; i++) {
					read.SEGMENT(idx, 0, headers[i].segment);						
					idx += headers[i].length;
				}
				
				return read.SEGMENT();
			},
			
			get: function(app) {
				var array = [];
								
				for (var i = 0, max = headers.length; i < max; i++) {
					if (headers[i].app === app.toUpperCase()) {
						array.push(headers[i].segment);
					}
				}
				return array;
			},
			
			set: function(app, segment) {
				var array = [];
				
				if (typeof(segment) === 'string') {
					array.push(segment);	
				} else {
					array = segment;	
				}
				
				for (var i = ii = 0, max = headers.length; i < max; i++) {
					if (headers[i].app === app.toUpperCase()) {
						headers[i].segment = array[ii];
						headers[i].length = array[ii].length;
						ii++;
					}
					if (ii >= array.length) break;
				}
			},
			
			purge: function() {
				headers = [];
				read.init(null);
			}
		};		
	}
	
	
	function ExifParser() {
		// Private ExifParser fields
		var data, tags, offsets = {}, tagDescs;

		data = new BinaryReader();

		tags = {
			tiff : {
				/*
				The image orientation viewed in terms of rows and columns.
	
				1 - The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
				2 - The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
				3 - The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.
				4 - The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.
				5 - The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.
				6 - The 0th row is the visual left-hand side of the image, and the 0th column is the visual top.
				7 - The 0th row is the visual right-hand side of the image, and the 0th column is the visual top.
				8 - The 0th row is the visual right-hand side of the image, and the 0th column is the visual bottom.
				9 - The 0th row is the visual left-hand side of the image, and the 0th column is the visual bottom.
				*/
				0x0112: 'Orientation',
				0x8769: 'ExifIFDPointer',
				0x8825:	'GPSInfoIFDPointer'
			},
			exif : {
				0x9000: 'ExifVersion',
				0xA001: 'ColorSpace',
				0xA002: 'PixelXDimension',
				0xA003: 'PixelYDimension',
				0x9003: 'DateTimeOriginal',
				0x829A: 'ExposureTime',
				0x829D: 'FNumber',
				0x8827: 'ISOSpeedRatings',
				0x9201: 'ShutterSpeedValue',
				0x9202: 'ApertureValue'	,
				0x9207: 'MeteringMode',
				0x9208: 'LightSource',
				0x9209: 'Flash',
				0xA402: 'ExposureMode',
				0xA403: 'WhiteBalance',
				0xA406: 'SceneCaptureType',
				0xA404: 'DigitalZoomRatio',
				0xA408: 'Contrast',
				0xA409: 'Saturation',
				0xA40A: 'Sharpness'
			},
			gps : {
				0x0000: 'GPSVersionID',
				0x0001: 'GPSLatitudeRef',
				0x0002: 'GPSLatitude',
				0x0003: 'GPSLongitudeRef',
				0x0004: 'GPSLongitude'
			}
		};

		tagDescs = {
			'ColorSpace': {
				1: 'sRGB',
				0: 'Uncalibrated'
			},

			'MeteringMode': {
				0: 'Unknown',
				1: 'Average',
				2: 'CenterWeightedAverage',
				3: 'Spot',
				4: 'MultiSpot',
				5: 'Pattern',
				6: 'Partial',
				255: 'Other'
			},

			'LightSource': {
				1: 'Daylight',
				2: 'Fliorescent',
				3: 'Tungsten',
				4: 'Flash',
				9: 'Fine weather',
				10: 'Cloudy weather',
				11: 'Shade',
				12: 'Daylight fluorescent (D 5700 - 7100K)',
				13: 'Day white fluorescent (N 4600 -5400K)',
				14: 'Cool white fluorescent (W 3900 - 4500K)',
				15: 'White fluorescent (WW 3200 - 3700K)',
				17: 'Standard light A',
				18: 'Standard light B',
				19: 'Standard light C',
				20: 'D55',
				21: 'D65',
				22: 'D75',
				23: 'D50',
				24: 'ISO studio tungsten',
				255: 'Other'
			},

			'Flash': {
				0x0000: 'Flash did not fire.',
				0x0001: 'Flash fired.',
				0x0005: 'Strobe return light not detected.',
				0x0007: 'Strobe return light detected.',
				0x0009: 'Flash fired, compulsory flash mode',
				0x000D: 'Flash fired, compulsory flash mode, return light not detected',
				0x000F: 'Flash fired, compulsory flash mode, return light detected',
				0x0010: 'Flash did not fire, compulsory flash mode',
				0x0018: 'Flash did not fire, auto mode',
				0x0019: 'Flash fired, auto mode',
				0x001D: 'Flash fired, auto mode, return light not detected',
				0x001F: 'Flash fired, auto mode, return light detected',
				0x0020: 'No flash function',
				0x0041: 'Flash fired, red-eye reduction mode',
				0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
				0x0047: 'Flash fired, red-eye reduction mode, return light detected',
				0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
				0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
				0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
				0x0059: 'Flash fired, auto mode, red-eye reduction mode',
				0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
				0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
			},

			'ExposureMode': {
				0: 'Auto exposure',
				1: 'Manual exposure',
				2: 'Auto bracket'
			},

			'WhiteBalance': {
				0: 'Auto white balance',
				1: 'Manual white balance'
			},

			'SceneCaptureType': {
				0: 'Standard',
				1: 'Landscape',
				2: 'Portrait',
				3: 'Night scene'
			},

			'Contrast': {
				0: 'Normal',
				1: 'Soft',
				2: 'Hard'
			},

			'Saturation': {
				0: 'Normal',
				1: 'Low saturation',
				2: 'High saturation'
			},

			'Sharpness': {
				0: 'Normal',
				1: 'Soft',
				2: 'Hard'
			},

			// GPS related
			'GPSLatitudeRef': {
				N: 'North latitude',
				S: 'South latitude'
			},

			'GPSLongitudeRef': {
				E: 'East longitude',
				W: 'West longitude'
			}
		};

		function extractTags(IFD_offset, tags2extract) {
			var length = data.SHORT(IFD_offset), i, ii,
				tag, type, count, tagOffset, offset, value, values = [], hash = {};

			for (i = 0; i < length; i++) {
				// Set binary reader pointer to beginning of the next tag
				offset = tagOffset = IFD_offset + 12 * i + 2;

				tag = tags2extract[data.SHORT(offset)];

				if (tag === undef) {
					continue; // Not the tag we requested
				}

				type = data.SHORT(offset+=2);
				count = data.LONG(offset+=2);

				offset += 4;
				values = [];

				switch (type) {
					case 1: // BYTE
					case 7: // UNDEFINED
						if (count > 4) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.BYTE(offset + ii);
						}

						break;

					case 2: // STRING
						if (count > 4) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						hash[tag] = data.STRING(offset, count - 1);

						continue;

					case 3: // SHORT
						if (count > 2) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.SHORT(offset + ii*2);
						}

						break;

					case 4: // LONG
						if (count > 1) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.LONG(offset + ii*4);
						}

						break;

					case 5: // RATIONAL
						offset = data.LONG(offset) + offsets.tiffHeader;

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.LONG(offset + ii*4) / data.LONG(offset + ii*4 + 4);
						}

						break;

					case 9: // SLONG
						offset = data.LONG(offset) + offsets.tiffHeader;

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.SLONG(offset + ii*4);
						}

						break;

					case 10: // SRATIONAL
						offset = data.LONG(offset) + offsets.tiffHeader;

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.SLONG(offset + ii*4) / data.SLONG(offset + ii*4 + 4);
						}

						break;

					default:
						continue;
				}

				value = (count == 1 ? values[0] : values);

				if (tagDescs.hasOwnProperty(tag) && typeof value != 'object') {
					hash[tag] = tagDescs[tag][value];
				} else {
					hash[tag] = value;
				}
			}

			return hash;
		}

		function getIFDOffsets() {
			var Tiff = undef, idx = offsets.tiffHeader;

			// Set read order of multi-byte data
			data.II(data.SHORT(idx) == 0x4949);

			// Check if always present bytes are indeed present
			if (data.SHORT(idx+=2) !== 0x002A) {
				return false;
			}
		
			offsets['IFD0'] = offsets.tiffHeader + data.LONG(idx += 2);
			Tiff = extractTags(offsets['IFD0'], tags.tiff);

			offsets['exifIFD'] = ('ExifIFDPointer' in Tiff ? offsets.tiffHeader + Tiff.ExifIFDPointer : undef);
			offsets['gpsIFD'] = ('GPSInfoIFDPointer' in Tiff ? offsets.tiffHeader + Tiff.GPSInfoIFDPointer : undef);

			return true;
		}
		
		// At the moment only setting of simple (LONG) values, that do not require offset recalculation, is supported
		function setTag(ifd, tag, value) {
			var offset, length, tagOffset, valueOffset = 0;
			
			// If tag name passed translate into hex key
			if (typeof(tag) === 'string') {
				var tmpTags = tags[ifd.toLowerCase()];
				for (hex in tmpTags) {
					if (tmpTags[hex] === tag) {
						tag = hex;
						break;	
					}
				}
			}
			offset = offsets[ifd.toLowerCase() + 'IFD'];
			length = data.SHORT(offset);
						
			for (i = 0; i < length; i++) {
				tagOffset = offset + 12 * i + 2;

				if (data.SHORT(tagOffset) == tag) {
					valueOffset = tagOffset + 8;
					break;
				}
			}
			
			if (!valueOffset) return false;

			
			data.LONG(valueOffset, value);
			return true;
		}
		

		// Public functions
		return {
			init: function(segment) {
				// Reset internal data
				offsets = {
					tiffHeader: 10
				};
				
				if (segment === undef || !segment.length) {
					return false;
				}

				data.init(segment);

				// Check if that's APP1 and that it has EXIF
				if (data.SHORT(0) === 0xFFE1 && data.STRING(4, 5).toUpperCase() === "EXIF\0") {
					return getIFDOffsets();
				}
				return false;
			},
			
			EXIF: function() {
				var Exif;
				
				// Populate EXIF hash
				Exif = extractTags(offsets.exifIFD, tags.exif);

				// Fix formatting of some tags
				if (Exif.ExifVersion && plupload.typeOf(Exif.ExifVersion) === 'array') {
					for (var i = 0, exifVersion = ''; i < Exif.ExifVersion.length; i++) {
						exifVersion += String.fromCharCode(Exif.ExifVersion[i]);	
					}
					Exif.ExifVersion = exifVersion;
				}

				return Exif;
			},

			GPS: function() {
				var GPS;
				
				GPS = extractTags(offsets.gpsIFD, tags.gps);
				
				// iOS devices (and probably some others) do not put in GPSVersionID tag (why?..)
				if (GPS.GPSVersionID) { 
					GPS.GPSVersionID = GPS.GPSVersionID.join('.');
				}

				return GPS;
			},
			
			setExif: function(tag, value) {
				// Right now only setting of width/height is possible
				if (tag !== 'PixelXDimension' && tag !== 'PixelYDimension') return false;
				
				return setTag('exif', tag, value);
			},


			getBinary: function() {
				return data.SEGMENT();
			}
		};
	};
})(window, document, $.plupload);
$.Controller("plupload",
{
	pluginName: "plupload",
	hostname: "plupload",

	defaultOptions: {

		"{uploader}" : "[data-plupload-uploader]",
		"{uploadButton}" : "[data-plupload-upload-button]",
		"{uploadDropsite}" : "[data-plupload-dropsite]",

		settings: {
			runtimes: "html5, html4",
			url: $.indexUrl,
			max_file_count: 20,
			unique_names: true
		}
	}
},
function(self, opts, base) { return {

	init: function() {

		var settings = self.options.settings;

		// Create upload container identifier
		var uploadContainerId = $.uid("uploadContainer-");

		self.element
			.attr('id', uploadContainerId);

		settings.container = uploadContainerId;

		// Create upload button identifier
		var uploadButtonId = self.uploadButtonId = $.uid("uploadButton-");

		// Apply the id to the first found upload button
		self.uploadButtonMain =
			self.uploadButton(":first")
				.attr('id', uploadButtonId);

		settings.browse_button = uploadButtonId;

		// Create upload drop site identifier
		var uploadDropsiteId = $.uid("uploadDropsite-");

		if (self.uploadDropsite().length > 0) {

			self.uploadDropsite()
						.attr('id', uploadDropsiteId);

			settings.drop_element = uploadDropsiteId;
		}

		// Decide where the uploader events are binded to
		self.uploader = $(self.uploader()[0] || self.element);

		// Create new plupload instance
		self.plupload = new $.plupload.Uploader(settings);

		// @rule: Init() plupload before you bind except for postInit
		self.plupload.bind('PostInit', function() {
			self.eventHandler("PostInit", $.makeArray(arguments));
		});

		self.plupload.init();

		var events = [
			"BeforeUpload",
			"ChunkUploaded",
			"Destroy",
			"Error",
			"FilesAdded",
			"FilesRemoved",
			"FileUploaded",
			"Init",
			"QueueChanged",
			"Refresh",
			"StateChanged",
			"UploadComplete",
			"UploadFile",
			"UploadProgress"
		];

		$.each(events, function(i, eventName) {

			self.plupload.bind(eventName, function(){
				self.eventHandler(eventName, $.makeArray(arguments));
			});
		});

		// Indicate uploader supports drag & drop
		if (!$.IE && self.plupload.runtime=="html5") {

			base.addClass("can-drop-file");
		}

		// Indicate uploader is ready
		base.addClass("can-upload");
	},

	"{uploadButton} click": function(uploadButton) {
		
		if (uploadButton[0]==self.uploadButtonMain[0]) {
			return;
		}

		if (self.plupload.features.triggerDialog) {
			self.uploadButtonMain.click();
		}
	},

	"{uploadButton} mouseover": function(uploadButton) {

		// If we can trigger browser dialog programatically,
		// don't do anything.
		if (self.plupload.features.triggerDialog) return;

		// Remove id on all upload buttons
		self.uploadButton().removeAttr('id');

		// Add to the current one
		uploadButton.attr('id', self.uploadButtonId);

		// Reposition button
		self.plupload.refresh();
	},

	eventHandler: function(eventName, args) {

		var eventHandler = self["plupload::"+eventName],

			elementEventHandler = (function(){
				var eventHandlers = (self.uploader.data("events") || {})[eventName];
				return (eventHandlers) ? eventHandlers[0].handler : undefined;
			})(),

			elementEventHandlerArgs;

		if ($.isFunction(eventHandler)) {

			elementEventHandlerArgs = eventHandler.apply(self, args);
		}

		if (elementEventHandlerArgs!==false) {

			self.uploader.trigger(eventName, elementEventHandlerArgs || args);
		}
	},

	"plupload::FileUploaded": function(up, file, data, handler) {

		var response;

		try {

			response = eval('('+data.response+')');

		} catch(e) {

			response = {
				type: "error",
				message: "Unable to parse server response.",
				data: data
			};
		}

		// If response type is an error, trigger FileError event
		if (response.type=="error") {

			self.uploader.trigger("FileError", [up, file, response]);

			// This ensure the FileUploaded event
			// doesn't get triggered anymore.
			return false;
		}

		// Trigger FileUploaded event with the following params
		return [up, file, response];
	},

	"plupload::Error": function(up, error) {

		try { console.log('plupload Error: ', up, error); } catch(e) {};
	}

}});

};

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("plupload", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
$.require()
 .script("ui/position")
 .done(function() {
var exports = function() {

/*
<div
	data-popbox="module://popbox/options/exporter"
	data-popbox-class="profile"
	data-popbox-position="bottom-left"></div>

<div class="popbox" data-popbox-tooltip>
<div class="arrow"></div>
<div class="popbox-content">
</div>
</div>
*/

$.fn.popbox = function(options) {

	// Creating or updating popbox options
	if ($.isPlainObject(options)) {

		this.each(function(){

			var button = $(this),
				popbox = Popbox.get(button);

			// Update popbox options
			if (popbox) {
				popbox.update(options);

			// Or create a new popbox
			} else {

				popbox = new Popbox(button, options);
			}
		});

		return this;
	}

	// Calling a method in popbox
	if ($.isString(options)) {

		var button = $(this[0]),

			// Create new popbox instance if
			// it hasn't been created yet
			popbox = Popbox.get(button) || new Popbox(button),

			method = popbox[options],

			ret;

		if ($.isFunction(method)) {

			ret = method.apply(popbox, $.makeArray(arguments).slice(1));
		}

		return ret || this;
	}

	return this;
}

var Popbox = function(button, options) {

	var popbox = this;

	// Store popbox instance within button
	button.data("popbox", popbox);

	// Normalize arguments
	if ($.isString(options)) {
		options = {content: options}
	}

	if (!options) {
		options = {};
	}

	// Popbox button that is placed in a
	// fixed position needs special handling.
	button.parentsUntil("body").addBack()
		.each(function(){
			var parent = $(this);
			if (parent.css("position")==="fixed") {
				options.fixed = true;
				return false;
			}
		});

	// Gather element options
	var elementOptions = {},
		// Takes content from data-popbox attribute, else take it from inline content.
		content = button.attr("data-popbox") || button.find("[data-popbox-content]").html() || $(button.attr("data-popbox-target")).html();
		if (content) elementOptions.content = content;

	$(["id", "component", "type", "toggle", "position", "collision"])
		.each(function(i, key){
			var val = button.attr("data-popbox-" + key);

			// We need to flip all the left -> right for rtl documents
			if (window.es.direction == 'rtl' && val) {
				if (val.indexOf('left') !== -1) {
					val = val.replace('left', 'right');
				} else if (val.indexOf('right') !== -1) {
					val = val.replace('right', 'left');
				}
			}

			elementOptions[key] = val;
		});

	// Quick Hack
	if (button.attr("data-popbox-offset")!==undefined) {
		elementOptions["offset"] = parseInt(button.attr("data-popbox-offset"));
	}

	if (button.attr("data-popbox-offset-horizontal") !== undefined) {
		elementOptions["offsethorizontal"] = parseInt(button.attr("data-popbox-offset-horizontal"));
	}

	// If popbox was set up via jQuery, the element may not
	// have the data-popbox attribute. We need this attribute
	// for click and hover events to work (and keep things DRY).
	if (content===undefined) button.attr("data-popbox", "");

	// Build final options
	popbox.update(
		$.extend(true,
			{},
			Popbox.defaultOptions, {
				tooltip: $(),
				loader : $('<div id="es" class="popbox loading" data-popbox-tooltip><div class="arrow"></div><div class="o-loader o-loader--sm o-loader--top is-active"></div></div>'),
				uid    : $.uid(),
				button : button
			},
			elementOptions,
			options
		)
	);
};

// Default options
Popbox.defaultOptions = {
	content: "",
	id: null,
	type: "",
	enabled: false,
	wait: false,
	locked: false,
	exclusive: false,
	hideTimer: null,
	hideDelay: 50,
	toggle: "hover",
	position: "bottom",
	collision: "flip",
	cache: true,
	fixed: false,
	offset: 10,
	offsethorizontal: 0
};

Popbox.get = function(el) {

	var popbox = $(el).data("popbox");

	if (popbox instanceof Popbox) return popbox;
}

Popbox.toggleEvent = navigator.userAgent.match(/iPhone|iPad|iPod/i) && window.es.environment != 'development' ? "touchstart" : "click";

$.extend(Popbox.prototype, {

	positions: "top top-left top-right top-center bottom bottom-left bottom-right bottom-center left left-top left-bottom left-center right right-top right-bottom right-center",

	update: function(options) {

		var popbox = this;

		// Update popbox options
		$.extend(true, popbox, options);

		// If popbox content is a module
		if ($.isModule(popbox.content)) {

			// Don't let anything happen until module is resolved.
			popbox.wait = true;

			$.module(popbox.content)
				.done(function(options){

					// Popbox options
					if ($.isPlainObject(options)) {
						popbox.update(options);
					}

					// Callback that returns customized popbox options
					if ($.isFunction(options)) {

						popbox.update({
							content: options
						});
					}
				})
				.fail(function(){

					var errorMessage = $('[data-es-popbox-error]').text();

					// safe check
					if (errorMessage.length <= 0 || errorMessage.indexOf('COM_EASYSOCIAL_') >= 0) {
						errorMessage = 'Unable to load tooltip content.';
					}

					popbox.update({
						content: errorMessage
					});

				})
				.always(function(){
					popbox.wait = false;
				});

			return;
		}

		// If popbox content is a string,
		// we'll just rewrap it in deferred.
		if ($.isString(popbox.content)) {
			popbox.content = $.Deferred().resolve(popbox.content);
		}

		var position = popbox.position;

		if ($.isString(position)) {

			// Determine position
			var pos = position.split("-"),
				x1, y1, x2, y2;

			switch (pos[0]) {

				case "top":
				case "bottom":
					x1 = x2 = pos[1] || "center";
					// y1 = pos[0]=="top" ? "bottom-10" : "top+10";
					y1 = pos[0]=="top" ? "bottom" : "top";
					y2 = pos[0]=="top" ? "top"    : "bottom";
					break;

				case "left":
				case "right":
					y1 = y2 = pos[1] || "center";
					// x1 = pos[0]=="left" ? "right-10" : "left+10";
					x1 = pos[0]=="left" ? "right" : "left";
					x2 = pos[0]=="left" ? "left"  : "right";
					break;
			}

			popbox.position = {
				classname: position,
				my: x1 + " " + y1,
				at: x2 + " " + y2,
				using: function(coords, feedback) {

					var tooltip   = $(this),
						classname = popbox.position.classname,
						top       = coords.top,
						left      = coords.left,
						offset    = popbox.offset,
						offsethorizontal = popbox.offsethorizontal,
						buttonOffset = popbox.button.offset();

					switch (pos[0]) {

						case "top":
						case "bottom":
							var vertical = feedback.vertical;

							if (vertical==pos[0]) {
								classname = classname.replace(/top|bottom/gi, (vertical=="top") ? "bottom" : "top");
							}
							top = (vertical=="top") ? top + offset : top - offset;

							if (pos[1]=="left" && (left < Math.floor(buttonOffset.left))) {
								classname = classname.replace(/left|right/gi, (pos[1]=="left") ? "right" : "left");
							}

							var horizontal = feedback.horizontal;
							left = (horizontal == 'left') ? left + offsethorizontal : left - offsethorizontal;

							break;

						case "left":
						case "right":
							var horizontal = feedback.horizontal;
							if (feedback.horizontal==pos[0]) {
								classname = classname.replace(/left|right/gi, (feedback.horizontal=="left") ? "right" : "left");
							}

							left = (horizontal=="left") ? left + offset : left - offset;
							break;
					}


					// We need to flip all the left -> right for rtl documents
					if (window.es.direction == 'rtl') {
						if (classname.indexOf('left') !== -1) {
							classname = classname.replace('left', 'right');
						} else if (classname.indexOf('right') !== -1) {
							classname = classname.replace('right', 'left');
						}
					}

					tooltip
						.css({
							top : top  + 'px',
							left: left + 'px'
						})
						.removeClass(popbox.positions)
						.addClass(classname);
				}
			};
		}

		$.extend(popbox.position, {
			of: popbox.button,
			collision: popbox.collision
		});

		// Popbox loader
		popbox.loader
			.attr({
				"id": popbox.id,
				"data-popbox-tooltip": popbox.type,
				"style": popbox.fixed ? 'position: fixed' : ''
			})
			.addClass(popbox.component)
			.addClass("popbox-" + popbox.type);

		if (window.es.mobile) {
			popbox.loader.addClass('is-mobile');
		}

		if (window.es.android) {
			popbox.loader.addClass('is-android');
		}

		if (window.es.ios) {
			popbox.loader.addClass('is-ios');
		}

		// If popbox is enabled, show tooltip with new options.
		if (popbox.enabled) {
			popbox.show();
		}
	},

	trigger: function(event, args) {

		var popbox = this;

		this.tooltip.trigger(event, args);
		this.button.trigger(event, args);
	},

	show: function() {

		var popbox = this;

		// Enable popbox
		popbox.enabled = true;

		// If we're waiting for module to resolve, stop.
		if (popbox.wait) {
			return;
		}

		// Stop any task that hides popover
		clearTimeout(popbox.hideTimer);

		// If this popbox can only be shown exclusively,
		// then hide other popbox.
		if (popbox.exclusive) {

			$("[data-popbox-tooltip]").each(function(){

				var popbox = Popbox.get($(this));

				if (!popbox) return;

				popbox.hide(true);
			});
		}

		// Insert active for button
		popbox.button.addClass("active");

		// Hide when popbox is blurred
		if (popbox.toggle=="click") {

			var doc = $(document);
			var hideOnClick = Popbox.toggleEvent + ".popbox." + popbox.uid;

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					// in mobile, we allow own button to click to close.
					if (window.es.mobile && targets.filter(popbox.tooltip).length > 0) {
						return;
					}


					// Don't hide popbox is popbox button or tooltip is one of those elements.
					if (!window.es.mobile && (targets.filter(popbox.button).length  > 0 ||
						targets.filter(popbox.tooltip).length > 0)) {
						return;
					}

					// Unbind hiding
					doc.off(hideOnClick);

					popbox.hide();
				});
		}

		// Reposition popbox when browser resized or zoomed
		var win = $(window),
			repositionOnResize = "resize.popbox" + popbox.uid;

		win
			.off(repositionOnResize)
			.on(repositionOnResize, function(){

				// Reposition popbox
				if (popbox.tooltip.length > 0) {
					popbox.tooltip
						.position(popbox.position);
				}
			});

		// If tooltip exists, just show tootip
		if (popbox.tooltip.length > 0) {

			popbox.tooltip
				.appendTo("body")
				.position(popbox.position);

			// Trigger popboxActivate event
			popbox.trigger("popboxActivate", [popbox]);

			return;
		}

		// If popbox content is a function,
		if ($.isFunction(popbox.content)) {

			// Execute the function and to get popbox options
			var options = popbox.content(popbox);

			// Update popbox with the new options
			popbox.update(options);

			// If updating popbox causes it to fall into wait mode, stop.
			if (popbox.wait) return;
		}

		// If at this point, popbox is not a deferred object,
		// then we don't have any tooltip to show.
		if (!$.isDeferred(popbox.content)) return;

		// If the popbox content is still loading,
		// show loading indicator.
		if (popbox.content.state()=="pending") {

			popbox.loader
				.appendTo("body")
				.position(popbox.position);

			// Trigger popboxLoading event
			popbox.trigger("popboxLoading", [popbox]);
		}

		popbox.content
			.always(function(){

				popbox.wait = false;
			})
			.done(function(html){

				// If popbox already has a tooltip, stop.
				if (popbox.tooltip.length > 0) return;

				// If popbox is disabled, don't show it.
				if (!popbox.enabled) return;

				// Remove loading indicator
				popbox.loader.detach();

				var tooltip = $.buildHTML(html);

				if (tooltip.filter("[data-popbox-tooltip]").length < 1) {

					var content = tooltip;

					tooltip =
						// Create wrapper and
						$('<div id="es" class="es popbox" data-popbox-tooltip><div class="arrow"></div><div class="popbox-content" data-popbox-content></div></div>')
							.attr({
								"id": popbox.id,
								"data-popbox-tooltip": popbox.type,
								"style": popbox.fixed ? 'position: fixed' : ''
							})
							.addClass(popbox.component)
							.addClass("popbox-" + popbox.type)
							// append to body first because
							.appendTo("body");

					if (window.es.mobile) {
						tooltip.addClass('is-mobile');
					}

					if (window.es.android) {
						tooltip.addClass('is-android');
					}

					if (window.es.ios) {
						tooltip.addClass('is-ios');
					}

					// We want any possible scripts within the tooltip
					// content to execute when it is visible in DOM.
					tooltip
						.find('[data-popbox-content]')
						.append(content);

				} else {

					tooltip =
						// This tooltip might be an array of elements, e.g.
						// tooltip div, scripts and text nodes.
						tooltip
							// we append to body first to
							// let the scripts execute
							.appendTo("body")
							// then filter out the popbox tooltip
							// to assign it back as our variable
							.filter("[data-popbox-tooltip]");
				}

				// Store tooltip property in popbox
				popbox.tooltip =
					tooltip
						// and let tooltip has a reference back to popbox
						.data("popbox", popbox)
						// reposition tooltip
						.position(popbox.position);

				// Find any labels on the popbox and we need to prevent it from doing any bubbling up
				popbox
					.tooltip
					.find('label')
					.on('click', function(event) {
						event.preventDefault();
						event.stopPropagation();

						// Find the target
						var target = popbox.tooltip.find('#' + $(this).attr('for'));

						if (target.length > 0) {
							if (target.is(':checkbox')) {
								target.click();
							} else {
								target.focus();
							}
						}

						return;

					});
				// Trigger popboxActivate event
				popbox.trigger("popboxActivate", [popbox]);
			})
			.fail(function(){
				var errorMessage = $('[data-es-popbox-error]').text();

				// safe check
				if (errorMessage.length <= 0 || errorMessage.indexOf('COM_EASYSOCIAL_') >= 0) {
					errorMessage = 'Unable to load tooltip content.';
				}

				popbox.update({
					content: errorMessage
				});
			});
	},

	hide: function(force) {

		var popbox = this;

		// Disable popbox
		popbox.enabled = false;

		// Stop any previous hide timer
		clearTimeout(popbox.hideTimer);

		// Detach popbox loader
		popbox.loader.detach();

		var hide = function(){

			if (popbox.locked && !force) return;

			// Detach tooltip
			popbox.tooltip
				.detach();

			// Detach repositionOnResize
			$(window).off("resize.popbox" + popbox.uid);

			// Trigger popboxDeactivate event
			popbox.trigger("popboxDeactivate", [popbox]);

			if (!popbox.cache) {
				popbox.destroy();
			}
		}

		// Removed active for button
		popbox.button.removeClass("active");
		var delay = popbox.hideDelay;

		if (force) {delay = 0}

		popbox.hideTimer = setTimeout(hide, delay);
	},

	destroy: function() {
		this.button.removeData("popbox");
	},

	widget: function() {

		return this;
	}
});

// Data API
$(document)
	.on(Popbox.toggleEvent + '.popbox', '[data-popbox]', function(){

		var popbox = $(this).popbox("widget");

		if (popbox.toggle=="hover") {
			return;
		}

		if (popbox.enabled) {
			popbox.hide();
		} else {
			popbox.show();
		}
	})
	.on('mouseover.popbox', '[data-popbox]', function(){
		var popbox = $(this).popbox("widget");

		if (popbox.toggle=="hover" && !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))) popbox.show();
	})
	.on('mouseout.popbox', '[data-popbox]', function(){

		var popbox = $(this).popbox("widget");

		if (popbox.toggle=="hover") popbox.hide();

		// if (popbox.toggle=="hover" && !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))) popbox.hide();
	})
	.on('mouseover.popbox.tooltip', '[data-popbox-tooltip]', function(){

		var popbox = Popbox.get(this);

		if (!popbox) return;

		if (popbox.toggle!=="hover") return;

		// Lock popbox
		popbox.locked = true;

		clearTimeout(popbox.hideTimer);
	})
	.on('mouseout.popbox.tooltip', '[data-popbox-tooltip]', function(){

		var popbox = Popbox.get(this);

		if (!popbox) return;

		if (popbox.toggle!=="hover") return;

		// Unlock popbox
		popbox.locked = false;

		// Hide popbox
		popbox.hide();
	})
	.on('click.popbox.close', '[data-popbox-close]', function(){

		var popbox = Popbox.get($(this).parents('[data-popbox-tooltip]'));

		if (!popbox) return;

		popbox.hide();
	});
};

exports();
module.resolveWith(exports);

});
// module body: end

};
// module factory: end

FD40.module("popbox", moduleFactory);

}());
			(function(){

var moduleFactory = function($) {

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery.scrollTo
 * Copyright (c) 2007-2015 Ariel Flesler - aflesler  gmail  com | http://flesler.blogspot.com
 * Licensed under MIT
 * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
 * @projectDescription Lightweight, cross-browser and highly customizable animated scrolling with jQuery
 * @author Ariel Flesler
 * @version 2.1.2
 */
;(function($) {
	'use strict';

	var $scrollTo = $.scrollTo = function(target, duration, settings) {
		return $(window).scrollTo(target, duration, settings);
	};

	$scrollTo.defaults = {
		axis:'xy',
		duration: 0,
		limit:true
	};

	function isWin(elem) {
		return !elem.nodeName ||
			$.inArray(elem.nodeName.toLowerCase(), ['iframe','#document','html','body']) !== -1;
	}		

	$.fn.scrollTo = function(target, duration, settings) {
		if (typeof duration === 'object') {
			settings = duration;
			duration = 0;
		}
		if (typeof settings === 'function') {
			settings = { onAfter:settings };
		}
		if (target === 'max') {
			target = 9e9;
		}

		settings = $.extend({}, $scrollTo.defaults, settings);
		// Speed is still recognized for backwards compatibility
		duration = duration || settings.duration;
		// Make sure the settings are given right
		var queue = settings.queue && settings.axis.length > 1;
		if (queue) {
			// Let's keep the overall duration
			duration /= 2;
		}
		settings.offset = both(settings.offset);
		settings.over = both(settings.over);

		return this.each(function() {
			// Null target yields nothing, just like jQuery does
			if (target === null) return;

			var win = isWin(this),
				elem = win ? this.contentWindow || window : this,
				$elem = $(elem),
				targ = target, 
				attr = {},
				toff;

			switch (typeof targ) {
				// A number will pass the regex
				case 'number':
				case 'string':
					if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
						targ = both(targ);
						// We are done
						break;
					}
					// Relative/Absolute selector
					targ = win ? $(targ) : $(targ, elem);
					/* falls through */
				case 'object':
					if (targ.length === 0) return;
					// DOMElement / jQuery
					if (targ.is || targ.style) {
						// Get the real position of the target
						toff = (targ = $(targ)).offset();
					}
			}

			var offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;

			$.each(settings.axis.split(''), function(i, axis) {
				var Pos	= axis === 'x' ? 'Left' : 'Top',
					pos = Pos.toLowerCase(),
					key = 'scroll' + Pos,
					prev = $elem[key](),
					max = $scrollTo.max(elem, axis);

				if (toff) {// jQuery / DOMElement
					attr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);

					// If it's a dom element, reduce the margin
					if (settings.margin) {
						attr[key] -= parseInt(targ.css('margin'+Pos), 10) || 0;
						attr[key] -= parseInt(targ.css('border'+Pos+'Width'), 10) || 0;
					}

					attr[key] += offset[pos] || 0;

					if (settings.over[pos]) {
						// Scroll to a fraction of its width/height
						attr[key] += targ[axis === 'x'?'width':'height']() * settings.over[pos];
					}
				} else {
					var val = targ[pos];
					// Handle percentage values
					attr[key] = val.slice && val.slice(-1) === '%' ?
						parseFloat(val) / 100 * max
						: val;
				}

				// Number or 'number'
				if (settings.limit && /^\d+$/.test(attr[key])) {
					// Check the limits
					attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);
				}

				// Don't waste time animating, if there's no need.
				if (!i && settings.axis.length > 1) {
					if (prev === attr[key]) {
						// No animation needed
						attr = {};
					} else if (queue) {
						// Intermediate animation
						animate(settings.onAfterFirst);
						// Don't animate this axis again in the next iteration.
						attr = {};
					}
				}
			});

			animate(settings.onAfter);

			function animate(callback) {
				var opts = $.extend({}, settings, {
					// The queue setting conflicts with animate()
					// Force it to always be true
					queue: true,
					duration: duration,
					complete: callback && function() {
						callback.call(elem, targ, settings);
					}
				});
				$elem.animate(attr, opts);
			}
		});
	};

	$.fn.scrollIntoView = function(target) {

		// TODO: Add support for X axis.
		// TODO: Add support for passing in custom options.

		var target = $(target);
		if (target.length < 1) return;

		var viewportOffset = this.offset(),
			viewportHeight = this.height(),
			viewportTop    = viewportOffset.top,
			viewportBottom = viewportTop + viewportHeight,

			targetOffset = target.offset(),
			targetHeight = target.height(),
			targetTop    = targetOffset.top,
			targetBottom = targetTop + targetHeight;

		if (targetBottom > viewportBottom) {
			return this.scrollTo(target);
		}

		if (targetTop < viewportTop) {
			return this.scrollTo(target, {offset: (viewportHeight - targetHeight) * -1});
		}
	};

	// Max scrolling position, works on quirks mode
	// It only fails (not too badly) on IE, quirks mode.
	$scrollTo.max = function(elem, axis) {
		var Dim = axis === 'x' ? 'Width' : 'Height',
			scroll = 'scroll'+Dim;

		if (!isWin(elem))
			return elem[scroll] - $(elem)[Dim.toLowerCase()]();

		var size = 'client' + Dim,
			doc = elem.ownerDocument || elem.document,
			html = doc.documentElement,
			body = doc.body;

		return Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size]);
	};

	function both(val) {
		return $.isFunction(val) || $.isPlainObject(val) ? val : { top:val, left:val };
	}

	// Add special hooks so that window scroll properties can be animated
	$.Tween.propHooks.scrollLeft = 
	$.Tween.propHooks.scrollTop = {
		get: function(t) {
			return $(t.elem)[t.prop]();
		},
		set: function(t) {
			var curr = this.get(t);
			// If interrupt is true and user scrolled, stop animating
			if (t.options.interrupt && t._last && t._last !== curr) {
				return $(t.elem).stop();
			}
			var next = Math.round(t.now);
			// Don't waste CPU
			// Browsers don't render floating point scroll
			if (curr !== next) {
				$(t.elem)[t.prop](next);
				t._last = this.get(t);
			}
		}
	};

	// AMD requirement
	return $scrollTo;
})(jQuery);
}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("scrollTo", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() {

var jQuery = $;

/*!
 * Select2 4.0.3
 * https://select2.github.io
 *
 * Released under the MIT license
 * https://github.com/select2/select2/blob/master/LICENSE.md
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
	// AMD. Register as an anonymous module.
	define(['jquery'], factory);
  } else if (typeof exports === 'object') {
	// Node/CommonJS
	factory(require('jquery'));
  } else {
	// Browser globals
	factory(jQuery);
  }
}(function (jQuery) {
  // This is needed so we can catch the AMD loader configuration and use it
  // The inner file should be wrapped (by `banner.start.js`) in a function that
  // returns the AMD loader references.
  var S2 =
(function () {
  // Restore the Select2 AMD loader so it can be used
  // Needed mostly in the language files, where the loader is not inserted
  if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
	var S2 = jQuery.fn.select2.amd;
  }
var S2;(function () { if (!S2 || !S2.requirejs) {
if (!S2) { S2 = {}; } else { require = S2; }
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
	var main, req, makeMap, handlers,
		defined = {},
		waiting = {},
		config = {},
		defining = {},
		hasOwn = Object.prototype.hasOwnProperty,
		aps = [].slice,
		jsSuffixRegExp = /\.js$/;

	function hasProp(obj, prop) {
		return hasOwn.call(obj, prop);
	}

	/**
	 * Given a relative module name, like ./something, normalize it to
	 * a real name that can be mapped to a path.
	 * @param {String} name the relative name
	 * @param {String} baseName a real name that the name arg is relative
	 * to.
	 * @returns {String} normalized name
	 */
	function normalize(name, baseName) {
		var nameParts, nameSegment, mapValue, foundMap, lastIndex,
			foundI, foundStarMap, starI, i, j, part,
			baseParts = baseName && baseName.split("/"),
			map = config.map,
			starMap = (map && map['*']) || {};

		//Adjust any relative paths.
		if (name && name.charAt(0) === ".") {
			//If have a base name, try to normalize against it,
			//otherwise, assume it is a top-level require that will
			//be relative to baseUrl in the end.
			if (baseName) {
				name = name.split('/');
				lastIndex = name.length - 1;

				// Node .js allowance:
				if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
					name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
				}

				//Lop off the last part of baseParts, so that . matches the
				//"directory" and not name of the baseName's module. For instance,
				//baseName of "one/two/three", maps to "one/two/three.js", but we
				//want the directory, "one/two" for this normalization.
				name = baseParts.slice(0, baseParts.length - 1).concat(name);

				//start trimDots
				for (i = 0; i < name.length; i += 1) {
					part = name[i];
					if (part === ".") {
						name.splice(i, 1);
						i -= 1;
					} else if (part === "..") {
						if (i === 1 && (name[2] === '..' || name[0] === '..')) {
							//End of the line. Keep at least one non-dot
							//path segment at the front so it can be mapped
							//correctly to disk. Otherwise, there is likely
							//no path mapping for a path starting with '..'.
							//This can still fail, but catches the most reasonable
							//uses of ..
							break;
						} else if (i > 0) {
							name.splice(i - 1, 2);
							i -= 2;
						}
					}
				}
				//end trimDots

				name = name.join("/");
			} else if (name.indexOf('./') === 0) {
				// No baseName, so this is ID is resolved relative
				// to baseUrl, pull off the leading dot.
				name = name.substring(2);
			}
		}

		//Apply map config if available.
		if ((baseParts || starMap) && map) {
			nameParts = name.split('/');

			for (i = nameParts.length; i > 0; i -= 1) {
				nameSegment = nameParts.slice(0, i).join("/");

				if (baseParts) {
					//Find the longest baseName segment match in the config.
					//So, do joins on the biggest to smallest lengths of baseParts.
					for (j = baseParts.length; j > 0; j -= 1) {
						mapValue = map[baseParts.slice(0, j).join('/')];

						//baseName segment has  config, find if it has one for
						//this name.
						if (mapValue) {
							mapValue = mapValue[nameSegment];
							if (mapValue) {
								//Match, update name to the new value.
								foundMap = mapValue;
								foundI = i;
								break;
							}
						}
					}
				}

				if (foundMap) {
					break;
				}

				//Check for a star map match, but just hold on to it,
				//if there is a shorter segment match later in a matching
				//config, then favor over this star map.
				if (!foundStarMap && starMap && starMap[nameSegment]) {
					foundStarMap = starMap[nameSegment];
					starI = i;
				}
			}

			if (!foundMap && foundStarMap) {
				foundMap = foundStarMap;
				foundI = starI;
			}

			if (foundMap) {
				nameParts.splice(0, foundI, foundMap);
				name = nameParts.join('/');
			}
		}

		return name;
	}

	function makeRequire(relName, forceSync) {
		return function () {
			//A version of a require function that passes a moduleName
			//value for items that may need to
			//look up paths relative to the moduleName
			var args = aps.call(arguments, 0);

			//If first arg is not require('string'), and there is only
			//one arg, it is the array form without a callback. Insert
			//a null so that the following concat is correct.
			if (typeof args[0] !== 'string' && args.length === 1) {
				args.push(null);
			}
			return req.apply(undef, args.concat([relName, forceSync]));
		};
	}

	function makeNormalize(relName) {
		return function (name) {
			return normalize(name, relName);
		};
	}

	function makeLoad(depName) {
		return function (value) {
			defined[depName] = value;
		};
	}

	function callDep(name) {
		if (hasProp(waiting, name)) {
			var args = waiting[name];
			delete waiting[name];
			defining[name] = true;
			main.apply(undef, args);
		}

		if (!hasProp(defined, name) && !hasProp(defining, name)) {
			throw new Error('No ' + name);
		}
		return defined[name];
	}

	//Turns a plugin!resource to [plugin, resource]
	//with the plugin being undefined if the name
	//did not have a plugin prefix.
	function splitPrefix(name) {
		var prefix,
			index = name ? name.indexOf('!') : -1;
		if (index > -1) {
			prefix = name.substring(0, index);
			name = name.substring(index + 1, name.length);
		}
		return [prefix, name];
	}

	/**
	 * Makes a name map, normalizing the name, and using a plugin
	 * for normalization if necessary. Grabs a ref to plugin
	 * too, as an optimization.
	 */
	makeMap = function (name, relName) {
		var plugin,
			parts = splitPrefix(name),
			prefix = parts[0];

		name = parts[1];

		if (prefix) {
			prefix = normalize(prefix, relName);
			plugin = callDep(prefix);
		}

		//Normalize according
		if (prefix) {
			if (plugin && plugin.normalize) {
				name = plugin.normalize(name, makeNormalize(relName));
			} else {
				name = normalize(name, relName);
			}
		} else {
			name = normalize(name, relName);
			parts = splitPrefix(name);
			prefix = parts[0];
			name = parts[1];
			if (prefix) {
				plugin = callDep(prefix);
			}
		}

		//Using ridiculous property names for space reasons
		return {
			f: prefix ? prefix + '!' + name : name, //fullName
			n: name,
			pr: prefix,
			p: plugin
		};
	};

	function makeConfig(name) {
		return function () {
			return (config && config.config && config.config[name]) || {};
		};
	}

	handlers = {
		require: function (name) {
			return makeRequire(name);
		},
		exports: function (name) {
			var e = defined[name];
			if (typeof e !== 'undefined') {
				return e;
			} else {
				return (defined[name] = {});
			}
		},
		module: function (name) {
			return {
				id: name,
				uri: '',
				exports: defined[name],
				config: makeConfig(name)
			};
		}
	};

	main = function (name, deps, callback, relName) {
		var cjsModule, depName, ret, map, i,
			args = [],
			callbackType = typeof callback,
			usingExports;

		//Use name if no relName
		relName = relName || name;

		//Call the callback to define the module, if necessary.
		if (callbackType === 'undefined' || callbackType === 'function') {
			//Pull out the defined dependencies and pass the ordered
			//values to the callback.
			//Default to [require, exports, module] if no deps
			deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
			for (i = 0; i < deps.length; i += 1) {
				map = makeMap(deps[i], relName);
				depName = map.f;

				//Fast path CommonJS standard dependencies.
				if (depName === "require") {
					args[i] = handlers.require(name);
				} else if (depName === "exports") {
					//CommonJS module spec 1.1
					args[i] = handlers.exports(name);
					usingExports = true;
				} else if (depName === "module") {
					//CommonJS module spec 1.1
					cjsModule = args[i] = handlers.module(name);
				} else if (hasProp(defined, depName) ||
						   hasProp(waiting, depName) ||
						   hasProp(defining, depName)) {
					args[i] = callDep(depName);
				} else if (map.p) {
					map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
					args[i] = defined[depName];
				} else {
					throw new Error(name + ' missing ' + depName);
				}
			}

			ret = callback ? callback.apply(defined[name], args) : undefined;

			if (name) {
				//If setting exports via "module" is in play,
				//favor that over return value and exports. After that,
				//favor a non-undefined return value over exports use.
				if (cjsModule && cjsModule.exports !== undef &&
						cjsModule.exports !== defined[name]) {
					defined[name] = cjsModule.exports;
				} else if (ret !== undef || !usingExports) {
					//Use the return value from the function.
					defined[name] = ret;
				}
			}
		} else if (name) {
			//May just be an object definition for the module. Only
			//worry about defining if have a module name.
			defined[name] = callback;
		}
	};

	requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
		if (typeof deps === "string") {
			if (handlers[deps]) {
				//callback in this case is really relName
				return handlers[deps](callback);
			}
			//Just return the module wanted. In this scenario, the
			//deps arg is the module name, and second arg (if passed)
			//is just the relName.
			//Normalize module name, if it contains . or ..
			return callDep(makeMap(deps, callback).f);
		} else if (!deps.splice) {
			//deps is a config object, not an array.
			config = deps;
			if (config.deps) {
				req(config.deps, config.callback);
			}
			if (!callback) {
				return;
			}

			if (callback.splice) {
				//callback is an array, which means it is a dependency list.
				//Adjust args if there are dependencies
				deps = callback;
				callback = relName;
				relName = null;
			} else {
				deps = undef;
			}
		}

		//Support require(['a'])
		callback = callback || function () {};

		//If relName is a function, it is an errback handler,
		//so remove it.
		if (typeof relName === 'function') {
			relName = forceSync;
			forceSync = alt;
		}

		//Simulate async callback;
		if (forceSync) {
			main(undef, deps, callback, relName);
		} else {
			//Using a non-zero value because of concern for what old browsers
			//do, and latest browsers "upgrade" to 4 if lower value is used:
			//http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
			//If want a value immediately, use require('id') instead -- something
			//that works in almond on the global level, but not guaranteed and
			//unlikely to work in other AMD implementations.
			setTimeout(function () {
				main(undef, deps, callback, relName);
			}, 4);
		}

		return req;
	};

	/**
	 * Just drops the config on the floor, but returns req in case
	 * the config return value is used.
	 */
	req.config = function (cfg) {
		return req(cfg);
	};

	/**
	 * Expose module registry for debugging and tooling
	 */
	requirejs._defined = defined;

	define = function (name, deps, callback) {
		if (typeof name !== 'string') {
			throw new Error('See almond README: incorrect module build, no module name');
		}

		//This module may not have dependencies
		if (!deps.splice) {
			//deps is not an array, so probably means
			//an object literal or factory function for
			//the value. Adjust args.
			callback = deps;
			deps = [];
		}

		if (!hasProp(defined, name) && !hasProp(waiting, name)) {
			waiting[name] = [name, deps, callback];
		}
	};

	define.amd = {
		jQuery: true
	};
}());

S2.requirejs = requirejs;S2.require = require;S2.define = define;
}
}());
S2.define("almond", function(){});

/* global jQuery:false, $:false */
S2.define('jquery',[],function () {
  var _$ = jQuery || $;

  if (_$ == null && console && console.error) {
	console.error(
	  'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
	  'found. Make sure that you are including jQuery before Select2 on your ' +
	  'web page.'
	);
  }

  return _$;
});

S2.define('select2/utils',[
  'jquery'
], function ($) {
  var Utils = {};

  Utils.Extend = function (ChildClass, SuperClass) {
	var __hasProp = {}.hasOwnProperty;

	function BaseConstructor () {
	  this.constructor = ChildClass;
	}

	for (var key in SuperClass) {
	  if (__hasProp.call(SuperClass, key)) {
		ChildClass[key] = SuperClass[key];
	  }
	}

	BaseConstructor.prototype = SuperClass.prototype;
	ChildClass.prototype = new BaseConstructor();
	ChildClass.__super__ = SuperClass.prototype;

	return ChildClass;
  };

  function getMethods (theClass) {
	var proto = theClass.prototype;

	var methods = [];

	for (var methodName in proto) {
	  var m = proto[methodName];

	  if (typeof m !== 'function') {
		continue;
	  }

	  if (methodName === 'constructor') {
		continue;
	  }

	  methods.push(methodName);
	}

	return methods;
  }

  Utils.Decorate = function (SuperClass, DecoratorClass) {
	var decoratedMethods = getMethods(DecoratorClass);
	var superMethods = getMethods(SuperClass);

	function DecoratedClass () {
	  var unshift = Array.prototype.unshift;

	  var argCount = DecoratorClass.prototype.constructor.length;

	  var calledConstructor = SuperClass.prototype.constructor;

	  if (argCount > 0) {
		unshift.call(arguments, SuperClass.prototype.constructor);

		calledConstructor = DecoratorClass.prototype.constructor;
	  }

	  calledConstructor.apply(this, arguments);
	}

	DecoratorClass.displayName = SuperClass.displayName;

	function ctr () {
	  this.constructor = DecoratedClass;
	}

	DecoratedClass.prototype = new ctr();

	for (var m = 0; m < superMethods.length; m++) {
		var superMethod = superMethods[m];

		DecoratedClass.prototype[superMethod] =
		  SuperClass.prototype[superMethod];
	}

	var calledMethod = function (methodName) {
	  // Stub out the original method if it's not decorating an actual method
	  var originalMethod = function () {};

	  if (methodName in DecoratedClass.prototype) {
		originalMethod = DecoratedClass.prototype[methodName];
	  }

	  var decoratedMethod = DecoratorClass.prototype[methodName];

	  return function () {
		var unshift = Array.prototype.unshift;

		unshift.call(arguments, originalMethod);

		return decoratedMethod.apply(this, arguments);
	  };
	};

	for (var d = 0; d < decoratedMethods.length; d++) {
	  var decoratedMethod = decoratedMethods[d];

	  DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
	}

	return DecoratedClass;
  };

  var Observable = function () {
	this.listeners = {};
  };

  Observable.prototype.on = function (event, callback) {
	this.listeners = this.listeners || {};

	if (event in this.listeners) {
	  this.listeners[event].push(callback);
	} else {
	  this.listeners[event] = [callback];
	}
  };

  Observable.prototype.trigger = function (event) {
	var slice = Array.prototype.slice;
	var params = slice.call(arguments, 1);

	this.listeners = this.listeners || {};

	// Params should always come in as an array
	if (params == null) {
	  params = [];
	}

	// If there are no arguments to the event, use a temporary object
	if (params.length === 0) {
	  params.push({});
	}

	// Set the `_type` of the first object to the event
	params[0]._type = event;

	if (event in this.listeners) {
	  this.invoke(this.listeners[event], slice.call(arguments, 1));
	}

	if ('*' in this.listeners) {
	  this.invoke(this.listeners['*'], arguments);
	}
  };

  Observable.prototype.invoke = function (listeners, params) {
	for (var i = 0, len = listeners.length; i < len; i++) {
	  listeners[i].apply(this, params);
	}
  };

  Utils.Observable = Observable;

  Utils.generateChars = function (length) {
	var chars = '';

	for (var i = 0; i < length; i++) {
	  var randomChar = Math.floor(Math.random() * 36);
	  chars += randomChar.toString(36);
	}

	return chars;
  };

  Utils.bind = function (func, context) {
	return function () {
	  func.apply(context, arguments);
	};
  };

  Utils._convertData = function (data) {
	for (var originalKey in data) {
	  var keys = originalKey.split('-');

	  var dataLevel = data;

	  if (keys.length === 1) {
		continue;
	  }

	  for (var k = 0; k < keys.length; k++) {
		var key = keys[k];

		// Lowercase the first letter
		// By default, dash-separated becomes camelCase
		key = key.substring(0, 1).toLowerCase() + key.substring(1);

		if (!(key in dataLevel)) {
		  dataLevel[key] = {};
		}

		if (k == keys.length - 1) {
		  dataLevel[key] = data[originalKey];
		}

		dataLevel = dataLevel[key];
	  }

	  delete data[originalKey];
	}

	return data;
  };

  Utils.hasScroll = function (index, el) {
	// Adapted from the function created by @ShadowScripter
	// and adapted by @BillBarry on the Stack Exchange Code Review website.
	// The original code can be found at
	// http://codereview.stackexchange.com/q/13338
	// and was designed to be used with the Sizzle selector engine.

	var $el = $(el);
	var overflowX = el.style.overflowX;
	var overflowY = el.style.overflowY;

	//Check both x and y declarations
	if (overflowX === overflowY &&
		(overflowY === 'hidden' || overflowY === 'visible')) {
	  return false;
	}

	if (overflowX === 'scroll' || overflowY === 'scroll') {
	  return true;
	}

	return ($el.innerHeight() < el.scrollHeight ||
	  $el.innerWidth() < el.scrollWidth);
  };

  Utils.escapeMarkup = function (markup) {
	var replaceMap = {
	  '\\': '&#92;',
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  '\'': '&#39;',
	  '/': '&#47;'
	};

	// Do not try to escape the markup if it's not a string
	if (typeof markup !== 'string') {
	  return markup;
	}

	return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
	  return replaceMap[match];
	});
  };

  // Append an array of jQuery nodes to a given element.
  Utils.appendMany = function ($element, $nodes) {
	// jQuery 1.7.x does not support $.fn.append() with an array
	// Fall back to a jQuery object collection using $.fn.add()
	if ($.fn.jquery.substr(0, 3) === '1.7') {
	  var $jqNodes = $();

	  $.map($nodes, function (node) {
		$jqNodes = $jqNodes.add(node);
	  });

	  $nodes = $jqNodes;
	}

	$element.append($nodes);
  };

  return Utils;
});

S2.define('select2/results',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Results ($element, options, dataAdapter) {
	this.$element = $element;
	this.data = dataAdapter;
	this.options = options;

	Results.__super__.constructor.call(this);
  }

  Utils.Extend(Results, Utils.Observable);

  Results.prototype.render = function () {
	var $results = $(
	  '<ul class="select2-results__options" role="tree"></ul>'
	);

	if (this.options.get('multiple')) {
	  $results.attr('aria-multiselectable', 'true');
	}

	this.$results = $results;

	return $results;
  };

  Results.prototype.clear = function () {
	this.$results.empty();
  };

  Results.prototype.displayMessage = function (params) {
	var escapeMarkup = this.options.get('escapeMarkup');

	this.clear();
	this.hideLoading();

	var $message = $(
	  '<li role="treeitem" aria-live="assertive"' +
	  ' class="select2-results__option"></li>'
	);

	var message = this.options.get('translations').get(params.message);

	$message.append(
	  escapeMarkup(
		message(params.args)
	  )
	);

	$message[0].className += ' select2-results__message';

	this.$results.append($message);
  };

  Results.prototype.hideMessages = function () {
	this.$results.find('.select2-results__message').remove();
  };

  Results.prototype.append = function (data) {
	this.hideLoading();

	var $options = [];

	if (data.results == null || data.results.length === 0) {
	  if (this.$results.children().length === 0) {
		this.trigger('results:message', {
		  message: 'noResults'
		});
	  }

	  return;
	}

	data.results = this.sort(data.results);

	for (var d = 0; d < data.results.length; d++) {
	  var item = data.results[d];

	  var $option = this.option(item);

	  $options.push($option);
	}

	this.$results.append($options);
  };

  Results.prototype.position = function ($results, $dropdown) {
	var $resultsContainer = $dropdown.find('.select2-results');
	$resultsContainer.append($results);
  };

  Results.prototype.sort = function (data) {
	var sorter = this.options.get('sorter');

	return sorter(data);
  };

  Results.prototype.highlightFirstItem = function () {
	var $options = this.$results
	  .find('.select2-results__option[aria-selected]');

	var $selected = $options.filter('[aria-selected=true]');

	// Check if there are any selected options
	if ($selected.length > 0) {
	  // If there are selected options, highlight the first
	  $selected.first().trigger('mouseenter');
	} else {
	  // If there are no selected options, highlight the first option
	  // in the dropdown
	  $options.first().trigger('mouseenter');
	}

	this.ensureHighlightVisible();
  };

  Results.prototype.setClasses = function () {
	var self = this;

	this.data.current(function (selected) {
	  var selectedIds = $.map(selected, function (s) {
		return s.id.toString();
	  });

	  var $options = self.$results
		.find('.select2-results__option[aria-selected]');

	  $options.each(function () {
		var $option = $(this);

		var item = $.data(this, 'data');

		// id needs to be converted to a string when comparing
		var id = '' + item.id;

		if ((item.element != null && item.element.selected) ||
			(item.element == null && $.inArray(id, selectedIds) > -1)) {
		  $option.attr('aria-selected', 'true');
		} else {
		  $option.attr('aria-selected', 'false');
		}
	  });

	});
  };

  Results.prototype.showLoading = function (params) {
	this.hideLoading();

	var loadingMore = this.options.get('translations').get('searching');

	var loading = {
	  disabled: true,
	  loading: true,
	  text: loadingMore(params)
	};
	var $loading = this.option(loading);
	$loading.className += ' loading-results';

	this.$results.prepend($loading);
  };

  Results.prototype.hideLoading = function () {
	this.$results.find('.loading-results').remove();
  };

  Results.prototype.option = function (data) {
	var option = document.createElement('li');
	option.className = 'select2-results__option';

	var attrs = {
	  'role': 'treeitem',
	  'aria-selected': 'false'
	};

	if (data.disabled) {
	  delete attrs['aria-selected'];
	  attrs['aria-disabled'] = 'true';
	}

	if (data.id == null) {
	  delete attrs['aria-selected'];
	}

	if (data._resultId != null) {
	  option.id = data._resultId;
	}

	if (data.title) {
	  option.title = data.title;
	}

	if (data.children) {
	  attrs.role = 'group';
	  attrs['aria-label'] = data.text;
	  delete attrs['aria-selected'];
	}

	for (var attr in attrs) {
	  var val = attrs[attr];

	  option.setAttribute(attr, val);
	}

	if (data.children) {
	  var $option = $(option);

	  var label = document.createElement('strong');
	  label.className = 'select2-results__group';

	  var $label = $(label);
	  this.template(data, label);

	  var $children = [];

	  for (var c = 0; c < data.children.length; c++) {
		var child = data.children[c];

		var $child = this.option(child);

		$children.push($child);
	  }

	  var $childrenContainer = $('<ul></ul>', {
		'class': 'select2-results__options select2-results__options--nested'
	  });

	  $childrenContainer.append($children);

	  $option.append(label);
	  $option.append($childrenContainer);
	} else {
	  this.template(data, option);
	}

	$.data(option, 'data', data);

	return option;
  };

  Results.prototype.bind = function (container, $container) {
	var self = this;

	var id = container.id + '-results';

	this.$results.attr('id', id);

	container.on('results:all', function (params) {
	  self.clear();
	  self.append(params.data);

	  if (container.isOpen()) {
		self.setClasses();
		self.highlightFirstItem();
	  }
	});

	container.on('results:append', function (params) {
	  self.append(params.data);

	  if (container.isOpen()) {
		self.setClasses();
	  }
	});

	container.on('query', function (params) {
	  self.hideMessages();
	  self.showLoading(params);
	});

	container.on('select', function () {
	  if (!container.isOpen()) {
		return;
	  }

	  self.setClasses();
	  self.highlightFirstItem();
	});

	container.on('unselect', function () {
	  if (!container.isOpen()) {
		return;
	  }

	  self.setClasses();
	  self.highlightFirstItem();
	});

	container.on('open', function () {
	  // When the dropdown is open, aria-expended="true"
	  self.$results.attr('aria-expanded', 'true');
	  self.$results.attr('aria-hidden', 'false');

	  self.setClasses();
	  self.ensureHighlightVisible();
	});

	container.on('close', function () {
	  // When the dropdown is closed, aria-expended="false"
	  self.$results.attr('aria-expanded', 'false');
	  self.$results.attr('aria-hidden', 'true');
	  self.$results.removeAttr('aria-activedescendant');
	});

	container.on('results:toggle', function () {
	  var $highlighted = self.getHighlightedResults();

	  if ($highlighted.length === 0) {
		return;
	  }

	  $highlighted.trigger('mouseup');
	});

	container.on('results:select', function () {
	  var $highlighted = self.getHighlightedResults();

	  if ($highlighted.length === 0) {
		return;
	  }

	  var data = $highlighted.data('data');

	  if ($highlighted.attr('aria-selected') == 'true') {
		self.trigger('close', {});
	  } else {
		self.trigger('select', {
		  data: data
		});
	  }
	});

	container.on('results:previous', function () {
	  var $highlighted = self.getHighlightedResults();

	  var $options = self.$results.find('[aria-selected]');

	  var currentIndex = $options.index($highlighted);

	  // If we are already at te top, don't move further
	  if (currentIndex === 0) {
		return;
	  }

	  var nextIndex = currentIndex - 1;

	  // If none are highlighted, highlight the first
	  if ($highlighted.length === 0) {
		nextIndex = 0;
	  }

	  var $next = $options.eq(nextIndex);

	  $next.trigger('mouseenter');

	  var currentOffset = self.$results.offset().top;
	  var nextTop = $next.offset().top;
	  var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);

	  if (nextIndex === 0) {
		self.$results.scrollTop(0);
	  } else if (nextTop - currentOffset < 0) {
		self.$results.scrollTop(nextOffset);
	  }
	});

	container.on('results:next', function () {
	  var $highlighted = self.getHighlightedResults();

	  var $options = self.$results.find('[aria-selected]');

	  var currentIndex = $options.index($highlighted);

	  var nextIndex = currentIndex + 1;

	  // If we are at the last option, stay there
	  if (nextIndex >= $options.length) {
		return;
	  }

	  var $next = $options.eq(nextIndex);

	  $next.trigger('mouseenter');

	  var currentOffset = self.$results.offset().top +
		self.$results.outerHeight(false);
	  var nextBottom = $next.offset().top + $next.outerHeight(false);
	  var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;

	  if (nextIndex === 0) {
		self.$results.scrollTop(0);
	  } else if (nextBottom > currentOffset) {
		self.$results.scrollTop(nextOffset);
	  }
	});

	container.on('results:focus', function (params) {
	  params.element.addClass('select2-results__option--highlighted');
	});

	container.on('results:message', function (params) {
	  self.displayMessage(params);
	});

	if ($.fn.mousewheel) {
	  this.$results.on('mousewheel', function (e) {
		var top = self.$results.scrollTop();

		var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;

		var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
		var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

		if (isAtTop) {
		  self.$results.scrollTop(0);

		  e.preventDefault();
		  e.stopPropagation();
		} else if (isAtBottom) {
		  self.$results.scrollTop(
			self.$results.get(0).scrollHeight - self.$results.height()
		  );

		  e.preventDefault();
		  e.stopPropagation();
		}
	  });
	}

	this.$results.on('mouseup', '.select2-results__option[aria-selected]',
	  function (evt) {
	  var $this = $(this);

	  var data = $this.data('data');

	  if ($this.attr('aria-selected') === 'true') {
		if (self.options.get('multiple')) {
		  self.trigger('unselect', {
			originalEvent: evt,
			data: data
		  });
		} else {
		  self.trigger('close', {});
		}

		return;
	  }

	  self.trigger('select', {
		originalEvent: evt,
		data: data
	  });
	});

	this.$results.on('mouseenter', '.select2-results__option[aria-selected]',
	  function (evt) {
	  var data = $(this).data('data');

	  self.getHighlightedResults()
		  .removeClass('select2-results__option--highlighted');

	  self.trigger('results:focus', {
		data: data,
		element: $(this)
	  });
	});
  };

  Results.prototype.getHighlightedResults = function () {
	var $highlighted = this.$results
	.find('.select2-results__option--highlighted');

	return $highlighted;
  };

  Results.prototype.destroy = function () {
	this.$results.remove();
  };

  Results.prototype.ensureHighlightVisible = function () {
	var $highlighted = this.getHighlightedResults();

	if ($highlighted.length === 0) {
	  return;
	}

	var $options = this.$results.find('[aria-selected]');

	var currentIndex = $options.index($highlighted);

	var currentOffset = this.$results.offset().top;
	var nextTop = $highlighted.offset().top;
	var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);

	var offsetDelta = nextTop - currentOffset;
	nextOffset -= $highlighted.outerHeight(false) * 2;

	if (currentIndex <= 2) {
	  this.$results.scrollTop(0);
	} else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
	  this.$results.scrollTop(nextOffset);
	}
  };

  Results.prototype.template = function (result, container) {
	var template = this.options.get('templateResult');
	var escapeMarkup = this.options.get('escapeMarkup');

	var content = template(result, container);

	if (content == null) {
	  container.style.display = 'none';
	} else if (typeof content === 'string') {
	  container.innerHTML = escapeMarkup(content);
	} else {
	  $(container).append(content);
	}
  };

  return Results;
});

S2.define('select2/keys',[

], function () {
  var KEYS = {
	BACKSPACE: 8,
	TAB: 9,
	ENTER: 13,
	SHIFT: 16,
	CTRL: 17,
	ALT: 18,
	ESC: 27,
	SPACE: 32,
	PAGE_UP: 33,
	PAGE_DOWN: 34,
	END: 35,
	HOME: 36,
	LEFT: 37,
	UP: 38,
	RIGHT: 39,
	DOWN: 40,
	DELETE: 46
  };

  return KEYS;
});

S2.define('select2/selection/base',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function BaseSelection ($element, options) {
	this.$element = $element;
	this.options = options;

	BaseSelection.__super__.constructor.call(this);
  }

  Utils.Extend(BaseSelection, Utils.Observable);

  BaseSelection.prototype.render = function () {
	var $selection = $(
	  '<span class="select2-selection" role="combobox" ' +
	  ' aria-haspopup="true" aria-expanded="false">' +
	  '</span>'
	);

	this._tabindex = 0;

	if (this.$element.data('old-tabindex') != null) {
	  this._tabindex = this.$element.data('old-tabindex');
	} else if (this.$element.attr('tabindex') != null) {
	  this._tabindex = this.$element.attr('tabindex');
	}

	$selection.attr('title', this.$element.attr('title'));
	$selection.attr('tabindex', this._tabindex);

	this.$selection = $selection;

	return $selection;
  };

  BaseSelection.prototype.bind = function (container, $container) {
	var self = this;

	var id = container.id + '-container';
	var resultsId = container.id + '-results';

	this.container = container;

	this.$selection.on('focus', function (evt) {
	  self.trigger('focus', evt);
	});

	this.$selection.on('blur', function (evt) {
	  self._handleBlur(evt);
	});

	this.$selection.on('keydown', function (evt) {
	  self.trigger('keypress', evt);

	  if (evt.which === KEYS.SPACE) {
		evt.preventDefault();
	  }
	});

	container.on('results:focus', function (params) {
	  self.$selection.attr('aria-activedescendant', params.data._resultId);
	});

	container.on('selection:update', function (params) {
	  self.update(params.data);
	});

	container.on('open', function () {
	  // When the dropdown is open, aria-expanded="true"
	  self.$selection.attr('aria-expanded', 'true');
	  self.$selection.attr('aria-owns', resultsId);

	  self._attachCloseHandler(container);
	});

	container.on('close', function () {
	  // When the dropdown is closed, aria-expanded="false"
	  self.$selection.attr('aria-expanded', 'false');
	  self.$selection.removeAttr('aria-activedescendant');
	  self.$selection.removeAttr('aria-owns');

	  self.$selection.focus();

	  self._detachCloseHandler(container);
	});

	container.on('enable', function () {
	  self.$selection.attr('tabindex', self._tabindex);
	});

	container.on('disable', function () {
	  self.$selection.attr('tabindex', '-1');
	});
  };

  BaseSelection.prototype._handleBlur = function (evt) {
	var self = this;

	// This needs to be delayed as the active element is the body when the tab
	// key is pressed, possibly along with others.
	window.setTimeout(function () {
	  // Don't trigger `blur` if the focus is still in the selection
	  if (
		(document.activeElement == self.$selection[0]) ||
		($.contains(self.$selection[0], document.activeElement))
	  ) {
		return;
	  }

	  self.trigger('blur', evt);
	}, 1);
  };

  BaseSelection.prototype._attachCloseHandler = function (container) {
	var self = this;

	$(document.body).on('mousedown.select2.' + container.id, function (e) {
	  var $target = $(e.target);

	  var $select = $target.closest('.select2');

	  var $all = $('.select2.select2-container--open');

	  $all.each(function () {
		var $this = $(this);

		if (this == $select[0]) {
		  return;
		}

		var $element = $this.data('element');

		$element.select2('close');
	  });
	});
  };

  BaseSelection.prototype._detachCloseHandler = function (container) {
	$(document.body).off('mousedown.select2.' + container.id);
  };

  BaseSelection.prototype.position = function ($selection, $container) {
	var $selectionContainer = $container.find('.selection');
	$selectionContainer.append($selection);
  };

  BaseSelection.prototype.destroy = function () {
	this._detachCloseHandler(this.container);
  };

  BaseSelection.prototype.update = function (data) {
	throw new Error('The `update` method must be defined in child classes.');
  };

  return BaseSelection;
});

S2.define('select2/selection/single',[
  'jquery',
  './base',
  '../utils',
  '../keys'
], function ($, BaseSelection, Utils, KEYS) {
  function SingleSelection () {
	SingleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(SingleSelection, BaseSelection);

  SingleSelection.prototype.render = function () {
	var $selection = SingleSelection.__super__.render.call(this);

	$selection.addClass('select2-selection--single');

	$selection.html(
	  '<span class="select2-selection__rendered"></span>' +
	  '<span class="select2-selection__arrow" role="presentation">' +
		'<b role="presentation"></b>' +
	  '</span>'
	);

	return $selection;
  };

  SingleSelection.prototype.bind = function (container, $container) {
	var self = this;

	SingleSelection.__super__.bind.apply(this, arguments);

	var id = container.id + '-container';

	this.$selection.find('.select2-selection__rendered').attr('id', id);
	this.$selection.attr('aria-labelledby', id);

	this.$selection.on('mousedown', function (evt) {
	  // Only respond to left clicks
	  if (evt.which !== 1) {
		return;
	  }

	  self.trigger('toggle', {
		originalEvent: evt
	  });
	});

	this.$selection.on('focus', function (evt) {
	  // User focuses on the container
	});

	this.$selection.on('blur', function (evt) {
	  // User exits the container
	});

	container.on('focus', function (evt) {
	  if (!container.isOpen()) {
		self.$selection.focus();
	  }
	});

	container.on('selection:update', function (params) {
	  self.update(params.data);
	});
  };

  SingleSelection.prototype.clear = function () {
	this.$selection.find('.select2-selection__rendered').empty();
  };

  SingleSelection.prototype.display = function (data, container) {
	var template = this.options.get('templateSelection');
	var escapeMarkup = this.options.get('escapeMarkup');

	return escapeMarkup(template(data, container));
  };

  SingleSelection.prototype.selectionContainer = function () {
	return $('<span></span>');
  };

  SingleSelection.prototype.update = function (data) {
	if (data.length === 0) {
	  this.clear();
	  return;
	}

	var selection = data[0];

	var $rendered = this.$selection.find('.select2-selection__rendered');
	var formatted = this.display(selection, $rendered);

	$rendered.empty().append(formatted);
	$rendered.prop('title', selection.title || selection.text);
  };

  return SingleSelection;
});

S2.define('select2/selection/multiple',[
  'jquery',
  './base',
  '../utils'
], function ($, BaseSelection, Utils) {
  function MultipleSelection ($element, options) {
	MultipleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(MultipleSelection, BaseSelection);

  MultipleSelection.prototype.render = function () {
	var $selection = MultipleSelection.__super__.render.call(this);

	$selection.addClass('select2-selection--multiple');

	$selection.html(
	  '<ul class="select2-selection__rendered"></ul>'
	);

	return $selection;
  };

  MultipleSelection.prototype.bind = function (container, $container) {
	var self = this;

	MultipleSelection.__super__.bind.apply(this, arguments);

	this.$selection.on('click', function (evt) {
	  self.trigger('toggle', {
		originalEvent: evt
	  });
	});

	this.$selection.on(
	  'click',
	  '.select2-selection__choice__remove',
	  function (evt) {
		// Ignore the event if it is disabled
		if (self.options.get('disabled')) {
		  return;
		}

		var $remove = $(this);
		var $selection = $remove.parent();

		var data = $selection.data('data');

		self.trigger('unselect', {
		  originalEvent: evt,
		  data: data
		});
	  }
	);
  };

  MultipleSelection.prototype.clear = function () {
	this.$selection.find('.select2-selection__rendered').empty();
  };

  MultipleSelection.prototype.display = function (data, container) {
	var template = this.options.get('templateSelection');
	var escapeMarkup = this.options.get('escapeMarkup');

	return escapeMarkup(template(data, container));
  };

  MultipleSelection.prototype.selectionContainer = function () {
	var $container = $(
	  '<li class="select2-selection__choice">' +
		'<span class="select2-selection__choice__remove" role="presentation">' +
		  '&times;' +
		'</span>' +
	  '</li>'
	);

	return $container;
  };

  MultipleSelection.prototype.update = function (data) {
	this.clear();

	if (data.length === 0) {
	  return;
	}

	var $selections = [];

	for (var d = 0; d < data.length; d++) {
	  var selection = data[d];

	  var $selection = this.selectionContainer();
	  var formatted = this.display(selection, $selection);

	  $selection.append(formatted);
	  $selection.prop('title', selection.title || selection.text);

	  $selection.data('data', selection);

	  $selections.push($selection);
	}

	var $rendered = this.$selection.find('.select2-selection__rendered');

	Utils.appendMany($rendered, $selections);
  };

  return MultipleSelection;
});

S2.define('select2/selection/placeholder',[
  '../utils'
], function (Utils) {
  function Placeholder (decorated, $element, options) {
	this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

	decorated.call(this, $element, options);
  }

  Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
	if (typeof placeholder === 'string') {
	  placeholder = {
		id: '',
		text: placeholder
	  };
	}

	return placeholder;
  };

  Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
	var $placeholder = this.selectionContainer();

	$placeholder.html(this.display(placeholder));
	$placeholder.addClass('select2-selection__placeholder')
				.removeClass('select2-selection__choice');

	return $placeholder;
  };

  Placeholder.prototype.update = function (decorated, data) {
	var singlePlaceholder = (
	  data.length == 1 && data[0].id != this.placeholder.id
	);
	var multipleSelections = data.length > 1;

	if (multipleSelections || singlePlaceholder) {
	  return decorated.call(this, data);
	}

	this.clear();

	var $placeholder = this.createPlaceholder(this.placeholder);

	this.$selection.find('.select2-selection__rendered').append($placeholder);
  };

  return Placeholder;
});

S2.define('select2/selection/allowClear',[
  'jquery',
  '../keys'
], function ($, KEYS) {
  function AllowClear () { }

  AllowClear.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	if (this.placeholder == null) {
	  if (this.options.get('debug') && window.console && console.error) {
		console.error(
		  'Select2: The `allowClear` option should be used in combination ' +
		  'with the `placeholder` option.'
		);
	  }
	}

	this.$selection.on('mousedown', '.select2-selection__clear',
	  function (evt) {
		self._handleClear(evt);
	});

	container.on('keypress', function (evt) {
	  self._handleKeyboardClear(evt, container);
	});
  };

  AllowClear.prototype._handleClear = function (_, evt) {
	// Ignore the event if it is disabled
	if (this.options.get('disabled')) {
	  return;
	}

	var $clear = this.$selection.find('.select2-selection__clear');

	// Ignore the event if nothing has been selected
	if ($clear.length === 0) {
	  return;
	}

	evt.stopPropagation();

	var data = $clear.data('data');

	for (var d = 0; d < data.length; d++) {
	  var unselectData = {
		data: data[d]
	  };

	  // Trigger the `unselect` event, so people can prevent it from being
	  // cleared.
	  this.trigger('unselect', unselectData);

	  // If the event was prevented, don't clear it out.
	  if (unselectData.prevented) {
		return;
	  }
	}

	this.$element.val(this.placeholder.id).trigger('change');

	this.trigger('toggle', {});
  };

  AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
	if (container.isOpen()) {
	  return;
	}

	if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
	  this._handleClear(evt);
	}
  };

  AllowClear.prototype.update = function (decorated, data) {
	decorated.call(this, data);

	if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
		data.length === 0) {
	  return;
	}

	var $remove = $(
	  '<span class="select2-selection__clear">' +
		'&times;' +
	  '</span>'
	);
	$remove.data('data', data);

	this.$selection.find('.select2-selection__rendered').prepend($remove);
  };

  return AllowClear;
});

S2.define('select2/selection/search',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function Search (decorated, $element, options) {
	decorated.call(this, $element, options);
  }

  Search.prototype.render = function (decorated) {
	var $search = $(
	  '<li class="select2-search select2-search--inline">' +
		'<input class="select2-search__field" type="search" tabindex="-1"' +
		' autocomplete="off" autocorrect="off" autocapitalize="off"' +
		' spellcheck="false" role="textbox" aria-autocomplete="list" />' +
	  '</li>'
	);

	this.$searchContainer = $search;
	this.$search = $search.find('input');

	var $rendered = decorated.call(this);

	this._transferTabIndex();

	return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	container.on('open', function () {
	  self.$search.trigger('focus');
	});

	container.on('close', function () {
	  self.$search.val('');
	  self.$search.removeAttr('aria-activedescendant');
	  self.$search.trigger('focus');
	});

	container.on('enable', function () {
	  self.$search.prop('disabled', false);

	  self._transferTabIndex();
	});

	container.on('disable', function () {
	  self.$search.prop('disabled', true);
	});

	container.on('focus', function (evt) {
	  self.$search.trigger('focus');
	});

	container.on('results:focus', function (params) {
	  self.$search.attr('aria-activedescendant', params.id);
	});

	this.$selection.on('focusin', '.select2-search--inline', function (evt) {
	  self.trigger('focus', evt);
	});

	this.$selection.on('focusout', '.select2-search--inline', function (evt) {
	  self._handleBlur(evt);
	});

	this.$selection.on('keydown', '.select2-search--inline', function (evt) {
	  evt.stopPropagation();

	  self.trigger('keypress', evt);

	  self._keyUpPrevented = evt.isDefaultPrevented();

	  var key = evt.which;

	  if (key === KEYS.BACKSPACE && self.$search.val() === '') {
		var $previousChoice = self.$searchContainer
		  .prev('.select2-selection__choice');

		if ($previousChoice.length > 0) {
		  var item = $previousChoice.data('data');

		  self.searchRemoveChoice(item);

		  evt.preventDefault();
		}
	  }
	});

	// Try to detect the IE version should the `documentMode` property that
	// is stored on the document. This is only implemented in IE and is
	// slightly cleaner than doing a user agent check.
	// This property is not available in Edge, but Edge also doesn't have
	// this bug.
	var msie = document.documentMode;
	var disableInputEvents = msie && msie <= 11;

	// Workaround for browsers which do not support the `input` event
	// This will prevent double-triggering of events for browsers which support
	// both the `keyup` and `input` events.
	this.$selection.on(
	  'input.searchcheck',
	  '.select2-search--inline',
	  function (evt) {
		// IE will trigger the `input` event when a placeholder is used on a
		// search box. To get around this issue, we are forced to ignore all
		// `input` events in IE and keep using `keyup`.
		if (disableInputEvents) {
		  self.$selection.off('input.search input.searchcheck');
		  return;
		}

		// Unbind the duplicated `keyup` event
		self.$selection.off('keyup.search');
	  }
	);

	this.$selection.on(
	  'keyup.search input.search',
	  '.select2-search--inline',
	  function (evt) {
		// IE will trigger the `input` event when a placeholder is used on a
		// search box. To get around this issue, we are forced to ignore all
		// `input` events in IE and keep using `keyup`.
		if (disableInputEvents && evt.type === 'input') {
		  self.$selection.off('input.search input.searchcheck');
		  return;
		}

		var key = evt.which;

		// We can freely ignore events from modifier keys
		if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
		  return;
		}

		// Tabbing will be handled during the `keydown` phase
		if (key == KEYS.TAB) {
		  return;
		}

		self.handleSearch(evt);
	  }
	);
  };

  /**
   * This method will transfer the tabindex attribute from the rendered
   * selection to the search box. This allows for the search box to be used as
   * the primary focus instead of the selection container.
   *
   * @private
   */
  Search.prototype._transferTabIndex = function (decorated) {
	this.$search.attr('tabindex', this.$selection.attr('tabindex'));
	this.$selection.attr('tabindex', '-1');
  };

  Search.prototype.createPlaceholder = function (decorated, placeholder) {
	this.$search.attr('placeholder', placeholder.text);
  };

  Search.prototype.update = function (decorated, data) {
	var searchHadFocus = this.$search[0] == document.activeElement;

	this.$search.attr('placeholder', '');

	decorated.call(this, data);

	this.$selection.find('.select2-selection__rendered')
				   .append(this.$searchContainer);

	this.resizeSearch();
	if (searchHadFocus) {
	  this.$search.focus();
	}
  };

  Search.prototype.handleSearch = function () {
	this.resizeSearch();

	if (!this._keyUpPrevented) {
	  var input = this.$search.val();

	  this.trigger('query', {
		term: input
	  });
	}

	this._keyUpPrevented = false;
  };

  Search.prototype.searchRemoveChoice = function (decorated, item) {
	this.trigger('unselect', {
	  data: item
	});

	this.$search.val(item.text);
	this.handleSearch();
  };

  Search.prototype.resizeSearch = function () {
	this.$search.css('width', '25px');

	var width = '';

	if (this.$search.attr('placeholder') !== '') {
	  width = this.$selection.find('.select2-selection__rendered').innerWidth();
	} else {
	  var minimumWidth = this.$search.val().length + 1;

	  width = (minimumWidth * 0.75) + 'em';
	}

	this.$search.css('width', width);
  };

  return Search;
});

S2.define('select2/selection/eventRelay',[
  'jquery'
], function ($) {
  function EventRelay () { }

  EventRelay.prototype.bind = function (decorated, container, $container) {
	var self = this;
	var relayEvents = [
	  'open', 'opening',
	  'close', 'closing',
	  'select', 'selecting',
	  'unselect', 'unselecting'
	];

	var preventableEvents = ['opening', 'closing', 'selecting', 'unselecting'];

	decorated.call(this, container, $container);

	container.on('*', function (name, params) {
	  // Ignore events that should not be relayed
	  if ($.inArray(name, relayEvents) === -1) {
		return;
	  }

	  // The parameters should always be an object
	  params = params || {};

	  // Generate the jQuery event for the Select2 event
	  var evt = $.Event('select2:' + name, {
		params: params
	  });

	  self.$element.trigger(evt);

	  // Only handle preventable events if it was one
	  if ($.inArray(name, preventableEvents) === -1) {
		return;
	  }

	  params.prevented = evt.isDefaultPrevented();
	});
  };

  return EventRelay;
});

S2.define('select2/translation',[
  'jquery',
  'require'
], function ($, require) {
  function Translation (dict) {
	this.dict = dict || {};
  }

  Translation.prototype.all = function () {
	return this.dict;
  };

  Translation.prototype.get = function (key) {
	return this.dict[key];
  };

  Translation.prototype.extend = function (translation) {
	this.dict = $.extend({}, translation.all(), this.dict);
  };

  // Static functions

  Translation._cache = {};

  Translation.loadPath = function (path) {
	if (!(path in Translation._cache)) {
	  var translations = require(path);

	  Translation._cache[path] = translations;
	}

	return new Translation(Translation._cache[path]);
  };

  return Translation;
});

S2.define('select2/diacritics',[

], function () {
  var diacritics = {
	'\u24B6': 'A',
	'\uFF21': 'A',
	'\u00C0': 'A',
	'\u00C1': 'A',
	'\u00C2': 'A',
	'\u1EA6': 'A',
	'\u1EA4': 'A',
	'\u1EAA': 'A',
	'\u1EA8': 'A',
	'\u00C3': 'A',
	'\u0100': 'A',
	'\u0102': 'A',
	'\u1EB0': 'A',
	'\u1EAE': 'A',
	'\u1EB4': 'A',
	'\u1EB2': 'A',
	'\u0226': 'A',
	'\u01E0': 'A',
	'\u00C4': 'A',
	'\u01DE': 'A',
	'\u1EA2': 'A',
	'\u00C5': 'A',
	'\u01FA': 'A',
	'\u01CD': 'A',
	'\u0200': 'A',
	'\u0202': 'A',
	'\u1EA0': 'A',
	'\u1EAC': 'A',
	'\u1EB6': 'A',
	'\u1E00': 'A',
	'\u0104': 'A',
	'\u023A': 'A',
	'\u2C6F': 'A',
	'\uA732': 'AA',
	'\u00C6': 'AE',
	'\u01FC': 'AE',
	'\u01E2': 'AE',
	'\uA734': 'AO',
	'\uA736': 'AU',
	'\uA738': 'AV',
	'\uA73A': 'AV',
	'\uA73C': 'AY',
	'\u24B7': 'B',
	'\uFF22': 'B',
	'\u1E02': 'B',
	'\u1E04': 'B',
	'\u1E06': 'B',
	'\u0243': 'B',
	'\u0182': 'B',
	'\u0181': 'B',
	'\u24B8': 'C',
	'\uFF23': 'C',
	'\u0106': 'C',
	'\u0108': 'C',
	'\u010A': 'C',
	'\u010C': 'C',
	'\u00C7': 'C',
	'\u1E08': 'C',
	'\u0187': 'C',
	'\u023B': 'C',
	'\uA73E': 'C',
	'\u24B9': 'D',
	'\uFF24': 'D',
	'\u1E0A': 'D',
	'\u010E': 'D',
	'\u1E0C': 'D',
	'\u1E10': 'D',
	'\u1E12': 'D',
	'\u1E0E': 'D',
	'\u0110': 'D',
	'\u018B': 'D',
	'\u018A': 'D',
	'\u0189': 'D',
	'\uA779': 'D',
	'\u01F1': 'DZ',
	'\u01C4': 'DZ',
	'\u01F2': 'Dz',
	'\u01C5': 'Dz',
	'\u24BA': 'E',
	'\uFF25': 'E',
	'\u00C8': 'E',
	'\u00C9': 'E',
	'\u00CA': 'E',
	'\u1EC0': 'E',
	'\u1EBE': 'E',
	'\u1EC4': 'E',
	'\u1EC2': 'E',
	'\u1EBC': 'E',
	'\u0112': 'E',
	'\u1E14': 'E',
	'\u1E16': 'E',
	'\u0114': 'E',
	'\u0116': 'E',
	'\u00CB': 'E',
	'\u1EBA': 'E',
	'\u011A': 'E',
	'\u0204': 'E',
	'\u0206': 'E',
	'\u1EB8': 'E',
	'\u1EC6': 'E',
	'\u0228': 'E',
	'\u1E1C': 'E',
	'\u0118': 'E',
	'\u1E18': 'E',
	'\u1E1A': 'E',
	'\u0190': 'E',
	'\u018E': 'E',
	'\u24BB': 'F',
	'\uFF26': 'F',
	'\u1E1E': 'F',
	'\u0191': 'F',
	'\uA77B': 'F',
	'\u24BC': 'G',
	'\uFF27': 'G',
	'\u01F4': 'G',
	'\u011C': 'G',
	'\u1E20': 'G',
	'\u011E': 'G',
	'\u0120': 'G',
	'\u01E6': 'G',
	'\u0122': 'G',
	'\u01E4': 'G',
	'\u0193': 'G',
	'\uA7A0': 'G',
	'\uA77D': 'G',
	'\uA77E': 'G',
	'\u24BD': 'H',
	'\uFF28': 'H',
	'\u0124': 'H',
	'\u1E22': 'H',
	'\u1E26': 'H',
	'\u021E': 'H',
	'\u1E24': 'H',
	'\u1E28': 'H',
	'\u1E2A': 'H',
	'\u0126': 'H',
	'\u2C67': 'H',
	'\u2C75': 'H',
	'\uA78D': 'H',
	'\u24BE': 'I',
	'\uFF29': 'I',
	'\u00CC': 'I',
	'\u00CD': 'I',
	'\u00CE': 'I',
	'\u0128': 'I',
	'\u012A': 'I',
	'\u012C': 'I',
	'\u0130': 'I',
	'\u00CF': 'I',
	'\u1E2E': 'I',
	'\u1EC8': 'I',
	'\u01CF': 'I',
	'\u0208': 'I',
	'\u020A': 'I',
	'\u1ECA': 'I',
	'\u012E': 'I',
	'\u1E2C': 'I',
	'\u0197': 'I',
	'\u24BF': 'J',
	'\uFF2A': 'J',
	'\u0134': 'J',
	'\u0248': 'J',
	'\u24C0': 'K',
	'\uFF2B': 'K',
	'\u1E30': 'K',
	'\u01E8': 'K',
	'\u1E32': 'K',
	'\u0136': 'K',
	'\u1E34': 'K',
	'\u0198': 'K',
	'\u2C69': 'K',
	'\uA740': 'K',
	'\uA742': 'K',
	'\uA744': 'K',
	'\uA7A2': 'K',
	'\u24C1': 'L',
	'\uFF2C': 'L',
	'\u013F': 'L',
	'\u0139': 'L',
	'\u013D': 'L',
	'\u1E36': 'L',
	'\u1E38': 'L',
	'\u013B': 'L',
	'\u1E3C': 'L',
	'\u1E3A': 'L',
	'\u0141': 'L',
	'\u023D': 'L',
	'\u2C62': 'L',
	'\u2C60': 'L',
	'\uA748': 'L',
	'\uA746': 'L',
	'\uA780': 'L',
	'\u01C7': 'LJ',
	'\u01C8': 'Lj',
	'\u24C2': 'M',
	'\uFF2D': 'M',
	'\u1E3E': 'M',
	'\u1E40': 'M',
	'\u1E42': 'M',
	'\u2C6E': 'M',
	'\u019C': 'M',
	'\u24C3': 'N',
	'\uFF2E': 'N',
	'\u01F8': 'N',
	'\u0143': 'N',
	'\u00D1': 'N',
	'\u1E44': 'N',
	'\u0147': 'N',
	'\u1E46': 'N',
	'\u0145': 'N',
	'\u1E4A': 'N',
	'\u1E48': 'N',
	'\u0220': 'N',
	'\u019D': 'N',
	'\uA790': 'N',
	'\uA7A4': 'N',
	'\u01CA': 'NJ',
	'\u01CB': 'Nj',
	'\u24C4': 'O',
	'\uFF2F': 'O',
	'\u00D2': 'O',
	'\u00D3': 'O',
	'\u00D4': 'O',
	'\u1ED2': 'O',
	'\u1ED0': 'O',
	'\u1ED6': 'O',
	'\u1ED4': 'O',
	'\u00D5': 'O',
	'\u1E4C': 'O',
	'\u022C': 'O',
	'\u1E4E': 'O',
	'\u014C': 'O',
	'\u1E50': 'O',
	'\u1E52': 'O',
	'\u014E': 'O',
	'\u022E': 'O',
	'\u0230': 'O',
	'\u00D6': 'O',
	'\u022A': 'O',
	'\u1ECE': 'O',
	'\u0150': 'O',
	'\u01D1': 'O',
	'\u020C': 'O',
	'\u020E': 'O',
	'\u01A0': 'O',
	'\u1EDC': 'O',
	'\u1EDA': 'O',
	'\u1EE0': 'O',
	'\u1EDE': 'O',
	'\u1EE2': 'O',
	'\u1ECC': 'O',
	'\u1ED8': 'O',
	'\u01EA': 'O',
	'\u01EC': 'O',
	'\u00D8': 'O',
	'\u01FE': 'O',
	'\u0186': 'O',
	'\u019F': 'O',
	'\uA74A': 'O',
	'\uA74C': 'O',
	'\u01A2': 'OI',
	'\uA74E': 'OO',
	'\u0222': 'OU',
	'\u24C5': 'P',
	'\uFF30': 'P',
	'\u1E54': 'P',
	'\u1E56': 'P',
	'\u01A4': 'P',
	'\u2C63': 'P',
	'\uA750': 'P',
	'\uA752': 'P',
	'\uA754': 'P',
	'\u24C6': 'Q',
	'\uFF31': 'Q',
	'\uA756': 'Q',
	'\uA758': 'Q',
	'\u024A': 'Q',
	'\u24C7': 'R',
	'\uFF32': 'R',
	'\u0154': 'R',
	'\u1E58': 'R',
	'\u0158': 'R',
	'\u0210': 'R',
	'\u0212': 'R',
	'\u1E5A': 'R',
	'\u1E5C': 'R',
	'\u0156': 'R',
	'\u1E5E': 'R',
	'\u024C': 'R',
	'\u2C64': 'R',
	'\uA75A': 'R',
	'\uA7A6': 'R',
	'\uA782': 'R',
	'\u24C8': 'S',
	'\uFF33': 'S',
	'\u1E9E': 'S',
	'\u015A': 'S',
	'\u1E64': 'S',
	'\u015C': 'S',
	'\u1E60': 'S',
	'\u0160': 'S',
	'\u1E66': 'S',
	'\u1E62': 'S',
	'\u1E68': 'S',
	'\u0218': 'S',
	'\u015E': 'S',
	'\u2C7E': 'S',
	'\uA7A8': 'S',
	'\uA784': 'S',
	'\u24C9': 'T',
	'\uFF34': 'T',
	'\u1E6A': 'T',
	'\u0164': 'T',
	'\u1E6C': 'T',
	'\u021A': 'T',
	'\u0162': 'T',
	'\u1E70': 'T',
	'\u1E6E': 'T',
	'\u0166': 'T',
	'\u01AC': 'T',
	'\u01AE': 'T',
	'\u023E': 'T',
	'\uA786': 'T',
	'\uA728': 'TZ',
	'\u24CA': 'U',
	'\uFF35': 'U',
	'\u00D9': 'U',
	'\u00DA': 'U',
	'\u00DB': 'U',
	'\u0168': 'U',
	'\u1E78': 'U',
	'\u016A': 'U',
	'\u1E7A': 'U',
	'\u016C': 'U',
	'\u00DC': 'U',
	'\u01DB': 'U',
	'\u01D7': 'U',
	'\u01D5': 'U',
	'\u01D9': 'U',
	'\u1EE6': 'U',
	'\u016E': 'U',
	'\u0170': 'U',
	'\u01D3': 'U',
	'\u0214': 'U',
	'\u0216': 'U',
	'\u01AF': 'U',
	'\u1EEA': 'U',
	'\u1EE8': 'U',
	'\u1EEE': 'U',
	'\u1EEC': 'U',
	'\u1EF0': 'U',
	'\u1EE4': 'U',
	'\u1E72': 'U',
	'\u0172': 'U',
	'\u1E76': 'U',
	'\u1E74': 'U',
	'\u0244': 'U',
	'\u24CB': 'V',
	'\uFF36': 'V',
	'\u1E7C': 'V',
	'\u1E7E': 'V',
	'\u01B2': 'V',
	'\uA75E': 'V',
	'\u0245': 'V',
	'\uA760': 'VY',
	'\u24CC': 'W',
	'\uFF37': 'W',
	'\u1E80': 'W',
	'\u1E82': 'W',
	'\u0174': 'W',
	'\u1E86': 'W',
	'\u1E84': 'W',
	'\u1E88': 'W',
	'\u2C72': 'W',
	'\u24CD': 'X',
	'\uFF38': 'X',
	'\u1E8A': 'X',
	'\u1E8C': 'X',
	'\u24CE': 'Y',
	'\uFF39': 'Y',
	'\u1EF2': 'Y',
	'\u00DD': 'Y',
	'\u0176': 'Y',
	'\u1EF8': 'Y',
	'\u0232': 'Y',
	'\u1E8E': 'Y',
	'\u0178': 'Y',
	'\u1EF6': 'Y',
	'\u1EF4': 'Y',
	'\u01B3': 'Y',
	'\u024E': 'Y',
	'\u1EFE': 'Y',
	'\u24CF': 'Z',
	'\uFF3A': 'Z',
	'\u0179': 'Z',
	'\u1E90': 'Z',
	'\u017B': 'Z',
	'\u017D': 'Z',
	'\u1E92': 'Z',
	'\u1E94': 'Z',
	'\u01B5': 'Z',
	'\u0224': 'Z',
	'\u2C7F': 'Z',
	'\u2C6B': 'Z',
	'\uA762': 'Z',
	'\u24D0': 'a',
	'\uFF41': 'a',
	'\u1E9A': 'a',
	'\u00E0': 'a',
	'\u00E1': 'a',
	'\u00E2': 'a',
	'\u1EA7': 'a',
	'\u1EA5': 'a',
	'\u1EAB': 'a',
	'\u1EA9': 'a',
	'\u00E3': 'a',
	'\u0101': 'a',
	'\u0103': 'a',
	'\u1EB1': 'a',
	'\u1EAF': 'a',
	'\u1EB5': 'a',
	'\u1EB3': 'a',
	'\u0227': 'a',
	'\u01E1': 'a',
	'\u00E4': 'a',
	'\u01DF': 'a',
	'\u1EA3': 'a',
	'\u00E5': 'a',
	'\u01FB': 'a',
	'\u01CE': 'a',
	'\u0201': 'a',
	'\u0203': 'a',
	'\u1EA1': 'a',
	'\u1EAD': 'a',
	'\u1EB7': 'a',
	'\u1E01': 'a',
	'\u0105': 'a',
	'\u2C65': 'a',
	'\u0250': 'a',
	'\uA733': 'aa',
	'\u00E6': 'ae',
	'\u01FD': 'ae',
	'\u01E3': 'ae',
	'\uA735': 'ao',
	'\uA737': 'au',
	'\uA739': 'av',
	'\uA73B': 'av',
	'\uA73D': 'ay',
	'\u24D1': 'b',
	'\uFF42': 'b',
	'\u1E03': 'b',
	'\u1E05': 'b',
	'\u1E07': 'b',
	'\u0180': 'b',
	'\u0183': 'b',
	'\u0253': 'b',
	'\u24D2': 'c',
	'\uFF43': 'c',
	'\u0107': 'c',
	'\u0109': 'c',
	'\u010B': 'c',
	'\u010D': 'c',
	'\u00E7': 'c',
	'\u1E09': 'c',
	'\u0188': 'c',
	'\u023C': 'c',
	'\uA73F': 'c',
	'\u2184': 'c',
	'\u24D3': 'd',
	'\uFF44': 'd',
	'\u1E0B': 'd',
	'\u010F': 'd',
	'\u1E0D': 'd',
	'\u1E11': 'd',
	'\u1E13': 'd',
	'\u1E0F': 'd',
	'\u0111': 'd',
	'\u018C': 'd',
	'\u0256': 'd',
	'\u0257': 'd',
	'\uA77A': 'd',
	'\u01F3': 'dz',
	'\u01C6': 'dz',
	'\u24D4': 'e',
	'\uFF45': 'e',
	'\u00E8': 'e',
	'\u00E9': 'e',
	'\u00EA': 'e',
	'\u1EC1': 'e',
	'\u1EBF': 'e',
	'\u1EC5': 'e',
	'\u1EC3': 'e',
	'\u1EBD': 'e',
	'\u0113': 'e',
	'\u1E15': 'e',
	'\u1E17': 'e',
	'\u0115': 'e',
	'\u0117': 'e',
	'\u00EB': 'e',
	'\u1EBB': 'e',
	'\u011B': 'e',
	'\u0205': 'e',
	'\u0207': 'e',
	'\u1EB9': 'e',
	'\u1EC7': 'e',
	'\u0229': 'e',
	'\u1E1D': 'e',
	'\u0119': 'e',
	'\u1E19': 'e',
	'\u1E1B': 'e',
	'\u0247': 'e',
	'\u025B': 'e',
	'\u01DD': 'e',
	'\u24D5': 'f',
	'\uFF46': 'f',
	'\u1E1F': 'f',
	'\u0192': 'f',
	'\uA77C': 'f',
	'\u24D6': 'g',
	'\uFF47': 'g',
	'\u01F5': 'g',
	'\u011D': 'g',
	'\u1E21': 'g',
	'\u011F': 'g',
	'\u0121': 'g',
	'\u01E7': 'g',
	'\u0123': 'g',
	'\u01E5': 'g',
	'\u0260': 'g',
	'\uA7A1': 'g',
	'\u1D79': 'g',
	'\uA77F': 'g',
	'\u24D7': 'h',
	'\uFF48': 'h',
	'\u0125': 'h',
	'\u1E23': 'h',
	'\u1E27': 'h',
	'\u021F': 'h',
	'\u1E25': 'h',
	'\u1E29': 'h',
	'\u1E2B': 'h',
	'\u1E96': 'h',
	'\u0127': 'h',
	'\u2C68': 'h',
	'\u2C76': 'h',
	'\u0265': 'h',
	'\u0195': 'hv',
	'\u24D8': 'i',
	'\uFF49': 'i',
	'\u00EC': 'i',
	'\u00ED': 'i',
	'\u00EE': 'i',
	'\u0129': 'i',
	'\u012B': 'i',
	'\u012D': 'i',
	'\u00EF': 'i',
	'\u1E2F': 'i',
	'\u1EC9': 'i',
	'\u01D0': 'i',
	'\u0209': 'i',
	'\u020B': 'i',
	'\u1ECB': 'i',
	'\u012F': 'i',
	'\u1E2D': 'i',
	'\u0268': 'i',
	'\u0131': 'i',
	'\u24D9': 'j',
	'\uFF4A': 'j',
	'\u0135': 'j',
	'\u01F0': 'j',
	'\u0249': 'j',
	'\u24DA': 'k',
	'\uFF4B': 'k',
	'\u1E31': 'k',
	'\u01E9': 'k',
	'\u1E33': 'k',
	'\u0137': 'k',
	'\u1E35': 'k',
	'\u0199': 'k',
	'\u2C6A': 'k',
	'\uA741': 'k',
	'\uA743': 'k',
	'\uA745': 'k',
	'\uA7A3': 'k',
	'\u24DB': 'l',
	'\uFF4C': 'l',
	'\u0140': 'l',
	'\u013A': 'l',
	'\u013E': 'l',
	'\u1E37': 'l',
	'\u1E39': 'l',
	'\u013C': 'l',
	'\u1E3D': 'l',
	'\u1E3B': 'l',
	'\u017F': 'l',
	'\u0142': 'l',
	'\u019A': 'l',
	'\u026B': 'l',
	'\u2C61': 'l',
	'\uA749': 'l',
	'\uA781': 'l',
	'\uA747': 'l',
	'\u01C9': 'lj',
	'\u24DC': 'm',
	'\uFF4D': 'm',
	'\u1E3F': 'm',
	'\u1E41': 'm',
	'\u1E43': 'm',
	'\u0271': 'm',
	'\u026F': 'm',
	'\u24DD': 'n',
	'\uFF4E': 'n',
	'\u01F9': 'n',
	'\u0144': 'n',
	'\u00F1': 'n',
	'\u1E45': 'n',
	'\u0148': 'n',
	'\u1E47': 'n',
	'\u0146': 'n',
	'\u1E4B': 'n',
	'\u1E49': 'n',
	'\u019E': 'n',
	'\u0272': 'n',
	'\u0149': 'n',
	'\uA791': 'n',
	'\uA7A5': 'n',
	'\u01CC': 'nj',
	'\u24DE': 'o',
	'\uFF4F': 'o',
	'\u00F2': 'o',
	'\u00F3': 'o',
	'\u00F4': 'o',
	'\u1ED3': 'o',
	'\u1ED1': 'o',
	'\u1ED7': 'o',
	'\u1ED5': 'o',
	'\u00F5': 'o',
	'\u1E4D': 'o',
	'\u022D': 'o',
	'\u1E4F': 'o',
	'\u014D': 'o',
	'\u1E51': 'o',
	'\u1E53': 'o',
	'\u014F': 'o',
	'\u022F': 'o',
	'\u0231': 'o',
	'\u00F6': 'o',
	'\u022B': 'o',
	'\u1ECF': 'o',
	'\u0151': 'o',
	'\u01D2': 'o',
	'\u020D': 'o',
	'\u020F': 'o',
	'\u01A1': 'o',
	'\u1EDD': 'o',
	'\u1EDB': 'o',
	'\u1EE1': 'o',
	'\u1EDF': 'o',
	'\u1EE3': 'o',
	'\u1ECD': 'o',
	'\u1ED9': 'o',
	'\u01EB': 'o',
	'\u01ED': 'o',
	'\u00F8': 'o',
	'\u01FF': 'o',
	'\u0254': 'o',
	'\uA74B': 'o',
	'\uA74D': 'o',
	'\u0275': 'o',
	'\u01A3': 'oi',
	'\u0223': 'ou',
	'\uA74F': 'oo',
	'\u24DF': 'p',
	'\uFF50': 'p',
	'\u1E55': 'p',
	'\u1E57': 'p',
	'\u01A5': 'p',
	'\u1D7D': 'p',
	'\uA751': 'p',
	'\uA753': 'p',
	'\uA755': 'p',
	'\u24E0': 'q',
	'\uFF51': 'q',
	'\u024B': 'q',
	'\uA757': 'q',
	'\uA759': 'q',
	'\u24E1': 'r',
	'\uFF52': 'r',
	'\u0155': 'r',
	'\u1E59': 'r',
	'\u0159': 'r',
	'\u0211': 'r',
	'\u0213': 'r',
	'\u1E5B': 'r',
	'\u1E5D': 'r',
	'\u0157': 'r',
	'\u1E5F': 'r',
	'\u024D': 'r',
	'\u027D': 'r',
	'\uA75B': 'r',
	'\uA7A7': 'r',
	'\uA783': 'r',
	'\u24E2': 's',
	'\uFF53': 's',
	'\u00DF': 's',
	'\u015B': 's',
	'\u1E65': 's',
	'\u015D': 's',
	'\u1E61': 's',
	'\u0161': 's',
	'\u1E67': 's',
	'\u1E63': 's',
	'\u1E69': 's',
	'\u0219': 's',
	'\u015F': 's',
	'\u023F': 's',
	'\uA7A9': 's',
	'\uA785': 's',
	'\u1E9B': 's',
	'\u24E3': 't',
	'\uFF54': 't',
	'\u1E6B': 't',
	'\u1E97': 't',
	'\u0165': 't',
	'\u1E6D': 't',
	'\u021B': 't',
	'\u0163': 't',
	'\u1E71': 't',
	'\u1E6F': 't',
	'\u0167': 't',
	'\u01AD': 't',
	'\u0288': 't',
	'\u2C66': 't',
	'\uA787': 't',
	'\uA729': 'tz',
	'\u24E4': 'u',
	'\uFF55': 'u',
	'\u00F9': 'u',
	'\u00FA': 'u',
	'\u00FB': 'u',
	'\u0169': 'u',
	'\u1E79': 'u',
	'\u016B': 'u',
	'\u1E7B': 'u',
	'\u016D': 'u',
	'\u00FC': 'u',
	'\u01DC': 'u',
	'\u01D8': 'u',
	'\u01D6': 'u',
	'\u01DA': 'u',
	'\u1EE7': 'u',
	'\u016F': 'u',
	'\u0171': 'u',
	'\u01D4': 'u',
	'\u0215': 'u',
	'\u0217': 'u',
	'\u01B0': 'u',
	'\u1EEB': 'u',
	'\u1EE9': 'u',
	'\u1EEF': 'u',
	'\u1EED': 'u',
	'\u1EF1': 'u',
	'\u1EE5': 'u',
	'\u1E73': 'u',
	'\u0173': 'u',
	'\u1E77': 'u',
	'\u1E75': 'u',
	'\u0289': 'u',
	'\u24E5': 'v',
	'\uFF56': 'v',
	'\u1E7D': 'v',
	'\u1E7F': 'v',
	'\u028B': 'v',
	'\uA75F': 'v',
	'\u028C': 'v',
	'\uA761': 'vy',
	'\u24E6': 'w',
	'\uFF57': 'w',
	'\u1E81': 'w',
	'\u1E83': 'w',
	'\u0175': 'w',
	'\u1E87': 'w',
	'\u1E85': 'w',
	'\u1E98': 'w',
	'\u1E89': 'w',
	'\u2C73': 'w',
	'\u24E7': 'x',
	'\uFF58': 'x',
	'\u1E8B': 'x',
	'\u1E8D': 'x',
	'\u24E8': 'y',
	'\uFF59': 'y',
	'\u1EF3': 'y',
	'\u00FD': 'y',
	'\u0177': 'y',
	'\u1EF9': 'y',
	'\u0233': 'y',
	'\u1E8F': 'y',
	'\u00FF': 'y',
	'\u1EF7': 'y',
	'\u1E99': 'y',
	'\u1EF5': 'y',
	'\u01B4': 'y',
	'\u024F': 'y',
	'\u1EFF': 'y',
	'\u24E9': 'z',
	'\uFF5A': 'z',
	'\u017A': 'z',
	'\u1E91': 'z',
	'\u017C': 'z',
	'\u017E': 'z',
	'\u1E93': 'z',
	'\u1E95': 'z',
	'\u01B6': 'z',
	'\u0225': 'z',
	'\u0240': 'z',
	'\u2C6C': 'z',
	'\uA763': 'z',
	'\u0386': '\u0391',
	'\u0388': '\u0395',
	'\u0389': '\u0397',
	'\u038A': '\u0399',
	'\u03AA': '\u0399',
	'\u038C': '\u039F',
	'\u038E': '\u03A5',
	'\u03AB': '\u03A5',
	'\u038F': '\u03A9',
	'\u03AC': '\u03B1',
	'\u03AD': '\u03B5',
	'\u03AE': '\u03B7',
	'\u03AF': '\u03B9',
	'\u03CA': '\u03B9',
	'\u0390': '\u03B9',
	'\u03CC': '\u03BF',
	'\u03CD': '\u03C5',
	'\u03CB': '\u03C5',
	'\u03B0': '\u03C5',
	'\u03C9': '\u03C9',
	'\u03C2': '\u03C3'
  };

  return diacritics;
});

S2.define('select2/data/base',[
  '../utils'
], function (Utils) {
  function BaseAdapter ($element, options) {
	BaseAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(BaseAdapter, Utils.Observable);

  BaseAdapter.prototype.current = function (callback) {
	throw new Error('The `current` method must be defined in child classes.');
  };

  BaseAdapter.prototype.query = function (params, callback) {
	throw new Error('The `query` method must be defined in child classes.');
  };

  BaseAdapter.prototype.bind = function (container, $container) {
	// Can be implemented in subclasses
  };

  BaseAdapter.prototype.destroy = function () {
	// Can be implemented in subclasses
  };

  BaseAdapter.prototype.generateResultId = function (container, data) {
	var id = container.id + '-result-';

	id += Utils.generateChars(4);

	if (data.id != null) {
	  id += '-' + data.id.toString();
	} else {
	  id += '-' + Utils.generateChars(4);
	}
	return id;
  };

  return BaseAdapter;
});

S2.define('select2/data/select',[
  './base',
  '../utils',
  'jquery'
], function (BaseAdapter, Utils, $) {
  function SelectAdapter ($element, options) {
	this.$element = $element;
	this.options = options;

	SelectAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(SelectAdapter, BaseAdapter);

  SelectAdapter.prototype.current = function (callback) {
	var data = [];
	var self = this;

	this.$element.find(':selected').each(function () {
	  var $option = $(this);

	  var option = self.item($option);

	  data.push(option);
	});

	callback(data);
  };

  SelectAdapter.prototype.select = function (data) {
	var self = this;

	data.selected = true;

	// If data.element is a DOM node, use it instead
	if ($(data.element).is('option')) {
	  data.element.selected = true;

	  this.$element.trigger('change');

	  return;
	}

	if (this.$element.prop('multiple')) {
	  this.current(function (currentData) {
		var val = [];

		data = [data];
		data.push.apply(data, currentData);

		for (var d = 0; d < data.length; d++) {
		  var id = data[d].id;

		  if ($.inArray(id, val) === -1) {
			val.push(id);
		  }
		}

		self.$element.val(val);
		self.$element.trigger('change');
	  });
	} else {
	  var val = data.id;

	  this.$element.val(val);
	  this.$element.trigger('change');
	}
  };

  SelectAdapter.prototype.unselect = function (data) {
	var self = this;

	if (!this.$element.prop('multiple')) {
	  return;
	}

	data.selected = false;

	if ($(data.element).is('option')) {
	  data.element.selected = false;

	  this.$element.trigger('change');

	  return;
	}

	this.current(function (currentData) {
	  var val = [];

	  for (var d = 0; d < currentData.length; d++) {
		var id = currentData[d].id;

		if (id !== data.id && $.inArray(id, val) === -1) {
		  val.push(id);
		}
	  }

	  self.$element.val(val);

	  self.$element.trigger('change');
	});
  };

  SelectAdapter.prototype.bind = function (container, $container) {
	var self = this;

	this.container = container;

	container.on('select', function (params) {
	  self.select(params.data);
	});

	container.on('unselect', function (params) {
	  self.unselect(params.data);
	});
  };

  SelectAdapter.prototype.destroy = function () {
	// Remove anything added to child elements
	this.$element.find('*').each(function () {
	  // Remove any custom data set by Select2
	  $.removeData(this, 'data');
	});
  };

  SelectAdapter.prototype.query = function (params, callback) {
	var data = [];
	var self = this;

	var $options = this.$element.children();

	$options.each(function () {
	  var $option = $(this);

	  if (!$option.is('option') && !$option.is('optgroup')) {
		return;
	  }

	  var option = self.item($option);

	  var matches = self.matches(params, option);

	  if (matches !== null) {
		data.push(matches);
	  }
	});

	callback({
	  results: data
	});
  };

  SelectAdapter.prototype.addOptions = function ($options) {
	Utils.appendMany(this.$element, $options);
  };

  SelectAdapter.prototype.option = function (data) {
	var option;

	if (data.children) {
	  option = document.createElement('optgroup');
	  option.label = data.text;
	} else {
	  option = document.createElement('option');

	  if (option.textContent !== undefined) {
		option.textContent = data.text;
	  } else {
		option.innerText = data.text;
	  }
	}

	if (data.id) {
	  option.value = data.id;
	}

	if (data.disabled) {
	  option.disabled = true;
	}

	if (data.selected) {
	  option.selected = true;
	}

	if (data.title) {
	  option.title = data.title;
	}

	var $option = $(option);

	var normalizedData = this._normalizeItem(data);
	normalizedData.element = option;

	// Override the option's data with the combined data
	$.data(option, 'data', normalizedData);

	return $option;
  };

  SelectAdapter.prototype.item = function ($option) {
	var data = {};

	data = $.data($option[0], 'data');

	if (data != null) {
	  return data;
	}

	if ($option.is('option')) {
	  data = {
		id: $option.val(),
		text: $option.text(),
		disabled: $option.prop('disabled'),
		selected: $option.prop('selected'),
		title: $option.prop('title')
	  };
	} else if ($option.is('optgroup')) {
	  data = {
		text: $option.prop('label'),
		children: [],
		title: $option.prop('title')
	  };

	  var $children = $option.children('option');
	  var children = [];

	  for (var c = 0; c < $children.length; c++) {
		var $child = $($children[c]);

		var child = this.item($child);

		children.push(child);
	  }

	  data.children = children;
	}

	data = this._normalizeItem(data);
	data.element = $option[0];

	$.data($option[0], 'data', data);

	return data;
  };

  SelectAdapter.prototype._normalizeItem = function (item) {
	if (!$.isPlainObject(item)) {
	  item = {
		id: item,
		text: item
	  };
	}

	item = $.extend({}, {
	  text: ''
	}, item);

	var defaults = {
	  selected: false,
	  disabled: false
	};

	if (item.id != null) {
	  item.id = item.id.toString();
	}

	if (item.text != null) {
	  item.text = item.text.toString();
	}

	if (item._resultId == null && item.id && this.container != null) {
	  item._resultId = this.generateResultId(this.container, item);
	}

	return $.extend({}, defaults, item);
  };

  SelectAdapter.prototype.matches = function (params, data) {
	var matcher = this.options.get('matcher');

	return matcher(params, data);
  };

  return SelectAdapter;
});

S2.define('select2/data/array',[
  './select',
  '../utils',
  'jquery'
], function (SelectAdapter, Utils, $) {
  function ArrayAdapter ($element, options) {
	var data = options.get('data') || [];

	ArrayAdapter.__super__.constructor.call(this, $element, options);

	this.addOptions(this.convertToOptions(data));
  }

  Utils.Extend(ArrayAdapter, SelectAdapter);

  ArrayAdapter.prototype.select = function (data) {
	var $option = this.$element.find('option').filter(function (i, elm) {
	  return elm.value == data.id.toString();
	});

	if ($option.length === 0) {
	  $option = this.option(data);

	  this.addOptions($option);
	}

	ArrayAdapter.__super__.select.call(this, data);
  };

  ArrayAdapter.prototype.convertToOptions = function (data) {
	var self = this;

	var $existing = this.$element.find('option');
	var existingIds = $existing.map(function () {
	  return self.item($(this)).id;
	}).get();

	var $options = [];

	// Filter out all items except for the one passed in the argument
	function onlyItem (item) {
	  return function () {
		return $(this).val() == item.id;
	  };
	}

	for (var d = 0; d < data.length; d++) {
	  var item = this._normalizeItem(data[d]);

	  // Skip items which were pre-loaded, only merge the data
	  if ($.inArray(item.id, existingIds) >= 0) {
		var $existingOption = $existing.filter(onlyItem(item));

		var existingData = this.item($existingOption);
		var newData = $.extend(true, {}, item, existingData);

		var $newOption = this.option(newData);

		$existingOption.replaceWith($newOption);

		continue;
	  }

	  var $option = this.option(item);

	  if (item.children) {
		var $children = this.convertToOptions(item.children);

		Utils.appendMany($option, $children);
	  }

	  $options.push($option);
	}

	return $options;
  };

  return ArrayAdapter;
});

S2.define('select2/data/ajax',[
  './array',
  '../utils',
  'jquery'
], function (ArrayAdapter, Utils, $) {
  function AjaxAdapter ($element, options) {
	this.ajaxOptions = this._applyDefaults(options.get('ajax'));

	if (this.ajaxOptions.processResults != null) {
	  this.processResults = this.ajaxOptions.processResults;
	}

	AjaxAdapter.__super__.constructor.call(this, $element, options);
  }

  Utils.Extend(AjaxAdapter, ArrayAdapter);

  AjaxAdapter.prototype._applyDefaults = function (options) {
	var defaults = {
	  data: function (params) {
		return $.extend({}, params, {
		  q: params.term
		});
	  },
	  transport: function (params, success, failure) {
		var $request = $.ajax(params);

		$request.then(success);
		$request.fail(failure);

		return $request;
	  }
	};

	return $.extend({}, defaults, options, true);
  };

  AjaxAdapter.prototype.processResults = function (results) {
	return results;
  };

  AjaxAdapter.prototype.query = function (params, callback) {
	var matches = [];
	var self = this;

	if (this._request != null) {
	  // JSONP requests cannot always be aborted
	  if ($.isFunction(this._request.abort)) {
		this._request.abort();
	  }

	  this._request = null;
	}

	var options = $.extend({
	  type: 'GET'
	}, this.ajaxOptions);

	if (typeof options.url === 'function') {
	  options.url = options.url.call(this.$element, params);
	}

	if (typeof options.data === 'function') {
	  options.data = options.data.call(this.$element, params);
	}

	function request () {
	  var $request = options.transport(options, function (data) {
		var results = self.processResults(data, params);

		if (self.options.get('debug') && window.console && console.error) {
		  // Check to make sure that the response included a `results` key.
		  if (!results || !results.results || !$.isArray(results.results)) {
			console.error(
			  'Select2: The AJAX results did not return an array in the ' +
			  '`results` key of the response.'
			);
		  }
		}

		callback(results);
	  }, function () {
		// Attempt to detect if a request was aborted
		// Only works if the transport exposes a status property
		if ($request.status && $request.status === '0') {
		  return;
		}

		self.trigger('results:message', {
		  message: 'errorLoading'
		});
	  });

	  self._request = $request;
	}

	if (this.ajaxOptions.delay && params.term != null) {
	  if (this._queryTimeout) {
		window.clearTimeout(this._queryTimeout);
	  }

	  this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
	} else {
	  request();
	}
  };

  return AjaxAdapter;
});

S2.define('select2/data/tags',[
  'jquery'
], function ($) {
  function Tags (decorated, $element, options) {
	var tags = options.get('tags');

	var createTag = options.get('createTag');

	if (createTag !== undefined) {
	  this.createTag = createTag;
	}

	var insertTag = options.get('insertTag');

	if (insertTag !== undefined) {
		this.insertTag = insertTag;
	}

	decorated.call(this, $element, options);

	if ($.isArray(tags)) {
	  for (var t = 0; t < tags.length; t++) {
		var tag = tags[t];
		var item = this._normalizeItem(tag);

		var $option = this.option(item);

		this.$element.append($option);
	  }
	}
  }

  Tags.prototype.query = function (decorated, params, callback) {
	var self = this;

	this._removeOldTags();

	if (params.term == null || params.page != null) {
	  decorated.call(this, params, callback);
	  return;
	}

	function wrapper (obj, child) {
	  var data = obj.results;

	  for (var i = 0; i < data.length; i++) {
		var option = data[i];

		var checkChildren = (
		  option.children != null &&
		  !wrapper({
			results: option.children
		  }, true)
		);

		var checkText = option.text === params.term;

		if (checkText || checkChildren) {
		  if (child) {
			return false;
		  }

		  obj.data = data;
		  callback(obj);

		  return;
		}
	  }

	  if (child) {
		return true;
	  }

	  var tag = self.createTag(params);

	  if (tag != null) {
		var $option = self.option(tag);
		$option.attr('data-select2-tag', true);

		self.addOptions([$option]);

		self.insertTag(data, tag);
	  }

	  obj.results = data;

	  callback(obj);
	}

	decorated.call(this, params, wrapper);
  };

  Tags.prototype.createTag = function (decorated, params) {
	var term = $.trim(params.term);

	if (term === '') {
	  return null;
	}

	return {
	  id: term,
	  text: term
	};
  };

  Tags.prototype.insertTag = function (_, data, tag) {
	data.unshift(tag);
  };

  Tags.prototype._removeOldTags = function (_) {
	var tag = this._lastTag;

	var $options = this.$element.find('option[data-select2-tag]');

	$options.each(function () {
	  if (this.selected) {
		return;
	  }

	  $(this).remove();
	});
  };

  return Tags;
});

S2.define('select2/data/tokenizer',[
  'jquery'
], function ($) {
  function Tokenizer (decorated, $element, options) {
	var tokenizer = options.get('tokenizer');

	if (tokenizer !== undefined) {
	  this.tokenizer = tokenizer;
	}

	decorated.call(this, $element, options);
  }

  Tokenizer.prototype.bind = function (decorated, container, $container) {
	decorated.call(this, container, $container);

	this.$search =  container.dropdown.$search || container.selection.$search ||
	  $container.find('.select2-search__field');
  };

  Tokenizer.prototype.query = function (decorated, params, callback) {
	var self = this;

	function createAndSelect (data) {
	  // Normalize the data object so we can use it for checks
	  var item = self._normalizeItem(data);

	  // Check if the data object already exists as a tag
	  // Select it if it doesn't
	  var $existingOptions = self.$element.find('option').filter(function () {
		return $(this).val() === item.id;
	  });

	  // If an existing option wasn't found for it, create the option
	  if (!$existingOptions.length) {
		var $option = self.option(item);
		$option.attr('data-select2-tag', true);

		self._removeOldTags();
		self.addOptions([$option]);
	  }

	  // Select the item, now that we know there is an option for it
	  select(item);
	}

	function select (data) {
	  self.trigger('select', {
		data: data
	  });
	}

	params.term = params.term || '';

	var tokenData = this.tokenizer(params, this.options, createAndSelect);

	if (tokenData.term !== params.term) {
	  // Replace the search term if we have the search box
	  if (this.$search.length) {
		this.$search.val(tokenData.term);
		this.$search.focus();
	  }

	  params.term = tokenData.term;
	}

	decorated.call(this, params, callback);
  };

  Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
	var separators = options.get('tokenSeparators') || [];
	var term = params.term;
	var i = 0;

	var createTag = this.createTag || function (params) {
	  return {
		id: params.term,
		text: params.term
	  };
	};

	while (i < term.length) {
	  var termChar = term[i];

	  if ($.inArray(termChar, separators) === -1) {
		i++;

		continue;
	  }

	  var part = term.substr(0, i);
	  var partParams = $.extend({}, params, {
		term: part
	  });

	  var data = createTag(partParams);

	  if (data == null) {
		i++;
		continue;
	  }

	  callback(data);

	  // Reset the term to not include the tokenized portion
	  term = term.substr(i + 1) || '';
	  i = 0;
	}

	return {
	  term: term
	};
  };

  return Tokenizer;
});

S2.define('select2/data/minimumInputLength',[

], function () {
  function MinimumInputLength (decorated, $e, options) {
	this.minimumInputLength = options.get('minimumInputLength');

	decorated.call(this, $e, options);
  }

  MinimumInputLength.prototype.query = function (decorated, params, callback) {
	params.term = params.term || '';

	if (params.term.length < this.minimumInputLength) {
	  this.trigger('results:message', {
		message: 'inputTooShort',
		args: {
		  minimum: this.minimumInputLength,
		  input: params.term,
		  params: params
		}
	  });

	  return;
	}

	decorated.call(this, params, callback);
  };

  return MinimumInputLength;
});

S2.define('select2/data/maximumInputLength',[

], function () {
  function MaximumInputLength (decorated, $e, options) {
	this.maximumInputLength = options.get('maximumInputLength');

	decorated.call(this, $e, options);
  }

  MaximumInputLength.prototype.query = function (decorated, params, callback) {
	params.term = params.term || '';

	if (this.maximumInputLength > 0 &&
		params.term.length > this.maximumInputLength) {
	  this.trigger('results:message', {
		message: 'inputTooLong',
		args: {
		  maximum: this.maximumInputLength,
		  input: params.term,
		  params: params
		}
	  });

	  return;
	}

	decorated.call(this, params, callback);
  };

  return MaximumInputLength;
});

S2.define('select2/data/maximumSelectionLength',[

], function (){
  function MaximumSelectionLength (decorated, $e, options) {
	this.maximumSelectionLength = options.get('maximumSelectionLength');

	decorated.call(this, $e, options);
  }

  MaximumSelectionLength.prototype.query =
	function (decorated, params, callback) {
	  var self = this;

	  this.current(function (currentData) {
		var count = currentData != null ? currentData.length : 0;
		if (self.maximumSelectionLength > 0 &&
		  count >= self.maximumSelectionLength) {
		  self.trigger('results:message', {
			message: 'maximumSelected',
			args: {
			  maximum: self.maximumSelectionLength
			}
		  });
		  return;
		}
		decorated.call(self, params, callback);
	  });
  };

  return MaximumSelectionLength;
});

S2.define('select2/dropdown',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Dropdown ($element, options) {
	this.$element = $element;
	this.options = options;

	Dropdown.__super__.constructor.call(this);
  }

  Utils.Extend(Dropdown, Utils.Observable);

  Dropdown.prototype.render = function () {
	var $dropdown = $(
	  '<span class="select2-dropdown">' +
		'<span class="select2-results"></span>' +
	  '</span>'
	);

	$dropdown.attr('dir', this.options.get('dir'));

	this.$dropdown = $dropdown;

	return $dropdown;
  };

  Dropdown.prototype.bind = function () {
	// Should be implemented in subclasses
  };

  Dropdown.prototype.position = function ($dropdown, $container) {
	// Should be implmented in subclasses
  };

  Dropdown.prototype.destroy = function () {
	// Remove the dropdown from the DOM
	this.$dropdown.remove();
  };

  return Dropdown;
});

S2.define('select2/dropdown/search',[
  'jquery',
  '../utils'
], function ($, Utils) {
  function Search () { }

  Search.prototype.render = function (decorated) {
	var $rendered = decorated.call(this);

	var $search = $(
	  '<span class="select2-search select2-search--dropdown">' +
		'<input class="select2-search__field" type="search" tabindex="-1"' +
		' autocomplete="off" autocorrect="off" autocapitalize="off"' +
		' spellcheck="false" role="textbox" />' +
	  '</span>'
	);

	this.$searchContainer = $search;
	this.$search = $search.find('input');

	$rendered.prepend($search);

	return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	this.$search.on('keydown', function (evt) {
	  self.trigger('keypress', evt);

	  self._keyUpPrevented = evt.isDefaultPrevented();
	});

	// Workaround for browsers which do not support the `input` event
	// This will prevent double-triggering of events for browsers which support
	// both the `keyup` and `input` events.
	this.$search.on('input', function (evt) {
	  // Unbind the duplicated `keyup` event
	  $(this).off('keyup');
	});

	this.$search.on('keyup input', function (evt) {
	  self.handleSearch(evt);
	});

	container.on('open', function () {
	  self.$search.attr('tabindex', 0);

	  self.$search.focus();

	  window.setTimeout(function () {
		self.$search.focus();
	  }, 0);
	});

	container.on('close', function () {
	  self.$search.attr('tabindex', -1);

	  self.$search.val('');
	});

	container.on('focus', function () {
	  if (container.isOpen()) {
		self.$search.focus();
	  }
	});

	container.on('results:all', function (params) {
	  if (params.query.term == null || params.query.term === '') {
		var showSearch = self.showSearch(params);

		if (showSearch) {
		  self.$searchContainer.removeClass('select2-search--hide');
		} else {
		  self.$searchContainer.addClass('select2-search--hide');
		}
	  }
	});
  };

  Search.prototype.handleSearch = function (evt) {
	if (!this._keyUpPrevented) {
	  var input = this.$search.val();

	  this.trigger('query', {
		term: input
	  });
	}

	this._keyUpPrevented = false;
  };

  Search.prototype.showSearch = function (_, params) {
	return true;
  };

  return Search;
});

S2.define('select2/dropdown/hidePlaceholder',[

], function () {
  function HidePlaceholder (decorated, $element, options, dataAdapter) {
	this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

	decorated.call(this, $element, options, dataAdapter);
  }

  HidePlaceholder.prototype.append = function (decorated, data) {
	data.results = this.removePlaceholder(data.results);

	decorated.call(this, data);
  };

  HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
	if (typeof placeholder === 'string') {
	  placeholder = {
		id: '',
		text: placeholder
	  };
	}

	return placeholder;
  };

  HidePlaceholder.prototype.removePlaceholder = function (_, data) {
	var modifiedData = data.slice(0);

	for (var d = data.length - 1; d >= 0; d--) {
	  var item = data[d];

	  if (this.placeholder.id === item.id) {
		modifiedData.splice(d, 1);
	  }
	}

	return modifiedData;
  };

  return HidePlaceholder;
});

S2.define('select2/dropdown/infiniteScroll',[
  'jquery'
], function ($) {
  function InfiniteScroll (decorated, $element, options, dataAdapter) {
	this.lastParams = {};

	decorated.call(this, $element, options, dataAdapter);

	this.$loadingMore = this.createLoadingMore();
	this.loading = false;
  }

  InfiniteScroll.prototype.append = function (decorated, data) {
	this.$loadingMore.remove();
	this.loading = false;

	decorated.call(this, data);

	if (this.showLoadingMore(data)) {
	  this.$results.append(this.$loadingMore);
	}
  };

  InfiniteScroll.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	container.on('query', function (params) {
	  self.lastParams = params;
	  self.loading = true;
	});

	container.on('query:append', function (params) {
	  self.lastParams = params;
	  self.loading = true;
	});

	this.$results.on('scroll', function () {
	  var isLoadMoreVisible = $.contains(
		document.documentElement,
		self.$loadingMore[0]
	  );

	  if (self.loading || !isLoadMoreVisible) {
		return;
	  }

	  var currentOffset = self.$results.offset().top +
		self.$results.outerHeight(false);
	  var loadingMoreOffset = self.$loadingMore.offset().top +
		self.$loadingMore.outerHeight(false);

	  if (currentOffset + 50 >= loadingMoreOffset) {
		self.loadMore();
	  }
	});
  };

  InfiniteScroll.prototype.loadMore = function () {
	this.loading = true;

	var params = $.extend({}, {page: 1}, this.lastParams);

	params.page++;

	this.trigger('query:append', params);
  };

  InfiniteScroll.prototype.showLoadingMore = function (_, data) {
	return data.pagination && data.pagination.more;
  };

  InfiniteScroll.prototype.createLoadingMore = function () {
	var $option = $(
	  '<li ' +
	  'class="select2-results__option select2-results__option--load-more"' +
	  'role="treeitem" aria-disabled="true"></li>'
	);

	var message = this.options.get('translations').get('loadingMore');

	$option.html(message(this.lastParams));

	return $option;
  };

  return InfiniteScroll;
});

S2.define('select2/dropdown/attachBody',[
  'jquery',
  '../utils'
], function ($, Utils) {
  function AttachBody (decorated, $element, options) {
	this.$dropdownParent = options.get('dropdownParent') || $(document.body);

	decorated.call(this, $element, options);
  }

  AttachBody.prototype.bind = function (decorated, container, $container) {
	var self = this;

	var setupResultsEvents = false;

	decorated.call(this, container, $container);

	container.on('open', function () {
	  self._showDropdown();
	  self._attachPositioningHandler(container);

	  if (!setupResultsEvents) {
		setupResultsEvents = true;

		container.on('results:all', function () {
		  self._positionDropdown();
		  self._resizeDropdown();
		});

		container.on('results:append', function () {
		  self._positionDropdown();
		  self._resizeDropdown();
		});
	  }
	});

	container.on('close', function () {
	  self._hideDropdown();
	  self._detachPositioningHandler(container);
	});

	this.$dropdownContainer.on('mousedown', function (evt) {
	  evt.stopPropagation();
	});
  };

  AttachBody.prototype.destroy = function (decorated) {
	decorated.call(this);

	this.$dropdownContainer.remove();
  };

  AttachBody.prototype.position = function (decorated, $dropdown, $container) {
	// Clone all of the container classes
	$dropdown.attr('class', $container.attr('class'));

	$dropdown.removeClass('select2');
	$dropdown.addClass('select2-container--open');

	$dropdown.css({
	  position: 'absolute',
	  top: -999999
	});

	this.$container = $container;
  };

  AttachBody.prototype.render = function (decorated) {
	var $container = $('<span></span>');

	var $dropdown = decorated.call(this);
	$container.append($dropdown);

	this.$dropdownContainer = $container;

	return $container;
  };

  AttachBody.prototype._hideDropdown = function (decorated) {
	this.$dropdownContainer.detach();
  };

  AttachBody.prototype._attachPositioningHandler =
	  function (decorated, container) {
	var self = this;

	var scrollEvent = 'scroll.select2.' + container.id;
	var resizeEvent = 'resize.select2.' + container.id;
	var orientationEvent = 'orientationchange.select2.' + container.id;

	var $watchers = this.$container.parents().filter(Utils.hasScroll);
	$watchers.each(function () {
	  $(this).data('select2-scroll-position', {
		x: $(this).scrollLeft(),
		y: $(this).scrollTop()
	  });
	});

	$watchers.on(scrollEvent, function (ev) {
	  var position = $(this).data('select2-scroll-position');
	  $(this).scrollTop(position.y);
	});

	$(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
	  function (e) {
	  self._positionDropdown();
	  self._resizeDropdown();
	});
  };

  AttachBody.prototype._detachPositioningHandler =
	  function (decorated, container) {
	var scrollEvent = 'scroll.select2.' + container.id;
	var resizeEvent = 'resize.select2.' + container.id;
	var orientationEvent = 'orientationchange.select2.' + container.id;

	var $watchers = this.$container.parents().filter(Utils.hasScroll);
	$watchers.off(scrollEvent);

	$(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
  };

  AttachBody.prototype._positionDropdown = function () {
	var $window = $(window);

	var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
	var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');

	var newDirection = null;

	var offset = this.$container.offset();

	offset.bottom = offset.top + this.$container.outerHeight(false);

	var container = {
	  height: this.$container.outerHeight(false)
	};

	container.top = offset.top;
	container.bottom = offset.top + container.height;

	var dropdown = {
	  height: this.$dropdown.outerHeight(false)
	};

	var viewport = {
	  top: $window.scrollTop(),
	  bottom: $window.scrollTop() + $window.height()
	};

	var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
	var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);

	var css = {
	  left: offset.left,
	  top: container.bottom
	};

	// Determine what the parent element is to use for calciulating the offset
	var $offsetParent = this.$dropdownParent;

	// For statically positoned elements, we need to get the element
	// that is determining the offset
	if ($offsetParent.css('position') === 'static') {
	  $offsetParent = $offsetParent.offsetParent();
	}

	var parentOffset = $offsetParent.offset();

	css.top -= parentOffset.top;
	css.left -= parentOffset.left;

	if (!isCurrentlyAbove && !isCurrentlyBelow) {
	  newDirection = 'below';
	}

	if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
	  newDirection = 'above';
	} else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
	  newDirection = 'below';
	}

	if (newDirection == 'above' ||
	  (isCurrentlyAbove && newDirection !== 'below')) {
	  css.top = container.top - parentOffset.top - dropdown.height;
	}

	if (newDirection != null) {
	  this.$dropdown
		.removeClass('select2-dropdown--below select2-dropdown--above')
		.addClass('select2-dropdown--' + newDirection);
	  this.$container
		.removeClass('select2-container--below select2-container--above')
		.addClass('select2-container--' + newDirection);
	}

	this.$dropdownContainer.css(css);
  };

  AttachBody.prototype._resizeDropdown = function () {
	var css = {
	  width: this.$container.outerWidth(false) + 'px'
	};

	if (this.options.get('dropdownAutoWidth')) {
	  css.minWidth = css.width;
	  css.position = 'relative';
	  css.width = 'auto';
	}

	this.$dropdown.css(css);
  };

  AttachBody.prototype._showDropdown = function (decorated) {
	this.$dropdownContainer.appendTo(this.$dropdownParent);

	this._positionDropdown();
	this._resizeDropdown();
  };

  return AttachBody;
});

S2.define('select2/dropdown/minimumResultsForSearch',[

], function () {
  function countResults (data) {
	var count = 0;

	for (var d = 0; d < data.length; d++) {
	  var item = data[d];

	  if (item.children) {
		count += countResults(item.children);
	  } else {
		count++;
	  }
	}

	return count;
  }

  function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
	this.minimumResultsForSearch = options.get('minimumResultsForSearch');

	if (this.minimumResultsForSearch < 0) {
	  this.minimumResultsForSearch = Infinity;
	}

	decorated.call(this, $element, options, dataAdapter);
  }

  MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
	if (countResults(params.data.results) < this.minimumResultsForSearch) {
	  return false;
	}

	return decorated.call(this, params);
  };

  return MinimumResultsForSearch;
});

S2.define('select2/dropdown/selectOnClose',[

], function () {
  function SelectOnClose () { }

  SelectOnClose.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	container.on('close', function (params) {
	  self._handleSelectOnClose(params);
	});
  };

  SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
	if (params && params.originalSelect2Event != null) {
	  var event = params.originalSelect2Event;

	  // Don't select an item if the close event was triggered from a select or
	  // unselect event
	  if (event._type === 'select' || event._type === 'unselect') {
		return;
	  }
	}

	var $highlightedResults = this.getHighlightedResults();

	// Only select highlighted results
	if ($highlightedResults.length < 1) {
	  return;
	}

	var data = $highlightedResults.data('data');

	// Don't re-select already selected resulte
	if (
	  (data.element != null && data.element.selected) ||
	  (data.element == null && data.selected)
	) {
	  return;
	}

	this.trigger('select', {
		data: data
	});
  };

  return SelectOnClose;
});

S2.define('select2/dropdown/closeOnSelect',[

], function () {
  function CloseOnSelect () { }

  CloseOnSelect.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	container.on('select', function (evt) {
	  self._selectTriggered(evt);
	});

	container.on('unselect', function (evt) {
	  self._selectTriggered(evt);
	});
  };

  CloseOnSelect.prototype._selectTriggered = function (_, evt) {
	var originalEvent = evt.originalEvent;

	// Don't close if the control key is being held
	if (originalEvent && originalEvent.ctrlKey) {
	  return;
	}

	this.trigger('close', {
	  originalEvent: originalEvent,
	  originalSelect2Event: evt
	});
  };

  return CloseOnSelect;
});

S2.define('select2/i18n/en',[],function () {
  // English
  return {
	errorLoading: function () {
	  return 'The results could not be loaded.';
	},
	inputTooLong: function (args) {
	  var overChars = args.input.length - args.maximum;

	  var message = 'Please delete ' + overChars + ' character';

	  if (overChars != 1) {
		message += 's';
	  }

	  return message;
	},
	inputTooShort: function (args) {
	  var remainingChars = args.minimum - args.input.length;

	  var message = 'Please enter ' + remainingChars + ' or more characters';

	  return message;
	},
	loadingMore: function () {
	  return 'Loading more results';
	},
	maximumSelected: function (args) {
	  var message = 'You can only select ' + args.maximum + ' item';

	  if (args.maximum != 1) {
		message += 's';
	  }

	  return message;
	},
	noResults: function () {
	  return 'No results found';
	},
	searching: function () {
	  return 'Searching';
	}
  };
});

S2.define('select2/defaults',[
  'jquery',
  'require',

  './results',

  './selection/single',
  './selection/multiple',
  './selection/placeholder',
  './selection/allowClear',
  './selection/search',
  './selection/eventRelay',

  './utils',
  './translation',
  './diacritics',

  './data/select',
  './data/array',
  './data/ajax',
  './data/tags',
  './data/tokenizer',
  './data/minimumInputLength',
  './data/maximumInputLength',
  './data/maximumSelectionLength',

  './dropdown',
  './dropdown/search',
  './dropdown/hidePlaceholder',
  './dropdown/infiniteScroll',
  './dropdown/attachBody',
  './dropdown/minimumResultsForSearch',
  './dropdown/selectOnClose',
  './dropdown/closeOnSelect',

  './i18n/en'
], function ($, require,

			 ResultsList,

			 SingleSelection, MultipleSelection, Placeholder, AllowClear,
			 SelectionSearch, EventRelay,

			 Utils, Translation, DIACRITICS,

			 SelectData, ArrayData, AjaxData, Tags, Tokenizer,
			 MinimumInputLength, MaximumInputLength, MaximumSelectionLength,

			 Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
			 AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,

			 EnglishTranslation) {
  function Defaults () {
	this.reset();
  }

  Defaults.prototype.apply = function (options) {
	options = $.extend(true, {}, this.defaults, options);

	if (options.dataAdapter == null) {
	  if (options.ajax != null) {
		options.dataAdapter = AjaxData;
	  } else if (options.data != null) {
		options.dataAdapter = ArrayData;
	  } else {
		options.dataAdapter = SelectData;
	  }

	  if (options.minimumInputLength > 0) {
		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  MinimumInputLength
		);
	  }

	  if (options.maximumInputLength > 0) {
		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  MaximumInputLength
		);
	  }

	  if (options.maximumSelectionLength > 0) {
		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  MaximumSelectionLength
		);
	  }

	  if (options.tags) {
		options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
	  }

	  if (options.tokenSeparators != null || options.tokenizer != null) {
		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  Tokenizer
		);
	  }

	  if (options.query != null) {
		var Query = require(options.amdBase + 'compat/query');

		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  Query
		);
	  }

	  if (options.initSelection != null) {
		var InitSelection = require(options.amdBase + 'compat/initSelection');

		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  InitSelection
		);
	  }
	}

	if (options.resultsAdapter == null) {
	  options.resultsAdapter = ResultsList;

	  if (options.ajax != null) {
		options.resultsAdapter = Utils.Decorate(
		  options.resultsAdapter,
		  InfiniteScroll
		);
	  }

	  if (options.placeholder != null) {
		options.resultsAdapter = Utils.Decorate(
		  options.resultsAdapter,
		  HidePlaceholder
		);
	  }

	  if (options.selectOnClose) {
		options.resultsAdapter = Utils.Decorate(
		  options.resultsAdapter,
		  SelectOnClose
		);
	  }
	}

	if (options.dropdownAdapter == null) {
	  if (options.multiple) {
		options.dropdownAdapter = Dropdown;
	  } else {
		var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);

		options.dropdownAdapter = SearchableDropdown;
	  }

	  if (options.minimumResultsForSearch !== 0) {
		options.dropdownAdapter = Utils.Decorate(
		  options.dropdownAdapter,
		  MinimumResultsForSearch
		);
	  }

	  if (options.closeOnSelect) {
		options.dropdownAdapter = Utils.Decorate(
		  options.dropdownAdapter,
		  CloseOnSelect
		);
	  }

	  if (
		options.dropdownCssClass != null ||
		options.dropdownCss != null ||
		options.adaptDropdownCssClass != null
	  ) {
		var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');

		options.dropdownAdapter = Utils.Decorate(
		  options.dropdownAdapter,
		  DropdownCSS
		);
	  }

	  options.dropdownAdapter = Utils.Decorate(
		options.dropdownAdapter,
		AttachBody
	  );
	}

	if (options.selectionAdapter == null) {
	  if (options.multiple) {
		options.selectionAdapter = MultipleSelection;
	  } else {
		options.selectionAdapter = SingleSelection;
	  }

	  // Add the placeholder mixin if a placeholder was specified
	  if (options.placeholder != null) {
		options.selectionAdapter = Utils.Decorate(
		  options.selectionAdapter,
		  Placeholder
		);
	  }

	  if (options.allowClear) {
		options.selectionAdapter = Utils.Decorate(
		  options.selectionAdapter,
		  AllowClear
		);
	  }

	  if (options.multiple) {
		options.selectionAdapter = Utils.Decorate(
		  options.selectionAdapter,
		  SelectionSearch
		);
	  }

	  if (
		options.containerCssClass != null ||
		options.containerCss != null ||
		options.adaptContainerCssClass != null
	  ) {
		var ContainerCSS = require(options.amdBase + 'compat/containerCss');

		options.selectionAdapter = Utils.Decorate(
		  options.selectionAdapter,
		  ContainerCSS
		);
	  }

	  options.selectionAdapter = Utils.Decorate(
		options.selectionAdapter,
		EventRelay
	  );
	}

	if (typeof options.language === 'string') {
	  // Check if the language is specified with a region
	  if (options.language.indexOf('-') > 0) {
		// Extract the region information if it is included
		var languageParts = options.language.split('-');
		var baseLanguage = languageParts[0];

		options.language = [options.language, baseLanguage];
	  } else {
		options.language = [options.language];
	  }
	}

	if ($.isArray(options.language)) {
	  var languages = new Translation();
	  options.language.push('en');

	  var languageNames = options.language;

	  for (var l = 0; l < languageNames.length; l++) {
		var name = languageNames[l];
		var language = {};

		try {
		  // Try to load it with the original name
		  language = Translation.loadPath(name);
		} catch (e) {
		  try {
			// If we couldn't load it, check if it wasn't the full path
			name = this.defaults.amdLanguageBase + name;
			language = Translation.loadPath(name);
		  } catch (ex) {
			// The translation could not be loaded at all. Sometimes this is
			// because of a configuration problem, other times this can be
			// because of how Select2 helps load all possible translation files.
			if (options.debug && window.console && console.warn) {
			  console.warn(
				'Select2: The language file for "' + name + '" could not be ' +
				'automatically loaded. A fallback will be used instead.'
			  );
			}

			continue;
		  }
		}

		languages.extend(language);
	  }

	  options.translations = languages;
	} else {
	  var baseTranslation = Translation.loadPath(
		this.defaults.amdLanguageBase + 'en'
	  );
	  var customTranslation = new Translation(options.language);

	  customTranslation.extend(baseTranslation);

	  options.translations = customTranslation;
	}

	return options;
  };

  Defaults.prototype.reset = function () {
	function stripDiacritics (text) {
	  // Used 'uni range + named function' from http://jsperf.com/diacritics/18
	  function match(a) {
		return DIACRITICS[a] || a;
	  }

	  return text.replace(/[^\u0000-\u007E]/g, match);
	}

	function matcher (params, data) {
	  // Always return the object if there is nothing to compare
	  if ($.trim(params.term) === '') {
		return data;
	  }

	  // Do a recursive check for options with children
	  if (data.children && data.children.length > 0) {
		// Clone the data object if there are children
		// This is required as we modify the object to remove any non-matches
		var match = $.extend(true, {}, data);

		// Check each child of the option
		for (var c = data.children.length - 1; c >= 0; c--) {
		  var child = data.children[c];

		  var matches = matcher(params, child);

		  // If there wasn't a match, remove the object in the array
		  if (matches == null) {
			match.children.splice(c, 1);
		  }
		}

		// If any children matched, return the new object
		if (match.children.length > 0) {
		  return match;
		}

		// If there were no matching children, check just the plain object
		return matcher(params, match);
	  }

	  var original = stripDiacritics(data.text).toUpperCase();
	  var term = stripDiacritics(params.term).toUpperCase();

	  // Check if the text contains the term
	  if (original.indexOf(term) > -1) {
		return data;
	  }

	  // If it doesn't contain the term, don't return anything
	  return null;
	}

	this.defaults = {
	  amdBase: './',
	  amdLanguageBase: './i18n/',
	  closeOnSelect: true,
	  debug: false,
	  dropdownAutoWidth: false,
	  escapeMarkup: Utils.escapeMarkup,
	  language: EnglishTranslation,
	  matcher: matcher,
	  minimumInputLength: 0,
	  maximumInputLength: 0,
	  maximumSelectionLength: 0,
	  minimumResultsForSearch: 0,
	  selectOnClose: false,
	  sorter: function (data) {
		return data;
	  },
	  templateResult: function (result) {
		return result.text;
	  },
	  templateSelection: function (selection) {
		return selection.text;
	  },
	  theme: 'default',
	  width: 'resolve'
	};
  };

  Defaults.prototype.set = function (key, value) {
	var camelKey = $.camelCase(key);

	var data = {};
	data[camelKey] = value;

	var convertedData = Utils._convertData(data);

	$.extend(this.defaults, convertedData);
  };

  var defaults = new Defaults();

  return defaults;
});

S2.define('select2/options',[
  'require',
  'jquery',
  './defaults',
  './utils'
], function (require, $, Defaults, Utils) {
  function Options (options, $element) {
	this.options = options;

	if ($element != null) {
	  this.fromElement($element);
	}

	this.options = Defaults.apply(this.options);

	if ($element && $element.is('input')) {
	  var InputCompat = require(this.get('amdBase') + 'compat/inputData');

	  this.options.dataAdapter = Utils.Decorate(
		this.options.dataAdapter,
		InputCompat
	  );
	}
  }

  Options.prototype.fromElement = function ($e) {
	var excludedData = ['select2'];

	if (this.options.multiple == null) {
	  this.options.multiple = $e.prop('multiple');
	}

	if (this.options.disabled == null) {
	  this.options.disabled = $e.prop('disabled');
	}

	if (this.options.language == null) {
	  if ($e.prop('lang')) {
		this.options.language = $e.prop('lang').toLowerCase();
	  } else if ($e.closest('[lang]').prop('lang')) {
		this.options.language = $e.closest('[lang]').prop('lang');
	  }
	}

	if (this.options.dir == null) {
	  if ($e.prop('dir')) {
		this.options.dir = $e.prop('dir');
	  } else if ($e.closest('[dir]').prop('dir')) {
		this.options.dir = $e.closest('[dir]').prop('dir');
	  } else {
		this.options.dir = 'ltr';
	  }
	}

	$e.prop('disabled', this.options.disabled);
	$e.prop('multiple', this.options.multiple);

	if ($e.data('select2Tags')) {
	  if (this.options.debug && window.console && console.warn) {
		console.warn(
		  'Select2: The `data-select2-tags` attribute has been changed to ' +
		  'use the `data-data` and `data-tags="true"` attributes and will be ' +
		  'removed in future versions of Select2.'
		);
	  }

	  $e.data('data', $e.data('select2Tags'));
	  $e.data('tags', true);
	}

	if ($e.data('ajaxUrl')) {
	  if (this.options.debug && window.console && console.warn) {
		console.warn(
		  'Select2: The `data-ajax-url` attribute has been changed to ' +
		  '`data-ajax--url` and support for the old attribute will be removed' +
		  ' in future versions of Select2.'
		);
	  }

	  $e.attr('ajax--url', $e.data('ajaxUrl'));
	  $e.data('ajax--url', $e.data('ajaxUrl'));
	}

	var dataset = {};

	// Prefer the element's `dataset` attribute if it exists
	// jQuery 1.x does not correctly handle data attributes with multiple dashes
	if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
	  dataset = $.extend(true, {}, $e[0].dataset, $e.data());
	} else {
	  dataset = $e.data();
	}

	var data = $.extend(true, {}, dataset);

	data = Utils._convertData(data);

	for (var key in data) {
	  if ($.inArray(key, excludedData) > -1) {
		continue;
	  }

	  if ($.isPlainObject(this.options[key])) {
		$.extend(this.options[key], data[key]);
	  } else {
		this.options[key] = data[key];
	  }
	}

	return this;
  };

  Options.prototype.get = function (key) {
	return this.options[key];
  };

  Options.prototype.set = function (key, val) {
	this.options[key] = val;
  };

  return Options;
});

S2.define('select2/core',[
  'jquery',
  './options',
  './utils',
  './keys'
], function ($, Options, Utils, KEYS) {
  var Select2 = function ($element, options) {
	if ($element.data('select2') != null) {
	  $element.data('select2').destroy();
	}

	this.$element = $element;

	this.id = this._generateId($element);

	options = options || {};

	this.options = new Options(options, $element);

	Select2.__super__.constructor.call(this);

	// Set up the tabindex

	var tabindex = $element.attr('tabindex') || 0;
	$element.data('old-tabindex', tabindex);
	$element.attr('tabindex', '-1');

	// Set up containers and adapters

	var DataAdapter = this.options.get('dataAdapter');
	this.dataAdapter = new DataAdapter($element, this.options);

	var $container = this.render();

	this._placeContainer($container);

	var SelectionAdapter = this.options.get('selectionAdapter');
	this.selection = new SelectionAdapter($element, this.options);
	this.$selection = this.selection.render();

	this.selection.position(this.$selection, $container);

	var DropdownAdapter = this.options.get('dropdownAdapter');
	this.dropdown = new DropdownAdapter($element, this.options);
	this.$dropdown = this.dropdown.render();

	this.dropdown.position(this.$dropdown, $container);

	var ResultsAdapter = this.options.get('resultsAdapter');
	this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
	this.$results = this.results.render();

	this.results.position(this.$results, this.$dropdown);

	// Bind events

	var self = this;

	// Bind the container to all of the adapters
	this._bindAdapters();

	// Register any DOM event handlers
	this._registerDomEvents();

	// Register any internal event handlers
	this._registerDataEvents();
	this._registerSelectionEvents();
	this._registerDropdownEvents();
	this._registerResultsEvents();
	this._registerEvents();

	// Set the initial state
	this.dataAdapter.current(function (initialData) {
	  self.trigger('selection:update', {
		data: initialData
	  });
	});

	// Hide the original select
	$element.addClass('select2-hidden-accessible');
	$element.attr('aria-hidden', 'true');

	// Synchronize any monitored attributes
	this._syncAttributes();

	$element.data('select2', this);
  };

  Utils.Extend(Select2, Utils.Observable);

  Select2.prototype._generateId = function ($element) {
	var id = '';

	if ($element.attr('id') != null) {
	  id = $element.attr('id');
	} else if ($element.attr('name') != null) {
	  id = $element.attr('name') + '-' + Utils.generateChars(2);
	} else {
	  id = Utils.generateChars(4);
	}

	id = id.replace(/(:|\.|\[|\]|,)/g, '');
	id = 'select2-' + id;

	return id;
  };

  Select2.prototype._placeContainer = function ($container) {
	$container.insertAfter(this.$element);

	var width = this._resolveWidth(this.$element, this.options.get('width'));

	if (width != null) {
	  $container.css('width', width);
	}
  };

  Select2.prototype._resolveWidth = function ($element, method) {
	var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

	if (method == 'resolve') {
	  var styleWidth = this._resolveWidth($element, 'style');

	  if (styleWidth != null) {
		return styleWidth;
	  }

	  return this._resolveWidth($element, 'element');
	}

	if (method == 'element') {
	  var elementWidth = $element.outerWidth(false);

	  if (elementWidth <= 0) {
		return 'auto';
	  }

	  return elementWidth + 'px';
	}

	if (method == 'style') {
	  var style = $element.attr('style');

	  if (typeof(style) !== 'string') {
		return null;
	  }

	  var attrs = style.split(';');

	  for (var i = 0, l = attrs.length; i < l; i = i + 1) {
		var attr = attrs[i].replace(/\s/g, '');
		var matches = attr.match(WIDTH);

		if (matches !== null && matches.length >= 1) {
		  return matches[1];
		}
	  }

	  return null;
	}

	return method;
  };

  Select2.prototype._bindAdapters = function () {
	this.dataAdapter.bind(this, this.$container);
	this.selection.bind(this, this.$container);

	this.dropdown.bind(this, this.$container);
	this.results.bind(this, this.$container);
  };

  Select2.prototype._registerDomEvents = function () {
	var self = this;

	this.$element.on('change.select2', function () {
	  self.dataAdapter.current(function (data) {
		self.trigger('selection:update', {
		  data: data
		});
	  });
	});

	this.$element.on('focus.select2', function (evt) {
	  self.trigger('focus', evt);
	});

	this._syncA = Utils.bind(this._syncAttributes, this);
	this._syncS = Utils.bind(this._syncSubtree, this);

	if (this.$element[0].attachEvent) {
	  this.$element[0].attachEvent('onpropertychange', this._syncA);
	}

	var observer = window.MutationObserver ||
	  window.WebKitMutationObserver ||
	  window.MozMutationObserver
	;

	if (observer != null) {
	  this._observer = new observer(function (mutations) {
		$.each(mutations, self._syncA);
		$.each(mutations, self._syncS);
	  });
	  this._observer.observe(this.$element[0], {
		attributes: true,
		childList: true,
		subtree: false
	  });
	} else if (this.$element[0].addEventListener) {
	  this.$element[0].addEventListener(
		'DOMAttrModified',
		self._syncA,
		false
	  );
	  this.$element[0].addEventListener(
		'DOMNodeInserted',
		self._syncS,
		false
	  );
	  this.$element[0].addEventListener(
		'DOMNodeRemoved',
		self._syncS,
		false
	  );
	}
  };

  Select2.prototype._registerDataEvents = function () {
	var self = this;

	this.dataAdapter.on('*', function (name, params) {
	  self.trigger(name, params);
	});
  };

  Select2.prototype._registerSelectionEvents = function () {
	var self = this;
	var nonRelayEvents = ['toggle', 'focus'];

	this.selection.on('toggle', function () {
	  self.toggleDropdown();
	});

	this.selection.on('focus', function (params) {
	  self.focus(params);
	});

	this.selection.on('*', function (name, params) {
	  if ($.inArray(name, nonRelayEvents) !== -1) {
		return;
	  }

	  self.trigger(name, params);
	});
  };

  Select2.prototype._registerDropdownEvents = function () {
	var self = this;

	this.dropdown.on('*', function (name, params) {
	  self.trigger(name, params);
	});
  };

  Select2.prototype._registerResultsEvents = function () {
	var self = this;

	this.results.on('*', function (name, params) {
	  self.trigger(name, params);
	});
  };

  Select2.prototype._registerEvents = function () {
	var self = this;

	this.on('open', function () {
	  self.$container.addClass('select2-container--open');
	});

	this.on('close', function () {
	  self.$container.removeClass('select2-container--open');
	});

	this.on('enable', function () {
	  self.$container.removeClass('select2-container--disabled');
	});

	this.on('disable', function () {
	  self.$container.addClass('select2-container--disabled');
	});

	this.on('blur', function () {
	  self.$container.removeClass('select2-container--focus');
	});

	this.on('query', function (params) {
	  if (!self.isOpen()) {
		self.trigger('open', {});
	  }

	  this.dataAdapter.query(params, function (data) {
		self.trigger('results:all', {
		  data: data,
		  query: params
		});
	  });
	});

	this.on('query:append', function (params) {
	  this.dataAdapter.query(params, function (data) {
		self.trigger('results:append', {
		  data: data,
		  query: params
		});
	  });
	});

	this.on('keypress', function (evt) {
	  var key = evt.which;

	  if (self.isOpen()) {
		if (key === KEYS.ESC || key === KEYS.TAB ||
			(key === KEYS.UP && evt.altKey)) {
		  self.close();

		  evt.preventDefault();
		} else if (key === KEYS.ENTER) {
		  self.trigger('results:select', {});

		  evt.preventDefault();
		} else if ((key === KEYS.SPACE && evt.ctrlKey)) {
		  self.trigger('results:toggle', {});

		  evt.preventDefault();
		} else if (key === KEYS.UP) {
		  self.trigger('results:previous', {});

		  evt.preventDefault();
		} else if (key === KEYS.DOWN) {
		  self.trigger('results:next', {});

		  evt.preventDefault();
		}
	  } else {
		if (key === KEYS.ENTER || key === KEYS.SPACE ||
			(key === KEYS.DOWN && evt.altKey)) {
		  self.open();

		  evt.preventDefault();
		}
	  }
	});
  };

  Select2.prototype._syncAttributes = function () {
	this.options.set('disabled', this.$element.prop('disabled'));

	if (this.options.get('disabled')) {
	  if (this.isOpen()) {
		this.close();
	  }

	  this.trigger('disable', {});
	} else {
	  this.trigger('enable', {});
	}
  };

  Select2.prototype._syncSubtree = function (evt, mutations) {
	var changed = false;
	var self = this;

	// Ignore any mutation events raised for elements that aren't options or
	// optgroups. This handles the case when the select element is destroyed
	if (
	  evt && evt.target && (
		evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP'
	  )
	) {
	  return;
	}

	if (!mutations) {
	  // If mutation events aren't supported, then we can only assume that the
	  // change affected the selections
	  changed = true;
	} else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
	  for (var n = 0; n < mutations.addedNodes.length; n++) {
		var node = mutations.addedNodes[n];

		if (node.selected) {
		  changed = true;
		}
	  }
	} else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
	  changed = true;
	}

	// Only re-pull the data if we think there is a change
	if (changed) {
	  this.dataAdapter.current(function (currentData) {
		self.trigger('selection:update', {
		  data: currentData
		});
	  });
	}
  };

  /**
   * Override the trigger method to automatically trigger pre-events when
   * there are events that can be prevented.
   */
  Select2.prototype.trigger = function (name, args) {
	var actualTrigger = Select2.__super__.trigger;
	var preTriggerMap = {
	  'open': 'opening',
	  'close': 'closing',
	  'select': 'selecting',
	  'unselect': 'unselecting'
	};

	if (args === undefined) {
	  args = {};
	}

	if (name in preTriggerMap) {
	  var preTriggerName = preTriggerMap[name];
	  var preTriggerArgs = {
		prevented: false,
		name: name,
		args: args
	  };

	  actualTrigger.call(this, preTriggerName, preTriggerArgs);

	  if (preTriggerArgs.prevented) {
		args.prevented = true;

		return;
	  }
	}

	actualTrigger.call(this, name, args);
  };

  Select2.prototype.toggleDropdown = function () {
	if (this.options.get('disabled')) {
	  return;
	}

	if (this.isOpen()) {
	  this.close();
	} else {
	  this.open();
	}
  };

  Select2.prototype.open = function () {
	if (this.isOpen()) {
	  return;
	}

	this.trigger('query', {});
  };

  Select2.prototype.close = function () {
	if (!this.isOpen()) {
	  return;
	}

	this.trigger('close', {});
  };

  Select2.prototype.isOpen = function () {
	return this.$container.hasClass('select2-container--open');
  };

  Select2.prototype.hasFocus = function () {
	return this.$container.hasClass('select2-container--focus');
  };

  Select2.prototype.focus = function (data) {
	// No need to re-trigger focus events if we are already focused
	if (this.hasFocus()) {
	  return;
	}

	this.$container.addClass('select2-container--focus');
	this.trigger('focus', {});
  };

  Select2.prototype.enable = function (args) {
	if (this.options.get('debug') && window.console && console.warn) {
	  console.warn(
		'Select2: The `select2("enable")` method has been deprecated and will' +
		' be removed in later Select2 versions. Use $element.prop("disabled")' +
		' instead.'
	  );
	}

	if (args == null || args.length === 0) {
	  args = [true];
	}

	var disabled = !args[0];

	this.$element.prop('disabled', disabled);
  };

  Select2.prototype.data = function () {
	if (this.options.get('debug') &&
		arguments.length > 0 && window.console && console.warn) {
	  console.warn(
		'Select2: Data can no longer be set using `select2("data")`. You ' +
		'should consider setting the value instead using `$element.val()`.'
	  );
	}

	var data = [];

	this.dataAdapter.current(function (currentData) {
	  data = currentData;
	});

	return data;
  };

  Select2.prototype.val = function (args) {
	if (this.options.get('debug') && window.console && console.warn) {
	  console.warn(
		'Select2: The `select2("val")` method has been deprecated and will be' +
		' removed in later Select2 versions. Use $element.val() instead.'
	  );
	}

	if (args == null || args.length === 0) {
	  return this.$element.val();
	}

	var newVal = args[0];

	if ($.isArray(newVal)) {
	  newVal = $.map(newVal, function (obj) {
		return obj.toString();
	  });
	}

	this.$element.val(newVal).trigger('change');
  };

  Select2.prototype.destroy = function () {
	this.$container.remove();

	if (this.$element[0].detachEvent) {
	  this.$element[0].detachEvent('onpropertychange', this._syncA);
	}

	if (this._observer != null) {
	  this._observer.disconnect();
	  this._observer = null;
	} else if (this.$element[0].removeEventListener) {
	  this.$element[0]
		.removeEventListener('DOMAttrModified', this._syncA, false);
	  this.$element[0]
		.removeEventListener('DOMNodeInserted', this._syncS, false);
	  this.$element[0]
		.removeEventListener('DOMNodeRemoved', this._syncS, false);
	}

	this._syncA = null;
	this._syncS = null;

	this.$element.off('.select2');
	this.$element.attr('tabindex', this.$element.data('old-tabindex'));

	this.$element.removeClass('select2-hidden-accessible');
	this.$element.attr('aria-hidden', 'false');
	this.$element.removeData('select2');

	this.dataAdapter.destroy();
	this.selection.destroy();
	this.dropdown.destroy();
	this.results.destroy();

	this.dataAdapter = null;
	this.selection = null;
	this.dropdown = null;
	this.results = null;
  };

  Select2.prototype.render = function () {
	var $container = $(
	  '<span class="select2 select2-container">' +
		'<span class="selection"></span>' +
		'<span class="dropdown-wrapper" aria-hidden="true"></span>' +
	  '</span>'
	);

	$container.attr('dir', this.options.get('dir'));

	this.$container = $container;

	this.$container.addClass('select2-container--' + this.options.get('theme'));

	$container.data('element', this.$element);

	return $container;
  };

  return Select2;
});

S2.define('jquery-mousewheel',[
  'jquery'
], function ($) {
  // Used to shim jQuery.mousewheel for non-full builds.
  return $;
});

S2.define('jquery.select2',[
  'jquery',
  'jquery-mousewheel',

  './select2/core',
  './select2/defaults'
], function ($, _, Select2, Defaults) {
  if ($.fn.select2 == null) {
	// All methods that should return the element
	var thisMethods = ['open', 'close', 'destroy'];

	$.fn.select2 = function (options) {
	  options = options || {};

	  if (typeof options === 'object') {
		this.each(function () {
		  var instanceOptions = $.extend(true, {}, options);

		  var instance = new Select2($(this), instanceOptions);
		});

		return this;
	  } else if (typeof options === 'string') {
		var ret;
		var args = Array.prototype.slice.call(arguments, 1);

		this.each(function () {
		  var instance = $(this).data('select2');

		  if (instance == null && window.console && console.error) {
			console.error(
			  'The select2(\'' + options + '\') method was called on an ' +
			  'element that is not using Select2.'
			);
		  }

		  ret = instance[options].apply(instance, args);
		});

		// Check if we should be returning `this`
		if ($.inArray(options, thisMethods) > -1) {
		  return this;
		}

		return ret;
	  } else {
		throw new Error('Invalid arguments for Select2: ' + options);
	  }
	};
  }

  if ($.fn.select2.defaults == null) {
	$.fn.select2.defaults = Defaults;
  }

  return Select2;
});

  // Return the AMD loader configuration so it can be used outside of this file
  return {
	define: S2.define,
	require: S2.require
  };
}());

  // Autoload the jQuery bindings
  // We know that all of the modules exist above this, so we're safe
  var select2 = S2.require('jquery.select2');

  // Hold the AMD module references on the jQuery function that was just loaded
  // This allows Select2 to use the internal loader outside of this file, such
  // as in the language files.
  jQuery.fn.select2.amd = S2;

  // Return the Select2 instance for anyone who is importing it.
  return select2;
}));


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("select2", moduleFactory);

}());			(function(){
// module factory: start

var moduleFactory = function($) {
// module body: start

var jQuery = $;
var module = this; 
var exports = function() { 


/*!
 * sly 1.6.1 - 8th Aug 2015
 * https://github.com/darsain/sly
 *
 * Licensed under the MIT license.
 * http://opensource.org/licenses/MIT
 */

;(function ($, w, undefined) {
	'use strict';

	var pluginName = 'sly';
	var className  = 'Sly';
	var namespace  = pluginName;

	// Local WindowAnimationTiming interface
	var cAF = w.cancelAnimationFrame || w.cancelRequestAnimationFrame;
	var rAF = w.requestAnimationFrame;

	// Support indicators
	var transform, gpuAcceleration;

	// Other global values
	var $doc = $(document);
	var dragInitEvents = 'touchstart.' + namespace + ' mousedown.' + namespace;
	var dragMouseEvents = 'mousemove.' + namespace + ' mouseup.' + namespace;
	var dragTouchEvents = 'touchmove.' + namespace + ' touchend.' + namespace;
	var wheelEvent = (document.implementation.hasFeature('Event.wheel', '3.0') ? 'wheel.' : 'mousewheel.') + namespace;
	var clickEvent = 'click.' + namespace;
	var mouseDownEvent = 'mousedown.' + namespace;
	var interactiveElements = ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'];
	var tmpArray = [];
	var time;

	// Math shorthands
	var abs = Math.abs;
	var sqrt = Math.sqrt;
	var pow = Math.pow;
	var round = Math.round;
	var max = Math.max;
	var min = Math.min;

	// Keep track of last fired global wheel event
	var lastGlobalWheel = 0;
	$doc.on(wheelEvent, function (event) {
		var sly = event.originalEvent[namespace];
		var time = +new Date();
		// Update last global wheel time, but only when event didn't originate
		// in Sly frame, or the origin was less than scrollHijack time ago
		if (!sly || sly.options.scrollHijack < time - lastGlobalWheel) lastGlobalWheel = time;
	});

	/**
	 * Sly.
	 *
	 * @class
	 *
	 * @param {Element} frame       DOM element of sly container.
	 * @param {Object}  options     Object with options.
	 * @param {Object}  callbackMap Callbacks map.
	 */
	function Sly(frame, options, callbackMap) {
		if (!(this instanceof Sly)) return new Sly(frame, options, callbackMap);

		// Extend options
		var o = $.extend({}, Sly.defaults, options);

		// Private variables
		var self = this;
		var parallax = isNumber(frame);

		// Frame
		var $frame = $(frame);
		var $slidee = o.slidee ? $(o.slidee).eq(0) : $frame.children().eq(0);
		var frameSize = 0;
		var slideeSize = 0;
		var pos = {
			start: 0,
			center: 0,
			end: 0,
			cur: 0,
			dest: 0
		};

		// Scrollbar
		var $sb = $(o.scrollBar).eq(0);
		var $handle = $sb.children().eq(0);
		var sbSize = 0;
		var handleSize = 0;
		var hPos = {
			start: 0,
			end: 0,
			cur: 0
		};

		// Pagesbar
		var $pb = $(o.pagesBar);
		var $pages = 0;
		var pages = [];

		// Items
		var $items = 0;
		var items = [];
		var rel = {
			firstItem: 0,
			lastItem: 0,
			centerItem: 0,
			activeItem: null,
			activePage: 0
		};

		// Styles
		var frameStyles = new StyleRestorer($frame[0]);
		var slideeStyles = new StyleRestorer($slidee[0]);
		var sbStyles = new StyleRestorer($sb[0]);
		var handleStyles = new StyleRestorer($handle[0]);

		// Navigation type booleans
		var basicNav = o.itemNav === 'basic';
		var forceCenteredNav = o.itemNav === 'forceCentered';
		var centeredNav = o.itemNav === 'centered' || forceCenteredNav;
		var itemNav = !parallax && (basicNav || centeredNav || forceCenteredNav);

		// Miscellaneous
		var $scrollSource = o.scrollSource ? $(o.scrollSource) : $frame;
		var $dragSource = o.dragSource ? $(o.dragSource) : $frame;
		var $forwardButton = $(o.forward);
		var $backwardButton = $(o.backward);
		var $prevButton = $(o.prev);
		var $nextButton = $(o.next);
		var $prevPageButton = $(o.prevPage);
		var $nextPageButton = $(o.nextPage);
		var callbacks = {};
		var last = {};
		var animation = {};
		var move = {};
		var dragging = {
			released: 1
		};
		var scrolling = {
			last: 0,
			delta: 0,
			resetTime: 200
		};
		var renderID = 0;
		var historyID = 0;
		var cycleID = 0;
		var continuousID = 0;
		var i, l;

		// Normalizing frame
		if (!parallax) {
			frame = $frame[0];
		}

		// Expose properties
		self.initialized = 0;
		self.frame = frame;
		self.slidee = $slidee[0];
		self.pos = pos;
		self.rel = rel;
		self.items = items;
		self.pages = pages;
		self.isPaused = 0;
		self.options = o;
		self.dragging = dragging;

		/**
		 * Loading function.
		 *
		 * Populate arrays, set sizes, bind events, ...
		 *
		 * @param {Boolean} [isInit] Whether load is called from within self.init().
		 * @return {Void}
		 */
		function load(isInit) {
			// Local variables
			var lastItemsCount = 0;
			var lastPagesCount = pages.length;

			// Save old position
			pos.old = $.extend({}, pos);

			// Reset global variables
			frameSize = parallax ? 0 : $frame[o.horizontal ? 'width' : 'height']();
			sbSize = $sb[o.horizontal ? 'width' : 'height']();
			slideeSize = parallax ? frame : $slidee[o.horizontal ? 'outerWidth' : 'outerHeight']();
			pages.length = 0;

			// Set position limits & relatives
			pos.start = 0;
			pos.end = max(slideeSize - frameSize, 0);

			// Sizes & offsets for item based navigations
			if (itemNav) {
				// Save the number of current items
				lastItemsCount = items.length;

				// Reset itemNav related variables
				$items = $slidee.children(o.itemSelector);
				items.length = 0;

				// Needed variables
				var paddingStart = getPx($slidee, o.horizontal ? 'paddingLeft' : 'paddingTop');
				var paddingEnd = getPx($slidee, o.horizontal ? 'paddingRight' : 'paddingBottom');
				var borderBox = $($items).css('boxSizing') === 'border-box';
				var areFloated = $items.css('float') !== 'none';
				var ignoredMargin = 0;
				var lastItemIndex = $items.length - 1;
				var lastItem;

				// Reset slideeSize
				slideeSize = 0;

				// Iterate through items
				$items.each(function (i, element) {
					// Item
					var $item = $(element);
					var rect = element.getBoundingClientRect();
					var itemSize = round(o.horizontal ? rect.width || rect.right - rect.left : rect.height || rect.bottom - rect.top);
					var itemMarginStart = getPx($item, o.horizontal ? 'marginLeft' : 'marginTop');
					var itemMarginEnd = getPx($item, o.horizontal ? 'marginRight' : 'marginBottom');
					var itemSizeFull = itemSize + itemMarginStart + itemMarginEnd;
					var singleSpaced = !itemMarginStart || !itemMarginEnd;
					var item = {};
					item.el = element;
					item.size = singleSpaced ? itemSize : itemSizeFull;
					item.half = item.size / 2;
					item.start = slideeSize + (singleSpaced ? itemMarginStart : 0);
					item.center = item.start - round(frameSize / 2 - item.size / 2);
					item.end = item.start - frameSize + item.size;

					// Account for slidee padding
					if (!i) {
						slideeSize += paddingStart;
					}

					// Increment slidee size for size of the active element
					slideeSize += itemSizeFull;

					// Try to account for vertical margin collapsing in vertical mode
					// It's not bulletproof, but should work in 99% of cases
					if (!o.horizontal && !areFloated) {
						// Subtract smaller margin, but only when top margin is not 0, and this is not the first element
						if (itemMarginEnd && itemMarginStart && i > 0) {
							slideeSize -= min(itemMarginStart, itemMarginEnd);
						}
					}

					// Things to be done on last item
					if (i === lastItemIndex) {
						item.end += paddingEnd;
						slideeSize += paddingEnd;
						ignoredMargin = singleSpaced ? itemMarginEnd : 0;
					}

					// Add item object to items array
					items.push(item);
					lastItem = item;
				});

				// Resize SLIDEE to fit all items
				$slidee[0].style[o.horizontal ? 'width' : 'height'] = (borderBox ? slideeSize: slideeSize - paddingStart - paddingEnd) + 'px';

				// Adjust internal SLIDEE size for last margin
				slideeSize -= ignoredMargin;

				// Set limits
				if (items.length) {
					pos.start =  items[0][forceCenteredNav ? 'center' : 'start'];
					pos.end = forceCenteredNav ? lastItem.center : frameSize < slideeSize ? lastItem.end : pos.start;
				} else {
					pos.start = pos.end = 0;
				}
			}

			// Calculate SLIDEE center position
			pos.center = round(pos.end / 2 + pos.start / 2);

			// Update relative positions
			updateRelatives();

			// Scrollbar
			if ($handle.length && sbSize > 0) {
				// Stretch scrollbar handle to represent the visible area
				if (o.dynamicHandle) {
					handleSize = pos.start === pos.end ? sbSize : round(sbSize * frameSize / slideeSize);
					handleSize = within(handleSize, o.minHandleSize, sbSize);
					$handle[0].style[o.horizontal ? 'width' : 'height'] = handleSize + 'px';
				} else {
					handleSize = $handle[o.horizontal ? 'outerWidth' : 'outerHeight']();
				}

				hPos.end = sbSize - handleSize;

				if (!renderID) {
					syncScrollbar();
				}
			}

			// Pages
			if (!parallax && frameSize > 0) {
				var tempPagePos = pos.start;
				var pagesHtml = '';

				// Populate pages array
				if (itemNav) {
					$.each(items, function (i, item) {
						if (forceCenteredNav) {
							pages.push(item.center);
						} else if (item.start + item.size > tempPagePos && tempPagePos <= pos.end) {
							tempPagePos = item.start;
							pages.push(tempPagePos);
							tempPagePos += frameSize;
							if (tempPagePos > pos.end && tempPagePos < pos.end + frameSize) {
								pages.push(pos.end);
							}
						}
					});
				} else {
					while (tempPagePos - frameSize < pos.end) {
						pages.push(tempPagePos);
						tempPagePos += frameSize;
					}
				}

				// Pages bar
				if ($pb[0] && lastPagesCount !== pages.length) {
					for (var i = 0; i < pages.length; i++) {
						pagesHtml += o.pageBuilder.call(self, i);
					}
					$pages = $pb.html(pagesHtml).children();
					$pages.eq(rel.activePage).addClass(o.activeClass);
				}
			}

			// Extend relative variables object with some useful info
			rel.slideeSize = slideeSize;
			rel.frameSize = frameSize;
			rel.sbSize = sbSize;
			rel.handleSize = handleSize;

			// Activate requested position
			if (itemNav) {
				if (isInit && o.startAt != null) {
					activate(o.startAt);
					self[centeredNav ? 'toCenter' : 'toStart'](o.startAt);
				}
				// Fix possible overflowing
				var activeItem = items[rel.activeItem];
				slideTo(centeredNav && activeItem ? activeItem.center : within(pos.dest, pos.start, pos.end));
			} else {
				if (isInit) {
					if (o.startAt != null) slideTo(o.startAt, 1);
				} else {
					// Fix possible overflowing
					slideTo(within(pos.dest, pos.start, pos.end));
				}
			}

			// Trigger load event
			trigger('load');
		}
		self.reload = function () { load(); };

		/**
		 * Animate to a position.
		 *
		 * @param {Int}  newPos    New position.
		 * @param {Bool} immediate Reposition immediately without an animation.
		 * @param {Bool} dontAlign Do not align items, use the raw position passed in first argument.
		 *
		 * @return {Void}
		 */
		function slideTo(newPos, immediate, dontAlign) {
			// Align items
			if (itemNav && dragging.released && !dontAlign) {
				var tempRel = getRelatives(newPos);
				var isNotBordering = newPos > pos.start && newPos < pos.end;

				if (centeredNav) {
					if (isNotBordering) {
						newPos = items[tempRel.centerItem].center;
					}
					if (forceCenteredNav && o.activateMiddle) {
						activate(tempRel.centerItem);
					}
				} else if (isNotBordering) {
					newPos = items[tempRel.firstItem].start;
				}
			}

			// Handle overflowing position limits
			if (dragging.init && dragging.slidee && o.elasticBounds) {
				if (newPos > pos.end) {
					newPos = pos.end + (newPos - pos.end) / 6;
				} else if (newPos < pos.start) {
					newPos = pos.start + (newPos - pos.start) / 6;
				}
			} else {
				newPos = within(newPos, pos.start, pos.end);
			}

			// Update the animation object
			animation.start = +new Date();
			animation.time = 0;
			animation.from = pos.cur;
			animation.to = newPos;
			animation.delta = newPos - pos.cur;
			animation.tweesing = dragging.tweese || dragging.init && !dragging.slidee;
			animation.immediate = !animation.tweesing && (immediate || dragging.init && dragging.slidee || !o.speed);

			// Reset dragging tweesing request
			dragging.tweese = 0;

			// Start animation rendering
			if (newPos !== pos.dest) {
				pos.dest = newPos;
				trigger('change');
				if (!renderID) {
					render();
				}
			}

			// Reset next cycle timeout
			resetCycle();

			// Synchronize states
			updateRelatives();
			updateButtonsState();
			syncPagesbar();
		}

		/**
		 * Render animation frame.
		 *
		 * @return {Void}
		 */
		function render() {
			if (!self.initialized) {
				return;
			}

			// If first render call, wait for next animationFrame
			if (!renderID) {
				renderID = rAF(render);
				if (dragging.released) {
					trigger('moveStart');
				}
				return;
			}

			// If immediate repositioning is requested, don't animate.
			if (animation.immediate) {
				pos.cur = animation.to;
			}
			// Use tweesing for animations without known end point
			else if (animation.tweesing) {
				animation.tweeseDelta = animation.to - pos.cur;
				// Fuck Zeno's paradox
				if (abs(animation.tweeseDelta) < 0.1) {
					pos.cur = animation.to;
				} else {
					pos.cur += animation.tweeseDelta * (dragging.released ? o.swingSpeed : o.syncSpeed);
				}
			}
			// Use tweening for basic animations with known end point
			else {
				animation.time = min(+new Date() - animation.start, o.speed);
				pos.cur = animation.from + animation.delta * $.easing[o.easing](animation.time/o.speed, animation.time, 0, 1, o.speed);
			}

			// If there is nothing more to render break the rendering loop, otherwise request new animation frame.
			if (animation.to === pos.cur) {
				pos.cur = animation.to;
				dragging.tweese = renderID = 0;
			} else {
				renderID = rAF(render);
			}

			trigger('move');

			// Update SLIDEE position
			if (!parallax) {
				if (transform) {
					$slidee[0].style[transform] = gpuAcceleration + (o.horizontal ? 'translateX' : 'translateY') + '(' + (-pos.cur) + 'px)';
				} else {
					$slidee[0].style[o.horizontal ? 'left' : 'top'] = -round(pos.cur) + 'px';
				}
			}

			// When animation reached the end, and dragging is not active, trigger moveEnd
			if (!renderID && dragging.released) {
				trigger('moveEnd');
			}

			syncScrollbar();
		}

		/**
		 * Synchronizes scrollbar with the SLIDEE.
		 *
		 * @return {Void}
		 */
		function syncScrollbar() {
			if ($handle.length) {
				hPos.cur = pos.start === pos.end ? 0 : (((dragging.init && !dragging.slidee) ? pos.dest : pos.cur) - pos.start) / (pos.end - pos.start) * hPos.end;
				hPos.cur = within(round(hPos.cur), hPos.start, hPos.end);
				if (last.hPos !== hPos.cur) {
					last.hPos = hPos.cur;
					if (transform) {
						$handle[0].style[transform] = gpuAcceleration + (o.horizontal ? 'translateX' : 'translateY') + '(' + hPos.cur + 'px)';
					} else {
						$handle[0].style[o.horizontal ? 'left' : 'top'] = hPos.cur + 'px';
					}
				}
			}
		}

		/**
		 * Synchronizes pagesbar with SLIDEE.
		 *
		 * @return {Void}
		 */
		function syncPagesbar() {
			if ($pages[0] && last.page !== rel.activePage) {
				last.page = rel.activePage;
				$pages.removeClass(o.activeClass).eq(rel.activePage).addClass(o.activeClass);
				trigger('activePage', last.page);
			}
		}

		/**
		 * Returns the position object.
		 *
		 * @param {Mixed} item
		 *
		 * @return {Object}
		 */
		self.getPos = function (item) {
			if (itemNav) {
				var index = getIndex(item);
				return index !== -1 ? items[index] : false;
			} else {
				var $item = $slidee.find(item).eq(0);

				if ($item[0]) {
					var offset = o.horizontal ? $item.offset().left - $slidee.offset().left : $item.offset().top - $slidee.offset().top;
					var size = $item[o.horizontal ? 'outerWidth' : 'outerHeight']();

					return {
						start: offset,
						center: offset - frameSize / 2 + size / 2,
						end: offset - frameSize + size,
						size: size
					};
				} else {
					return false;
				}
			}
		};

		/**
		 * Continuous move in a specified direction.
		 *
		 * @param  {Bool} forward True for forward movement, otherwise it'll go backwards.
		 * @param  {Int}  speed   Movement speed in pixels per frame. Overrides options.moveBy value.
		 *
		 * @return {Void}
		 */
		self.moveBy = function (speed) {
			move.speed = speed;
			// If already initiated, or there is nowhere to move, abort
			if (dragging.init || !move.speed || pos.cur === (move.speed > 0 ? pos.end : pos.start)) {
				return;
			}
			// Initiate move object
			move.lastTime = +new Date();
			move.startPos = pos.cur;
			// Set dragging as initiated
			continuousInit('button');
			dragging.init = 1;
			// Start movement
			trigger('moveStart');
			cAF(continuousID);
			moveLoop();
		};

		/**
		 * Continuous movement loop.
		 *
		 * @return {Void}
		 */
		function moveLoop() {
			// If there is nowhere to move anymore, stop
			if (!move.speed || pos.cur === (move.speed > 0 ? pos.end : pos.start)) {
				self.stop();
			}
			// Request new move loop if it hasn't been stopped
			continuousID = dragging.init ? rAF(moveLoop) : 0;
			// Update move object
			move.now = +new Date();
			move.pos = pos.cur + (move.now - move.lastTime) / 1000 * move.speed;
			// Slide
			slideTo(dragging.init ? move.pos : round(move.pos));
			// Normally, this is triggered in render(), but if there
			// is nothing to render, we have to do it manually here.
			if (!dragging.init && pos.cur === pos.dest) {
				trigger('moveEnd');
			}
			// Update times for future iteration
			move.lastTime = move.now;
		}

		/**
		 * Stops continuous movement.
		 *
		 * @return {Void}
		 */
		self.stop = function () {
			if (dragging.source === 'button') {
				dragging.init = 0;
				dragging.released = 1;
			}
		};

		/**
		 * Activate previous item.
		 *
		 * @return {Void}
		 */
		self.prev = function () {
			self.activate(rel.activeItem == null ? 0 : rel.activeItem - 1);
		};

		/**
		 * Activate next item.
		 *
		 * @return {Void}
		 */
		self.next = function () {
			self.activate(rel.activeItem == null ? 0 : rel.activeItem + 1);
		};

		/**
		 * Activate previous page.
		 *
		 * @return {Void}
		 */
		self.prevPage = function () {
			self.activatePage(rel.activePage - 1);
		};

		/**
		 * Activate next page.
		 *
		 * @return {Void}
		 */
		self.nextPage = function () {
			self.activatePage(rel.activePage + 1);
		};

		/**
		 * Slide SLIDEE by amount of pixels.
		 *
		 * @param {Int}  delta     Pixels/Items. Positive means forward, negative means backward.
		 * @param {Bool} immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.slideBy = function (delta, immediate) {
			if (!delta) {
				return;
			}
			if (itemNav) {
				self[centeredNav ? 'toCenter' : 'toStart'](
					within((centeredNav ? rel.centerItem : rel.firstItem) + o.scrollBy * delta, 0, items.length)
				);
			} else {
				slideTo(pos.dest + delta, immediate);
			}
		};

		/**
		 * Animate SLIDEE to a specific position.
		 *
		 * @param {Int}  pos       New position.
		 * @param {Bool} immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.slideTo = function (pos, immediate) {
			slideTo(pos, immediate);
		};

		/**
		 * Core method for handling `toLocation` methods.
		 *
		 * @param  {String} location
		 * @param  {Mixed}  item
		 * @param  {Bool}   immediate
		 *
		 * @return {Void}
		 */
		function to(location, item, immediate) {
			// Optional arguments logic
			if (type(item) === 'boolean') {
				immediate = item;
				item = undefined;
			}

			if (item === undefined) {
				slideTo(pos[location], immediate);
			} else {
				// You can't align items to sides of the frame
				// when centered navigation type is enabled
				if (centeredNav && location !== 'center') {
					return;
				}

				var itemPos = self.getPos(item);
				if (itemPos) {
					slideTo(itemPos[location], immediate, !centeredNav);
				}
			}
		}

		/**
		 * Animate element or the whole SLIDEE to the start of the frame.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.
		 * @param {Bool}  immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.toStart = function (item, immediate) {
			to('start', item, immediate);
		};

		/**
		 * Animate element or the whole SLIDEE to the end of the frame.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.
		 * @param {Bool}  immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.toEnd = function (item, immediate) {
			to('end', item, immediate);
		};

		/**
		 * Animate element or the whole SLIDEE to the center of the frame.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.
		 * @param {Bool}  immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.toCenter = function (item, immediate) {
			to('center', item, immediate);
		};

		/**
		 * Get the index of an item in SLIDEE.
		 *
		 * @param {Mixed} item     Item DOM element.
		 *
		 * @return {Int}  Item index, or -1 if not found.
		 */
		function getIndex(item) {
			return item != null ?
					isNumber(item) ?
						item >= 0 && item < items.length ? item : -1 :
						$items.index(item) :
					-1;
		}
		// Expose getIndex without lowering the compressibility of it,
		// as it is used quite often throughout Sly.
		self.getIndex = getIndex;

		/**
		 * Get index of an item in SLIDEE based on a variety of input types.
		 *
		 * @param  {Mixed} item DOM element, positive or negative integer.
		 *
		 * @return {Int}   Item index, or -1 if not found.
		 */
		function getRelativeIndex(item) {
			return getIndex(isNumber(item) && item < 0 ? item + items.length : item);
		}

		/**
		 * Activates an item.
		 *
		 * @param  {Mixed} item Item DOM element, or index starting at 0.
		 *
		 * @return {Mixed} Activated item index or false on fail.
		 */
		function activate(item, force) {
			var index = getIndex(item);

			if (!itemNav || index < 0) {
				return false;
			}

			// Update classes, last active index, and trigger active event only when there
			// has been a change. Otherwise just return the current active index.
			if (last.active !== index || force) {
				// Update classes
				$items.eq(rel.activeItem).removeClass(o.activeClass);
				$items.eq(index).addClass(o.activeClass);

				last.active = rel.activeItem = index;

				updateButtonsState();
				trigger('active', index);
			}

			return index;
		}

		/**
		 * Activates an item and helps with further navigation when o.smart is enabled.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0.
		 * @param {Bool}  immediate Whether to reposition immediately in smart navigation.
		 *
		 * @return {Void}
		 */
		self.activate = function (item, immediate) {
			var index = activate(item);

			// Smart navigation
			if (o.smart && index !== false) {
				// When centeredNav is enabled, center the element.
				// Otherwise, determine where to position the element based on its current position.
				// If the element is currently on the far end side of the frame, assume that user is
				// moving forward and animate it to the start of the visible frame, and vice versa.
				if (centeredNav) {
					self.toCenter(index, immediate);
				} else if (index >= rel.lastItem) {
					self.toStart(index, immediate);
				} else if (index <= rel.firstItem) {
					self.toEnd(index, immediate);
				} else {
					resetCycle();
				}
			}
		};

		/**
		 * Activates a page.
		 *
		 * @param {Int}  index     Page index, starting from 0.
		 * @param {Bool} immediate Whether to reposition immediately without animation.
		 *
		 * @return {Void}
		 */
		self.activatePage = function (index, immediate) {
			if (isNumber(index)) {
				slideTo(pages[within(index, 0, pages.length - 1)], immediate);
			}
		};

		/**
		 * Return relative positions of items based on their visibility within FRAME.
		 *
		 * @param {Int} slideePos Position of SLIDEE.
		 *
		 * @return {Void}
		 */
		function getRelatives(slideePos) {
			slideePos = within(isNumber(slideePos) ? slideePos : pos.dest, pos.start, pos.end);

			var relatives = {};
			var centerOffset = forceCenteredNav ? 0 : frameSize / 2;

			// Determine active page
			if (!parallax) {
				for (var p = 0, pl = pages.length; p < pl; p++) {
					if (slideePos >= pos.end || p === pages.length - 1) {
						relatives.activePage = pages.length - 1;
						break;
					}

					if (slideePos <= pages[p] + centerOffset) {
						relatives.activePage = p;
						break;
					}
				}
			}

			// Relative item indexes
			if (itemNav) {
				var first = false;
				var last = false;
				var center = false;

				// From start
				for (var i = 0, il = items.length; i < il; i++) {
					// First item
					if (first === false && slideePos <= items[i].start + items[i].half) {
						first = i;
					}

					// Center item
					if (center === false && slideePos <= items[i].center + items[i].half) {
						center = i;
					}

					// Last item
					if (i === il - 1 || slideePos <= items[i].end + items[i].half) {
						last = i;
						break;
					}
				}

				// Safe assignment, just to be sure the false won't be returned
				relatives.firstItem = isNumber(first) ? first : 0;
				relatives.centerItem = isNumber(center) ? center : relatives.firstItem;
				relatives.lastItem = isNumber(last) ? last : relatives.centerItem;
			}

			return relatives;
		}

		/**
		 * Update object with relative positions.
		 *
		 * @param {Int} newPos
		 *
		 * @return {Void}
		 */
		function updateRelatives(newPos) {
			$.extend(rel, getRelatives(newPos));
		}

		/**
		 * Disable navigation buttons when needed.
		 *
		 * Adds disabledClass, and when the button is <button> or <input>, activates :disabled state.
		 *
		 * @return {Void}
		 */
		function updateButtonsState() {
			var isStart = pos.dest <= pos.start;
			var isEnd = pos.dest >= pos.end;
			var slideePosState = (isStart ? 1 : 0) | (isEnd ? 2 : 0);

			// Update paging buttons only if there has been a change in SLIDEE position
			if (last.slideePosState !== slideePosState) {
				last.slideePosState = slideePosState;

				if ($prevPageButton.is('button,input')) {
					$prevPageButton.prop('disabled', isStart);
				}

				if ($nextPageButton.is('button,input')) {
					$nextPageButton.prop('disabled', isEnd);
				}

				$prevPageButton.add($backwardButton)[isStart ? 'addClass' : 'removeClass'](o.disabledClass);
				$nextPageButton.add($forwardButton)[isEnd ? 'addClass' : 'removeClass'](o.disabledClass);
			}

			// Forward & Backward buttons need a separate state caching because we cannot "property disable"
			// them while they are being used, as disabled buttons stop emitting mouse events.
			if (last.fwdbwdState !== slideePosState && dragging.released) {
				last.fwdbwdState = slideePosState;

				if ($backwardButton.is('button,input')) {
					$backwardButton.prop('disabled', isStart);
				}

				if ($forwardButton.is('button,input')) {
					$forwardButton.prop('disabled', isEnd);
				}
			}

			// Item navigation
			if (itemNav && rel.activeItem != null) {
				var isFirst = rel.activeItem === 0;
				var isLast = rel.activeItem >= items.length - 1;
				var itemsButtonState = (isFirst ? 1 : 0) | (isLast ? 2 : 0);

				if (last.itemsButtonState !== itemsButtonState) {
					last.itemsButtonState = itemsButtonState;

					if ($prevButton.is('button,input')) {
						$prevButton.prop('disabled', isFirst);
					}

					if ($nextButton.is('button,input')) {
						$nextButton.prop('disabled', isLast);
					}

					$prevButton[isFirst ? 'addClass' : 'removeClass'](o.disabledClass);
					$nextButton[isLast ? 'addClass' : 'removeClass'](o.disabledClass);
				}
			}
		}

		/**
		 * Resume cycling.
		 *
		 * @param {Int} priority Resume pause with priority lower or equal than this. Used internally for pauseOnHover.
		 *
		 * @return {Void}
		 */
		self.resume = function (priority) {
			if (!o.cycleBy || !o.cycleInterval || o.cycleBy === 'items' && (!items[0] || rel.activeItem == null) || priority < self.isPaused) {
				return;
			}

			self.isPaused = 0;

			if (cycleID) {
				cycleID = clearTimeout(cycleID);
			} else {
				trigger('resume');
			}

			cycleID = setTimeout(function () {
				trigger('cycle');
				switch (o.cycleBy) {
					case 'items':
						self.activate(rel.activeItem >= items.length - 1 ? 0 : rel.activeItem + 1);
						break;

					case 'pages':
						self.activatePage(rel.activePage >= pages.length - 1 ? 0 : rel.activePage + 1);
						break;
				}
			}, o.cycleInterval);
		};

		/**
		 * Pause cycling.
		 *
		 * @param {Int} priority Pause priority. 100 is default. Used internally for pauseOnHover.
		 *
		 * @return {Void}
		 */
		self.pause = function (priority) {
			if (priority < self.isPaused) {
				return;
			}

			self.isPaused = priority || 100;

			if (cycleID) {
				cycleID = clearTimeout(cycleID);
				trigger('pause');
			}
		};

		/**
		 * Toggle cycling.
		 *
		 * @return {Void}
		 */
		self.toggle = function () {
			self[cycleID ? 'pause' : 'resume']();
		};

		/**
		 * Updates a signle or multiple option values.
		 *
		 * @param {Mixed} name  Name of the option that should be updated, or object that will extend the options.
		 * @param {Mixed} value New option value.
		 *
		 * @return {Void}
		 */
		self.set = function (name, value) {
			if ($.isPlainObject(name)) {
				$.extend(o, name);
			} else if (o.hasOwnProperty(name)) {
				o[name] = value;
			}
		};

		/**
		 * Add one or multiple items to the SLIDEE end, or a specified position index.
		 *
		 * @param {Mixed} element Node element, or HTML string.
		 * @param {Int}   index   Index of a new item position. By default item is appended at the end.
		 *
		 * @return {Void}
		 */
		self.add = function (element, index) {
			var $element = $(element);

			if (itemNav) {
				// Insert the element(s)
				if (index == null || !items[0] || index >= items.length) {
					$element.appendTo($slidee);
				} else if (items.length) {
					$element.insertBefore(items[index].el);
				}

				// Adjust the activeItem index
				if (rel.activeItem != null && index <= rel.activeItem) {
					last.active = rel.activeItem += $element.length;
				}
			} else {
				$slidee.append($element);
			}

			// Reload
			load();
		};

		/**
		 * Remove an item from SLIDEE.
		 *
		 * @param {Mixed} element Item index, or DOM element.
		 * @param {Int}   index   Index of a new item position. By default item is appended at the end.
		 *
		 * @return {Void}
		 */
		self.remove = function (element) {
			if (itemNav) {
				var index = getRelativeIndex(element);

				if (index > -1) {
					// Remove the element
					$items.eq(index).remove();

					// If the current item is being removed, activate new one after reload
					var reactivate = index === rel.activeItem;

					// Adjust the activeItem index
					if (rel.activeItem != null && index < rel.activeItem) {
						last.active = --rel.activeItem;
					}

					// Reload
					load();

					// Activate new item at the removed position
					if (reactivate) {
						last.active = null;
						self.activate(rel.activeItem);
					}
				}
			} else {
				$(element).remove();
				load();
			}
		};

		/**
		 * Helps re-arranging items.
		 *
		 * @param  {Mixed} item     Item DOM element, or index starting at 0. Use negative numbers to select items from the end.
		 * @param  {Mixed} position Item insertion anchor. Accepts same input types as item argument.
		 * @param  {Bool}  after    Insert after instead of before the anchor.
		 *
		 * @return {Void}
		 */
		function moveItem(item, position, after) {
			item = getRelativeIndex(item);
			position = getRelativeIndex(position);

			// Move only if there is an actual change requested
			if (item > -1 && position > -1 && item !== position && (!after || position !== item - 1) && (after || position !== item + 1)) {
				$items.eq(item)[after ? 'insertAfter' : 'insertBefore'](items[position].el);

				var shiftStart = item < position ? item : (after ? position : position - 1);
				var shiftEnd = item > position ? item : (after ? position + 1 : position);
				var shiftsUp = item > position;

				// Update activeItem index
				if (rel.activeItem != null) {
					if (item === rel.activeItem) {
						last.active = rel.activeItem = after ? (shiftsUp ? position + 1 : position) : (shiftsUp ? position : position - 1);
					} else if (rel.activeItem > shiftStart && rel.activeItem < shiftEnd) {
						last.active = rel.activeItem += shiftsUp ? 1 : -1;
					}
				}

				// Reload
				load();
			}
		}

		/**
		 * Move item after the target anchor.
		 *
		 * @param  {Mixed} item     Item to be moved. Can be DOM element or item index.
		 * @param  {Mixed} position Target position anchor. Can be DOM element or item index.
		 *
		 * @return {Void}
		 */
		self.moveAfter = function (item, position) {
			moveItem(item, position, 1);
		};

		/**
		 * Move item before the target anchor.
		 *
		 * @param  {Mixed} item     Item to be moved. Can be DOM element or item index.
		 * @param  {Mixed} position Target position anchor. Can be DOM element or item index.
		 *
		 * @return {Void}
		 */
		self.moveBefore = function (item, position) {
			moveItem(item, position);
		};

		/**
		 * Registers callbacks.
		 *
		 * @param  {Mixed} name  Event name, or callbacks map.
		 * @param  {Mixed} fn    Callback, or an array of callback functions.
		 *
		 * @return {Void}
		 */
		self.on = function (name, fn) {
			// Callbacks map
			if (type(name) === 'object') {
				for (var key in name) {
					if (name.hasOwnProperty(key)) {
						self.on(key, name[key]);
					}
				}
			// Callback
			} else if (type(fn) === 'function') {
				var names = name.split(' ');
				for (var n = 0, nl = names.length; n < nl; n++) {
					callbacks[names[n]] = callbacks[names[n]] || [];
					if (callbackIndex(names[n], fn) === -1) {
						callbacks[names[n]].push(fn);
					}
				}
			// Callbacks array
			} else if (type(fn) === 'array') {
				for (var f = 0, fl = fn.length; f < fl; f++) {
					self.on(name, fn[f]);
				}
			}
		};

		/**
		 * Registers callbacks to be executed only once.
		 *
		 * @param  {Mixed} name  Event name, or callbacks map.
		 * @param  {Mixed} fn    Callback, or an array of callback functions.
		 *
		 * @return {Void}
		 */
		self.one = function (name, fn) {
			function proxy() {
				fn.apply(self, arguments);
				self.off(name, proxy);
			}
			self.on(name, proxy);
		};

		/**
		 * Remove one or all callbacks.
		 *
		 * @param  {String} name Event name.
		 * @param  {Mixed}  fn   Callback, or an array of callback functions. Omit to remove all callbacks.
		 *
		 * @return {Void}
		 */
		self.off = function (name, fn) {
			if (fn instanceof Array) {
				for (var f = 0, fl = fn.length; f < fl; f++) {
					self.off(name, fn[f]);
				}
			} else {
				var names = name.split(' ');
				for (var n = 0, nl = names.length; n < nl; n++) {
					callbacks[names[n]] = callbacks[names[n]] || [];
					if (fn == null) {
						callbacks[names[n]].length = 0;
					} else {
						var index = callbackIndex(names[n], fn);
						if (index !== -1) {
							callbacks[names[n]].splice(index, 1);
						}
					}
				}
			}
		};

		/**
		 * Returns callback array index.
		 *
		 * @param  {String}   name Event name.
		 * @param  {Function} fn   Function
		 *
		 * @return {Int} Callback array index, or -1 if isn't registered.
		 */
		function callbackIndex(name, fn) {
			for (var i = 0, l = callbacks[name].length; i < l; i++) {
				if (callbacks[name][i] === fn) {
					return i;
				}
			}
			return -1;
		}

		/**
		 * Reset next cycle timeout.
		 *
		 * @return {Void}
		 */
		function resetCycle() {
			if (dragging.released && !self.isPaused) {
				self.resume();
			}
		}

		/**
		 * Calculate SLIDEE representation of handle position.
		 *
		 * @param  {Int} handlePos
		 *
		 * @return {Int}
		 */
		function handleToSlidee(handlePos) {
			return round(within(handlePos, hPos.start, hPos.end) / hPos.end * (pos.end - pos.start)) + pos.start;
		}

		/**
		 * Keeps track of a dragging delta history.
		 *
		 * @return {Void}
		 */
		function draggingHistoryTick() {
			// Looking at this, I know what you're thinking :) But as we need only 4 history states, doing it this way
			// as opposed to a proper loop is ~25 bytes smaller (when minified with GCC), a lot faster, and doesn't
			// generate garbage. The loop version would create 2 new variables on every tick. Unexaptable!
			dragging.history[0] = dragging.history[1];
			dragging.history[1] = dragging.history[2];
			dragging.history[2] = dragging.history[3];
			dragging.history[3] = dragging.delta;
		}

		/**
		 * Initialize continuous movement.
		 *
		 * @return {Void}
		 */
		function continuousInit(source) {
			dragging.released = 0;
			dragging.source = source;
			dragging.slidee = source === 'slidee';
		}

		/**
		 * Dragging initiator.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function dragInit(event) {
			var isTouch = event.type === 'touchstart';
			var source = event.data.source;
			var isSlidee = source === 'slidee';

			// Ignore when already in progress, or interactive element in non-touch navivagion
			if (dragging.init || !isTouch && isInteractive(event.target)) {
				return;
			}

			// Handle dragging conditions
			if (source === 'handle' && (!o.dragHandle || hPos.start === hPos.end)) {
				return;
			}

			// SLIDEE dragging conditions
			if (isSlidee && !(isTouch ? o.touchDragging : o.mouseDragging && event.which < 2)) {
				return;
			}

			if (!isTouch) {
				// prevents native image dragging in Firefox
				stopDefault(event);
			}

			// Reset dragging object
			continuousInit(source);

			// Properties used in dragHandler
			dragging.init = 0;
			dragging.$source = $(event.target);
			dragging.touch = isTouch;
			dragging.pointer = isTouch ? event.originalEvent.touches[0] : event;
			dragging.initX = dragging.pointer.pageX;
			dragging.initY = dragging.pointer.pageY;
			dragging.initPos = isSlidee ? pos.cur : hPos.cur;
			dragging.start = +new Date();
			dragging.time = 0;
			dragging.path = 0;
			dragging.delta = 0;
			dragging.locked = 0;
			dragging.history = [0, 0, 0, 0];
			dragging.pathToLock = isSlidee ? isTouch ? 30 : 10 : 0;

			// Bind dragging events
			$doc.on(isTouch ? dragTouchEvents : dragMouseEvents, dragHandler);

			// Pause ongoing cycle
			self.pause(1);

			// Add dragging class
			(isSlidee ? $slidee : $handle).addClass(o.draggedClass);

			// Trigger moveStart event
			trigger('moveStart');

			// Keep track of a dragging path history. This is later used in the
			// dragging release swing calculation when dragging SLIDEE.
			if (isSlidee) {
				historyID = setInterval(draggingHistoryTick, 10);
			}
		}

		/**
		 * Handler for dragging scrollbar handle or SLIDEE.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function dragHandler(event) {
			dragging.released = event.type === 'mouseup' || event.type === 'touchend';
			dragging.pointer = dragging.touch ? event.originalEvent[dragging.released ? 'changedTouches' : 'touches'][0] : event;
			dragging.pathX = dragging.pointer.pageX - dragging.initX;
			dragging.pathY = dragging.pointer.pageY - dragging.initY;
			dragging.path = sqrt(pow(dragging.pathX, 2) + pow(dragging.pathY, 2));
			dragging.delta = o.horizontal ? dragging.pathX : dragging.pathY;

			if (!dragging.released && dragging.path < 1) return;

			// We haven't decided whether this is a drag or not...
			if (!dragging.init) {
				// If the drag path was very short, maybe it's not a drag?
				if (dragging.path < o.dragThreshold) {
					// If the pointer was released, the path will not become longer and it's
					// definitely not a drag. If not released yet, decide on next iteration
					return dragging.released ? dragEnd() : undefined;
				}
				else {
					// If dragging path is sufficiently long we can confidently start a drag
					// if drag is in different direction than scroll, ignore it
					if (o.horizontal ? abs(dragging.pathX) > abs(dragging.pathY) : abs(dragging.pathX) < abs(dragging.pathY)) {
						dragging.init = 1;
					} else {
						return dragEnd();
					}
				}
			}

			stopDefault(event);

			// Disable click on a source element, as it is unwelcome when dragging
			if (!dragging.locked && dragging.path > dragging.pathToLock && dragging.slidee) {
				dragging.locked = 1;
				dragging.$source.on(clickEvent, disableOneEvent);
			}

			// Cancel dragging on release
			if (dragging.released) {
				dragEnd();

				// Adjust path with a swing on mouse release
				if (o.releaseSwing && dragging.slidee) {
					dragging.swing = (dragging.delta - dragging.history[0]) / 40 * 300;
					dragging.delta += dragging.swing;
					dragging.tweese = abs(dragging.swing) > 10;
				}
			}

			slideTo(dragging.slidee ? round(dragging.initPos - dragging.delta) : handleToSlidee(dragging.initPos + dragging.delta));
		}

		/**
		 * Stops dragging and cleans up after it.
		 *
		 * @return {Void}
		 */
		function dragEnd() {
			clearInterval(historyID);
			dragging.released = true;
			$doc.off(dragging.touch ? dragTouchEvents : dragMouseEvents, dragHandler);
			(dragging.slidee ? $slidee : $handle).removeClass(o.draggedClass);

			// Make sure that disableOneEvent is not active in next tick.
			setTimeout(function () {
				dragging.$source.off(clickEvent, disableOneEvent);
			});

			// Normally, this is triggered in render(), but if there
			// is nothing to render, we have to do it manually here.
			if (pos.cur === pos.dest && dragging.init) {
				trigger('moveEnd');
			}

			// Resume ongoing cycle
			self.resume(1);

			dragging.init = 0;
		}

		/**
		 * Check whether element is interactive.
		 *
		 * @return {Boolean}
		 */
		function isInteractive(element) {
			return ~$.inArray(element.nodeName, interactiveElements) || $(element).is(o.interactive);
		}

		/**
		 * Continuous movement cleanup on mouseup.
		 *
		 * @return {Void}
		 */
		function movementReleaseHandler() {
			self.stop();
			$doc.off('mouseup', movementReleaseHandler);
		}

		/**
		 * Buttons navigation handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function buttonsHandler(event) {
			/*jshint validthis:true */
			stopDefault(event);
			switch (this) {
				case $forwardButton[0]:
				case $backwardButton[0]:
					self.moveBy($forwardButton.is(this) ? o.moveBy : -o.moveBy);
					$doc.on('mouseup', movementReleaseHandler);
					break;

				case $prevButton[0]:
					self.prev();
					break;

				case $nextButton[0]:
					self.next();
					break;

				case $prevPageButton[0]:
					self.prevPage();
					break;

				case $nextPageButton[0]:
					self.nextPage();
					break;
			}
		}

		/**
		 * Mouse wheel delta normalization.
		 *
		 * @param  {Event} event
		 *
		 * @return {Int}
		 */
		function normalizeWheelDelta(event) {
			// wheelDelta needed only for IE8-
			scrolling.curDelta = ((o.horizontal ? event.deltaY || event.deltaX : event.deltaY) || -event.wheelDelta);
			scrolling.curDelta /= event.deltaMode === 1 ? 3 : 100;
			if (!itemNav) {
				return scrolling.curDelta;
			}
			time = +new Date();
			if (scrolling.last < time - scrolling.resetTime) {
				scrolling.delta = 0;
			}
			scrolling.last = time;
			scrolling.delta += scrolling.curDelta;
			if (abs(scrolling.delta) < 1) {
				scrolling.finalDelta = 0;
			} else {
				scrolling.finalDelta = round(scrolling.delta / 1);
				scrolling.delta %= 1;
			}
			return scrolling.finalDelta;
		}

		/**
		 * Mouse scrolling handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function scrollHandler(event) {
			// Mark event as originating in a Sly instance
			event.originalEvent[namespace] = self;
			// Don't hijack global scrolling
			var time = +new Date();
			if (lastGlobalWheel + o.scrollHijack > time && $scrollSource[0] !== document && $scrollSource[0] !== window) {
				lastGlobalWheel = time;
				return;
			}
			// Ignore if there is no scrolling to be done
			if (!o.scrollBy || pos.start === pos.end) {
				return;
			}
			var delta = normalizeWheelDelta(event.originalEvent);
			// Trap scrolling only when necessary and/or requested
			if (o.scrollTrap || delta > 0 && pos.dest < pos.end || delta < 0 && pos.dest > pos.start) {
				stopDefault(event, 1);
			}
			self.slideBy(o.scrollBy * delta);
		}

		/**
		 * Scrollbar click handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function scrollbarHandler(event) {
			// Only clicks on scroll bar. Ignore the handle.
			if (o.clickBar && event.target === $sb[0]) {
				stopDefault(event);
				// Calculate new handle position and sync SLIDEE to it
				slideTo(handleToSlidee((o.horizontal ? event.pageX - $sb.offset().left : event.pageY - $sb.offset().top) - handleSize / 2));
			}
		}

		/**
		 * Keyboard input handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function keyboardHandler(event) {
			if (!o.keyboardNavBy) {
				return;
			}

			switch (event.which) {
				// Left or Up
				case o.horizontal ? 37 : 38:
					stopDefault(event);
					self[o.keyboardNavBy === 'pages' ? 'prevPage' : 'prev']();
					break;

				// Right or Down
				case o.horizontal ? 39 : 40:
					stopDefault(event);
					self[o.keyboardNavBy === 'pages' ? 'nextPage' : 'next']();
					break;
			}
		}

		/**
		 * Click on item activation handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function activateHandler(event) {
			/*jshint validthis:true */

			// Ignore clicks on interactive elements.
			if (isInteractive(this)) {
				event.originalEvent[namespace + 'ignore'] = true;
				return;
			}

			// Ignore events that:
			// - are not originating from direct SLIDEE children
			// - originated from interactive elements
			if (this.parentNode !== $slidee[0] || event.originalEvent[namespace + 'ignore']) return;

			self.activate(this);
		}

		/**
		 * Click on page button handler.
		 *
		 * @param {Event} event
		 *
		 * @return {Void}
		 */
		function activatePageHandler() {
			/*jshint validthis:true */
			// Accept only events from direct pages bar children.
			if (this.parentNode === $pb[0]) {
				self.activatePage($pages.index(this));
			}
		}

		/**
		 * Pause on hover handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function pauseOnHoverHandler(event) {
			if (o.pauseOnHover) {
				self[event.type === 'mouseenter' ? 'pause' : 'resume'](2);
			}
		}

		/**
		 * Trigger callbacks for event.
		 *
		 * @param  {String} name Event name.
		 * @param  {Mixed}  argX Arguments passed to callbacks.
		 *
		 * @return {Void}
		 */
		function trigger(name, arg1) {
			if (callbacks[name]) {
				l = callbacks[name].length;
				// Callbacks will be stored and executed from a temporary array to not
				// break the execution queue when one of the callbacks unbinds itself.
				tmpArray.length = 0;
				for (i = 0; i < l; i++) {
					tmpArray.push(callbacks[name][i]);
				}
				// Execute the callbacks
				for (i = 0; i < l; i++) {
					tmpArray[i].call(self, name, arg1);
				}
			}
		}

		/**
		 * Destroys instance and everything it created.
		 *
		 * @return {Void}
		 */
		self.destroy = function () {
			// Remove the reference to itself
			Sly.removeInstance(frame);

			// Unbind all events
			$scrollSource
				.add($handle)
				.add($sb)
				.add($pb)
				.add($forwardButton)
				.add($backwardButton)
				.add($prevButton)
				.add($nextButton)
				.add($prevPageButton)
				.add($nextPageButton)
				.off('.' + namespace);

			// Unbinding specifically as to not nuke out other instances
			$doc.off('keydown', keyboardHandler);

			// Remove classes
			$prevButton
				.add($nextButton)
				.add($prevPageButton)
				.add($nextPageButton)
				.removeClass(o.disabledClass);

			if ($items && rel.activeItem != null) {
				$items.eq(rel.activeItem).removeClass(o.activeClass);
			}

			// Remove page items
			$pb.empty();

			if (!parallax) {
				// Unbind events from frame
				$frame.off('.' + namespace);
				// Restore original styles
				frameStyles.restore();
				slideeStyles.restore();
				sbStyles.restore();
				handleStyles.restore();
				// Remove the instance from element data storage
				$.removeData(frame, namespace);
			}

			// Clean up collections
			items.length = pages.length = 0;
			last = {};

			// Reset initialized status and return the instance
			self.initialized = 0;
			return self;
		};

		/**
		 * Initialize.
		 *
		 * @return {Object}
		 */
		self.init = function () {
			if (self.initialized) {
				return;
			}

			// Disallow multiple instances on the same element
			if (Sly.getInstance(frame)) throw new Error('There is already a Sly instance on this element');

			// Store the reference to itself
			Sly.storeInstance(frame, self);

			// Register callbacks map
			self.on(callbackMap);

			// Save styles
			var holderProps = ['overflow', 'position'];
			var movableProps = ['position', 'webkitTransform', 'msTransform', 'transform', 'left', 'top', 'width', 'height'];
			frameStyles.save.apply(frameStyles, holderProps);
			sbStyles.save.apply(sbStyles, holderProps);
			slideeStyles.save.apply(slideeStyles, movableProps);
			handleStyles.save.apply(handleStyles, movableProps);

			// Set required styles
			var $movables = $handle;
			if (!parallax) {
				$movables = $movables.add($slidee);
				$frame.css('overflow', 'hidden');
				if (!transform && $frame.css('position') === 'static') {
					$frame.css('position', 'relative');
				}
			}
			if (transform) {
				if (gpuAcceleration) {
					$movables.css(transform, gpuAcceleration);
				}
			} else {
				if ($sb.css('position') === 'static') {
					$sb.css('position', 'relative');
				}
				$movables.css({ position: 'absolute' });
			}

			// Navigation buttons
			if (o.forward) {
				$forwardButton.on(mouseDownEvent, buttonsHandler);
			}
			if (o.backward) {
				$backwardButton.on(mouseDownEvent, buttonsHandler);
			}
			if (o.prev) {
				$prevButton.on(clickEvent, buttonsHandler);
			}
			if (o.next) {
				$nextButton.on(clickEvent, buttonsHandler);
			}
			if (o.prevPage) {
				$prevPageButton.on(clickEvent, buttonsHandler);
			}
			if (o.nextPage) {
				$nextPageButton.on(clickEvent, buttonsHandler);
			}

			// Scrolling navigation
			$scrollSource.on(wheelEvent, scrollHandler);

			// Clicking on scrollbar navigation
			if ($sb[0]) {
				$sb.on(clickEvent, scrollbarHandler);
			}

			// Click on items navigation
			if (itemNav && o.activateOn) {
				$frame.on(o.activateOn + '.' + namespace, '*', activateHandler);
			}

			// Pages navigation
			if ($pb[0] && o.activatePageOn) {
				$pb.on(o.activatePageOn + '.' + namespace, '*', activatePageHandler);
			}

			// Dragging navigation
			$dragSource.on(dragInitEvents, { source: 'slidee' }, dragInit);

			// Scrollbar dragging navigation
			if ($handle) {
				$handle.on(dragInitEvents, { source: 'handle' }, dragInit);
			}

			// Keyboard navigation
			$doc.on('keydown', keyboardHandler);

			if (!parallax) {
				// Pause on hover
				$frame.on('mouseenter.' + namespace + ' mouseleave.' + namespace, pauseOnHoverHandler);
				// Reset native FRAME element scroll
				$frame.on('scroll.' + namespace, resetScroll);
			}

			// Mark instance as initialized
			self.initialized = 1;

			// Load
			load(true);

			// Initiate automatic cycling
			if (o.cycleBy && !parallax) {
				self[o.startPaused ? 'pause' : 'resume']();
			}

			// Return instance
			return self;
		};
	}

	Sly.getInstance = function (element) {
		return $.data(element, namespace);
	};

	Sly.storeInstance = function (element, sly) {
		return $.data(element, namespace, sly);
	};

	Sly.removeInstance = function (element) {
		return $.removeData(element, namespace);
	};

	/**
	 * Return type of the value.
	 *
	 * @param  {Mixed} value
	 *
	 * @return {String}
	 */
	function type(value) {
		if (value == null) {
			return String(value);
		}

		if (typeof value === 'object' || typeof value === 'function') {
			return Object.prototype.toString.call(value).match(/\s([a-z]+)/i)[1].toLowerCase() || 'object';
		}

		return typeof value;
	}

	/**
	 * Event preventDefault & stopPropagation helper.
	 *
	 * @param {Event} event     Event object.
	 * @param {Bool}  noBubbles Cancel event bubbling.
	 *
	 * @return {Void}
	 */
	function stopDefault(event, noBubbles) {

		// HACK: Stop the annoying console error #1203
		return;
		event.preventDefault();
		if (noBubbles) {
			event.stopPropagation();
		}
	}

	/**
	 * Disables an event it was triggered on and unbinds itself.
	 *
	 * @param  {Event} event
	 *
	 * @return {Void}
	 */
	function disableOneEvent(event) {
		/*jshint validthis:true */
		stopDefault(event, 1);
		$(this).off(event.type, disableOneEvent);
	}

	/**
	 * Resets native element scroll values to 0.
	 *
	 * @return {Void}
	 */
	function resetScroll() {
		/*jshint validthis:true */
		this.scrollLeft = 0;
		this.scrollTop = 0;
	}

	/**
	 * Check if variable is a number.
	 *
	 * @param {Mixed} value
	 *
	 * @return {Boolean}
	 */
	function isNumber(value) {
		return !isNaN(parseFloat(value)) && isFinite(value);
	}

	/**
	 * Parse style to pixels.
	 *
	 * @param {Object}   $item    jQuery object with element.
	 * @param {Property} property CSS property to get the pixels from.
	 *
	 * @return {Int}
	 */
	function getPx($item, property) {
		return 0 | round(String($item.css(property)).replace(/[^\-0-9.]/g, ''));
	}

	/**
	 * Make sure that number is within the limits.
	 *
	 * @param {Number} number
	 * @param {Number} min
	 * @param {Number} max
	 *
	 * @return {Number}
	 */
	function within(number, min, max) {
		return number < min ? min : number > max ? max : number;
	}

	/**
	 * Saves element styles for later restoration.
	 *
	 * Example:
	 *   var styles = new StyleRestorer(frame);
	 *   styles.save('position');
	 *   element.style.position = 'absolute';
	 *   styles.restore(); // restores to state before the assignment above
	 *
	 * @param {Element} element
	 */
	function StyleRestorer(element) {
		var self = {};
		self.style = {};
		self.save = function () {
			if (!element || !element.nodeType) return;
			for (var i = 0; i < arguments.length; i++) {
				self.style[arguments[i]] = element.style[arguments[i]];
			}
			return self;
		};
		self.restore = function () {
			if (!element || !element.nodeType) return;
			for (var prop in self.style) {
				if (self.style.hasOwnProperty(prop)) element.style[prop] = self.style[prop];
			}
			return self;
		};
		return self;
	}

	// Local WindowAnimationTiming interface polyfill
	(function (w) {
		rAF = w.requestAnimationFrame
			|| w.webkitRequestAnimationFrame
			|| fallback;

		/**
		* Fallback implementation.
		*/
		var prev = new Date().getTime();
		function fallback(fn) {
			var curr = new Date().getTime();
			var ms = Math.max(0, 16 - (curr - prev));
			var req = setTimeout(fn, ms);
			prev = curr;
			return req;
		}

		/**
		* Cancel.
		*/
		var cancel = w.cancelAnimationFrame
			|| w.webkitCancelAnimationFrame
			|| w.clearTimeout;

		cAF = function(id){
			cancel.call(w, id);
		};
	}(window));

	// Feature detects
	(function () {
		var prefixes = ['', 'Webkit', 'Moz', 'ms', 'O'];
		var el = document.createElement('div');

		function testProp(prop) {
			for (var p = 0, pl = prefixes.length; p < pl; p++) {
				var prefixedProp = prefixes[p] ? prefixes[p] + prop.charAt(0).toUpperCase() + prop.slice(1) : prop;
				if (el.style[prefixedProp] != null) {
					return prefixedProp;
				}
			}
		}

		// Global support indicators
		transform = testProp('transform');
		gpuAcceleration = testProp('perspective') ? 'translateZ(0) ' : '';
	}());

	// Expose class globally
	w[className] = Sly;

	// jQuery proxy
	$.fn[pluginName] = function (options, callbackMap) {
		var method, methodArgs;

		// Attributes logic
		if (!$.isPlainObject(options)) {
			if (type(options) === 'string' || options === false) {
				method = options === false ? 'destroy' : options;
				methodArgs = Array.prototype.slice.call(arguments, 1);
			}
			options = {};
		}

		// Apply to all elements
		return this.each(function (i, element) {
			// Call with prevention against multiple instantiations
			var plugin = Sly.getInstance(element);

			if (!plugin && !method) {
				// Create a new object if it doesn't exist yet
				plugin = new Sly(element, options, callbackMap).init();
			} else if (plugin && method) {
				// Call method
				if (plugin[method]) {
					plugin[method].apply(plugin, methodArgs);
				}
			}
		});
	};

	// Default options
	Sly.defaults = {
		slidee:     null,  // Selector, DOM element, or jQuery object with DOM element representing SLIDEE.
		horizontal: false, // Switch to horizontal mode.

		// Item based navigation
		itemNav:        null,  // Item navigation type. Can be: 'basic', 'centered', 'forceCentered'.
		itemSelector:   null,  // Select only items that match this selector.
		smart:          false, // Repositions the activated item to help with further navigation.
		activateOn:     null,  // Activate an item on this event. Can be: 'click', 'mouseenter', ...
		activateMiddle: false, // Always activate the item in the middle of the FRAME. forceCentered only.

		// Scrolling
		scrollSource: null,  // Element for catching the mouse wheel scrolling. Default is FRAME.
		scrollBy:     0,     // Pixels or items to move per one mouse scroll. 0 to disable scrolling.
		scrollHijack: 300,   // Milliseconds since last wheel event after which it is acceptable to hijack global scroll.
		scrollTrap:   false, // Don't bubble scrolling when hitting scrolling limits.

		// Dragging
		dragSource:    null,  // Selector or DOM element for catching dragging events. Default is FRAME.
		mouseDragging: false, // Enable navigation by dragging the SLIDEE with mouse cursor.
		touchDragging: false, // Enable navigation by dragging the SLIDEE with touch events.
		releaseSwing:  false, // Ease out on dragging swing release.
		swingSpeed:    0.2,   // Swing synchronization speed, where: 1 = instant, 0 = infinite.
		elasticBounds: false, // Stretch SLIDEE position limits when dragging past FRAME boundaries.
		dragThreshold: 3,     // Distance in pixels before Sly recognizes dragging.
		interactive:   null,  // Selector for special interactive elements.

		// Scrollbar
		scrollBar:     null,  // Selector or DOM element for scrollbar container.
		dragHandle:    false, // Whether the scrollbar handle should be draggable.
		dynamicHandle: false, // Scrollbar handle represents the ratio between hidden and visible content.
		minHandleSize: 50,    // Minimal height or width (depends on sly direction) of a handle in pixels.
		clickBar:      false, // Enable navigation by clicking on scrollbar.
		syncSpeed:     0.5,   // Handle => SLIDEE synchronization speed, where: 1 = instant, 0 = infinite.

		// Pagesbar
		pagesBar:       null, // Selector or DOM element for pages bar container.
		activatePageOn: null, // Event used to activate page. Can be: click, mouseenter, ...
		pageBuilder:          // Page item generator.
			function (index) {
				return '<li>' + (index + 1) + '</li>';
			},

		// Navigation buttons
		forward:  null, // Selector or DOM element for "forward movement" button.
		backward: null, // Selector or DOM element for "backward movement" button.
		prev:     null, // Selector or DOM element for "previous item" button.
		next:     null, // Selector or DOM element for "next item" button.
		prevPage: null, // Selector or DOM element for "previous page" button.
		nextPage: null, // Selector or DOM element for "next page" button.

		// Automated cycling
		cycleBy:       null,  // Enable automatic cycling by 'items' or 'pages'.
		cycleInterval: 5000,  // Delay between cycles in milliseconds.
		pauseOnHover:  false, // Pause cycling when mouse hovers over the FRAME.
		startPaused:   false, // Whether to start in paused sate.

		// Mixed options
		moveBy:        300,     // Speed in pixels per second used by forward and backward buttons.
		speed:         0,       // Animations speed in milliseconds. 0 to disable animations.
		easing:        'swing', // Easing for duration based (tweening) animations.
		startAt:       null,    // Starting offset in pixels or items.
		keyboardNavBy: null,    // Enable keyboard navigation by 'items' or 'pages'.

		// Classes
		draggedClass:  'dragged', // Class for dragged elements (like SLIDEE or scrollbar handle).
		activeClass:   'active',  // Class for active items and pages.
		disabledClass: 'disabled' // Class for disabled navigation elements.
	};
}(jQuery, window));

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("sly", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
$.require()
 .script("autosize.input","scrollTo", "ui/position")
 .done(function() {
var exports = function() {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

// Templates
$.template("textboxlist/item", '<div class="textboxlist-item[%== (this.locked) ? " is-locked" : "" %]" data-textboxlist-item><span class="textboxlist-itemContent" data-textboxlist-itemContent>[%== html %]</span><div class="textboxlist-itemRemoveButton" data-textboxlist-itemRemoveButton><i class="fa fa-times"></i></a></div>');
$.template("textboxlist/itemContent", '[%= title %]<input type="hidden" name="[%= name %]" value="[%= id %]"/>');

$.Controller("Textboxlist", {
	pluginName: "textboxlist",
	hostname: "textboxlist",

	defaultOptions: {

		view: {
			item: 'textboxlist/item',
			itemContent: 'textboxlist/itemContent'
		},

		plugin: {},

		// Options
		name: "items[]",
		unique: true,
		caseSensitive: false,
		max: null,
		ignoreLocked: false,

		// Events
		filterItem: null,

		"{item}"            : "[data-textboxlist-item]",
		"{itemContent}"     : "[data-textboxlist-itemContent]",
		"{itemRemoveButton}": "[data-textboxlist-itemRemoveButton]",
		"{textField}"       : "[data-textboxlist-textField]"
	}
}, function(self) { return {

	init: function() {

		var textField = self.textField();

		// Make textfield expandable
		textField.autosizeInput();

		// Keep the original placeholder text value
		textField.data("placeholderText", textField.attr("placeholder"));

		// Data attribute override options
		var name = textField.data("textboxlistName");
		if (name) {
			self.options.name = name;
		}

		// Go through existing item
		// and reconstruct item data.
		self.item().each(function(){

			var item = $(this),
				itemContent = item.find(self.itemContent.selector);

			self.createItem({

				id: item.data("id") || (function(){
					var id = $.uid("item-");
					item.data("id", id);
					return id;
				})(),

				value: item.data("value"),

				title: item.data("title") || $.trim(itemContent.text()),

				locked: item.hasClass("is-locked"),

				html: itemContent.html()
			});
		});

		// Determine if there's autocomplete
		if (self.options.plugin.autocomplete || self.element.data("query")) {
			self.addPlugin("autocomplete");
		}

		// Prevent form submission
		self.on("keypress", self.textField(), function(event){
			if (event.keyCode==KEYCODE.ENTER) return event.preventDefault();
		});
	},

	setLayout: function() {

		var textField = self.textField(),
			placeholderText = textField.data("placeholderText");

		// Don't show placeholder if there are items.
		if (self.item().length > 0) {
			placeholderText = "";
		}

		textField
			.attr("placeholder", placeholderText)
			.data("autosizeInputInstance")
			.update();
	},

	enable: function() {
		self.element.removeClass("disabled");
		self.textField().enabled(true);
	},

	disable: function() {
		self.element.addClass("disabled");
		self.textField().disabled(true);
	},

	items: {},

	itemsByTitle: {},

	get: function(title) {

		var key = self.getItemKey(title);

		if (self.itemsByTitle.hasOwnProperty(key)) {
			return self.itemsByTitle[key];
		}
	},

	getItemKey: function(title){

		return (self.options.caseSensitive) ? title : title.toLowerCase();
	},

	filterItem: function(item) {

		var options = self.options;

		// Use custom filter if provided
		var filterItem = options.filterItem;

		if ($.isFunction(filterItem)) {
			item = filterItem.call(self, item);
		}

		var items = self.itemsByTitle;

		// If item is a string,
		if ($.isString(item) && item!=="") {

			var title = item,
				key = self.getItemKey(title);

			item =
				(items.hasOwnProperty(key)) ?

					// Get existing item
					self.itemsByTitle[key] :

					{
						id    : $.uid("item-"),
						title : title,
						key   : self.getItemKey(title),
						locked: false
					}
		}

		// This is for the name attribute for the hidden input
		item.name = item.name || self.options.name;

		// If item content is not created, then make one.
		item.html = item.html || self.view.itemContent(true, item);

		return item;
	},

	createItem: function(item) {

		// Create key for item
		item.key = self.getItemKey(item.title);

		// Store to items object
		self.items[item.id] = item;

		// Store to itemsByTitle object
		self.itemsByTitle[item.key] = item;
	},

	deleteItem: function(id) {

		var item = self.items[id];

		// Remove item from the list
		self.item().filterBy("id", id)
			.remove();

		// Remove from items object
		delete self.items[id];

		// Remove from itemsByTitle object
		var key = (self.options.caseSensitive) ? item.title : item.title.toLowerCase();
		delete self.itemsByTitle[key];
	},

	addItem: function(item, force) {

		// Don't add invalid item
		if (!item) return;

		var options = self.options;

		// If we reached the maximum number of items, skip.
		var max = options.max;
		if (!force &&
			max!==null &&
			(options.ignoreLocked ? self.item(":not(.is-locked)") : self.item()).length>=max) return;

		// Filter item
		item = self.filterItem(item);

		// At this point, if item if not an object, skip.
		if (!$.isPlainObject(item)) return;

		var itemEl,
			existingItemEl = self.item().filterBy("id", item.id);

		// If items should be unique,
		// and this item has already been added to the list
		if (options.unique && existingItemEl.length > 0) {

			// then use existing item.
			itemEl = existingItemEl;
		}

		// Else create a new item
		if (!itemEl) {

			itemEl =
				self.view.item(item)
					.addClass(item.className || "")
					.attr("data-id", item.id);
		}

		self.createItem(item);

		// Locked item always gets added to the beginning
		if (item.locked) {

			var lastLockedItem = self.item(".is-locked:last");

			if (lastLockedItem.length > 0) {
				itemEl.insertAfter(lastLockedItem);
			} else {
				itemEl.prependTo(self.element);
			}

		} else {
			// Add item on to the list
			itemEl.insertBefore(self.textField());
		}

		self.trigger("addItem", [item]);
		self.trigger("listChange");

		return item;
	},

	removeItem: function(id) {

		var item = self.items[id];

		self.deleteItem(id);

		self.trigger("removeItem", [item]);
		self.trigger("listChange");
	},

	clearItems: function() {

		self.item().each(function(){
			self.removeItem($(this).data("id"));
		});
	},

	getAddedItems: function() {

		var addedItems = [];

		self.item().each(function(){

			var item = $(this),
				id = item.data("id");

			addedItems.push(self.items[id]);
		});

		return addedItems;
	},

	"{self} addItem": function() {

		self.setLayout();
	},

	"{self} removeItem": function() {

		self.setLayout();
	},

	"{itemRemoveButton} click": function(button) {

		var item = button.parents(self.item.selector);

		self.removeItem(item.data("id"));
	},

	"{textField} keydown": function(textField, event)
	{
		var keyCode = event.keyCode;

		textField.data("realEnterKey", keyCode==KEYCODE.ENTER);
	},

	"{textField} keypress": function(textField, event) {

		var keydownIsEnter = textField.data("realEnterKey"),

			// When a person enters the IME context menu,
			// the keyCode returned during keypress will
			// not be the enter keycode.
			keypressIsEnter = event.keyCode==KEYCODE.ENTER;

		textField.data("realEnterKey", keydownIsEnter && keypressIsEnter);

		var keyword = $.trim(self.textField().val());

		switch (event.keyCode) {

			// Add new item
			case KEYCODE.ENTER:

				if (textField.data("realEnterKey")) {

					var event = self.trigger("useItem", [keyword]),
						item = event.item;

					// If event handler did not decorate item,
					// use keyword as item.
					if (item===undefined) {
						item = keyword;
					}

					// If item was converted into a null/false object,
					// this means the custom keyup event wants to "preventDefault".
					if (item===false || item===null) return;

					// Detect if there is comma (,) in the item
					// Check for plain object
					if (!$.isPlainObject(item)) {
						// We try to split it by comma (,)
						var item = item.split(',');

						$.each(item, function(i, item){
							self.addItem(item);
						});
					} else {
						// Directly add the item
						self.addItem(item);
					}

					// and clear text field.
					textField.val("");
				}
				break;
		}
	},

	"{textField} keyup": function(textField, event) {
		var item = $.trim(self.textField().val());

		// Optimization for compiler
		var canRemoveItemUsingBackspace = "canRemoveItemUsingBackspace";

		switch (event.keyCode) {

			// Remove last added item
			case KEYCODE.BACKSPACE:

				// If the text field is empty
				if (item==="") {

					// If this is the first time pressing the backspace key
					if (!self[canRemoveItemUsingBackspace]) {

						// Allow removal of item for subsequent backspace
						self[canRemoveItemUsingBackspace] = true;

					// If this is the subsequent time pressing the backspace key
					} else {

						// Look for the item before it
						var prevItem = textField.prev(self.item.selector);

						// If the item before it exists,
						if (prevItem.length > 0) {

							var id = prevItem.data("id"),
								item = self.items[id];

							// Remove the item if it is not locked.
							!item.locked && self.removeItem(id);
						}
					}
				}
				break;

			default:
				// Reset backspace removal state
				self[canRemoveItemUsingBackspace] = false;
				break;
		}
	},

	"{self} click": function(el, event) {

		var textField = self.textField();

		if (!textField.is(event.target)) {
			textField.focus();
		}
	},

	"{textField} focusin": function() {

		if (self.activated) return;

		self.activated = true;
		self.trigger("textboxlistActivate");
	},

	"{self} mousedown": function() {
		self.focusing = true;
	},

	"{self} mouseup": function() {
		self.focusing = false;
	},

	"{self} focusout": function() {

		if (self.focusing) return;

		self.activated = false;

		self.deactivateTimer =
			setTimeout(function(){
				if (self.activated) return;
				self.trigger("textboxlistDeactivate");
			}, 1);
	}
}});

$(document)
	.on('click.textboxlist.data-api', '[data-textboxlist]', function(event){
		$(this).addController($.Controller.Textboxlist).textField().focus();
	})
	.on('focus.textboxlist.data-api', '[data-textboxlist] [data-textboxlist-textField]', function(event){
		$(this).parents("[data-textboxlist]").addController($.Controller.Textboxlist);
	});
// Textboxlist ends

// Autocomplete starts
$.template("textboxlist/menu", '<div id="es" class="textboxlist-autocomplete" data-textboxlist-autocomplete><b><b></b></b><div class="textboxlist-autocomplete-inner" data-textboxlist-autocomplete-viewport><div class="textboxlist-autocomplete-loading" data-textboxlist-autocomplete-loading></div><div class="textboxlist-autocomplete-empty" data-textboxlist-autocomplete-empty></div><ul class="textboxlist-menu" data-textboxlist-menu></ul></div></div>');
$.template("textboxlist/menuItem", '<li class="textboxlist-menuItem" data-textboxlist-menuItem>[%== html %]</li>');
$.template("textboxlist/loadingHint", '<i class="o-loader o-loader--sm is-active"></i>');
$.template("textboxlist/emptyHint", '<span class="textboxlist-autocomplete-empty-text">No items found.</span>');

$.Controller("Textboxlist.Autocomplete", {

	defaultOptions: {

		view: {
			menu: "textboxlist/menu",
			menuItem: "textboxlist/menuItem",
			loadingHint: "textboxlist/loadingHint",
			emptyHint: "textboxlist/emptyHint"
		},

		cache: true,
		minLength: 1,
		limit: 10,
		highlight: true,
		caseSensitive: false,
		exclusive: false,

		// Accepts url, function or array of objects.
		// If function, it should return a deferred object.
		query: null,

		position: {
			my: 'left top',
			at: 'left bottom',
			collision: 'none'
		},

		filterItem: null,
		showEmptyHint: false,
		showLoadingHint: false,

		id: "es",
		component: "",
		modifier: "",
		shadow: false,
		sticky: false,
		animation: false,

		emptyMessage: "No items found.",

		"{menu}": "[data-textboxlist-menu]",
		"{menuItem}": "[data-textboxlist-menuItem]",
		"{viewport}": "[data-textboxlist-autocomplete-viewport]",
		"{loadingHint}": "[data-textboxlist-autocomplete-loading]",
		"{emptyHint}": "[data-textboxlist-autocomplete-empty]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// Destroy controller
		if (!self.element.data(self.Class.fullName)) {

			self.destroy();

			// And reimplement on the context menu we created ourselves
			self.view.menu()
				.attr("id", opts.id)
				.addClass(opts.component)
				.addClass(opts.modifier)
				.addClass(opts.shadow ? 'has-shadow' : '')
				.addClass(opts.animation ? 'has-animation' : '')
				.addClass(opts.sticky ? 'is-sticky' : '')
				// This is legacy
				.addClass(self.textboxlist.options.component)
				.appendTo("body")
				.data(self.Class.fullName, true)
				.addController(self.Class, self.options);

			return;
		}

		var textboxlist = self.textboxlist;

		textboxlist.autocomplete = self;
		textboxlist.pluginInstances["autocomplete"] = self;

		// Set the position to be relative to the textboxlist
		self.options.position.of = self.textboxlist.element;

		self.initQuery();

		// Loading hint
		self.view.loadingHint()
			.appendTo(self.loadingHint());

		// Empty hint
		var emptyHint = self.view.emptyHint();
		emptyHint.html(opts.emptyMessage)
			.appendTo(self.emptyHint());

		// Only reattach element when autocomplete is needed.
		self.element.detach();
	},

	initQuery: function() {

		// Determine query method
		var query = self.options.query || self.textboxlist.element.data("query");

		// TODO: Wrap up query options and pass to query URL & query function.

		// Query URL
		if ($.isUrl(query)) {

			var url = query;

			self.query = function(keyword){
				return $.ajax(url + keyword);
			}

			return;
		}

		// Query function
		if ($.isFunction(query)) {

			var func = query;

			self.query = function(keyword) {
				return func.call(self, keyword);
			}

			return;
		}

		// Query dataset
		if ($.isArray(query)) {

			var dataset = query;

			self.query = function(keyword) {

				var task = $.Deferred(),
					keyword = keyword.toLowerCase();

				// Fork this process
				// so it won't choke on large dataset.
				setTimeout(function(){

					var result = $.grep(dataset, function(item){
						return item.title.toLowerCase().indexOf(keyword) > -1;
					});

					task.resolve(result);

				}, 0);

				return task;
			}

			return;
		}
	},

	setLayout: function() {

		if (!self.hidden) {

			self.element
				.css({
					opacity: 1,
					width: self.textboxlist.element.outerWidth()
				})
				.position(self.options.position);
		}
	},

	"{window} resize": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} scroll": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} dialogTransitionStart": function() {
		self.hidden = true;
		self.element.css("opacity", 0);
	},

	"{window} dialogTransitionEnd": function() {
		self.hidden = false;
		self.setLayout();
	},

	show: function() {

		clearTimeout(self.sleep);

		self.element
			.appendTo("body")
			.show();

		self.hidden = false;

		self.setLayout();
	},

	hide: function() {

		self.element.hide();

		var menuItem = self.menuItem(),
			activeMenuItem = menuItem.filter(".active");

		if (activeMenuItem.length > 0) {
			self.lastItem = {
				keyword: $.trim(self.textboxlist.textField().val()),
				item   : activeMenuItem.data("item")
			};
		}

		menuItem.removeClass("active");

		self.render.reset();

		self.hidden = true;

		// Clear any previous sleep timer first
		clearTimeout(self.sleep);

		// If no activity within 3000 seconds, detach myself.
		self.sleep = setTimeout(function(){
			self.element.detach();
		}, 3000);
	},

	queries: {},

	populated: false,

	populate: function(keyword) {

		self.populated = false;

		// Remove loading class
		var element = self.element,
			options = self.options;

		// Remove both loading & empty class
		element.removeClass("loading empty");

		if (options.showLoadingHint) {
			self.hide();
		}

		// Trigger populate event
		// If the populate event returns a modified keyword, use it.
		var event = self.trigger("populateKeyword", [keyword]);
		if (event.keyword) { keyword = event.keyword };


		var key = (options.caseSensitive) ? keyword : keyword.toLowerCase(),
			query = self.queries[key];

		var newQuery = !$.isDeferred(query) || !self.options.cache,

			runQuery = function(){

				// Show loading hint
				if (options.showLoadingHint) {
					element.addClass("loading");
					self.show();
				}

				// Query the keyword if:
				// - The query hasn't been made.
				// - The query has been rejected.
				if (newQuery || (!newQuery && query.state()=="rejected")) {

					query = self.queries[key] = self.query(keyword);
				}

				// When query is done, render items;
				query
					.done(
						self.render(function(items){
							return [items, keyword];
						})
					)
					.fail(function(){
						self.hide();
					})
					.always(function(){
						element.removeClass("loading");
					});

				// Trigger query event
				self.trigger("queryKeyword", [query, keyword]);
			}

		// If this is a new query
		if (newQuery) {

			// Don't run until we are sure that the user is finished typing
			clearTimeout(self.queryTask);
			self.queryTask = setTimeout(runQuery, 250);

		// Else run it immediately
		} else {
			runQuery();
		}
	},

	populateTask: null,

	populateFromTextField: function() {

		clearTimeout(self.populateTask);

		self.populateTask = setTimeout(function(){

			var textField = self.textboxlist.textField(),
				keyword = $.trim(textField.val());

			// If no keyword given or keyword doesn't meet minimum query length, stop.
			if (keyword==="" || (keyword.length < self.options.minLength)) {

				self.hide();

			// Else populate suggestions.
			} else {

				self.populate(keyword);
			}
		}, 1);
	},

	render: $.Enqueue(function(items, keyword){

		// If items passed in isn't an array,
		// fake an empty array.
		if (!$.isArray(items)) { items = [] };


		// Get textboxlist
		var textboxlist = self.textboxlist,
			autocomplete = self,
			element = self.element,
			options = self.options,
			menu = self.menu();

		// If there are no items, hide menu.
		if (items.length < 1) {

			// If we are supposed to show an empty hint
			if (options.showEmptyHint) {

				// Clear out menu
				menu.empty();

				// Add empty class
				element.addClass("empty");

				// Trigger renderMenu event
				textboxlist.trigger("renderMenu", [menu, autocomplete, textboxlist]);

				// Show menu
				self.show();

			// Just hide straight away
			} else {

				self.hide();
			}

			return;
		}

		// Remove empty class
		element.removeClass("empty");

		// Generate menu items
		if (!options.cache || menu.data("keyword")!==keyword) {

			// Clear out menu items
			menu.empty();

			$.each(items, function(i, item){

				if (!$.isPlainObject(item)) {
					var item = {
						"html": item
					};
				}

				textboxlist.trigger("filterItem", [item, autocomplete, textboxlist]);

				// Deprecated
				var filterItem = options.filterItem;
				if ($.isFunction(filterItem)) {
					item = filterItem.call(self, item, keyword);
				}


				// If the item is not an object,
				// or item should be discarded, stop.
				if (!$.isPlainObject(item) || item.discard) {
					console.log('discarding?');
					return;
				}

				var html = item.menuHtml || item.title;

				self.view.menuItem({html: html})
					.addClass(item.className || "")
					.data("item", item)
					.appendTo(menu);
			});

			menu.data("keyword", keyword);
		}

		// Get menu Items
		var menuItems = self.menuItem();

		// Trigger filterMenu event
		textboxlist.trigger("filterMenu", [menu, menuItems, autocomplete, textboxlist]);

		// If menu is empty, toggle empty classname
		if (menuItems.filter(":not(.hidden)").length < 1) {

			element.addClass("empty");

			// If we shouldn't show an empty hint
			if (!options.showEmptyHint) {

				// Hide menu straightaway
				return self.hide();
			}
		}

		// If we only allow adding item from suggestions
		if (options.exclusive) {

			// Automatically select the first item
			self.menuItem(":not(.hidden):first").addClass("active");
		}

		// Trigger renderMenu event
		textboxlist.trigger("renderMenu", [menu, autocomplete, textboxlist]);

		self.show();
	}),

	"{textboxlist.textField} keydown": function(textField, event) {

		// Prevent autocomplete from falling asleep.
		clearTimeout(self.sleep);

		// Get active menu item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		if (activeMenuItem.length < 1) {
			activeMenuItem = false;
		}

		var textField = self.textboxlist.textField();

		switch (event.keyCode) {

			// If up key is pressed
			case KEYCODE.UP:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the last one.
					self.menuItem(":not(.hidden):last").addClass("active");

				// Else find the menu item before it,
				} else {

					// and activate it.
					activeMenuItem.prev(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// We store this for the next item when at the end of the list
				var nextMenuItem = self.menuItem(":not(.hidden):last");

				// Prevent up/down keys from changing textfield cursor position.
				event.preventDefault();
				break;

			// If down key is pressed
			case KEYCODE.DOWN:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the first one.
					self.menuItem(":not(.hidden):first").addClass("active");

				// Else find the menu item after it,
				} else {

					// and activate it.
					activeMenuItem.next(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// We store this for the next item when at the end of the list
				var nextMenuItem = self.menuItem(":not(.hidden):first");

				// Prevent up/down keys from changing textfield cursor position.
				event.preventDefault();
				break;

			// If escape is pressed,
			case KEYCODE.ESCAPE:

				// hide menu.
				self.hide();
				break;

			// Don't do anything when enter is pressed.
			case KEYCODE.ENTER:
				break;

			default:
				self.populateFromTextField();
				break;
		}

		// Get newly activated item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		// If we are reaching the end of the menu cycle,
		// select textfield as a visual indication, else
		// unselect textfield and let the menu item appear selected.
		if (activeMenuItem.length < 1) {
			if (event.keyCode == KEYCODE.DOWN || event.keyCode == KEYCODE.UP) {
				var activeMenuItem = nextMenuItem;
				activeMenuItem.addClass("active");
			} else {
				return;
			}
		}

		// Scroll menu viewport if it is out of visible area.
		self.viewport().scrollIntoView(activeMenuItem);
	},

	"{textboxlist} textboxlistActivate": function(textboxlist) {

		self.populateFromTextField();
	},

	"{textboxlist} textboxlistDeactivate": function(textboxlist) {

		// Allow user to select menu first
		setTimeout(function(){
			self.hide();
		}, 150);
	},

	"{textboxlist} destroyed": function() {

		self.element.remove();
	},

	"{textboxlist} useItem": function(textField, event, keyword) {

		// If we only pick items exclusively from menu,
		// set item to false first. This prevents any
		// random keyword from being added to the list.
		var exclusive = self.options.exclusive;

		if (exclusive) event.item = false;

		// If menu is not visible
		if (self.hidden) {

			// and we are in exclusive mode
			// and the last item before we hide the menu
			// matches the current keyword,
			var lastItem = self.lastItem;

			if (exclusive && lastItem && lastItem.keyword==keyword) {

				// then we will automatically use the last
				// item as the item to be added to the list.
				event.item = lastItem.item;
			}

			return;
		}

		// If there are activated items
		var activeMenuItem = self.menuItem(".active");

		if (activeMenuItem.length > 0) {

			// get the item data,
			var item = activeMenuItem.data("item");

			// and return the item data to the textboxlist.
			event.item = item;
		}

		// Hide the menu
		self.hide();
	},

	"{menuItem} mousedown": function() {

		self.textboxlist.focusing = true;
	},

	"{menuItem} mouseup": function() {

		self.textboxlist.focusing = false;
	},

	"{menuItem} click": function(menuItem) {

		// Hide context menu
		self.hide();

		// Add item
		var item = menuItem.data("item");
		self.textboxlist.addItem(item);

		// Get text field & clear text field
		var textField = self.textboxlist.textField().val("");

		// Refocus text field
		setTimeout(function(){

			// Due to event delegation, this needs to be slightly delayed.
			textField.focus();
		}, 150);
	},

	"{menuItem} mouseover": function(menuItem) {

		self.menuItem().removeClass("active");

		menuItem.addClass("active");
	},

	"{menuItem} mouseout": function(menuItem) {

		self.menuItem().removeClass("active");
	}
}}
);
// Autocomplete ends
};

exports();
module.resolveWith(exports);

});
// module body: end

};
// module factory: end

FD40.module("textboxlist", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery UI Core 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.4pre",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

$(function(){

	if ($("body > [id=es].ui").length > 0) return;

	// Create container for #fd-ui
	$(document.createElement("div"))
		.attr("id", "es")
		.addClass("ui")
		.css({
			position: "absolute",
			top: 0,
			left: 0,
			overflow: "visible",
			width: 0,
			height: 0,
			zIndex: 10002
		})
		.appendTo("body");
});

})( jQuery );

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("ui/core", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
$.require() 
 .script("ui/widget") 
 .done(function() { 
var exports = function() { 

/*!
 * jQuery UI Mouse 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.10.4pre",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown."+this.widgetName, function(event, eventOverride) {
				return that._mouseDown(eventOverride || event);
			})
			.bind("click."+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("."+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

})(jQuery);

}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("ui/mouse", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery UI Position 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
			overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] );
		return {
			element: withinElement,
			isWindow: isWindow,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom > 0 ) {
				newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

}( jQuery ) );

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("ui/position", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
$.require() 
 .script("ui/core","ui/mouse","ui/widget") 
 .done(function() { 
var exports = function() { 

/*!
 * jQuery UI Resizable 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/resizable/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

function num(v) {
	return parseInt(v, 10) || 0;
}

function isNumber(value) {
	return !isNaN(parseInt(value, 10));
}

$.widget("ui.resizable", $.ui.mouse, {
	version: "1.10.4pre",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		// See #7960
		zIndex: 90,

		// callbacks
		resize: null,
		start: null,
		stop: null
	},
	_create: function() {

		var n, i, handle, axis, hname,
			that = this,
			o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
					position: this.element.css("position"),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css("top"),
					left: this.element.css("left")
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"ui-resizable", this.element.data("ui-resizable")
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css("resize");
			this.originalElement.css("resize", "none");

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css("margin") });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : { n: ".ui-resizable-n", e: ".ui-resizable-e", s: ".ui-resizable-s", w: ".ui-resizable-w", se: ".ui-resizable-se", sw: ".ui-resizable-sw", ne: ".ui-resizable-ne", nw: ".ui-resizable-nw" });
		if(this.handles.constructor === String) {

			if ( this.handles === "all") {
				this.handles = "n,e,s,w,se,sw,ne,nw";
			}

			n = this.handles.split(",");
			this.handles = {};

			for(i = 0; i < n.length; i++) {

				handle = $.trim(n[i]);
				hname = "ui-resizable-"+handle;
				axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

				// Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				//TODO : What's going on here?
				if ("se" === handle) {
					axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
				}

				//Insert into internal handles object and append to element
				this.handles[handle] = ".ui-resizable-"+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for(i in this.handles) {

				if(this.handles[i].constructor === String) {
					this.handles[i] = $(this.handles[i], this.element).show();
				}

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					axis = $(this.handles[i], this.element);

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					padPos = [ "padding",
						/ne|nw|n/.test(i) ? "Top" :
						/se|sw|s/.test(i) ? "Bottom" :
						/^e$/.test(i) ? "Right" : "Left" ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length) {
					continue;
				}
			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $(".ui-resizable-handle", this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className) {
					axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				}
				//Axis, default = se
				that.axis = axis && axis[1] ? axis[1] : "se";
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.mouseenter(function() {
					if (o.disabled) {
						return;
					}
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
				.mouseleave(function(){
					if (o.disabled) {
						return;
					}
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function(exp) {
				$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
					.removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
			};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css("position"),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css("top"),
				left: wrapper.css("left")
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css("resize", this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var i, handle,
			capture = false;

		for (i in this.handles) {
			handle = $(this.handles[i])[0];
			if (handle === event.target || $.contains(handle, event.target)) {
				capture = true;
			}
		}

		return !this.options.disabled && capture;
	},

	_mouseStart: function(event) {

		var curleft, curtop, cursor,
			o = this.options,
			iniPos = this.element.position(),
			el = this.element;

		this.resizing = true;

		// bugfix for http://dev.jquery.com/ticket/1749
		if ( (/absolute/).test( el.css("position") ) ) {
			el.css({ position: "absolute", top: el.css("top"), left: el.css("left") });
		} else if (el.is(".ui-draggable")) {
			el.css({ position: "absolute", top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		curleft = num(this.helper.css("left"));
		curtop = num(this.helper.css("top"));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

		cursor = $(".ui-resizable-" + this.axis).css("cursor");
		$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var data,
			el = this.helper, props = {},
			smp = this.originalMousePosition,
			a = this.axis,
			prevTop = this.position.top,
			prevLeft = this.position.left,
			prevWidth = this.size.width,
			prevHeight = this.size.height,
			dx = (event.pageX-smp.left)||0,
			dy = (event.pageY-smp.top)||0,
			trigger = this._change[a];

		if (!trigger) {
			return false;
		}

		// Calculate the attrs that will be change
		data = trigger.apply(this, [event, dx, dy]);

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey) {
			data = this._updateRatio(data, event);
		}

		data = this._respectSize(data, event);

		this._updateCache(data);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		if (this.position.top !== prevTop) {
			props.top = this.position.top + "px";
		}
		if (this.position.left !== prevLeft) {
			props.left = this.position.left + "px";
		}
		if (this.size.width !== prevWidth) {
			props.width = this.size.width + "px";
		}
		if (this.size.height !== prevHeight) {
			props.height = this.size.height + "px";
		}
		el.css(props);

		if (!this._helper && this._proportionallyResizeElements.length) {
			this._proportionallyResize();
		}

		// Call the user callback if the element was resized
		if ( ! $.isEmptyObject(props) ) {
			this._trigger("resize", event, this.ui());
		}

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if(this._helper) {

			pr = this._proportionallyResizeElements;
			ista = pr.length && (/textarea/i).test(pr[0].nodeName);
			soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) };
			left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
			top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

			if (!o.animate) {
				this.element.css($.extend(s, { top: top, left: left }));
			}

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper && !o.animate) {
				this._proportionallyResize();
			}
		}

		$("body").css("cursor", "auto");

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) {
			this.helper.remove();
		}

		return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if(this._aspectRatio || forceAspectRatio) {
			// We want to create an enclosing box whose aspect ration is the requested one
			// First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if(pMinWidth > b.minWidth) {
				b.minWidth = pMinWidth;
			}
			if(pMinHeight > b.minHeight) {
				b.minHeight = pMinHeight;
			}
			if(pMaxWidth < b.maxWidth) {
				b.maxWidth = pMaxWidth;
			}
			if(pMaxHeight < b.maxHeight) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		this.offset = this.helper.offset();
		if (isNumber(data.left)) {
			this.position.left = data.left;
		}
		if (isNumber(data.top)) {
			this.position.top = data.top;
		}
		if (isNumber(data.height)) {
			this.size.height = data.height;
		}
		if (isNumber(data.width)) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if (isNumber(data.height)) {
			data.width = (data.height * this.aspectRatio);
		} else if (isNumber(data.width)) {
			data.height = (data.width / this.aspectRatio);
		}

		if (a === "sw") {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a === "nw") {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
			isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.position.top + this.size.height,
			cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
		if (isminw) {
			data.width = o.minWidth;
		}
		if (isminh) {
			data.height = o.minHeight;
		}
		if (ismaxw) {
			data.width = o.maxWidth;
		}
		if (ismaxh) {
			data.height = o.maxHeight;
		}

		if (isminw && cw) {
			data.left = dw - o.minWidth;
		}
		if (ismaxw && cw) {
			data.left = dw - o.maxWidth;
		}
		if (isminh && ch) {
			data.top = dh - o.minHeight;
		}
		if (ismaxh && ch) {
			data.top = dh - o.maxHeight;
		}

		// fixing jump error on top/left - bug #2330
		if (!data.width && !data.height && !data.left && data.top) {
			data.top = null;
		} else if (!data.width && !data.height && !data.top && data.left) {
			data.left = null;
		}

		return data;
	},

	_proportionallyResize: function() {

		if (!this._proportionallyResizeElements.length) {
			return;
		}

		var i, j, borders, paddings, prel,
			element = this.helper || this.element;

		for ( i=0; i < this._proportionallyResizeElements.length; i++) {

			prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				this.borderDif = [];
				borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
				paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];

				for ( j = 0; j < borders.length; j++ ) {
					this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
				}
			}

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() - 1,
				height: this.element.outerHeight() - 1,
				position: "absolute",
				left: this.elementOffset.left +"px",
				top: this.elementOffset.top +"px",
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n !== "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "animate", {

	stop: function( event ) {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length && (/textarea/i).test(pr[0].nodeName),
			soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
			left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
			top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css("width"), 10),
						height: parseInt(that.element.css("height"), 10),
						top: parseInt(that.element.css("top"), 10),
						left: parseInt(that.element.css("left"), 10)
					};

					if (pr && pr.length) {
						$(pr[0]).css({ width: data.width, height: data.height });
					}

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $(this).data("ui-resizable"),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;

		if (!ce) {
			return;
		}

		that.containerElement = $(ce);

		if (/document/.test(oc) || oc === document) {
			that.containerOffset = { left: 0, top: 0 };
			that.containerPosition = { left: 0, top: 0 };

			that.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			element = $(ce);
			p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw );
			height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			that.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function( event ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $(this).data("ui-resizable"),
			o = that.options,
			co = that.containerOffset, cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = { top:0, left:0 }, ce = that.containerElement;

		if (ce[0] !== document && (/static/).test(ce.css("position"))) {
			cop = co;
		}

		if (cp.left < (that._helper ? co.left : 0)) {
			that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
			if (pRatio) {
				that.size.height = that.size.width / that.aspectRatio;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (that._helper ? co.top : 0)) {
			that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
			if (pRatio) {
				that.size.width = that.size.height * that.aspectRatio;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		that.offset.left = that.parentData.left+that.position.left;
		that.offset.top = that.parentData.top+that.position.top;

		woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width );
		hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

		isParent = that.containerElement.get(0) === that.element.parent().get(0);
		isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));

		if(isParent && isOffsetRelative) {
			woset -= that.parentData.left;
		}

		if (woset + that.size.width >= that.parentData.width) {
			that.size.width = that.parentData.width - woset;
			if (pRatio) {
				that.size.height = that.size.width / that.aspectRatio;
			}
		}

		if (hoset + that.size.height >= that.parentData.height) {
			that.size.height = that.parentData.height - hoset;
			if (pRatio) {
				that.size.width = that.size.height * that.aspectRatio;
			}
		}
	},

	stop: function(){
		var that = $(this).data("ui-resizable"),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $(that.helper),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
		}

		if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
		}

	}
});

$.ui.plugin.add("resizable", "alsoResize", {

	start: function () {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			_store = function (exp) {
				$(exp).each(function() {
					var el = $(this);
					el.data("ui-resizable-alsoresize", {
						width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
						left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
					});
				});
			};

		if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
				top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
			},

			_alsoResize = function (exp, c) {
				$(exp).each(function() {
					var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
						css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

					$.each(css, function (i, prop) {
						var sum = (start[prop]||0) + (delta[prop]||0);
						if (sum && sum >= 0) {
							style[prop] = sum || null;
						}
					});

					el.css(style);
				});
			};

		if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function () {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function() {

		var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({ opacity: 0.25, display: "block", position: "relative", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass("ui-resizable-ghost")
			.addClass(typeof o.ghost === "string" ? o.ghost : "");

		that.ghost.appendTo(that.helper);

	},

	resize: function(){
		var that = $(this).data("ui-resizable");
		if (that.ghost) {
			that.ghost.css({ position: "relative", height: that.size.height, width: that.size.width });
		}
	},

	stop: function() {
		var that = $(this).data("ui-resizable");
		if (that.ghost && that.helper) {
			that.helper.get(0).removeChild(that.ghost.get(0));
		}
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function() {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
			gridX = (grid[0]||1),
			gridY = (grid[1]||1),
			ox = Math.round((cs.width - os.width) / gridX) * gridX,
			oy = Math.round((cs.height - os.height) / gridY) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
			isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
			isMinWidth = o.minWidth && (o.minWidth > newWidth),
			isMinHeight = o.minHeight && (o.minHeight > newHeight);

		o.grid = grid;

		if (isMinWidth) {
			newWidth = newWidth + gridX;
		}
		if (isMinHeight) {
			newHeight = newHeight + gridY;
		}
		if (isMaxWidth) {
			newWidth = newWidth - gridX;
		}
		if (isMaxHeight) {
			newHeight = newHeight - gridY;
		}

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if (/^(ne)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if (/^(sw)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
			that.position.left = op.left - ox;
		}
	}

});

})(jQuery);

}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("ui/resizable", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
$.require() 
 .script("ui/core","ui/mouse","ui/widget") 
 .done(function() { 
var exports = function() { 

/*!
 * jQuery UI Slider 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slider/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {
	version: "1.10.4pre",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	_create: function() {
		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all");

		this._refresh();
		this._setOption( "disabled", this.options.disabled );

		this._animateOff = false;
	},

	_refresh: function() {
		this._createRange();
		this._createHandles();
		this._setupEvents();
		this._refreshValue();
	},

	_createHandles: function() {
		var i, handleCount,
			options = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handles = [];

		handleCount = ( options.values && options.values.length ) || 1;

		if ( existingHandles.length > handleCount ) {
			existingHandles.slice( handleCount ).remove();
			existingHandles = existingHandles.slice( 0, handleCount );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.each(function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		});
	},

	_createRange: function() {
		var options = this.options,
			classes = "";

		if ( options.range ) {
			if ( options.range === true ) {
				if ( !options.values ) {
					options.values = [ this._valueMin(), this._valueMin() ];
				} else if ( options.values.length && options.values.length !== 2 ) {
					options.values = [ options.values[0], options.values[0] ];
				} else if ( $.isArray( options.values ) ) {
					options.values = options.values.slice(0);
				}
			}

			if ( !this.range || !this.range.length ) {
				this.range = $( "<div></div>" )
					.appendTo( this.element );

				classes = "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header ui-corner-all";
			} else {
				this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
					// Handle range switching from true to min/max
					.css({
						"left": "",
						"bottom": ""
					});
			}

			this.range.addClass( classes +
				( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
		} else {
			this.range = $([]);
		}
	},

	_setupEvents: function() {
		var elements = this.handles.add( this.range ).filter( "a" );
		this._off( elements );
		this._on( elements, this._handleEvents );
		this._hoverable( elements );
		this._focusable( elements );
	},

	_destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if (( distance > thisDistance ) ||
				( distance === thisDistance &&
					(i === that._lastChangedValue || that.values(i) === o.min ))) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( key === "range" && this.options.range === true ) {
			if ( value === "min" ) {
				this.options.value = this._values( 0 );
				this.options.values = null;
			} else if ( value === "max" ) {
				this.options.value = this._values( this.options.values.length-1 );
				this.options.values = null;
			}
		}

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "min":
			case "max":
				this._animateOff = true;
				this._refreshValue();
				this._animateOff = false;
				break;
			case "range":
				this._animateOff = true;
				this._refresh();
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else if ( this.options.values && this.options.values.length ) {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		} else {
			return [];
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			/*jshint maxcomplexity:25*/
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						$( event.target ).addClass( "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this.options.values && this.options.values.length ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		click: function( event ) {
			event.preventDefault();
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				$( event.target ).removeClass( "ui-state-active" );
			}
		}
	}

});

}(jQuery));

}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("ui/slider", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery UI Widget 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("ui/widget", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() {

var jQuery = $;

/*
 * wavesurfer.js v1.4.0
 * http://wavesurfer-js.org/
 *
 * By katspaugh is licensed under a Creative Commons Attribution 3.0 Unported License. 
 */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
	// AMD. Register as an anonymous module unless amdModuleId is set
	define('wavesurfer', [], function () {
	  return (root['WaveSurfer'] = factory());
	});
  } else if (typeof exports === 'object') {
	// Node. Does not work with strict CommonJS, but
	// only CommonJS-like environments that support module.exports,
	// like Node.
	module.exports = factory();
  } else {
	root['WaveSurfer'] = factory();
  }
}(this, function () {

'use strict';

var WaveSurfer = {
	defaultParams: {
		audioContext  : null,
		audioRate     : 1,
		autoCenter    : true,
		backend       : 'WebAudio',
		barHeight     : 1,
		closeAudioContext: false,
		container     : null,
		cursorColor   : '#333',
		cursorWidth   : 1,
		dragSelection : true,
		fillParent    : true,
		forceDecode   : false,
		height        : 128,
		hideScrollbar : false,
		interact      : true,
		loopSelection : true,
		mediaContainer: null,
		mediaControls : false,
		mediaType     : 'audio',
		minPxPerSec   : 20,
		partialRender : false,
		pixelRatio    : window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI,
		progressColor : '#555',
		normalize     : false,
		renderer      : 'MultiCanvas',
		scrollParent  : false,
		skipLength    : 2,
		splitChannels : false,
		waveColor     : '#999',
	},

	init: function (params) {
		// Extract relevant parameters (or defaults)
		this.params = WaveSurfer.util.extend({}, this.defaultParams, params);

		this.container = 'string' == typeof params.container ?
			document.querySelector(this.params.container) :
			this.params.container;

		if (!this.container) {
			throw new Error('Container element not found');
		}

		if (this.params.mediaContainer == null) {
			this.mediaContainer = this.container;
		} else if (typeof this.params.mediaContainer == 'string') {
			this.mediaContainer = document.querySelector(this.params.mediaContainer);
		} else {
			this.mediaContainer = this.params.mediaContainer;
		}

		if (!this.mediaContainer) {
			throw new Error('Media Container element not found');
		}

		// Used to save the current volume when muting so we can
		// restore once unmuted
		this.savedVolume = 0;

		// The current muted state
		this.isMuted = false;

		// Will hold a list of event descriptors that need to be
		// cancelled on subsequent loads of audio
		this.tmpEvents = [];

		// Holds any running audio downloads
		this.currentAjax = null;

		this.createDrawer();
		this.createBackend();
		this.createPeakCache();

		this.isDestroyed = false;
	},

	createDrawer: function () {
		var my = this;

		this.drawer = Object.create(WaveSurfer.Drawer[this.params.renderer]);
		this.drawer.init(this.container, this.params);

		this.drawer.on('redraw', function () {
			my.drawBuffer();
			my.drawer.progress(my.backend.getPlayedPercents());
		});

		// Click-to-seek
		this.drawer.on('click', function (e, progress) {
			setTimeout(function () {
				my.seekTo(progress);
			}, 0);
		});

		// Relay the scroll event from the drawer
		this.drawer.on('scroll', function (e) {
			if (my.params.partialRender) {
				my.drawBuffer();
			}
			my.fireEvent('scroll', e);
		});
	},

	createBackend: function () {
		var my = this;

		if (this.backend) {
			this.backend.destroy();
		}

		// Back compat
		if (this.params.backend == 'AudioElement') {
			this.params.backend = 'MediaElement';
		}

		if (this.params.backend == 'WebAudio' && !WaveSurfer.WebAudio.supportsWebAudio()) {
			this.params.backend = 'MediaElement';
		}

		this.backend = Object.create(WaveSurfer[this.params.backend]);
		this.backend.init(this.params);

		this.backend.on('finish', function () { my.fireEvent('finish'); });
		this.backend.on('play', function () { my.fireEvent('play'); });
		this.backend.on('pause', function () { my.fireEvent('pause'); });

		this.backend.on('audioprocess', function (time) {
			my.drawer.progress(my.backend.getPlayedPercents());
			my.fireEvent('audioprocess', time);
		});
	},

	createPeakCache: function() {
		if (this.params.partialRender) {
			this.peakCache = Object.create(WaveSurfer.PeakCache);
			this.peakCache.init();
		}
	},

	getDuration: function () {
		return this.backend.getDuration();
	},

	getCurrentTime: function () {
		return this.backend.getCurrentTime();
	},

	play: function (start, end) {
		this.fireEvent('interaction', this.play.bind(this, start, end));
		this.backend.play(start, end);
	},

	pause: function () {
		this.backend.isPaused() || this.backend.pause();
	},

	playPause: function () {
		this.backend.isPaused() ? this.play() : this.pause();
	},

	isPlaying: function () {
		return !this.backend.isPaused();
	},

	skipBackward: function (seconds) {
		this.skip(-seconds || -this.params.skipLength);
	},

	skipForward: function (seconds) {
		this.skip(seconds || this.params.skipLength);
	},

	skip: function (offset) {
		var position = this.getCurrentTime() || 0;
		var duration = this.getDuration() || 1;
		position = Math.max(0, Math.min(duration, position + (offset || 0)));
		this.seekAndCenter(position / duration);
	},

	seekAndCenter: function (progress) {
		this.seekTo(progress);
		this.drawer.recenter(progress);
	},

	seekTo: function (progress) {
		this.fireEvent('interaction', this.seekTo.bind(this, progress));

		var paused = this.backend.isPaused();
		// avoid draw wrong position while playing backward seeking
		if (!paused) {
			this.backend.pause();
		}
		// avoid small scrolls while paused seeking
		var oldScrollParent = this.params.scrollParent;
		this.params.scrollParent = false;
		this.backend.seekTo(progress * this.getDuration());
		this.drawer.progress(this.backend.getPlayedPercents());

		if (!paused) {
			this.backend.play();
		}
		this.params.scrollParent = oldScrollParent;
		this.fireEvent('seek', progress);
	},

	stop: function () {
		this.pause();
		this.seekTo(0);
		this.drawer.progress(0);
	},

	/**
	 * Set the playback volume.
	 *
	 * @param {Number} newVolume A value between 0 and 1, 0 being no
	 * volume and 1 being full volume.
	 */
	setVolume: function (newVolume) {
		this.backend.setVolume(newVolume);
	},

	/**
	 * Get the playback volume.
	 */
	getVolume: function () {
		return this.backend.getVolume();
	},

	/**
	 * Set the playback rate.
	 *
	 * @param {Number} rate A positive number. E.g. 0.5 means half the
	 * normal speed, 2 means double speed and so on.
	 */
	setPlaybackRate: function (rate) {
		this.backend.setPlaybackRate(rate);
	},

	/**
	 * Get the playback rate.
	 */
	getPlaybackRate: function () {
		return this.backend.getPlaybackRate();
	},

	/**
	 * Toggle the volume on and off. It not currenly muted it will
	 * save the current volume value and turn the volume off.
	 * If currently muted then it will restore the volume to the saved
	 * value, and then rest the saved value.
	 */
	toggleMute: function () {
		this.setMute(!this.isMuted);
	},

	setMute: function (mute) {
		// ignore all muting requests if the audio is already in that state
		if (mute === this.isMuted) {
			return;
		}

		if (mute) {
			// If currently not muted then save current volume,
			// turn off the volume and update the mute properties
			this.savedVolume = this.backend.getVolume();
			this.backend.setVolume(0);
			this.isMuted = true;
		} else {
			// If currently muted then restore to the saved volume
			// and update the mute properties
			this.backend.setVolume(this.savedVolume);
			this.isMuted = false;
		}
	},

	/**
	 * Get the current mute status.
	 */
	getMute: function () {
		return this.isMuted;
	},

	/**
	 * Get the list of current set filters as an array.
	 *
	 * Filters must be set with setFilters method first
	 */
	getFilters: function() {
		return this.backend.filters || [];
	},

	toggleScroll: function () {
		this.params.scrollParent = !this.params.scrollParent;
		this.drawBuffer();
	},

	toggleInteraction: function () {
		this.params.interact = !this.params.interact;
	},

	drawBuffer: function () {
		var nominalWidth = Math.round(
			this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio
		);
		var parentWidth = this.drawer.getWidth();
		var width = nominalWidth;
		var start = this.drawer.getScrollX();
		var end = Math.min(start + parentWidth, width);

		// Fill container
		if (this.params.fillParent && (!this.params.scrollParent || nominalWidth < parentWidth)) {
			width = parentWidth;
			start = 0;
			end = width;
		}

		if (this.params.partialRender) {
			var newRanges = this.peakCache.addRangeToPeakCache(width, start, end);
			for (var i = 0; i < newRanges.length; i++) {
			  var peaks = this.backend.getPeaks(width, newRanges[i][0], newRanges[i][1]);
			  this.drawer.drawPeaks(peaks, width, newRanges[i][0], newRanges[i][1]);
			}
		} else {
			start = 0;
			end = width;
			var peaks = this.backend.getPeaks(width, start, end);
			this.drawer.drawPeaks(peaks, width, start, end);
		}
		this.fireEvent('redraw', peaks, width);
	},

	zoom: function (pxPerSec) {
		this.params.minPxPerSec = pxPerSec;

		this.params.scrollParent = true;

		this.drawBuffer();
		this.drawer.progress(this.backend.getPlayedPercents());

		this.drawer.recenter(
			this.getCurrentTime() / this.getDuration()
		);
		this.fireEvent('zoom', pxPerSec);
	},

	/**
	 * Internal method.
	 */
	loadArrayBuffer: function (arraybuffer) {
		this.decodeArrayBuffer(arraybuffer, function (data) {
			if (!this.isDestroyed) {
				this.loadDecodedBuffer(data);
			}
		}.bind(this));
	},

	/**
	 * Directly load an externally decoded AudioBuffer.
	 */
	loadDecodedBuffer: function (buffer) {
		this.backend.load(buffer);
		this.drawBuffer();
		this.fireEvent('ready');
	},

	/**
	 * Loads audio data from a Blob or File object.
	 *
	 * @param {Blob|File} blob Audio data.
	 */
	loadBlob: function (blob) {
		var my = this;
		// Create file reader
		var reader = new FileReader();
		reader.addEventListener('progress', function (e) {
			my.onProgress(e);
		});
		reader.addEventListener('load', function (e) {
			my.loadArrayBuffer(e.target.result);
		});
		reader.addEventListener('error', function () {
			my.fireEvent('error', 'Error reading file');
		});
		reader.readAsArrayBuffer(blob);
		this.empty();
	},

	/**
	 * Loads audio and re-renders the waveform.
	 */
	load: function (url, peaks, preload) {
		this.empty();
		this.isMuted = false;

		switch (this.params.backend) {
			case 'WebAudio': return this.loadBuffer(url, peaks);
			case 'MediaElement': return this.loadMediaElement(url, peaks, preload);
		}
	},

	/**
	 * Loads audio using Web Audio buffer backend.
	 */
	loadBuffer: function (url, peaks) {
		var load = (function (action) {
			if (action) {
				this.tmpEvents.push(this.once('ready', action));
			}
			return this.getArrayBuffer(url, this.loadArrayBuffer.bind(this));
		}).bind(this);

		if (peaks) {
			this.backend.setPeaks(peaks);
			this.drawBuffer();
			this.tmpEvents.push(this.once('interaction', load));
		} else {
			return load();
		}
	},

	/**
	 *  Either create a media element, or load
	 *  an existing media element.
	 *  @param  {String|HTMLElement} urlOrElt Either a path to a media file,
	 *                                          or an existing HTML5 Audio/Video
	 *                                          Element
	 *  @param  {Array}            [peaks]     Array of peaks. Required to bypass
	 *                                          web audio dependency
	 */
	loadMediaElement: function (urlOrElt, peaks, preload) {
		var url = urlOrElt;

		if (typeof urlOrElt === 'string') {
			this.backend.load(url, this.mediaContainer, peaks, preload);
		} else {
			var elt = urlOrElt;
			this.backend.loadElt(elt, peaks);

			// If peaks are not provided,
			// url = element.src so we can get peaks with web audio
			url = elt.src;
		}

		this.tmpEvents.push(
			this.backend.once('canplay', (function () {
				this.drawBuffer();
				this.fireEvent('ready');
			}).bind(this)),

			this.backend.once('error', (function (err) {
				this.fireEvent('error', err);
			}).bind(this))
		);

		// If no pre-decoded peaks provided or pre-decoded peaks are
		// provided with forceDecode flag, attempt to download the
		// audio file and decode it with Web Audio.
		if (peaks) { this.backend.setPeaks(peaks); }

		if ((!peaks || this.params.forceDecode) && this.backend.supportsWebAudio()) {
			this.getArrayBuffer(url, (function (arraybuffer) {
				this.decodeArrayBuffer(arraybuffer, (function (buffer) {
					this.backend.buffer = buffer;
					this.backend.setPeaks(null);
					this.drawBuffer();
					this.fireEvent('waveform-ready');
				}).bind(this));
			}).bind(this));
		}
	},

	decodeArrayBuffer: function (arraybuffer, callback) {
		this.arraybuffer = arraybuffer;

		this.backend.decodeArrayBuffer(
			arraybuffer,
			(function (data) {
				// Only use the decoded data if we haven't been destroyed or another decode started in the meantime
				if (!this.isDestroyed && this.arraybuffer == arraybuffer) {
					callback(data);
					this.arraybuffer = null;
				}
			}).bind(this),
			this.fireEvent.bind(this, 'error', 'Error decoding audiobuffer')
		);
	},

	getArrayBuffer: function (url, callback) {
		var my = this;

		var ajax = WaveSurfer.util.ajax({
			url: url,
			responseType: 'arraybuffer'
		});

		this.currentAjax = ajax;

		this.tmpEvents.push(
			ajax.on('progress', function (e) {
				my.onProgress(e);
			}),
			ajax.on('success', function (data, e) {
				callback(data);
				my.currentAjax = null;
			}),
			ajax.on('error', function (e) {
				my.fireEvent('error', 'XHR error: ' + e.target.statusText);
				my.currentAjax = null;
			})
		);

		return ajax;
	},

	onProgress: function (e) {
		if (e.lengthComputable) {
			var percentComplete = e.loaded / e.total;
		} else {
			// Approximate progress with an asymptotic
			// function, and assume downloads in the 1-3 MB range.
			percentComplete = e.loaded / (e.loaded + 1000000);
		}
		this.fireEvent('loading', Math.round(percentComplete * 100), e.target);
	},

	/**
	 * Exports PCM data into a JSON array and opens in a new window.
	 */
	exportPCM: function (length, accuracy, noWindow) {
		length = length || 1024;
		accuracy = accuracy || 10000;
		noWindow = noWindow || false;
		var peaks = this.backend.getPeaks(length, accuracy);
		var arr = [].map.call(peaks, function (val) {
			return Math.round(val * accuracy) / accuracy;
		});
		var json = JSON.stringify(arr);
		if (!noWindow) {
			window.open('data:application/json;charset=utf-8,' +
				encodeURIComponent(json));
		}
		return json;
	},

	/**
	 * Save waveform image as data URI.
	 *
	 * The default format is 'image/png'. Other supported types are
	 * 'image/jpeg' and 'image/webp'.
	 */
	exportImage: function(format, quality) {
		if (!format) {
			format = 'image/png';
		}
		if (!quality) {
			quality = 1;
		}

		return this.drawer.getImage(format, quality);
	},

	cancelAjax: function () {
		if (this.currentAjax) {
			this.currentAjax.xhr.abort();
			this.currentAjax = null;
		}
	},

	clearTmpEvents: function () {
		this.tmpEvents.forEach(function (e) { e.un(); });
	},

	/**
	 * Display empty waveform.
	 */
	empty: function () {
		if (!this.backend.isPaused()) {
			this.stop();
			this.backend.disconnectSource();
		}
		this.cancelAjax();
		this.clearTmpEvents();
		this.drawer.progress(0);
		this.drawer.setWidth(0);
		this.drawer.drawPeaks({ length: this.drawer.getWidth() }, 0);
	},

	/**
	 * Remove events, elements and disconnect WebAudio nodes.
	 */
	destroy: function () {
		this.fireEvent('destroy');
		this.cancelAjax();
		this.clearTmpEvents();
		this.unAll();
		this.backend.destroy();
		this.drawer.destroy();
		this.isDestroyed = true;
	}
};

WaveSurfer.create = function (params) {
	var wavesurfer = Object.create(WaveSurfer);
	wavesurfer.init(params);
	return wavesurfer;
};

WaveSurfer.util = {
	extend: function (dest) {
		var sources = Array.prototype.slice.call(arguments, 1);
		sources.forEach(function (source) {
			Object.keys(source).forEach(function (key) {
				dest[key] = source[key];
			});
		});
		return dest;
	},

	debounce: function (func, wait, immediate) {
		var args, context, timeout;
		var later = function() {
			timeout = null;
			if (!immediate) {
				func.apply(context, args);
			}
		};
		return function() {
			context = this;
			args = arguments;
			var callNow = immediate && !timeout;
			clearTimeout(timeout);
			timeout = setTimeout(later, wait);
			if (!timeout) {
				timeout = setTimeout(later, wait);
			}
			if (callNow) {
				func.apply(context, args);
			}
		};
	},

	min: function (values) {
		var min = +Infinity;
		for (var i in values) {
			if (values[i] < min) {
				min = values[i];
			}
		}

		return min;
	},

	max: function (values) {
		var max = -Infinity;
		for (var i in values) {
			if (values[i] > max) {
				max = values[i];
			}
		}

		return max;
	},

	getId: function () {
		return 'wavesurfer_' + Math.random().toString(32).substring(2);
	},

	ajax: function (options) {
		var ajax = Object.create(WaveSurfer.Observer);
		var xhr = new XMLHttpRequest();
		var fired100 = false;

		xhr.open(options.method || 'GET', options.url, true);
		xhr.responseType = options.responseType || 'json';

		xhr.addEventListener('progress', function (e) {
			ajax.fireEvent('progress', e);
			if (e.lengthComputable && e.loaded == e.total) {
				fired100 = true;
			}
		});

		xhr.addEventListener('load', function (e) {
			if (!fired100) {
				ajax.fireEvent('progress', e);
			}
			ajax.fireEvent('load', e);

			if (200 == xhr.status || 206 == xhr.status) {
				ajax.fireEvent('success', xhr.response, e);
			} else {
				ajax.fireEvent('error', e);
			}
		});

		xhr.addEventListener('error', function (e) {
			ajax.fireEvent('error', e);
		});

		xhr.send();
		ajax.xhr = xhr;
		return ajax;
	}
};

/* Observer */
WaveSurfer.Observer = {
	/**
	 * Attach a handler function for an event.
	 */
	on: function (event, fn) {
		if (!this.handlers) { this.handlers = {}; }

		var handlers = this.handlers[event];
		if (!handlers) {
			handlers = this.handlers[event] = [];
		}
		handlers.push(fn);

		// Return an event descriptor
		return {
			name: event,
			callback: fn,
			un: this.un.bind(this, event, fn)
		};
	},

	/**
	 * Remove an event handler.
	 */
	un: function (event, fn) {
		if (!this.handlers) { return; }

		var handlers = this.handlers[event];
		if (handlers) {
			if (fn) {
				for (var i = handlers.length - 1; i >= 0; i--) {
					if (handlers[i] == fn) {
						handlers.splice(i, 1);
					}
				}
			} else {
				handlers.length = 0;
			}
		}
	},

	/**
	 * Remove all event handlers.
	 */
	unAll: function () {
		this.handlers = null;
	},

	/**
	 * Attach a handler to an event. The handler is executed at most once per
	 * event type.
	 */
	once: function (event, handler) {
		var my = this;
		var fn = function () {
			handler.apply(this, arguments);
			setTimeout(function () {
				my.un(event, fn);
			}, 0);
		};
		return this.on(event, fn);
	},

	fireEvent: function (event) {
		if (!this.handlers) { return; }
		var handlers = this.handlers[event];
		var args = Array.prototype.slice.call(arguments, 1);
		handlers && handlers.forEach(function (fn) {
			fn.apply(null, args);
		});
	}
};

/* Make the main WaveSurfer object an observer */
WaveSurfer.util.extend(WaveSurfer, WaveSurfer.Observer);

'use strict';

WaveSurfer.WebAudio = {
	scriptBufferSize: 256,
	PLAYING_STATE: 0,
	PAUSED_STATE: 1,
	FINISHED_STATE: 2,

	supportsWebAudio: function () {
		return !!(window.AudioContext || window.webkitAudioContext);
	},

	getAudioContext: function () {
		if (!WaveSurfer.WebAudio.audioContext) {
			WaveSurfer.WebAudio.audioContext = new (
				window.AudioContext || window.webkitAudioContext
			);
		}
		return WaveSurfer.WebAudio.audioContext;
	},

	getOfflineAudioContext: function (sampleRate) {
		if (!WaveSurfer.WebAudio.offlineAudioContext) {
			WaveSurfer.WebAudio.offlineAudioContext = new (
				window.OfflineAudioContext || window.webkitOfflineAudioContext
			)(1, 2, sampleRate);
		}
		return WaveSurfer.WebAudio.offlineAudioContext;
	},

	init: function (params) {
		this.params = params;
		this.ac = params.audioContext || this.getAudioContext();

		this.lastPlay = this.ac.currentTime;
		this.startPosition = 0;
		this.scheduledPause = null;

		this.states = [
			Object.create(WaveSurfer.WebAudio.state.playing),
			Object.create(WaveSurfer.WebAudio.state.paused),
			Object.create(WaveSurfer.WebAudio.state.finished)
		];

		this.createVolumeNode();
		this.createScriptNode();
		this.createAnalyserNode();

		this.setState(this.PAUSED_STATE);
		this.setPlaybackRate(this.params.audioRate);
		this.setLength(0);
	},

	disconnectFilters: function () {
		if (this.filters) {
			this.filters.forEach(function (filter) {
				filter && filter.disconnect();
			});
			this.filters = null;
			// Reconnect direct path
			this.analyser.connect(this.gainNode);
		}
	},

	setState: function (state) {
		if (this.state !== this.states[state]) {
			this.state = this.states[state];
			this.state.init.call(this);
		}
	},

	// Unpacked filters
	setFilter: function () {
		this.setFilters([].slice.call(arguments));
	},

	/**
	 * @param {Array} filters Packed ilters array
	 */
	setFilters: function (filters) {
		// Remove existing filters
		this.disconnectFilters();

		// Insert filters if filter array not empty
		if (filters && filters.length) {
			this.filters = filters;

			// Disconnect direct path before inserting filters
			this.analyser.disconnect();

			// Connect each filter in turn
			filters.reduce(function (prev, curr) {
				prev.connect(curr);
				return curr;
			}, this.analyser).connect(this.gainNode);
		}

	},

	createScriptNode: function () {
		if (this.ac.createScriptProcessor) {
			this.scriptNode = this.ac.createScriptProcessor(this.scriptBufferSize);
		} else {
			this.scriptNode = this.ac.createJavaScriptNode(this.scriptBufferSize);
		}

		this.scriptNode.connect(this.ac.destination);
	},

	addOnAudioProcess: function () {
		var my = this;

		this.scriptNode.onaudioprocess = function () {
			var time = my.getCurrentTime();

			if (time >= my.getDuration()) {
				my.setState(my.FINISHED_STATE);
				my.fireEvent('pause');
			} else if (time >= my.scheduledPause) {
				my.pause();
			} else if (my.state === my.states[my.PLAYING_STATE]) {
				my.fireEvent('audioprocess', time);
			}
		};
	},

	removeOnAudioProcess: function () {
		this.scriptNode.onaudioprocess = null;
	},

	createAnalyserNode: function () {
		this.analyser = this.ac.createAnalyser();
		this.analyser.connect(this.gainNode);
	},

	/**
	 * Create the gain node needed to control the playback volume.
	 */
	createVolumeNode: function () {
		// Create gain node using the AudioContext
		if (this.ac.createGain) {
			this.gainNode = this.ac.createGain();
		} else {
			this.gainNode = this.ac.createGainNode();
		}
		// Add the gain node to the graph
		this.gainNode.connect(this.ac.destination);
	},

	/**
	 * Set the gain to a new value.
	 *
	 * @param {Number} newGain The new gain, a floating point value
	 * between 0 and 1. 0 being no gain and 1 being maximum gain.
	 */
	setVolume: function (newGain) {
		this.gainNode.gain.value = newGain;
	},

	/**
	 * Get the current gain.
	 *
	 * @returns {Number} The current gain, a floating point value
	 * between 0 and 1. 0 being no gain and 1 being maximum gain.
	 */
	getVolume: function () {
		return this.gainNode.gain.value;
	},

	decodeArrayBuffer: function (arraybuffer, callback, errback) {
		if (!this.offlineAc) {
			this.offlineAc = this.getOfflineAudioContext(this.ac ? this.ac.sampleRate : 44100);
		}
		this.offlineAc.decodeAudioData(arraybuffer, (function (data) {
			callback(data);
		}).bind(this), errback);
	},

	/**
	 * Set pre-decoded peaks.
	 */
	setPeaks: function (peaks) {
		this.peaks = peaks;
	},

	/**
	 * Set the rendered length (different from the length of the audio).
	 */
	setLength: function (length) {
		// No resize, we can preserve the cached peaks.
		if (this.mergedPeaks && length == ((2 * this.mergedPeaks.length - 1) + 2)) {
		  return;
		}

		this.splitPeaks = [];
		this.mergedPeaks = [];
		// Set the last element of the sparse array so the peak arrays are
		// appropriately sized for other calculations.
		var channels = this.buffer ? this.buffer.numberOfChannels : 1;
		for (var c = 0; c < channels; c++) {
		  this.splitPeaks[c] = [];
		  this.splitPeaks[c][2 * (length - 1)] = 0;
		  this.splitPeaks[c][2 * (length - 1) + 1] = 0;
		}
		this.mergedPeaks[2 * (length - 1)] = 0;
		this.mergedPeaks[2 * (length - 1) + 1] = 0;
	},

	/**
	 * Compute the max and min value of the waveform when broken into
	 * <length> subranges.
	 * @param {Number} length How many subranges to break the waveform into.
	 * @param {Number} first First sample in the required range.
	 * @param {Number} last Last sample in the required range.
	 * @returns {Array} Array of 2*<length> peaks or array of arrays
	 * of peaks consisting of (max, min) values for each subrange.
	 */
	getPeaks: function (length, first, last) {
		if (this.peaks) { return this.peaks; }

		this.setLength(length);

		var sampleSize = this.buffer.length / length;
		var sampleStep = ~~(sampleSize / 10) || 1;
		var channels = this.buffer.numberOfChannels;

		for (var c = 0; c < channels; c++) {
			var peaks = this.splitPeaks[c];
			var chan = this.buffer.getChannelData(c);

			for (var i = first; i <= last; i++) {
				var start = ~~(i * sampleSize);
				var end = ~~(start + sampleSize);
				var min = 0;
				var max = 0;

				for (var j = start; j < end; j += sampleStep) {
					var value = chan[j];

					if (value > max) {
						max = value;
					}

					if (value < min) {
						min = value;
					}
				}

				peaks[2 * i] = max;
				peaks[2 * i + 1] = min;

				if (c == 0 || max > this.mergedPeaks[2 * i]) {
					this.mergedPeaks[2 * i] = max;
				}

				if (c == 0 || min < this.mergedPeaks[2 * i + 1]) {
					this.mergedPeaks[2 * i + 1] = min;
				}
			}
		}

		return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
	},

	getPlayedPercents: function () {
		return this.state.getPlayedPercents.call(this);
	},

	disconnectSource: function () {
		if (this.source) {
			this.source.disconnect();
		}
	},

	destroy: function () {
		if (!this.isPaused()) {
			this.pause();
		}
		this.unAll();
		this.buffer = null;
		this.disconnectFilters();
		this.disconnectSource();
		this.gainNode.disconnect();
		this.scriptNode.disconnect();
		this.analyser.disconnect();
		// close the audioContext if closeAudioContext option is set to true
		if (this.params.closeAudioContext) {
			// check if browser supports AudioContext.close()
			if (typeof this.ac.close === 'function' && this.ac.state != 'closed') {
				this.ac.close();
			}
			// clear the reference to the audiocontext
			this.ac = null;
			// clear the actual audiocontext, either passed as param or the
			// global singleton
			if (!this.params.audioContext) {
				WaveSurfer.WebAudio.audioContext = null;
			} else {
				this.params.audioContext = null;
			}
			// clear the offlineAudioContext
			WaveSurfer.WebAudio.offlineAudioContext = null;
		}
	},

	load: function (buffer) {
		this.startPosition = 0;
		this.lastPlay = this.ac.currentTime;
		this.buffer = buffer;
		this.createSource();
	},

	createSource: function () {
		this.disconnectSource();
		this.source = this.ac.createBufferSource();

		//adjust for old browsers.
		this.source.start = this.source.start || this.source.noteGrainOn;
		this.source.stop = this.source.stop || this.source.noteOff;

		this.source.playbackRate.value = this.playbackRate;
		this.source.buffer = this.buffer;
		this.source.connect(this.analyser);
	},

	isPaused: function () {
		return this.state !== this.states[this.PLAYING_STATE];
	},

	getDuration: function () {
		if (!this.buffer) {
			return 0;
		}
		return this.buffer.duration;
	},

	seekTo: function (start, end) {
		if (!this.buffer) { return; }

		this.scheduledPause = null;

		if (start == null) {
			start = this.getCurrentTime();
			if (start >= this.getDuration()) {
				start = 0;
			}
		}
		if (end == null) {
			end = this.getDuration();
		}

		this.startPosition = start;
		this.lastPlay = this.ac.currentTime;

		if (this.state === this.states[this.FINISHED_STATE]) {
			this.setState(this.PAUSED_STATE);
		}

		return { start: start, end: end };
	},

	getPlayedTime: function () {
		return (this.ac.currentTime - this.lastPlay) * this.playbackRate;
	},

	/**
	 * Plays the loaded audio region.
	 *
	 * @param {Number} start Start offset in seconds,
	 * relative to the beginning of a clip.
	 * @param {Number} end When to stop
	 * relative to the beginning of a clip.
	 */
	play: function (start, end) {
		if (!this.buffer) { return; }

		// need to re-create source on each playback
		this.createSource();

		var adjustedTime = this.seekTo(start, end);

		start = adjustedTime.start;
		end = adjustedTime.end;

		this.scheduledPause = end;

		this.source.start(0, start, end - start);

		if (this.ac.state == 'suspended') {
		  this.ac.resume && this.ac.resume();
		}

		this.setState(this.PLAYING_STATE);

		this.fireEvent('play');
	},

	/**
	 * Pauses the loaded audio.
	 */
	pause: function () {
		this.scheduledPause = null;

		this.startPosition += this.getPlayedTime();
		this.source && this.source.stop(0);

		this.setState(this.PAUSED_STATE);

		this.fireEvent('pause');
	},

	/**
	*   Returns the current time in seconds relative to the audioclip's duration.
	*/
	getCurrentTime: function () {
		return this.state.getCurrentTime.call(this);
	},

	/**
	*   Returns the current playback rate.
	*/
	getPlaybackRate: function () {
		return this.playbackRate;
	},

	/**
	 * Set the audio source playback rate.
	 */
	setPlaybackRate: function (value) {
		value = value || 1;
		if (this.isPaused()) {
			this.playbackRate = value;
		} else {
			this.pause();
			this.playbackRate = value;
			this.play();
		}
	}
};

WaveSurfer.WebAudio.state = {};

WaveSurfer.WebAudio.state.playing = {
	init: function () {
		this.addOnAudioProcess();
	},
	getPlayedPercents: function () {
		var duration = this.getDuration();
		return (this.getCurrentTime() / duration) || 0;
	},
	getCurrentTime: function () {
		return this.startPosition + this.getPlayedTime();
	}
};

WaveSurfer.WebAudio.state.paused = {
	init: function () {
		this.removeOnAudioProcess();
	},
	getPlayedPercents: function () {
		var duration = this.getDuration();
		return (this.getCurrentTime() / duration) || 0;
	},
	getCurrentTime: function () {
		return this.startPosition;
	}
};

WaveSurfer.WebAudio.state.finished = {
	init: function () {
		this.removeOnAudioProcess();
		this.fireEvent('finish');
	},
	getPlayedPercents: function () {
		return 1;
	},
	getCurrentTime: function () {
		return this.getDuration();
	}
};

WaveSurfer.util.extend(WaveSurfer.WebAudio, WaveSurfer.Observer);

'use strict';

WaveSurfer.MediaElement = Object.create(WaveSurfer.WebAudio);

WaveSurfer.util.extend(WaveSurfer.MediaElement, {
	init: function (params) {
		this.params = params;

		// Dummy media to catch errors
		this.media = {
			currentTime: 0,
			duration: 0,
			paused: true,
			playbackRate: 1,
			play: function () {},
			pause: function () {}
		};

		this.mediaType = params.mediaType.toLowerCase();
		this.elementPosition = params.elementPosition;
		this.setPlaybackRate(this.params.audioRate);
		this.createTimer();
	},


	/**
	 * Create a timer to provide a more precise `audioprocess' event.
	 */
	createTimer: function () {
		var my = this;
		var playing = false;

		var onAudioProcess = function () {
			if (my.isPaused()) { return; }

			my.fireEvent('audioprocess', my.getCurrentTime());

			// Call again in the next frame
			var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
			requestAnimationFrame(onAudioProcess);
		};

		this.on('play', onAudioProcess);
	},

	/**
	 *  Create media element with url as its source,
	 *  and append to container element.
	 *  @param  {String}        url         path to media file
	 *  @param  {HTMLElement}   container   HTML element
	 *  @param  {Array}         peaks       array of peak data
	 *  @param  {String}        preload     HTML 5 preload attribute value
	 */
	load: function (url, container, peaks, preload) {
		var my = this;

		var media = document.createElement(this.mediaType);
		media.controls = this.params.mediaControls;
		media.autoplay = this.params.autoplay || false;
		media.preload = preload == null ? 'auto' : preload;
		media.src = url;
		media.style.width = '100%';

		var prevMedia = container.querySelector(this.mediaType);
		if (prevMedia) {
			container.removeChild(prevMedia);
		}
		container.appendChild(media);

		this._load(media, peaks);
	},

	/**
	 *  Load existing media element.
	 *  @param  {MediaElement}  elt     HTML5 Audio or Video element
	 *  @param  {Array}         peaks   array of peak data
	 */
	loadElt: function (elt, peaks) {
		var my = this;

		var media = elt;
		media.controls = this.params.mediaControls;
		media.autoplay = this.params.autoplay || false;

		this._load(media, peaks);
	},

	/**
	 *  Private method called by both load (from url)
	 *  and loadElt (existing media element).
	 *  @param  {MediaElement}  media     HTML5 Audio or Video element
	 *  @param  {Array}         peaks   array of peak data
	 *  @private
	 */
	_load: function (media, peaks) {
		var my = this;

		// load must be called manually on iOS, otherwise peaks won't draw
		// until a user interaction triggers load --> 'ready' event
		if (typeof media.load == 'function') {
			media.load();
		}

		media.addEventListener('error', function () {
			my.fireEvent('error', 'Error loading media element');
		});

		media.addEventListener('canplay', function () {
			my.fireEvent('canplay');
		});

		media.addEventListener('ended', function () {
			my.fireEvent('finish');
		});

		this.media = media;
		this.peaks = peaks;
		this.onPlayEnd = null;
		this.buffer = null;
		this.setPlaybackRate(this.playbackRate);
	},

	isPaused: function () {
		return !this.media || this.media.paused;
	},

	getDuration: function () {
		var duration = (this.buffer || this.media).duration;
		if (duration >= Infinity) { // streaming audio
			duration = this.media.seekable.end(0);
		}
		return duration;
	},

	getCurrentTime: function () {
		return this.media && this.media.currentTime;
	},

	getPlayedPercents: function () {
		return (this.getCurrentTime() / this.getDuration()) || 0;
	},

	getPlaybackRate: function () {
		return this.playbackRate || this.media.playbackRate;
	},

	/**
	 * Set the audio source playback rate.
	 */
	setPlaybackRate: function (value) {
		this.playbackRate = value || 1;
		this.media.playbackRate = this.playbackRate;
	},

	seekTo: function (start) {
		if (start != null) {
			this.media.currentTime = start;
		}
		this.clearPlayEnd();
	},

	/**
	 * Plays the loaded audio region.
	 *
	 * @param {Number} start Start offset in seconds,
	 * relative to the beginning of a clip.
	 * @param {Number} end End offset in seconds,
	 * relative to the beginning of a clip.
	 */
	play: function (start, end) {
		this.seekTo(start);
		this.media.play();
		end && this.setPlayEnd(end);
		this.fireEvent('play');
	},

	/**
	 * Pauses the loaded audio.
	 */
	pause: function () {
		this.media && this.media.pause();
		this.clearPlayEnd();
		this.fireEvent('pause');
	},

	setPlayEnd: function (end) {
		var my = this;
		this.onPlayEnd = function (time) {
			if (time >= end) {
				my.pause();
				my.seekTo(end);
			}
		};
		this.on('audioprocess', this.onPlayEnd);
	},

	clearPlayEnd: function () {
		if (this.onPlayEnd) {
			this.un('audioprocess', this.onPlayEnd);
			this.onPlayEnd = null;
		}
	},

	getPeaks: function (length, start, end) {
		if (this.buffer) {
			return WaveSurfer.WebAudio.getPeaks.call(this, length, start, end);
		}
		return this.peaks || [];
	},

	getVolume: function () {
		return this.media.volume;
	},

	setVolume: function (val) {
		this.media.volume = val;
	},

	destroy: function () {
		this.pause();
		this.unAll();
		this.media && this.media.parentNode && this.media.parentNode.removeChild(this.media);
		this.media = null;
	}
});

//For backwards compatibility
WaveSurfer.AudioElement = WaveSurfer.MediaElement;

'use strict';

WaveSurfer.Drawer = {
	init: function (container, params) {
		this.container = container;
		this.params = params;

		this.width = 0;
		this.height = params.height * this.params.pixelRatio;

		this.lastPos = 0;

		this.initDrawer(params);
		this.createWrapper();
		this.createElements();
	},

	createWrapper: function () {
		this.wrapper = this.container.appendChild(
			document.createElement('wave')
		);

		this.style(this.wrapper, {
			display: 'block',
			position: 'relative',
			userSelect: 'none',
			webkitUserSelect: 'none',
			height: this.params.height + 'px'
		});

		if (this.params.fillParent || this.params.scrollParent) {
			this.style(this.wrapper, {
				width: '100%',
				overflowX: this.params.hideScrollbar ? 'hidden' : 'auto',
				overflowY: 'hidden'
			});
		}

		this.setupWrapperEvents();
	},

	handleEvent: function (e, noPrevent) {
		!noPrevent && e.preventDefault();

		var clientX = e.targetTouches ? e.targetTouches[0].clientX : e.clientX;
		var bbox = this.wrapper.getBoundingClientRect();

		var nominalWidth = this.width;
		var parentWidth = this.getWidth();

		var progress;

		if (!this.params.fillParent && nominalWidth < parentWidth) {
			progress = ((clientX - bbox.left) * this.params.pixelRatio / nominalWidth) || 0;

			if (progress > 1) {
				progress = 1;
			}
		} else {
			progress = ((clientX - bbox.left + this.wrapper.scrollLeft) / this.wrapper.scrollWidth) || 0;
		}

		return progress;
	},

	setupWrapperEvents: function () {
		var my = this;

		this.wrapper.addEventListener('click', function (e) {
			var scrollbarHeight = my.wrapper.offsetHeight - my.wrapper.clientHeight;
			if (scrollbarHeight != 0) {
				// scrollbar is visible.  Check if click was on it
				var bbox = my.wrapper.getBoundingClientRect();
				if (e.clientY >= bbox.bottom - scrollbarHeight) {
					// ignore mousedown as it was on the scrollbar
					return;
				}
			}

			if (my.params.interact) {
				my.fireEvent('click', e, my.handleEvent(e));
			}
		});

		this.wrapper.addEventListener('scroll', function (e) {
			my.fireEvent('scroll', e);
		});
	},

	drawPeaks: function (peaks, length, start, end) {
		this.setWidth(length);

		this.params.barWidth ?
			this.drawBars(peaks, 0, start, end) :
			this.drawWave(peaks, 0, start, end);
	},

	style: function (el, styles) {
		Object.keys(styles).forEach(function (prop) {
			if (el.style[prop] !== styles[prop]) {
				el.style[prop] = styles[prop];
			}
		});
		return el;
	},

	resetScroll: function () {
		if (this.wrapper !== null) {
			this.wrapper.scrollLeft = 0;
		}
	},

	recenter: function (percent) {
		var position = this.wrapper.scrollWidth * percent;
		this.recenterOnPosition(position, true);
	},

	recenterOnPosition: function (position, immediate) {
		var scrollLeft = this.wrapper.scrollLeft;
		var half = ~~(this.wrapper.clientWidth / 2);
		var target = position - half;
		var offset = target - scrollLeft;
		var maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;

		if (maxScroll == 0) {
			// no need to continue if scrollbar is not there
			return;
		}

		// if the cursor is currently visible...
		if (!immediate && -half <= offset && offset < half) {
			// we'll limit the "re-center" rate.
			var rate = 5;
			offset = Math.max(-rate, Math.min(rate, offset));
			target = scrollLeft + offset;
		}

		// limit target to valid range (0 to maxScroll)
		target = Math.max(0, Math.min(maxScroll, target));
		// no use attempting to scroll if we're not moving
		if (target != scrollLeft) {
			this.wrapper.scrollLeft = target;
		}

	},

	getScrollX: function() {
		return Math.round(this.wrapper.scrollLeft * this.params.pixelRatio);
	},

	getWidth: function () {
		return Math.round(this.container.clientWidth * this.params.pixelRatio);
	},

	setWidth: function (width) {
		if (this.width == width) {
		  return;
		}

		this.width = width;

		if (this.params.fillParent || this.params.scrollParent) {
			this.style(this.wrapper, {
				width: ''
			});
		} else {
			this.style(this.wrapper, {
				width: ~~(this.width / this.params.pixelRatio) + 'px'
			});
		}

		this.updateSize();
	},

	setHeight: function (height) {
		if (height == this.height) { return; }
		this.height = height;
		this.style(this.wrapper, {
			height: ~~(this.height / this.params.pixelRatio) + 'px'
		});
		this.updateSize();
	},

	progress: function (progress) {
		var minPxDelta = 1 / this.params.pixelRatio;
		var pos = Math.round(progress * this.width) * minPxDelta;

		if (pos < this.lastPos || pos - this.lastPos >= minPxDelta) {
			this.lastPos = pos;

			if (this.params.scrollParent && this.params.autoCenter) {
				var newPos = ~~(this.wrapper.scrollWidth * progress);
				this.recenterOnPosition(newPos);
			}

			this.updateProgress(pos);
		}
	},

	destroy: function () {
		this.unAll();
		if (this.wrapper) {
			this.container.removeChild(this.wrapper);
			this.wrapper = null;
		}
	},

	/* Renderer-specific methods */
	initDrawer: function () {},

	createElements: function () {},

	updateSize: function () {},

	drawWave: function (peaks, max) {},

	clearWave: function () {},

	updateProgress: function (position) {}
};

WaveSurfer.util.extend(WaveSurfer.Drawer, WaveSurfer.Observer);

'use strict';

WaveSurfer.Drawer.Canvas = Object.create(WaveSurfer.Drawer);

WaveSurfer.util.extend(WaveSurfer.Drawer.Canvas, {
	createElements: function () {
		var waveCanvas = this.wrapper.appendChild(
			this.style(document.createElement('canvas'), {
				position: 'absolute',
				zIndex: 1,
				left: 0,
				top: 0,
				bottom: 0
			})
		);
		this.waveCc = waveCanvas.getContext('2d');

		this.progressWave = this.wrapper.appendChild(
			this.style(document.createElement('wave'), {
				position: 'absolute',
				zIndex: 2,
				left: 0,
				top: 0,
				bottom: 0,
				overflow: 'hidden',
				width: '0',
				display: 'none',
				boxSizing: 'border-box',
				borderRightStyle: 'solid',
				borderRightWidth: this.params.cursorWidth + 'px',
				borderRightColor: this.params.cursorColor
			})
		);

		if (this.params.waveColor != this.params.progressColor) {
			var progressCanvas = this.progressWave.appendChild(
				document.createElement('canvas')
			);
			this.progressCc = progressCanvas.getContext('2d');
		}
	},

	updateSize: function () {
		var width = Math.round(this.width / this.params.pixelRatio);

		this.waveCc.canvas.width = this.width;
		this.waveCc.canvas.height = this.height;
		this.style(this.waveCc.canvas, { width: width + 'px'});

		this.style(this.progressWave, { display: 'block'});

		if (this.progressCc) {
			this.progressCc.canvas.width = this.width;
			this.progressCc.canvas.height = this.height;
			this.style(this.progressCc.canvas, { width: width + 'px'});
		}

		this.clearWave();
	},

	clearWave: function () {
		this.waveCc.clearRect(0, 0, this.width, this.height);
		if (this.progressCc) {
			this.progressCc.clearRect(0, 0, this.width, this.height);
		}
	},

	drawBars: function (peaks, channelIndex, start, end) {
		var my = this;
		// Split channels
		if (peaks[0] instanceof Array) {
			var channels = peaks;
			if (this.params.splitChannels) {
				this.setHeight(channels.length * this.params.height * this.params.pixelRatio);
				channels.forEach(function(channelPeaks, i) {
					my.drawBars(channelPeaks, i, start, end);
				});
				return;
			} else {
				peaks = channels[0];
			}
		}

		// Bar wave draws the bottom only as a reflection of the top,
		// so we don't need negative values
		var hasMinVals = [].some.call(peaks, function (val) { return val < 0; });
		// Skip every other value if there are negatives.
		var peakIndexScale = 1;
		if (hasMinVals) {
			peakIndexScale = 2;
		}

		// A half-pixel offset makes lines crisp
		var $ = 0.5 / this.params.pixelRatio;
		var width = this.width;
		var height = this.params.height * this.params.pixelRatio;
		var offsetY = height * channelIndex || 0;
		var halfH = height / 2;
		var length = peaks.length / peakIndexScale;
		var bar = this.params.barWidth * this.params.pixelRatio;
		var gap = Math.max(this.params.pixelRatio, ~~(bar / 2));
		var step = bar + gap;

		var absmax = 1 / this.params.barHeight;
		if (this.params.normalize) {
			var max = WaveSurfer.util.max(peaks);
			var min = WaveSurfer.util.min(peaks);
			absmax = -min > max ? -min : max;
		}

		var scale = length / width;

		this.waveCc.fillStyle = this.params.waveColor;
		if (this.progressCc) {
			this.progressCc.fillStyle = this.params.progressColor;
		}

		[ this.waveCc, this.progressCc ].forEach(function (cc) {
			if (!cc) { return; }

			for (var i = (start / scale); i < (end / scale); i += step) {
				var peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;
				var h = Math.round(peak / absmax * halfH);
				cc.fillRect(i + $, halfH - h + offsetY, bar + $, h * 2);
			}
		}, this);
	},

	drawWave: function (peaks, channelIndex, start, end) {
		var my = this;
		// Split channels
		if (peaks[0] instanceof Array) {
			var channels = peaks;
			if (this.params.splitChannels) {
				this.setHeight(channels.length * this.params.height * this.params.pixelRatio);
				channels.forEach(function(channelPeaks, i) {
					my.drawWave(channelPeaks, i, start, end);
				});
				return;
			} else {
				peaks = channels[0];
			}
		}

		// Support arrays without negative peaks
		var hasMinValues = [].some.call(peaks, function (val) { return val < 0; });
		if (!hasMinValues) {
			var reflectedPeaks = [];
			for (var i = 0, len = peaks.length; i < len; i++) {
				reflectedPeaks[2 * i] = peaks[i];
				reflectedPeaks[2 * i + 1] = -peaks[i];
			}
			peaks = reflectedPeaks;
		}

		// A half-pixel offset makes lines crisp
		var $ = 0.5 / this.params.pixelRatio;
		var height = this.params.height * this.params.pixelRatio;
		var offsetY = height * channelIndex || 0;
		var halfH = height / 2;
		var length = ~~(peaks.length / 2);

		var scale = 1;
		if (this.params.fillParent && this.width != length) {
			scale = this.width / length;
		}

		var absmax = 1 / this.params.barHeight;
		if (this.params.normalize) {
			var max = WaveSurfer.util.max(peaks);
			var min = WaveSurfer.util.min(peaks);
			absmax = -min > max ? -min : max;
		}

		this.waveCc.fillStyle = this.params.waveColor;
		if (this.progressCc) {
			this.progressCc.fillStyle = this.params.progressColor;
		}

		[ this.waveCc, this.progressCc ].forEach(function (cc) {
			if (!cc) { return; }

			cc.beginPath();
			cc.moveTo(start * scale + $, halfH + offsetY);

			for (var i = start; i < end; i++) {
				var h = Math.round(peaks[2 * i] / absmax * halfH);
				cc.lineTo(i * scale + $, halfH - h + offsetY);
			}

			// Draw the bottom edge going backwards, to make a single
			// closed hull to fill.
			for (var i = end - 1; i >= start; i--) {
				var h = Math.round(peaks[2 * i + 1] / absmax * halfH);
				cc.lineTo(i * scale + $, halfH - h + offsetY);
			}

			cc.closePath();
			cc.fill();

			// Always draw a median line
			cc.fillRect(0, halfH + offsetY - $, this.width, $);
		}, this);
	},

	updateProgress: function (pos) {
		this.style(this.progressWave, { width: pos + 'px' });
	},

	getImage: function(type, quality) {
		return this.waveCc.canvas.toDataURL(type, quality);
	}
});

'use strict';

WaveSurfer.Drawer.MultiCanvas = Object.create(WaveSurfer.Drawer);

WaveSurfer.util.extend(WaveSurfer.Drawer.MultiCanvas, {

	initDrawer: function (params) {
		this.maxCanvasWidth = params.maxCanvasWidth != null ? params.maxCanvasWidth : 4000;
		this.maxCanvasElementWidth = Math.round(this.maxCanvasWidth / this.params.pixelRatio);

		if (this.maxCanvasWidth <= 1) {
			throw 'maxCanvasWidth must be greater than 1.';
		} else if (this.maxCanvasWidth % 2 == 1) {
			throw 'maxCanvasWidth must be an even number.';
		}

		this.hasProgressCanvas = this.params.waveColor != this.params.progressColor;
		this.halfPixel = 0.5 / this.params.pixelRatio;
		this.canvases = [];
	},

	createElements: function () {
		this.progressWave = this.wrapper.appendChild(
			this.style(document.createElement('wave'), {
				position: 'absolute',
				zIndex: 2,
				left: 0,
				top: 0,
				bottom: 0,
				overflow: 'hidden',
				width: '0',
				display: 'none',
				boxSizing: 'border-box',
				borderRightStyle: 'solid',
				borderRightWidth: this.params.cursorWidth + 'px',
				borderRightColor: this.params.cursorColor
			})
		);

		this.addCanvas();
	},

	updateSize: function () {
		var totalWidth = Math.round(this.width / this.params.pixelRatio),
			requiredCanvases = Math.ceil(totalWidth / this.maxCanvasElementWidth);

		while (this.canvases.length < requiredCanvases) {
			this.addCanvas();
		}

		while (this.canvases.length > requiredCanvases) {
			this.removeCanvas();
		}
		
		for (var i in this.canvases) {

			// if the canvas.waveCtx is undefined, skip this
			if (this.canvases[i].waveCtx === undefined) {
				break;
			}
			
			// Add some overlap to prevent vertical white stripes, keep the width even for simplicity.
			var canvasWidth = this.maxCanvasWidth + 2 * Math.ceil(this.params.pixelRatio / 2);

			if (i == this.canvases.length - 1) {
				canvasWidth = this.width - (this.maxCanvasWidth * (this.canvases.length - 1));
			}

			this.updateDimensions(this.canvases[i], canvasWidth, this.height);
			this.clearWaveForEntry(this.canvases[i]);
		}
	},

	addCanvas: function () {
		var entry = {},
			leftOffset = this.maxCanvasElementWidth * this.canvases.length;

		entry.wave = this.wrapper.appendChild(
			this.style(document.createElement('canvas'), {
				position: 'absolute',
				zIndex: 1,
				left: leftOffset + 'px',
				top: 0,
				bottom: 0,
				height: '100%'
			})
		);
		entry.waveCtx = entry.wave.getContext('2d');

		if (this.hasProgressCanvas) {
			entry.progress = this.progressWave.appendChild(
				this.style(document.createElement('canvas'), {
					position: 'absolute',
					left: leftOffset + 'px',
					top: 0,
					bottom: 0,
					height: '100%'
				})
			);
			entry.progressCtx = entry.progress.getContext('2d');
		}

		this.canvases.push(entry);
	},

	removeCanvas: function () {
		var lastEntry = this.canvases.pop();
		lastEntry.wave.parentElement.removeChild(lastEntry.wave);
		if (this.hasProgressCanvas) {
			lastEntry.progress.parentElement.removeChild(lastEntry.progress);
		}
	},

	updateDimensions: function (entry, width, height) {
		var elementWidth = Math.round(width / this.params.pixelRatio),
			totalWidth = Math.round(this.width / this.params.pixelRatio);

		// Where the canvas starts and ends in the waveform, represented as a decimal between 0 and 1.
		entry.start = (entry.waveCtx.canvas.offsetLeft / totalWidth) || 0;
		entry.end = entry.start + elementWidth / totalWidth;

		entry.waveCtx.canvas.width = width;
		entry.waveCtx.canvas.height = height;
		this.style(entry.waveCtx.canvas, { width: elementWidth + 'px'});

		this.style(this.progressWave, { display: 'block'});

		if (this.hasProgressCanvas) {
			entry.progressCtx.canvas.width = width;
			entry.progressCtx.canvas.height = height;
			this.style(entry.progressCtx.canvas, { width: elementWidth + 'px'});
		}
	},

	clearWave: function () {
		for (var i in this.canvases) {
			this.clearWaveForEntry(this.canvases[i]);
		}
	},

	clearWaveForEntry: function (entry) {
		entry.waveCtx.clearRect(0, 0, entry.waveCtx.canvas.width, entry.waveCtx.canvas.height);
		if (this.hasProgressCanvas) {
			entry.progressCtx.clearRect(0, 0, entry.progressCtx.canvas.width, entry.progressCtx.canvas.height);
		}
	},

	drawBars: function (peaks, channelIndex, start, end) {
		var my = this;
		// Split channels
		if (peaks[0] instanceof Array) {
			var channels = peaks;
			if (this.params.splitChannels) {
				this.setHeight(channels.length * this.params.height * this.params.pixelRatio);
				channels.forEach(function(channelPeaks, i) {
					my.drawBars(channelPeaks, i, start, end);
				});
				return;
			} else {
				peaks = channels[0];
			}
		}

		// Bar wave draws the bottom only as a reflection of the top,
		// so we don't need negative values
		var hasMinVals = [].some.call(peaks, function (val) { return val < 0; });
		// Skip every other value if there are negatives.
		var peakIndexScale = 1;
		if (hasMinVals) {
			peakIndexScale = 2;
		}

		// A half-pixel offset makes lines crisp
		var width = this.width;
		var height = this.params.height * this.params.pixelRatio;
		var offsetY = height * channelIndex || 0;
		var halfH = height / 2;
		var length = peaks.length / peakIndexScale;
		var bar = this.params.barWidth * this.params.pixelRatio;
		var gap = Math.max(this.params.pixelRatio, ~~(bar / 2));
		var step = bar + gap;

		var absmax = 1 / this.params.barHeight;
		if (this.params.normalize) {
			var max = WaveSurfer.util.max(peaks);
			var min = WaveSurfer.util.min(peaks);
			absmax = -min > max ? -min : max;
		}

		var scale = length / width;

		for (var i = (start / scale); i < (end / scale); i += step) {
			var peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;
			var h = Math.round(peak / absmax * halfH);
			this.fillRect(i + this.halfPixel, halfH - h + offsetY, bar + this.halfPixel, h * 2);
		}
	},

	drawWave: function (peaks, channelIndex, start, end) {
		var my = this;
		// Split channels
		if (peaks[0] instanceof Array) {
			var channels = peaks;
			if (this.params.splitChannels) {
				this.setHeight(channels.length * this.params.height * this.params.pixelRatio);
				channels.forEach(function(channelPeaks, i) {
					my.drawWave(channelPeaks, i, start, end);
				});
				return;
			} else {
				peaks = channels[0];
			}
		}

		// Support arrays without negative peaks
		var hasMinValues = [].some.call(peaks, function (val) { return val < 0; });
		if (!hasMinValues) {
			var reflectedPeaks = [];
			for (var i = 0, len = peaks.length; i < len; i++) {
				reflectedPeaks[2 * i] = peaks[i];
				reflectedPeaks[2 * i + 1] = -peaks[i];
			}
			peaks = reflectedPeaks;
		}

		// A half-pixel offset makes lines crisp
		var height = this.params.height * this.params.pixelRatio;
		var offsetY = height * channelIndex || 0;
		var halfH = height / 2;

		var absmax = 1 / this.params.barHeight;
		if (this.params.normalize) {
			var max = WaveSurfer.util.max(peaks);
			var min = WaveSurfer.util.min(peaks);
			absmax = -min > max ? -min : max;
		}

		this.drawLine(peaks, absmax, halfH, offsetY, start, end);

		// Always draw a median line
		this.fillRect(0, halfH + offsetY - this.halfPixel, this.width, this.halfPixel);
	},

	drawLine: function (peaks, absmax, halfH, offsetY, start, end) {
		for (var index in this.canvases) {
			var entry = this.canvases[index];

			this.setFillStyles(entry);

			this.drawLineToContext(entry, entry.waveCtx, peaks, absmax, halfH, offsetY, start, end);
			this.drawLineToContext(entry, entry.progressCtx, peaks, absmax, halfH, offsetY, start, end);
		}
	},

	drawLineToContext: function (entry, ctx, peaks, absmax, halfH, offsetY, start, end) {
		if (!ctx) { return; }

		var length = peaks.length / 2;

		var scale = 1;
		if (this.params.fillParent && this.width != length) {
			scale = this.width / length;
		}

		var first = Math.round(length * entry.start),
			last = Math.round(length * entry.end);
		if (first > end || last < start) { return; }
		var canvasStart = Math.max(first, start);
		var canvasEnd = Math.min(last, end);

		ctx.beginPath();
		ctx.moveTo((canvasStart - first) * scale + this.halfPixel, halfH + offsetY);

		for (var i = canvasStart; i < canvasEnd; i++) {
			var peak = peaks[2 * i] || 0;
			var h = Math.round(peak / absmax * halfH);
			ctx.lineTo((i - first) * scale + this.halfPixel, halfH - h + offsetY);
		}

		// Draw the bottom edge going backwards, to make a single
		// closed hull to fill.
		for (var i = canvasEnd - 1; i >= canvasStart; i--) {
			var peak = peaks[2 * i + 1] || 0;
			var h = Math.round(peak / absmax * halfH);
			ctx.lineTo((i - first) * scale + this.halfPixel, halfH - h + offsetY);
		}

		ctx.closePath();
		ctx.fill();
	},

	fillRect: function (x, y, width, height) {
		var startCanvas = Math.floor(x / this.maxCanvasWidth);
		var endCanvas = Math.min(Math.ceil((x + width) / this.maxCanvasWidth) + 1,
								 this.canvases.length);
		for (var i = startCanvas; i < endCanvas; i++) {
			var entry = this.canvases[i],
				leftOffset = i * this.maxCanvasWidth;

			var intersection = {
				x1: Math.max(x, i * this.maxCanvasWidth),
				y1: y,
				x2: Math.min(x + width, i * this.maxCanvasWidth + entry.waveCtx.canvas.width),
				y2: y + height
			};

			if (intersection.x1 < intersection.x2) {
				this.setFillStyles(entry);

				this.fillRectToContext(entry.waveCtx,
						intersection.x1 - leftOffset,
						intersection.y1,
						intersection.x2 - intersection.x1,
						intersection.y2 - intersection.y1);

				this.fillRectToContext(entry.progressCtx,
						intersection.x1 - leftOffset,
						intersection.y1,
						intersection.x2 - intersection.x1,
						intersection.y2 - intersection.y1);
			}
		}
	},

	fillRectToContext: function (ctx, x, y, width, height) {
		if (!ctx) { return; }
		ctx.fillRect(x, y, width, height);
	},

	setFillStyles: function (entry) {
		entry.waveCtx.fillStyle = this.params.waveColor;
		if (this.hasProgressCanvas) {
			entry.progressCtx.fillStyle = this.params.progressColor;
		}
	},

	updateProgress: function (pos) {
		this.style(this.progressWave, { width: pos + 'px' });
	},

	/**
	 * Combine all available canvasses together.
	 *
	 * @param {String} type - an optional value of a format type. Default is image/png.
	 * @param {Number} quality - an optional value between 0 and 1. Default is 0.92.
	 *
	 */
	getImage: function(type, quality) {
		var availableCanvas = [];
		this.canvases.forEach(function (entry) {
			availableCanvas.push(entry.wave.toDataURL(type, quality));
		});
		return availableCanvas.length > 1 ? availableCanvas : availableCanvas[0];
	}
});

'use strict';

WaveSurfer.Drawer.SplitWavePointPlot = Object.create(WaveSurfer.Drawer.Canvas);

WaveSurfer.util.extend(WaveSurfer.Drawer.SplitWavePointPlot, {

	defaultPlotParams: {
		plotNormalizeTo: 'whole',
		plotTimeStart: 0,
		plotMin: 0,
		plotMax: 1,
		plotColor     : '#f63',
		plotProgressColor : '#F00',
		plotPointHeight: 2,
		plotPointWidth: 2,
		plotSeparator: true,
		plotSeparatorColor: 'black',
		plotRangeDisplay: false,
		plotRangeUnits: '',
		plotRangePrecision: 4,
		plotRangeIgnoreOutliers: false,
		plotRangeFontSize: 12,
		plotRangeFontType: 'Ariel',
		waveDrawMedianLine: true,
		plotFileDelimiter:  '\t'
	},

	//object variables that get manipulated by various object functions
	plotTimeStart: 0,  //the start time of our wave according to plot data
	plotTimeEnd: -1,   //the end of our wave according to plot data
	plotArrayLoaded: false,
	plotArray: [],     //array of plot data objects containing time and plot value
	plotPoints: [],        //calculated average plot points corresponding to value of our wave
	plotMin: 0,
	plotMax: 1,

	/**
	 * Initializes the plot array. If params.plotFileUrl is provided an ajax call will be
	 * executed and drawing of the wave is delayed until plot info is retrieved
	 * @param params
	 */
	initDrawer: function (params) {
		var my = this;

		//set defaults if not passed in
		for(var paramName in this.defaultPlotParams) {
			if(this.params[paramName] === undefined) {
				this.params[paramName] = this.defaultPlotParams[paramName];
			}
		}

		//set the plotTimeStart
		this.plotTimeStart = this.params.plotTimeStart;

		//check to see if plotTimeEnd
		if(this.params.plotTimeEnd !== undefined) {
			this.plotTimeEnd = this.params.plotTimeEnd;
		}

		//set the plot array
		if (Array.isArray(params.plotArray)) {
			this.plotArray = params.plotArray;
			this.plotArrayLoaded = true;
		}
		//Need to load the plot array from ajax with our callback
		else {
			var onPlotArrayLoaded = function (plotArray) {
				my.plotArray = plotArray;
				my.plotArrayLoaded = true;
				my.fireEvent('plot_array_loaded');
			};
			this.loadPlotArrayFromFile(params.plotFileUrl, onPlotArrayLoaded, this.params.plotFileDelimiter);
		}
	},

	/**
	 * Draw the peaks - this overrides the drawer.js function and does the following additional steps
	 * - ensures that the plotArray has already been loaded, if not it loads via ajax
	 * - moves the wave form to where channel 1 would normally be
	 * @param peaks
	 * @param length
	 * @param start
	 * @param end
	 */
	drawPeaks: function (peaks, length, start, end) {
		//make sure that the plot array is already loaded
		if (this.plotArrayLoaded == true) {

			this.setWidth(length);

			//fake that we are splitting channels
			this.splitChannels = true;
			this.params.height = this.params.height/2;
			if (peaks[0] instanceof Array) {
			   peaks = peaks[0];
			}

			this.params.barWidth ?
				this.drawBars(peaks, 1, start, end) :
				this.drawWave(peaks, 1, start, end);

			//set the height back to the original
			this.params.height = this.params.height*2;

			this.calculatePlots();
			this.drawPlots();

		}
		//otherwise wait for the plot array to be loaded and then draw again
		else {
			var my = this;
			my.on('plot-array-loaded', function () {
				my.drawPeaks(peaks, length, start, end);
			});
		}
	},




	/**
	 * Loop through the calculated plot values and actually draw them
	 */
	drawPlots: function() {
		var height = this.params.height * this.params.pixelRatio / 2;

		var $ = 0.5 / this.params.pixelRatio;

		this.waveCc.fillStyle = this.params.plotColor;
		if(this.progressCc) {
			this.progressCc.fillStyle = this.params.plotProgressColor;
		}
		for(var i in this.plotPoints) {
			var x = parseInt(i);
			var y = height - this.params.plotPointHeight - (this.plotPoints[i] * (height - this.params.plotPointHeight));
			var pointHeight = this.params.plotPointHeight;

			this.waveCc.fillRect(x, y, this.params.plotPointWidth, pointHeight);

			if(this.progressCc) {
				this.progressCc.fillRect(x, y, this.params.plotPointWidth, pointHeight);
			}
		}

		//draw line to separate the two waves
		if(this.params.plotSeparator) {
			this.waveCc.fillStyle = this.params.plotSeparatorColor;
			this.waveCc.fillRect(0, height, this.width, $);
		}

		if(this.params.plotRangeDisplay) {
			this.displayPlotRange();
		}
	},


	/**
	 * Display the range for the plot graph
	 */
	displayPlotRange: function()
	{
		var fontSize = this.params.plotRangeFontSize * this.params.pixelRatio;
		var maxRange = this.plotMax.toPrecision(this.params.plotRangePrecision) + ' ' + this.params.plotRangeUnits;
		var minRange = this.plotMin.toPrecision(this.params.plotRangePrecision) + ' ' + this.params.plotRangeUnits;
		this.waveCc.font = fontSize.toString() + 'px ' + this.params.plotRangeFontType;
		this.waveCc.fillText(maxRange, 3, fontSize);
		this.waveCc.fillText(minRange, 3, this.height/2);

	},
	/**
	 * This function loops through the plotArray and converts it to the plot points
	 * to be drawn on the canvas keyed by their position
	 */
	calculatePlots: function() {
		//reset plots array
		this.plotPoints = {};

		//make sure we have our plotTimeEnd
		this.calculatePlotTimeEnd();

		var pointsForAverage = [];
		var previousWaveIndex = -1;
		var maxPlot = 0;
		var minPlot = 99999999999999;
		var maxSegmentPlot = 0;
		var minSegmentPlot = 99999999999999;
		var duration = this.plotTimeEnd - this.plotTimeStart;

		//loop through our plotArray and map values to wave indexes and take the average values for each wave index
		for(var i = 0; i < this.plotArray.length; i++) {
			var dataPoint = this.plotArray[i];
			if(dataPoint.value > maxPlot) {maxPlot = dataPoint.value;}
			if(dataPoint.value < minPlot) {minPlot = dataPoint.value;}

			//make sure we are in the specified range
			if(dataPoint.time >= this.plotTimeStart && dataPoint.time <= this.plotTimeEnd) {
				//get the wave index corresponding to the data point
				var waveIndex = Math.round(this.width * (dataPoint.time - this.plotTimeStart) / duration);

				pointsForAverage.push(dataPoint.value);

				//if we have moved on to a new position in our wave record average and reset previousWaveIndex
				if(waveIndex !== previousWaveIndex) {
					if(pointsForAverage.length > 0) {
						//get the average plot for this point
						var avgPlot = this.avg(pointsForAverage);

						//check for min max
						if(avgPlot > maxSegmentPlot) {maxSegmentPlot = avgPlot;}
						if(avgPlot < minSegmentPlot) {minSegmentPlot = avgPlot;}

						//add plot to the position
						this.plotPoints[previousWaveIndex] = avgPlot;
						pointsForAverage = [];
					}
				}
				previousWaveIndex = waveIndex;
			}
		}

		//normalize the plots points
		if(this.params.plotNormalizeTo == 'whole') {
			this.plotMin = minPlot;
			this.plotMax = maxPlot;
		}
		else if(this.params.plotNormalizeTo == 'values') {
			this.plotMin = this.params.plotMin;
			this.plotMax = this.params.plotMax;
		}
		else {
			this.plotMin = minSegmentPlot;
			this.plotMax = maxSegmentPlot;
		}
		this.normalizeValues();
	},

	/**
	 * Function to take all of the plots in this.plots and normalize them from 0 to one
	 * depending on this.plotMin and this.plotMax values
	 */
	normalizeValues: function() {
		var normalizedValues = {};

		//check to make sure we should be normalizing
		if(this.params.plotNormalizeTo === 'none') {return;}

		for(var i in this.plotPoints) {
			//get the normalized value between 0 and 1
			var normalizedValue = (this.plotPoints[i] - this.plotMin) / (this.plotMax - this.plotMin);

			//check if the value is above our specified range max
			if(normalizedValue > 1) {
				if(!this.params.plotRangeIgnoreOutliers) {
					normalizedValues[i] = 1;
				}
			}
			//check if hte value is below our specified rant
			else if(normalizedValue < 0) {
				if(!this.params.plotRangeIgnoreOutliers) {
					normalizedValues[i] = 0;
				}
			}
			//in our range add the normalized value
			else {
				normalizedValues[i] = normalizedValue;
			}
		}
		this.plotPoints = normalizedValues;
	},
	/**
	 *
	 */

	/**
	 * Function to load the plot array from a external file
	 *
	 * The text file should contain a series of lines.
	 * Each line should contain [audio time] [delimiter character] [plot value]
	 * e.g. "1.2355 [tab] 124.2321"
	 *
	 * @param plotFileUrl  url of the file containing time and value information
	 * @param onSuccess    function to run on success
	 * @param delimiter    the delimiter that separates the time and values on each line
	 */
	loadPlotArrayFromFile: function(plotFileUrl, onSuccess, delimiter) {
		//default delimiter to tab character
		if (delimiter === undefined) {delimiter = '\t';}

		var plotArray = [];

		var options = {
			url: plotFileUrl,
			responseType: 'text'
		};
		var fileAjax = WaveSurfer.util.ajax(options);

		fileAjax.on('load', function (data) {
			if (data.currentTarget.status == 200) {
				//split the file by line endings
				var plotLines = data.currentTarget.responseText.split('\n');
				//loop through each line and find the time and plot values (delimited by tab)
				for (var i = 0; i < plotLines.length; i++) {
					var plotParts = plotLines[i].split(delimiter);
					if(plotParts.length == 2) {
						plotArray.push({time: parseFloat(plotParts[0]), value: parseFloat(plotParts[1])});
					}
				}
				//run success function
				onSuccess(plotArray);
			}
		});
	},

	/***
	 * Calculate the end time of the plot
	 */
	calculatePlotTimeEnd: function() {
		if(this.params.plotTimeEnd !== undefined) {
			this.plotTimeEnd = this.params.plotTimeEnd;
		}
		else {
			this.plotTimeEnd = this.plotArray[this.plotArray.length -1].time;
		}
	},

	/**
	 * Quick convenience function to average numbers in an array
	 * @param  array of values
	 * @returns {number}
	 */
	avg: function(values) {
		var sum = values.reduce(function(a, b) {return a+b;});
		return sum/values.length;
	}
});

WaveSurfer.util.extend(WaveSurfer.Drawer.SplitWavePointPlot, WaveSurfer.Observer);

'use strict';

WaveSurfer.PeakCache = {
	init: function() {
		this.clearPeakCache();
	},

	clearPeakCache: function() {
	// Flat array with entries that are always in pairs to mark the
	// beginning and end of each subrange.  This is a convenience so we can
	// iterate over the pairs for easy set difference operations.
		this.peakCacheRanges = [];
	// Length of the entire cachable region, used for resetting the cache
	// when this changes (zoom events, for instance).
		this.peakCacheLength = -1;
	},

	addRangeToPeakCache: function(length, start, end) {
		if (length != this.peakCacheLength) {
			this.clearPeakCache();
			this.peakCacheLength = length;
		}

		// Return ranges that weren't in the cache before the call.
		var uncachedRanges = [];
		var i = 0;
		// Skip ranges before the current start.
		while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] < start) {
			i++;
		}
	// If |i| is even, |start| falls after an existing range.  Otherwise,
	// |start| falls between an existing range, and the uncached region
	// starts when we encounter the next node in |peakCacheRanges| or
	// |end|, whichever comes first.
		if (i % 2 == 0) {
			uncachedRanges.push(start);
		}
		while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= end) {
			uncachedRanges.push(this.peakCacheRanges[i]);
			i++;
		}
		// If |i| is even, |end| is after all existing ranges.
		if (i % 2 == 0) {
			uncachedRanges.push(end);
		}

		// Filter out the 0-length ranges.
		uncachedRanges = uncachedRanges.filter(function(item, pos, arr) {
			if (pos == 0) {
				return item != arr[pos + 1];
			} else if (pos == arr.length - 1) {
				return item != arr[pos - 1];
			} else {
				return item != arr[pos - 1] && item != arr[pos + 1];
			}
		});

	// Merge the two ranges together, uncachedRanges will either contain
	// wholly new points, or duplicates of points in peakCacheRanges.  If
	// duplicates are detected, remove both and extend the range.
		this.peakCacheRanges = this.peakCacheRanges.concat(uncachedRanges);
		this.peakCacheRanges = this.peakCacheRanges.sort(function(a, b) {
			return a - b;
		}).filter(function(item, pos, arr) {
			if (pos == 0) {
				return item != arr[pos + 1];
			} else if (pos == arr.length - 1) {
				return item != arr[pos - 1];
			} else {
				return item != arr[pos - 1] && item != arr[pos + 1];
			}
		});

	// Push the uncached ranges into an array of arrays for ease of
	// iteration in the functions that call this.
		var uncachedRangePairs = [];
		for (i = 0; i < uncachedRanges.length; i += 2) {
			uncachedRangePairs.push([uncachedRanges[i], uncachedRanges[i+1]]);
		}

		return uncachedRangePairs;
	},

	// For testing
	getCacheRanges: function() {
	  var peakCacheRangePairs = [];
	  for (var i = 0; i < this.peakCacheRanges.length; i += 2) {
		  peakCacheRangePairs.push([this.peakCacheRanges[i], this.peakCacheRanges[i+1]]);
	  }
	  return peakCacheRangePairs;
	}
};

'use strict';

/* Init from HTML */
(function () {
	var init = function () {
		var containers = document.querySelectorAll('wavesurfer');

		Array.prototype.forEach.call(containers, function (el) {
			var params = WaveSurfer.util.extend({
				container: el,
				backend: 'MediaElement',
				mediaControls: true
			}, el.dataset);

			el.style.display = 'block';

			var wavesurfer = WaveSurfer.create(params);

			if (el.dataset.peaks) {
				var peaks = JSON.parse(el.dataset.peaks);
			}

			wavesurfer.load(el.dataset.url, peaks);
		});
	};

	if (document.readyState === 'complete') {
		init();
	} else {
		window.addEventListener('load', init);
	}
}());

return WaveSurfer;

}));


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("wavesurfer", moduleFactory);

}());	});
// Prepare the script definitions
FD40.installer('EasySocial', 'definitions', function($) {
	$.module(["easysocial\/apps\/fields\/event\/description\/content","easysocial\/apps\/fields\/event\/permalink\/content","easysocial\/apps\/fields\/event\/permalink\/sample_content","easysocial\/apps\/fields\/event\/recurring\/content","easysocial\/apps\/fields\/event\/startend\/content","easysocial\/apps\/fields\/event\/startend\/display","easysocial\/apps\/fields\/group\/description\/content","easysocial\/apps\/fields\/group\/permalink\/content","easysocial\/apps\/fields\/group\/permalink\/sample_content","easysocial\/apps\/fields\/page\/description\/content","easysocial\/apps\/fields\/page\/permalink\/content","easysocial\/apps\/fields\/page\/permalink\/sample_content","easysocial\/apps\/fields\/user\/address\/content","easysocial\/apps\/fields\/user\/address\/display_content","easysocial\/apps\/fields\/user\/address\/maps","easysocial\/apps\/fields\/user\/address\/osm","easysocial\/apps\/fields\/user\/autocomplete\/content","easysocial\/apps\/fields\/user\/avatar\/content","easysocial\/apps\/fields\/user\/avatar\/sample_content","easysocial\/apps\/fields\/user\/checkbox\/content","easysocial\/apps\/fields\/user\/checkbox\/sample_content","easysocial\/apps\/fields\/user\/country\/content","easysocial\/apps\/fields\/user\/country\/sample_content","easysocial\/apps\/fields\/user\/cover\/content","easysocial\/apps\/fields\/user\/currency\/content","easysocial\/apps\/fields\/user\/datetime\/content","easysocial\/apps\/fields\/user\/datetime\/display_content","easysocial\/apps\/fields\/user\/datetime\/dropdown","easysocial\/apps\/fields\/user\/datetime\/sample_content","easysocial\/apps\/fields\/user\/dropdown\/content","easysocial\/apps\/fields\/user\/email\/content","easysocial\/apps\/fields\/user\/file\/content","easysocial\/apps\/fields\/user\/file\/sample_content","easysocial\/apps\/fields\/user\/gender\/content","easysocial\/apps\/fields\/user\/joomla_email\/content","easysocial\/apps\/fields\/user\/joomla_email\/registermini_content","easysocial\/apps\/fields\/user\/joomla_email\/sample_content","easysocial\/apps\/fields\/user\/joomla_fullname\/content","easysocial\/apps\/fields\/user\/joomla_fullname\/sample_content","easysocial\/apps\/fields\/user\/joomla_password\/content","easysocial\/apps\/fields\/user\/joomla_password\/registermini_content","easysocial\/apps\/fields\/user\/joomla_password\/sample_content","easysocial\/apps\/fields\/user\/joomla_timezone\/content","easysocial\/apps\/fields\/user\/joomla_username\/content","easysocial\/apps\/fields\/user\/joomla_username\/registermini_content","easysocial\/apps\/fields\/user\/joomla_username\/sample_content","easysocial\/apps\/fields\/user\/keycaptcha\/content","easysocial\/apps\/fields\/user\/keycaptcha\/registermini_content","easysocial\/apps\/fields\/user\/multidropdown\/content","easysocial\/apps\/fields\/user\/multilist\/content","easysocial\/apps\/fields\/user\/multitextbox\/content","easysocial\/apps\/fields\/user\/numeric\/content","easysocial\/apps\/fields\/user\/password\/content","easysocial\/apps\/fields\/user\/password\/sample_content","easysocial\/apps\/fields\/user\/permalink\/content","easysocial\/apps\/fields\/user\/permalink\/sample_content","easysocial\/apps\/fields\/user\/relationship\/content","easysocial\/apps\/fields\/user\/separator\/sample","easysocial\/apps\/fields\/user\/terms\/content","easysocial\/apps\/fields\/user\/textarea\/content","easysocial\/apps\/fields\/user\/textbox\/content","easysocial\/apps\/fields\/user\/textbox\/sample_content","easysocial\/apps\/fields\/user\/url\/content","easysocial\/shared\/elements","easysocial\/shared\/fields\/base","easysocial\/shared\/fields\/conditional","easysocial\/shared\/fields\/validate","easysocial\/shared\/popdown","easysocial\/shared\/privacy","easysocial\/shared\/responsive","easysocial\/shared\/sidebarmenu","easysocial\/uploader\/item","easysocial\/uploader\/queue","easysocial\/uploader\/uploader","easysocial\/admin\/admin","easysocial\/admin\/api\/tabs","easysocial\/admin\/api\/toolbar","easysocial\/admin\/apps\/store","easysocial\/admin\/clusters\/users","easysocial\/admin\/discovery\/discovery","easysocial\/admin\/events\/approveRecurring","easysocial\/admin\/events\/events","easysocial\/admin\/events\/store","easysocial\/admin\/events\/users","easysocial\/admin\/grid\/grid","easysocial\/admin\/grid\/ordering","easysocial\/admin\/grid\/sort","easysocial\/admin\/groups\/groups","easysocial\/admin\/header\/apps","easysocial\/admin\/maintenance\/maintenance","easysocial\/admin\/migrators\/migrator","easysocial\/admin\/pages\/pages","easysocial\/admin\/profiles\/avatar","easysocial\/admin\/profiles\/form","easysocial\/admin\/progress\/progress","easysocial\/admin\/regions\/form","easysocial\/admin\/regions\/init","easysocial\/admin\/users\/form","easysocial\/admin\/users\/privacy","easysocial\/admin\/users\/users","easysocial\/admin\/utilities\/alias","easysocial\/admin\/vendors\/drag","easysocial\/admin\/vendors\/mousewheel","easysocial\/admin\/vendors\/raty","easysocial\/admin\/vendors\/resize","easysocial\/admin\/vendors\/uniform","easysocial\/admin\/workflows\/choices","easysocial\/admin\/workflows\/form"]);
});

// Prepare the contents of all the scripts
FD40.installer('EasySocial', 'scripts', function($) {
			EasySocial.module('apps/fields/event/description/content', function($) {

var module = this;

EasySocial.Controller('Field.Event.Description', {
    defaultOptions: {
        "required": false,
        "editor": null,
        "{input}": '[data-field-description]'
    }
}, function(self, opts, base) { return {

    init: function() {
        self.editor = self.options.editor;
    },

    "{self} onRender": function() {
        var data = self.input().htmlData();
        opts.error = data.error || {};
    },

    '{input} keyup': function() {
        self.validateInput();
    },

    '{input} blur': function() {
        self.validateInput();
    },

    validateInput: function() {
        self.clearError();

        var value = self.editor.getContent();

        if (self.options.required && $.isEmpty(value)) {
            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },
    
    '{self} onError': function(el, ev, type) {
        if(type === 'required') {
            self.raiseError(opts.error.required);
        }
    },

    '{self} onSubmit': function(el, ev, register) {
        register.push(self.validateInput());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/event/permalink/content', function($) {
    var module = this;

EasySocial.Controller('Field.Event.Permalink', {
    defaultOptions: {
        required: false,

        max     : 0,

        id      : null,
        clusterid   : null,
        userid  : null,

        '{field}': '[data-field-permalink]',
        '{checkButton}': '[data-permalink-check]',
        '{input}': '[data-permalink-input]',
        '{available}': '[data-permalink-available]'
    }
}, function(self, opts, base) { return {
    state: false,

    init: function() {
        opts.max = self.field().data('max');
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    "{checkButton} click" : function() {
        self.delayedCheck();
    },

    "{input} keyup" : function() {
        self.delayedCheck();
    },

    delayedCheck: $.debounce(function() {
        self.checkPermalink();
    }, 250),

    checkPermalink: function() {
        self.clearError();

        var permalink   = self.input().val();

        self.available().hide();

        if (self.options.max > 0 && permalink.length > self.options.max) {
            self.raiseError(opts.error.max);
            return false;
        }

        if (!$.isEmpty(permalink)) {
            self.checkButton().addClass('is-loading');

            var state = $.Deferred();

            EasySocial.ajax('fields/event/permalink/isValid', {
                "id"        : self.options.id,
                "clusterid" : self.options.clusterid,
                "permalink" : permalink
            })
            .done(function(msg) {
                self.clearError();

                self.checkButton().removeClass('is-loading');

                self.available().show();

                state.resolve();
            })
            .fail(function(msg) {
                self.raiseError(msg);

                self.checkButton().removeClass('is-loading');

                self.available().hide();

                state.reject();
            });

            return state;
        }

        if (self.options.required && $.isEmpty(permalink)) {
            self.available().hide();

            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register) {
        register.push(self.checkPermalink());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/event/permalink/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Permalink.Sample', {
        defaultOptions: {
            '{checkPermalink}'      : '[data-check-permalink]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_permalink':
                        self.checkPermalink().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/event/recurring/content', function($) {

var module = this;
var lang = EasySocial.options.momentLang;

EasySocial.require().library('datetimepicker', 'moment/' + lang).done(function() {

EasySocial.Controller('Field.Event.Recurring', {
	defaultOptions: {
		dateFormat: '',
		id: null,
		value: {},
		allday: 0,
		showWarningMessages: 0,
		eventId: null,
		dow: 0,

		'{type}': '[data-recurring-type]',
		'{endBlock}': '[data-recurring-end-block]',
		'{picker}': '[data-recurring-end-picker]',
		'{toggle}': '[data-recurring-end-toggle]',
		'{result}': '[data-recurring-end-result]',
		'{dailyBlock}': '[data-recurring-daily-block]',
		'{dailyInput}': '[data-recurring-daily-block] input',
		'{summaryBlock}': '[data-recurring-summary-block]',
		"{showSchedules}": "[data-show-schedules]",
		'{scheduleLoadingBlock}': '[data-recurring-schedule-loading-block]',
		'{deleteRecurringButton}': '[data-recurring-delete]'
	}
}, function(self, opts) { return {
	init: function() {
		var dateFormat = self.options.dateFormat;
		var startofweek = self.options.dow;

		self.picker()._datetimepicker({
			pickTime: false,
			component: "es",
			useCurrent: false,
			format: dateFormat,
			language: lang,
			dow: startofweek

		});

		var value = self.result().val();

		if (!$.isEmpty(value)) {
			var dateObj = $.moment(value);

			self.datetimepicker('setDate', dateObj);
		}

		// Calculate total recurring events
		self.calculateRecurringEvents();
	},

	changed: 0,

	'{window} easysocial.fields.allday.change': function(el, ev, value) {
		self.options.allday = value;

		self.calculateRecurringEvents();
	},

	'{window} easysocial.fields.startend.start.change': function(el, ev, date) {
		self.calculateRecurringEvents();
	},

	'{toggle} click': function() {
		self.picker().focus();
	},

	'{picker} dp.change': function(el, ev) {
		self.setDateValue(ev.date.toDate());

		self.detectChanges();

		self.calculateRecurringEvents();
	},

	'{type} change': function(el, ev) {
		var value = el.val();

		self.endBlock()[value === 'none' ? 'hide' : 'show']();

		self.dailyBlock()[value === 'daily' ? 'show': 'hide']();

		self.detectChanges();

		self.calculateRecurringEvents();
	},

	'{dailyInput} change': function(el, ev) {
		self.detectChanges();

		self.calculateRecurringEvents();
	},

	calculateRecurringEvents: function() {
		
		self.summaryBlock().hide();

		self.scheduleLoadingBlock().hide();

		self.clearError();

		var start = $('[data-event-start]').find('[data-datetime]').val();
		var timezone = $('[data-event-timezone]').val();
		var end = self.result().val();
		var type = self.type().val();
		var daily = [];

		if (type == 'none' && !self.options.showWarningMessages) {
			return;
		}

		if ($.isEmpty(start) || $.isEmpty(end) || $.isEmpty(type)) {
			return;
		}

		$.each(self.dailyBlock().find('input'), function(i, input) {
			el = $(input);
			if (el.is(':checked')) {
				daily.push(el.val());
			}
		});

		self.scheduleLoadingBlock().show();

		self.getTotalRecurring({
			"start": start,
			"timezone": timezone,
			"end": end,
			"type": type,
			"daily": daily
		});
	},

	getTotalRecurring: $.debounce(function(options) {
		self.clearError();

		EasySocial.ajax('fields/event/recurring/calculateRecurringEvents', {
			"id": self.options.id,
			"start": options.start,
			"timezone": options.timezone,
			"allday": self.options.allday,
			"end": options.end,
			"type": options.type,
			"daily": options.daily,
			"eventId": self.options.eventId,
			"changed": self.changed,
			"showWarningMessages": self.options.showWarningMessages
		}).done(function(html) {
			self.summaryBlock().html(html).show();
		}).fail(function(msg) {
			self.raiseError(msg);
		}).always(function() {
			self.scheduleLoadingBlock().hide();
		});
	}, 500),

	detectChanges: function() {
		var end = self.result().val(),
			type = self.type().val(),
			daily = [],
			changed = false;

		$.each(self.dailyBlock().find('input'), function(i, input) {
			el = $(input);
			if (el.is(':checked')) {
				daily.push(el.val());
			}
		});

		if (type != self.options.value.type || end != self.options.value.end || daily.length != self.options.value.daily.length) {
			changed = true;
		}

		$.each(daily, function(i, d) {
			if ($.inArray(d, self.options.value.daily) == -1) {
				changed = true;
				return false;
			}
		});

		$.each(self.options.value.daily, function(i, d) {
			if ($.inArray(d, daily) == -1) {
				changed = true;
				return false;
			}
		});

		self.changed = changed ? 1 : 0;

		$(window).trigger('easysocial.fields.recurring.changed', [changed]);
	},

	"{showSchedules} click": function(button, event) {
		
		var start = $('[data-event-start]').find('[data-datetime]').val();
		var timezone = $('[data-event-timezone]').val();
		var end = self.result().val();
		var type = self.type().val();
		var daily = [];

		$.each(self.dailyBlock().find('input'), function(i, input) {
			el = $(input);

			if (el.is(':checked')) {
				daily.push(el.val());
			}
		});

		EasySocial.dialog({
			"content": EasySocial.ajax('fields/event/recurring/getScheduledEvents', {
							"id": self.options.id,
							"start": start,
							"timezone": timezone,
							"allday": self.options.allday,
							"end": end,
							"type": type,
							"daily": daily,
							"eventId": self.options.eventId
					})
		});
	},

	'{deleteRecurringButton} click': function(el, ev) {
		
		EasySocial.dialog({
			content: EasySocial.ajax('site/views/events/deleteRecurringDialog', {
				id: self.options.eventId
			}),
			bindings: {
				"{submitButton} click": function() {
					self.deleteRecurring()
						.done(function() {
							EasySocial.dialog().close();
							self.calculateRecurringEvents();
						});
				}
			}
		})
	},

	deleteRecurring: function() {
		return EasySocial.ajax('site/controllers/events/deleteRecurring', {
			eventId: self.options.eventId
		})
	},

	datetimepicker: function(name, value) {
		return self.picker().data('DateTimePicker')[name](value);
	},

	setDateValue: function(date) {
		// Convert the date object into sql format and set it into the input
		self.result().val(date.getFullYear() + '-' +
							('00' + (date.getMonth()+1)).slice(-2) + '-' +
							('00' + date.getDate()).slice(-2) + ' ' +
							('00' + date.getHours()).slice(-2) + ':' +
							('00' + date.getMinutes()).slice(-2) + ':' +
							('00' + date.getSeconds()).slice(-2));
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(true);
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/event/startend/content', function($) {
	
var module = this;
var lang = EasySocial.options.momentLang;

EasySocial
.require()
.library('datetimepicker', 'moment/' + lang, 'chosen')
.done(function($) {

EasySocial.Controller('Field.Event.Startend', {
	defaultOptions: {
		dateFormat: '',
		allowTime: true,
		allowTimezone: true,
		disallowPast: false,
		minuteStepping: 15,
		yearfrom: '',
		yearto: '',
		requiredEnd: false,
		allday: false,
		calendarLanguage: 'english',
		dow: 0,

		'{field}': '[data-field-startend]',
		'{startForm}': '[data-event-start]',
		'{endForm}': '[data-event-end]',
		'{timezone}': '[data-event-timezone]'
	}
}, function(self, opts, base) { return {
	init: function() {

		var data = self.field().htmlData();

		opts.error = data.error || {};

		// There is an issue with yearto where if I set yearto = 2014, I won't be able to select 2014 dates. 
		// This is a bug in datetimepicker. Currently, temporarily, we manually add 1 to the value if there are value set.
		if (!$.isEmpty(self.options.yearto)) {
			self.options.yearto = parseInt(self.options.yearto) + 1;
		} else {
			self.options.yearto = new Date().getFullYear() + 100
		}

		self.options.yearfrom = self.options.yearfrom || 1930;

		// Add controller on the start date
		self.startDatetime = self.startForm().addController('EasySocial.Controller.Field.Event.Startend.Form', {
			'{parent}': self,
			"type": 'start'
		});

		// Add controller on the end date
		self.endDatetime = self.endForm().addController('EasySocial.Controller.Field.Event.Startend.Form', {
			'{parent}': self,
			"type": 'end'
		});

		// Apply chosen on timezone field
		if (self.timezone().length > 0) {
			self.timezone().chosen({
				allow_single_deselect: true,
				search_contains: true
			});
		}
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	},

	validateInput: function() {
		self.clearError();

		if ($.isEmpty(self.startDatetime.datetime().val())) {
			self.raiseError(opts.error.start.required);

			return false;
		}

		if (self.options.requireEnd && $.isEmpty(self.endDatetime.datetime().val())) {
			self.raiseError(opts.error.end.required);

			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	}
}});

EasySocial.Controller('Field.Event.Startend.Form', {
	defaultOptions: {
		type: null,

		'{picker}': '[data-picker]',
		'{toggle}': '[data-picker-toggle]',
		'{datetime}': '[data-datetime]'
	}
}, function(self, options) {

	return {
		init: function() {
			self.load();
		},

		"{window} easysocial.fields.startend.start.change": function() {

			// When the start date is changed, set the minimum date on the end date
			if (options.type == 'start' && self.parent.endDatetime) {
				self.parent.endDatetime.datetimepicker('destroy');

				self.parent.endDatetime.load();
			}
		},


		'{window} easysocial.fields.allday.change': function(el, ev, value) {
			self.datetimepicker('destroy');

			self.parent.options.allday = value == 1 ? true : false;

			self.load();
		},

		// We move this here because there is a possibility that we want to "reinit"
		load: function() {

			// Generate a minimum date from momentjs
			var minDate = new $.moment();

			// If configured to disallow past dates, we need to minus 1 on the date as we need to allow today.
			if (self.parent.options.disallowPast) {
				minDate.date(minDate.date() - 1);
			} else {
				minDate.year(self.parent.options.yearfrom);
			}

			// If this type is end date, we need to set the minimum date based on the start date
			if (options.type == 'end') {
				var startDatetimeValue = self.parent.startDatetime.datetime().val();

				if (startDatetimeValue) {
					var minDate = $.moment(startDatetimeValue);
					
					// minus 1 on the date as we need to allow today.
					var minDate = minDate.date(minDate.date() - 1);
				}
			}

			var allowTime = self.parent.options.allowTime && !self.parent.options.allday;
			var dateFormat = self.parent.options.dateFormat;

			// If time is not allowed, then we remove the time part
			// Since the format is always (10 chars) (remaining chars)
			// We just substr by 10 chars
			if (!allowTime) {
				dateFormat = dateFormat.substr(0, 10);
			}

			self.picker()._datetimepicker({
				component: "es",
				useCurrent: false,
				format: dateFormat,
				minDate: minDate,
				maxDate: new $.moment({y: self.parent.options.yearto}),
				icons: {
					time: 'far fa-clock',
					date: 'fa fa-calendar',
					up: 'fa fa-chevron-up',
					down: 'fa fa-chevron-down'
				},
				sideBySide: false,
				pickTime: allowTime,
				minuteStepping: parseInt(self.parent.options.minuteStepping),
				language: self.parent.options.calendarLanguage == 'english' ? 'en-gb' : lang,
				dow: self.parent.options.dow
			});

			var date = self.datetime().val();

			// Datetimepicker is using moment.js, hence here we manually create a moment object to pass in instead of passing in date time string
			// This is because datetimepicker.setDate function passes along the format from self.options.calendarDateFormat to generate the date object, which will render moment.js to generate an invalid dateobject
			// self.options.calendarDateFormat is only for display purposes
			// Raw date object is always in SQL format
			if (!$.isEmpty(date)) {
				var dateObj = $.moment(date);

				self.datetimepicker('setDate', dateObj);
			}

			if (options.type == 'end') {
				var startDatetimeValue = self.parent.startDatetime.datetime().val();

				if (startDatetimeValue) {
					var startDateObj = $.moment(startDatetimeValue);

					if (!$.isEmpty(date)) {
						var endDateObj = $.moment(date);

						// If start date is greated than current end date, adjust it accordingly
						if (startDateObj.unix() > endDateObj.unix()) {
							self.datetimepicker('setDate', startDateObj);
						}

					} else {
						// Simulate jump to date based on start date
						self.datetimepicker('setDate', startDateObj);

						// Empty the value again since initially there are no value set
						self.datetimepicker('setDate', '');
						self.datetime().val('');
					}
				}
			}
		},

		datetimepicker: function(name, value) {
			return self.picker().data('DateTimePicker')[name](value);
		},

		'{toggle} click': function() {
			self.picker().focus();
		},

		'{picker} dp.change': function(el, ev) {

			self.setDateValue(ev.date.toDate());

			// easysocial.fields.startend.start.change
			// easysocial.fields.startend.end.change
			$(window).trigger('easysocial.fields.startend.' + options.type + '.change', [ev.date]);
		},

		'{picker} change': function(el, ev) {
			if ($.isEmpty(el.val())) {
				self.datetime().val('');
			}
		},

		setDateValue: function(date) {
			// Convert the date object into sql format and set it into the input
			self.datetime().val(date.getFullYear() + '-' +
								('00' + (date.getMonth()+1)).slice(-2) + '-' +
								('00' + date.getDate()).slice(-2) + ' ' +
								('00' + date.getHours()).slice(-2) + ':' +
								('00' + date.getMinutes()).slice(-2) + ':' +
								('00' + date.getSeconds()).slice(-2));
		}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/event/startend/display', function($) {

var module = this;

EasySocial
.require()
.library('chosen', 'popbox')
.done(function($) {

EasySocial.Controller('Field.Event.Startend.Display.Box', {
    defaultOptions: {
        date: null,
        timezone: null,
        local: null,
        '{toggle}': '[data-popbox]',
        '{content}': '[data-popbox-content]',
        '{date}': '[data-date]',
        '{timezone}': '[data-timezone]',
        '{loading}': '[data-loading]'
    }
}, function(self, opts) { return {

    init: function() {
        opts.timezone = self.timezone().data('timezone');
        opts.date = self.date().data('date-utc');

        // Get the local timezone first through client browser
        opts.local = -new Date().getTimezoneOffset / 60;

        var content = self.content().html();
        var position = self.toggle().data('popbox-position');

        self.toggle().popbox({
            content: content,
            id: 'es',
            component: 'ui',
            type: 'timezone',
            toggle: 'click',
            position: position
        }).attr('data-popbox', '');
    },

    '{toggle} popboxActivate': function(el, event, popbox) {
        popbox.tooltip.addController('EasySocial.Controller.Field.Event.Startend.Display.Timezone', {
            '{parent}': self
        });
    },

    datetime: $.memoize(function(tz) {
        return EasySocial.ajax('fields/event/startend/getDatetime', {
            "id": opts.id,
            "userid": opts.userid,
            "tz": tz,
            "local": self.options.local,
            "datetime": opts.date
        });
    })
}});

EasySocial.Controller('Field.Event.Startend.Display.Timezone', {
    defaultOptions: {
        '{timezones}': '[data-timezone-select]',
        '{reset}': '[data-timezone-reset]',
        '{local}': '[data-timezone-local]'
    }
}, function(self, opts) { return {
    init: function() {
        self.timezones().chosen({
            search_contains: true
        });
    },

    '{timezones} change': function(dropdown, event) {
        var option = dropdown.find(':selected');
        var value = option.val();
        var text = option.text();

        // Apply loading indicator
        self.parent.element.addClass('is-loading');

        // Update the text
        self.parent.timezone().html(text);

        self.parent.datetime(value).done(function(value) {
            self.parent.date().html(value);
            self.parent.element.removeClass('is-loading');
        });
    },

    '{reset} click': function() {
        self.setTimezone(self.parent.options.timezone);
    },

    '{local} click': function() {
        self.setTimezone('local')
    },

    setTimezone: function(tz) {
        self.timezones()
            .val(tz)
            .trigger('liszt:updated')
            .trigger('change');
    }

}});

module.resolve();

});

});
			EasySocial.module('apps/fields/group/description/content', function($) {

var module = this;

EasySocial.Controller('Field.Group.Description', {
    defaultOptions: {
        "required": false,
        "editor": null,
        "{input}": '[data-field-description]'
    }
}, function(self, opts, base) { return {

    init: function() {
        self.editor = self.options.editor;
    },

    "{self} onRender": function() {
        var data = self.input().htmlData();
        opts.error = data.error || {};
    },

    '{input} keyup': function() {
        self.validateInput();
    },

    '{input} blur': function() {
        self.validateInput();
    },

    validateInput: function() {
        self.clearError();

        var value = self.editor.getContent();

        if (self.options.required && $.isEmpty(value)) {
            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onError': function(el, ev, type) {
        if(type === 'required') {
            self.raiseError(opts.error.required);
        }
    },

    '{self} onSubmit': function(el, ev, register) {
        register.push(self.validateInput());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/group/permalink/content', function($) {

var module = this;

EasySocial.Controller('Field.Group.Permalink', {
    defaultOptions: {
        required: false,

        max     : 0,

        id      : null,
        groupid : null,
        userid  : null,

        '{field}'           : '[data-field-permalink]',

        '{checkButton}'     : '[data-permalink-check]',
        '{input}'           : '[data-permalink-input]',
        '{available}'       : '[data-permalink-available]'
    }
}, function(self, opts, base) { return {
    state: false,

    init: function() {
        opts.max = self.field().data('max');
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    "{checkButton} click" : function() {
        self.delayedCheck();
    },

    "{input} keyup" : function()
    {
        self.delayedCheck();
    },

    delayedCheck: $.debounce(function()
    {
        self.checkPermalink();
    }, 250),

    checkPermalink: function()
    {
        self.clearError();

        var permalink   = self.input().val();

        self.available().hide();

        if (self.options.max > 0 && permalink.length > self.options.max) {
            self.raiseError(opts.error.max);
            return false;
        }

        if (!$.isEmpty(permalink)) {
            self.checkButton().addClass('is-loading');

            var state = $.Deferred();

            EasySocial.ajax('fields/group/permalink/isValid', {
                "id"        : self.options.id,
                "groupid"   : self.options.groupid,
                "permalink" : permalink
            })
            .done(function(msg) {
                self.clearError();

                self.checkButton().removeClass('is-loading');

                self.available().show();

                state.resolve();
            })
            .fail(function(msg) {
                self.raiseError(msg);

                self.checkButton().removeClass('is-loading');

                self.available().hide();

                state.reject();
            });

            return state;
        }

        if (self.options.required && $.isEmpty(permalink)) {
            self.available().hide();

            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register) {
        register.push(self.checkPermalink());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/group/permalink/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Permalink.Sample', {
        defaultOptions: {
            '{checkPermalink}'      : '[data-check-permalink]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_permalink':
                        self.checkPermalink().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/page/description/content', function($) {

var module = this;

EasySocial.Controller('Field.Page.Description', {
    defaultOptions: {
        "required": false,
        "editor": null,
        "{input}": '[data-field-description]'
    }
}, function(self, opts, base) { return {

    init: function() {
        self.editor = self.options.editor;
    },

    "{self} onRender": function() {
        var data = self.input().htmlData();
        opts.error = data.error || {};
    },

    '{input} keyup': function() {
        self.validateInput();
    },

    '{input} blur': function() {
        self.validateInput();
    },

    validateInput: function() {
        self.clearError();

        var value = self.editor.getContent();

        if (self.options.required && $.isEmpty(value)) {
            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onError': function(el, ev, type) {
        if(type === 'required') {
            self.raiseError(opts.error.required);
        }
    },

    '{self} onSubmit': function(el, ev, register) {
        register.push(self.validateInput());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/page/permalink/content', function($) {

var module = this;

EasySocial.Controller('Field.Page.Permalink', {
    defaultOptions: {
        required: false,

        max     : 0,

        id      : null,
        pageid : null,
        userid  : null,

        '{field}'           : '[data-field-permalink]',

        '{checkButton}'     : '[data-permalink-check]',
        '{input}'           : '[data-permalink-input]',
        '{available}'       : '[data-permalink-available]'
    }
}, function(self, opts, base) { return {
    state: false,

    init: function() {
        opts.max = self.field().data('max');
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    "{checkButton} click" : function() {
        self.delayedCheck();
    },

    "{input} keyup" : function()
    {
        self.delayedCheck();
    },

    delayedCheck: $.debounce(function()
    {
        self.checkPermalink();
    }, 250),

    checkPermalink: function()
    {
        self.clearError();

        var permalink   = self.input().val();

        self.available().hide();

        if (self.options.max > 0 && permalink.length > self.options.max) {
            self.raiseError(opts.error.max);
            return false;
        }

        if (!$.isEmpty(permalink)) {
            self.checkButton().addClass('is-loading');

            var state = $.Deferred();

            EasySocial.ajax('fields/page/permalink/isValid', {
                "id"        : self.options.id,
                "pageid"   : self.options.pageid,
                "permalink" : permalink
            })
            .done(function(msg) {
                self.clearError();

                self.checkButton().removeClass('is-loading');

                self.available().show();

                state.resolve();
            })
            .fail(function(msg) {
                self.raiseError(msg);

                self.checkButton().removeClass('is-loading');

                self.available().hide();

                state.reject();
            });

            return state;
        }

        if (self.options.required && $.isEmpty(permalink)) {
            self.available().hide();

            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register) {
        register.push(self.checkPermalink());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/page/permalink/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Permalink.Sample', {
        defaultOptions: {
            '{checkPermalink}'      : '[data-check-permalink]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_permalink':
                        self.checkPermalink().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/address/content', function($) {

var module = this;

EasySocial.Controller('Field.Address', {
	defaultOptions: {
		required: {},
		show: {},

		"{field}": "[data-field-address]",
		"{address1}": "[data-field-address-address1]",
		"{address2}": "[data-field-address-address2]",
		"{city}": "[data-field-address-city]",
		"{state}": "[data-field-address-state]",
		"{country}": "[data-field-address-country]",
		"{zip}": "[data-field-address-zip]",
		'{required}': '[data-required]',
		'{notice}': '[data-check-notice]'
	}
}, function(self, opts, base) { return {

	init : function() {
	},

	fields: [
		'address1',
		'address2',
		'city',
		'state',
		'zip',
		'country'
	],

	"{self} onRender": function(element, event) {
		var data = self.field().htmlData();

		opts.error = data.error;
	},

	validateInput : function() {
		self.clearError();

		var errorRaised = false;

		self.clearError();

		$.each(self.fields, function(i, field) {
			var el = self[field]();

			el.removeClass('has-error');

			var val = el.val();

			if ($.isEmpty(val) && self.options.required[field] && self.options.show[field]) {
				el.addClass('has-error');

				if (!errorRaised) {
					self.raiseError(opts.error[field]);
					errorRaised = true;
				}
			}
		});

		if (errorRaised) {
			return false;
		}

		return true;
	},

	'{address1}, {address2}, {zip}, {city}, {state} blur': function() {
		self.validateInput();
	},

	'{country} change': function(el) {
		self.validateInput();

		if (self.state().is('select')) {

			if (el.val() == '') {
				self.state().empty();
				var option = $('<option></option>').html(self.options.selectCountryText).val('').appendTo(self.state());

				return;
			}

			EasySocial.ajax('fields/user/address/getStates', {
				id: self.options.id,
				country: el.val()
			}).done(function(states) {
				self.state().empty();
				$('<option></option>').html(self.options.selectStateText).val('').appendTo(self.state());

				$.each(states, function(code, name) {
					var option = $('<option></option>').html(name).val(name).appendTo(self.state());
				});
			});
		}
	},

	raiseError: function(message) {
		self.trigger('error', [message]);

		// self.notice()
		//     .css('color', '#a94442')
		//     .text(msg)
		//     .parent('.controls-error')
		//     .show();
	},

	clearError: function() {
		self.trigger('clear');
	},

	"{self} onSubmit" : function(el, event, register) {
		register.push(self.validateInput());
	},

	"{self} onConfigChange": function(el, event, name, value) {
		var requires = ['address1', 'address2', 'city', 'zip', 'state', 'country'];

		if($.inArray(name, requires) >= 0) {
			self.options.required[name] = !!value;
		}

		self.required().hide();

		$.each(requires, function(i, t) {
			if(self.options[t]) {
				self.required().show();
				return false;
			}
		});
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/address/display_content', function($) {

var module = this;

EasySocial
.require()
.library('gmaps', 'leaflet', 'leaflet-providers')
.done(function() {

EasySocial.Controller('Field.Address.Display', {
	defaultOptions: {
		latitude: null,
		longitude: null,
		ratio: 1,
		mapElementId: 'map',
		'{base}': '[data-location-base]',
		'{map}': '[data-location-map]',
		'{mapImage}': '[data-location-map-image]'
	}
}, function(self) { return {

	init: function() {

		if (self.options.mapElementId) {
			self.mapElementId = self.options.mapElementId;
		}

		var map = self.map();
		self.options.latitude = map.data('latitude');
		self.options.longitude = map.data('longitude');
		self.options.provider = map.data('location-provider');

		self.setLayout();
	},

	'{window} resize': $.debounce(function() {
		self.setLayout();
	}, 250),

	navigate: function(lat, lng) {
		if (!self.options.staticMap && self.options.provider == 'osm') {
			self.navigateDynamic(lat, lng);
			self.base().addClass("has-location");
			self.base().removeClass("is-loading");
			return;
		}

		var mapImage = self.mapImage(),
			width = Math.floor(mapImage.width()),
			height = Math.floor(mapImage.height());

		if (self.options.provider == 'osm') {
			var url = "//maps.wikimedia.org/img/osm-intl,15," + lat + "," + lng + ",600x300.png";
		} else {
			var url = $.GMaps.staticMapURL({
					size: [1280, 1280],
					lat: lat,
					lng: lng,
					sensor: true,
					scale: 2,
					markers: [
						{lat: lat, lng: lng}
					]
				});
		}

		var url = url.replace(/http\:|https\:/, '');

		// When map is loaded, fade in.
		$.Image.get(url)
			.done(function(){
				mapImage.css({
					"backgroundImage": $.cssUrl(url),
					"backgroundSize": "cover",
					"backgroundPosition": "center center"
				});
				self.base().addClass("has-location");
			})
			.always(function(){
				self.base().removeClass("is-loading");
			});
	},

	navigateDynamic: function(lat, lng) {
		self.osm = L.map(self.mapElementId, {
			zoom: 12
		})

		self.osm.fitWorld();

		L.tileLayer.provider('Wikimedia').addTo(self.osm);

		var latlng = {
			lat: parseFloat(lat),
			lng: parseFloat(lng)
		}

		self.osm.flyTo(latlng, 13, {
			"duration": 3
		});

		marker = L.marker(latlng).addTo(self.osm);
	},

	setLayout: function() {
		setTimeout(function() {
			if (self.options.latitude && self.options.longitude) {
				self.navigate(self.options.latitude, self.options.longitude);
				// self.navigateDynamic(self.options.latitude, self.options.longitude);
			}
		}, 1);
	},

	'{self} onShow': function() {
		self.setLayout();
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/address/maps', function($) {
var module = this;

// Create search template first
$.template('easysocial/maps.suggestion', '<div class="es-location-suggestion" data-location-suggestion><span class="formatted_address">[%= location.formatted_address %]</span></div>');

EasySocial
.require()
.library('gmaps', 'placeholder', 'image')
.done(function() {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

EasySocial.Controller('Field.Address.Maps', {
	defaultOptions: {
		zoom: 2,

		latitude: null,
		longitude: null,
		address: null,

		singleLocation: true,
		staticMap: false,

		required: false,

		ratio: 3,

		'{field}': '[data-field-address]',

		'{base}': '[data-location-base]',

		'{map}': '[data-location-map]',
		'{mapImage}': '[data-location-map-image]',

		'{detectButton}': '[data-location-detect]',
		'{removeButton}': '[data-location-remove]',

		'{form}': '[data-location-form]',
		'{textbox}': '[data-location-textbox]',
		'{textField}': '[data-location-textfield]',

		'{autocomplete}': '[data-location-autocomplete]',
		'{suggestions}': '[data-location-suggestions]',
		'{suggestion}': '[data-location-suggestion]',

		'{source}': '[data-location-source]',

		view: {
			suggestion: 'maps.suggestion'
		}
	}
}, function(self, opts, base) { return {

	init: function() {

		var data = self.field().htmlData();

		opts.error = data.error || {};

		if (navigator.geolocation) {
			self.base().addClass("is-detectable");
			// self.detectButton().show();
		}

		// Add placeholder support for IE9
		self.textField().placeholder();

		// Allow textField input only when controller is implemented
		self.textField().removeAttr("disabled");

		if (!$.isEmpty(self.source().val())) {
			var data = JSON.parse(self.source().val());

			if (data.latitude && data.longitude) {
				if (opts.staticMap) {
					self.navigate(data.latitude, data.longitude);
				} else {
					self.navigateDynamic(data.latitude, data.longitude);
				}

				self.base().addClass("has-location");
			}
		}
	},

	renderDynamicMap: function(latitude, longitude) {

		if (typeof gmap === 'undefined') {
			// Init for the dynamic map
			gmap = new $.GMaps({
				div: '#map',
				lat: latitude,
				lng: longitude,
				zoom: 15,
				mapTypeId: 'roadmap',
				zoomControl: true,
				clickableIcons: false,
				streetViewControl: false,
				mapTypeControl: false
			});
		} else {
			gmap.setCenter(latitude, longitude);
		}

		// This event listener will call addMarker() when the map is clicked.
		gmap.addListener('click', function(event) {
			var location = event.latLng;

			// Populate the marker on the map
			self.populateMarker(location.lat(), location.lng(), 'addmarker');
		});
	},

	populateMarker: function(lat, lng, action) {
		// We will remove all markers first (if any)
		gmap.removeMarkers();

		// Add the new marker on the map
		var marker = gmap.addMarker({
			lat: lat,
			lng: lng
		});

		gmap.setCenter(lat, lng);

		var currentZoom = gmap.map.zoom;

		// If the current zoom too far,
		// we zoom in a bit
		if (currentZoom < 13) {
			gmap.fitZoom();
			gmap.zoomOut(9);
		}
		
		// If this comes from addmarker action,
		// we need to get the correct address and update the field
		if (action == 'addmarker') {
			self.processMarker(marker);
		}
	},

	processMarker: function(marker, oldMarkerId) {

		markerLat = marker.getPosition().lat();
		markerLng = marker.getPosition().lng();

		// markers[markerId] = marker;

		var markerObj = {
					lat: markerLat,
					lng: markerLng
				}

		// Try to get the address from the given lat lng
		self.lookupLatLng(markerObj);
	},

	updateField: function(markerObj, venue) {

		// Fill in the field with address
		self.textField().val(markerObj.name);

		self.base().addClass("has-location");

		// Set the source here
		self.result = venue;
		var data = self.getResult('source');
		self.source().val(JSON.stringify(data));
	},

	"{window} resize": $.debounce(function() {

		var data = JSON.parse(self.source().val());

		if (!data.latitude || !data.longitude) {
			return;
		}

		var mapImage = self.mapImage();

		if (mapImage.data("width") !== mapImage.width()) {
			self.navigate(data.latitude, data.longitude);
		}

	}, 250),

	'{self} onShow': function() {

		var data = JSON.parse(self.source().val());

		if (!data.latitude || !data.longitude) {
			return;
		}

		var mapImage = self.mapImage();

		if (mapImage.data("width") !== mapImage.width()) {
			self.navigate(data.latitude, data.longitude);
		}
	},

	navigateDynamic: function(lat, lng) {
		self.renderDynamicMap(lat, lng);
		self.populateMarker(lat, lng);
	},

	navigate: function(lat, lng) {
		self.field().css({
			"max-width": "none"
		});

		var mapImage = self.mapImage(),
			apiKey = window.es.gmapsApiKey,
			width = Math.floor(mapImage.width()),
			height = Math.floor(mapImage.height()),
			url = $.GMaps.staticMapURL({
				key: apiKey,
				size: [1280, 1280],
				lat: lat,
				lng: lng,
				sensor: true,
				scale: 2,
				markers: [
					{lat: lat, lng: lng}
				]
			});

		// When map is loaded, fade in.
		$.Image.get(url)
			.done(function(){
				mapImage.css({
					"backgroundImage": $.cssUrl(url),
					"backgroundSize": "cover",
					"backgroundPosition": "center center"
				});
				self.base().addClass("has-location");
			})
			.always(function(){
				self.base().removeClass("is-loading");
			});
	},

	locations: {},

	lastQueryAddress: null,

	results: [],

	result: null,

	"{textField} keypress": function(textField, event) {

		switch (event.keyCode)
		{
			case KEYCODE.UP:

				var prevSuggestion = $(
					self.suggestion(".active").prev(self.suggestion.selector)[0] ||
					self.suggestion(":last")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				prevSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(prevSuggestion, {
						offset: prevSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.DOWN:

				var nextSuggestion = $(
					self.suggestion(".active").next(self.suggestion.selector)[0] ||
					self.suggestion(":first")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				nextSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(nextSuggestion, {
						offset: nextSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.ENTER:

				var activeSuggestion = self.suggestion(".active"),
					location = activeSuggestion.data("location");
					self.set(location);

				self.hideSuggestions();
				break;

			case KEYCODE.ESCAPE:
				self.hideSuggestions();
				break;
		}

	},

	"{textField} keyup": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:
			case KEYCODE.DOWN:
			case KEYCODE.LEFT:
			case KEYCODE.RIGHT:
			case KEYCODE.ENTER:
			case KEYCODE.ESCAPE:
				// Don't repopulate if these keys were pressed.
				break;

			default:
				var address = $.trim(textField.val());

				if (address==="") {
					self.base().removeClass("has-location");
					self.hideSuggestions();
				}

				// if (address==self.lastQueryAddress) return;

				var locations = self.locations[address];

				// If this location has been searched before
				if (locations) {

					// And set our last queried address to this address
					// so that it won't repopulate the suggestion again.
					self.lastQueryAddress = address;

					// Just use cached results
					self.suggest(locations);

				// Else ask google to find it out for us
				} else {
					self.lookup(address);
				}
				break;
		}
	},

	lookupLatLng: $.debounce(function(markerObj) {

		self.base().addClass("is-loading");

		$.GMaps.geocode({
			lat: markerObj.lat,
			lng: markerObj.lng,
			callback: function(locations, status) {

				self.base().removeClass("is-loading");

				if (status == "OK") {
					markerObj.name = locations[0].formatted_address;
					self.updateField(markerObj, locations[0]);
				}
			}
		});

	}, 250),

	lookup: $.debounce(function(address) {

		self.detectButton().addClass("is-loading");

		$.GMaps.geocode({
			address: address,
			callback: function(locations, status) {

				self.detectButton().removeClass("is-loading");

				if (status=="OK") {

					// Store a copy of the results
					self.locations[address] = locations;

					// Suggestion locations
					self.suggest(locations);

					self.lastQueryAddress = address;
				}
			}
		});

	}, 250),

	suggest: function(locations) {

		var suggestions = self.suggestions();

		// Clear location suggestions
		suggestions
			.empty();

		if (locations.length < 0) return;

		self.results = locations;

		$.each(locations, function(i, location){
			// Create suggestion and append to list
			self.view.suggestion({
					location: location
				})
				.data("location", location)
				.appendTo(suggestions);
		});

		self.showSuggestions();
	},

	showSuggestions: function() {

		self.focusSuggestion = true;

		self.element.find(".es-story-footer")
			.addClass("swap-zindex");

		setTimeout(function(){

			self.autocomplete().addClass("active");

			var doc = $(document),
				hideOnClick = "click.es.story.location";

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					if (targets.filter(self.element).length > 0) return;

					doc.off(hideOnClick);

					self.hideSuggestions();
				});

		}, 500);
	},

	hideSuggestions: function() {

		self.focusSuggestion = false;

		self.autocomplete().removeClass("active");

		$(document).off("click.es.story.location");

		setTimeout(function(){

			if (self.focusSuggestion) return;

			self.element.find(".es-story-footer")
				.removeClass("swap-zindex");

		}, 500);
	},

	"{suggestion} activate": function(suggestion, event) {

		var location = suggestion.data("location");
		var lat = location.geometry.location.lat(),
			lng = location.geometry.location.lng();

		if (opts.staticMap) {
			self.navigate(lat, lng);
		} else {
			self.navigateDynamic(lat, lng);
		}
	},

	"{suggestion} mouseover": function(suggestion) {

		// Remove all active class
		self.suggestion().removeClass("active");

		suggestion
			.addClass("active")
			.trigger("activate");
	},

	"{suggestion} click": function(suggestion, event) {

		var location = suggestion.data("location");

		self.set(location);

		self.hideSuggestions();

		self.validateInput();
	},

	set: function(location) {
		self.currentLocation = location;

		var lat = location.geometry.location.lat(),
			lng = location.geometry.location.lng();

		// self.navigateDynamic(lat, lng);

		var address = location.formatted_address;

		self.textField().val(address);

		self.lastQueryAddress = address;

		self.base().addClass("has-location");

		// Set the source here
		self.result = location;
		var data = self.getResult('source');
		self.source().val(JSON.stringify(data));
	},

	unset: function() {

		gmap.removeMarkers();

		self.currentLocation = null;

		self.textField().val('');

		self.base().removeClass("has-location");

		self.source().val('');
	},

	detectTimer: null,

	"{detectButton} click": function() {

		var textbox = self.textbox();

		self.detectButton().addClass("is-loading");

		clearTimeout(self.detectTimer);

		self.detectTimer = setTimeout(function() {
			self.detectButton().removeClass("is-loading");
		}, 8000);

		$.GMaps.geolocate({
			success: function(position) {
				$.GMaps.geocode({
					lat: position.coords.latitude,
					lng: position.coords.longitude,
					callback: function(locations, status) {
						if (status=="OK") {
							self.suggest(locations);
							self.textField().focus();
						}
					}
				});
			},
			error: function(error) {
				var message = "";

				switch (error.code) {

					case 1:
						message = opts.error.map.permission;
						break;

					case 2:
						message = opts.error.map.timeout;
						break;

					case 3:
					default:
						message = opts.error.map.unavailable;
						break;
				}

				// story.setMessage(message);
			},
			always: function() {
				clearTimeout(self.detectTimer);
				self.detectButton().removeClass("is-loading");
			}
		});
	},

	raiseError: function(message) {
		self.trigger('error', [message]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	validateInput : function() {
		self.clearError();

		if ($.isEmpty(self.source().val()) && opts.required) {
			self.raiseError(opts.error.maps);
			return false;
		}

		var value = self.source().val();

		if (value) {
			var data = JSON.parse(value);

			if ((!data.latitude || !data.longitude) && opts.required) {
				self.raiseError(opts.error.maps);
				return false;
			}
		}

		return true;
	},

	"{self} onSubmit" : function(el, event, register) {
		register.push(self.validateInput());
	},

	"{removeButton} click": function() {
		self.unset();
		self.hideSuggestions();
		self.validateInput();
	},

	getResult: function(type) {
		if (!self.result) {
			if (self.results.length === 0) {
				return false;
			}

			self.result = self.results[0];
		}

		var r = self.result;
// console.log(r);
		if (type === undefined) {
			return r;
		}

		switch(type) {
			case 'coords':
				return {
					lat: r.geometry.location.lat(),
					lng: r.geometry.location.lng()
				}
			break;

			case 'lat':
			case 'latitude':
				return r.geometry.location.lat();
			break;

			case 'lng':
			case 'longitude':
				return r.geometry.location.lng();
			break;

			case 'address':
				return r.formatted_address;
			break;

			case 'viewport':
				return r.geometry.viewport;
			break;

			case 'bounds':
				return r.geometry.bounds || r.geometry.viewport;
			break;

			case 'source':
				var components = {};

				$.each(r.address_components, function(index, component) {
					if (component.types[0]) {
						components[component.types[0]] = component.long_name;
					}
				});

				var mapping = {
					'address1': ['street_address', 'route'],
					'address2': ['intersection', 'colloquial_area', 'neighborhood', 'premise', 'subpremise'],
					'city': ['locality', 'sublocality', 'sublocality_level_1', 'sublocality_level_2', 'sublocality_level_3', 'sublocality_level_4', 'sublocality_level_5'],
					'state': ['administrative_area_level_1', 'administrative_area_level_2', 'administrative_area_level_3'],
					'zip': 'postal_code',
					'country': 'country'
				};

				// Based on the mapping we build the legacy data
				var legacy = {};

				$.each(mapping, function(key, value) {

					// Init with empty data
					legacy[key] = '';

					if ($.isArray(value)) {
						$.each(value, function(i, v) {

							// Search if components[v] exists
							if (components[v] !== undefined) {

								// Use it if it exists
								legacy[key] = components[v];

								// Break out and ignore other possible keys
								return false;
							} else {

								// Continue finding
								return true;
							}
						});

						// Continue on to the next key
						return true;
					}

					if (components[value] !== undefined) {
						legacy[key] = components[value];
					}
				});

				var data = $.extend(legacy, {
					components: components,
					address: r.formatted_address,
					latitude: r.geometry.location.lat(),
					longitude: r.geometry.location.lng()
				});

				return data;
			break;
		}
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/address/osm', function($) {
var module = this;

// Create search template first
$.template('easysocial/maps.suggestion', '<div class="es-location-suggestion" data-location-suggestion><span class="formatted_address">[%= location.formatted_address %]</span></div>');

EasySocial
.require()
.library('leaflet', 'placeholder', 'image', 'leaflet-providers')
.done(function() {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

EasySocial.Controller('Field.Address.Osm', {
	defaultOptions: {
		required: false,
		mapElementId: 'map',
		staticMap: false,

		'{field}': '[data-field-address]',
		'{base}': '[data-location-base]',

		'{map}': '[data-location-map]',
		'{mapImage}': '[data-location-map-image]',

		'{detectButton}': '[data-location-detect]',
		'{removeButton}': '[data-location-remove]',

		'{form}': '[data-location-form]',
		'{textbox}': '[data-location-textbox]',
		'{textField}': '[data-location-textfield]',

		'{autocomplete}': '[data-location-autocomplete]',
		'{suggestions}': '[data-location-suggestions]',
		'{suggestion}': '[data-location-suggestion]',

		'{source}': '[data-location-source]',

		view: {
			suggestion: 'maps.suggestion'
		},

		marker: {},
	}
}, function(self, opts, base) { return {
	init: function() {

		if (self.options.mapElementId) {
			self.mapElementId = self.options.mapElementId;
		}

		var data = self.field().htmlData();

		opts.error = data.error || {};

		// Only show auto-detect button if the browser supports geolocation
		if (navigator.geolocation && window.es.isHttps) {
			self.base().addClass("is-detectable");
			self.detectButton().show();
		}

		self.textField().removeAttr("disabled");

		if (!$.isEmpty(self.source().val())) {
			var data = JSON.parse(self.source().val());

			if (data.latitude && data.longitude) {
				lat = data.latitude;
				lng = data.longitude;

				self.initMap();

				self.navigate(lat, lng);

				self.base().addClass("has-location");
			}
		}
	},

	initMap: function() {

		if (opts.staticMap) {
			return;
		}

		if (self.osm !== undefined) {
			return;
		}

		self.osm = L.map(self.mapElementId, {
			zoom: 12
		});

		self.osm.fitWorld();

		L.tileLayer.provider('Wikimedia').addTo(self.osm);

		// Add placeholder support for IE9
		self.textField().placeholder();

		// Allow textField input only when controller is implemented
		self.textField().removeAttr("disabled");

		function onMapClick(e) {
			var latlng = e.latlng;

			self.osm.removeLayer(self.marker);
			self.marker = L.marker(latlng).addTo(self.osm);
			self.osm.setView(latlng);
			self.lookupLatLng(latlng);
		}

		self.osm.on('click', onMapClick);
	},

	marker: {},

	updateField: function(result) {

		// Fill in the field with address
		self.textField().val(result[0].formatted_address);

		self.base().addClass("has-location");

		// Set the source here
		self.result = result[0];
		var data = self.getResult('source');
		self.source().val(JSON.stringify(data));
	},


	"{window} resize": $.debounce(function() {

		var data = JSON.parse(self.source().val());

		if (!data.latitude || !data.longitude) {
			return;
		}

		var mapImage = self.mapImage();

		if (mapImage.data("width") !== mapImage.width()) {
			self.navigate(data.latitude, data.longitude);
		}

	}, 250),

	'{self} onShow': function() {

		var data = JSON.parse(self.source().val());

		if (!data.latitude || !data.longitude) {
			return;
		}

		var mapImage = self.mapImage();

		if (mapImage.data("width") !== mapImage.width()) {
			self.navigate(data.latitude, data.longitude);
		}
	},

	navigate: function(lat, lng) {
		if (opts.staticMap) {
			self.navigateStatic(lat, lng);
		} else {
			self.navigateDynamic(lat, lng);
		}
	},

	navigateStatic: function(lat, lng) {
		self.field().css({
			"max-width": "none"
		});

		var url = "//maps.wikimedia.org/img/osm-intl,13," + lat + "," + lng + ",600x300.png";

		var mapImage = self.mapImage();

		// When map is loaded, fade in.
		$.Image.get(url)
			.done(function(){
				mapImage.css({
					"backgroundImage": $.cssUrl(url),
					"backgroundSize": "cover",
					"backgroundPosition": "center center"
				});
				self.base().addClass("has-location");
			})
			.always(function(){
				self.base().removeClass("is-loading");
			});
		},

	navigateDynamic: function(lat, lng) {
		self.detectButton().addClass("t-hidden");

		self.field().css({
			"max-width": "none"
		});

		var latlng = {
					lat: parseFloat(lat),
					lng: parseFloat(lng)
				}
		self.osm.removeLayer(self.marker);

		self.osm.flyTo(latlng, 10, {
			"duration": 3
		});

		self.marker = L.marker(latlng).addTo(self.osm);
	},

	locations: {},

	lastQueryAddress: null,

	results: [],

	result: null,

	"{textField} keypress": function(textField, event) {

		switch (event.keyCode)
		{
			case KEYCODE.UP:

				var prevSuggestion = $(
					self.suggestion(".active").prev(self.suggestion.selector)[0] ||
					self.suggestion(":last")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				prevSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(prevSuggestion, {
						offset: prevSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.DOWN:

				var nextSuggestion = $(
					self.suggestion(".active").next(self.suggestion.selector)[0] ||
					self.suggestion(":first")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				nextSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(nextSuggestion, {
						offset: nextSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.ENTER:

				var activeSuggestion = self.suggestion(".active"),
					location = activeSuggestion.data("location");

					if (location !== undefined) {
						self.set(location);
					}

				self.hideSuggestions();
				break;

			case KEYCODE.ESCAPE:
				self.hideSuggestions();
				break;
		}

	},

	"{textField} keyup": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:
			case KEYCODE.DOWN:
			case KEYCODE.LEFT:
			case KEYCODE.RIGHT:
			case KEYCODE.ENTER:
			case KEYCODE.ESCAPE:
				// Don't repopulate if these keys were pressed.
				break;

			default:
				var address = $.trim(textField.val());

				if (address==="") {
					self.base().removeClass("has-location");
					self.hideSuggestions();
				}

				// if (address==self.lastQueryAddress) return;

				var locations = self.locations[address];

				// If this location has been searched before
				if (locations) {

					// And set our last queried address to this address
					// so that it won't repopulate the suggestion again.
					self.lastQueryAddress = address;

					// Just use cached results
					self.suggest(locations);

				// Else ask google to find it out for us
				} else {
					self.lookup(address);
				}
				break;
		}
	},

	lookupLatLng: $.debounce(function(latlng) {

		self.base().addClass("is-loading");

		EasySocial.ajax('site/controllers/location/getLocations', {
			latitude: latlng.lat,
			longitude: latlng.lng
		})
		.done(function(result) {
			self.base().removeClass("is-loading");
			self.updateField(result);
		});

	}, 250),

	lookup: $.debounce(function(address) {

		self.detectButton().addClass("is-loading");
		self.base().addClass("is-loading");

		EasySocial.ajax('site/controllers/location/getLocations', {
			query: address
		})
		.done(function(locations) {
			// Store a copy of the results
			self.locations[address] = locations;

			// Suggestion locations
			self.suggest(locations);

			self.lastQueryAddress = address;
		});

	}, 250),

	suggest: function(locations) {

		var suggestions = self.suggestions();

		// Clear location suggestions
		suggestions
			.empty();

		if (locations.length < 0) return;

		self.results = locations;

		$.each(locations, function(i, location){

			location.formatted_address = location.formatted_address;
			// Create suggestion and append to list
			self.view.suggestion({
					location: location
				})
				.data("location", location)
				.appendTo(suggestions);
		});

		self.showSuggestions();

		self.base().removeClass("is-loading");
	},

	showSuggestions: function() {

		self.focusSuggestion = true;

		self.element.find(".es-story-footer")
			.addClass("swap-zindex");

		setTimeout(function(){

			self.autocomplete().addClass("active");

			var doc = $(document),
				hideOnClick = "click.es.story.location";

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					if (targets.filter(self.element).length > 0) return;

					doc.off(hideOnClick);

					self.hideSuggestions();
				});

		}, 500);
	},

	hideSuggestions: function() {

		self.focusSuggestion = false;

		self.autocomplete().removeClass("active");

		$(document).off("click.es.story.location");

		setTimeout(function(){

			if (self.focusSuggestion) return;

			self.element.find(".es-story-footer")
				.removeClass("swap-zindex");

		}, 500);
	},

	"{suggestion} activate": function(suggestion, event) {

		self.initMap();

		var location = suggestion.data("location");

		var lat = location.latitude,
			lng = location.longitude;

		self.navigate(lat, lng);
	},

	"{suggestion} mouseover": function(suggestion) {

		// Remove all active class
		self.suggestion().removeClass("active");

		suggestion
			.addClass("active")
			.trigger("activate");
	},

	"{suggestion} click": function(suggestion, event) {

		self.initMap();

		var location = suggestion.data("location");

		self.set(location);

		self.hideSuggestions();

		self.validateInput();
	},

	set: function(location) {
		self.currentLocation = location;

		var lat = location.latitude,
			lng = location.longitude;

		var address = location.formatted_address;

		self.textField().val(address);

		self.lastQueryAddress = address;

		self.base().addClass("has-location");

		// Set the source here
		self.result = location;
		var data = self.getResult('source');
		self.source().val(JSON.stringify(data));
	},

	unset: function() {

		self.osm.removeLayer(self.marker);

		self.currentLocation = null;

		self.textField().val('');

		self.base().removeClass("has-location");

		self.source().val('');
	},

	detectTimer: null,

	"{detectButton} click": function() {

		var textbox = self.textbox();

		self.detectButton().addClass("is-loading");

		clearTimeout(self.detectTimer);

		self.detectTimer = setTimeout(function() {
			self.detectButton().removeClass("is-loading");

			navigator.geolocation.getCurrentPosition(

				// If successful
				function(position) {
					var coords = position.coords;

					lat = coords.latitude,
					lng = coords.longitude;

					self.initMap();

					self.navigate(lat, lng);
					self.lookupLatLng({lat: lat, lng: lng});
				}
			);
		}, 2000);
	},

	raiseError: function(message) {
		self.trigger('error', [message]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	validateInput : function() {
		self.clearError();

		if ($.isEmpty(self.source().val()) && opts.required) {
			self.raiseError(opts.error.maps);
			return false;
		}

		var value = self.source().val();

		if (value) {
			var data = JSON.parse(value);

			if ((!data.latitude || !data.longitude) && opts.required) {
				self.raiseError(opts.error.maps);
				return false;
			}
		}

		return true;
	},

	"{self} onSubmit" : function(el, event, register) {
		register.push(self.validateInput());
	},

	"{removeButton} click": function() {
		self.unset();
		self.hideSuggestions();
		self.validateInput();
	},

	getResult: function(type) {
		if (!self.result) {
			if (self.results.length === 0) {
				return false;
			}

			self.result = self.results[0];
		}

		var r = self.result;

		if (type === undefined) {
			return r;
		}

		switch(type) {
			case 'coords':
				return {
					lat: r.latitude,
					lng: r.longitude
				}
			break;

			case 'lat':
			case 'latitude':
				return r.latitude;
			break;

			case 'lng':
			case 'longitude':
				return r.longitude;
			break;

			case 'address':
				return r.formatted_address;
			break;

			// case 'viewport':
			// 	return r.geometry.viewport;
			// break;

			// case 'bounds':
			// 	return r.geometry.bounds || r.geometry.viewport;
			// break;

			case 'source':
				var components = {};

				$.each(r.address, function(index, component) {
					components[index] = component;
				});

				var mapping = {
					'address1': ['mall', 'route', 'building', 'public_building'],
					'address2': ['road', 'neighborhood', 'premise', 'subpremise'],
					'city': ['city', 'suburb'],
					'state': 'state',
					'zip': 'postcode',
					'country': 'country'
				};

				// Based on the mapping we build the legacy data
				var legacy = {};

				$.each(mapping, function(key, value) {

					// Init with empty data
					legacy[key] = '';

					if ($.isArray(value)) {
						$.each(value, function(i, v) {

							// Search if components[v] exists
							if (components[v] !== undefined) {

								// Use it if it exists
								legacy[key] = components[v];

								// Break out and ignore other possible keys
								return false;
							} else {

								// Continue finding
								return true;
							}
						});

						// Continue on to the next key
						return true;
					}

					if (components[value] !== undefined) {
						legacy[key] = components[value];
					}
				});

				var data = $.extend(legacy, {
					components: components,
					address: r.formatted_address,
					latitude: r.latitude,
					longitude: r.longitude
				});

				return data;
			break;
		}
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/autocomplete/content', function($) {

var module = this;

EasySocial
.require()
.library('textboxlist')
.done(function($) {

EasySocial.Controller('Field.Autocomplete', {
	defaultOptions: {

		required: false,
		id: null,
		types: null,
		fieldname: null,
		actor: null,
		target: null,

		// Determines pre-selected items
		selectedItems: [],

		// Suggest properties
		max: null,
		exclusive: true,
		exclusion: [],
		minLength: 1,
		highlight: true,
		name: "uid[]",
		type: "",

		"{suggest}": "[data-field-suggest]"
	}
}, function(self, opts, base) { return {
	init: function() {

		// Set the input's name.
		opts.name = opts.fieldname + '[]';

		self.initSuggest();
	},

	// Implement the textbox list on the implemented element.
	initSuggest: function() {
		
		self.suggest()
			.textboxlist({
				component: 'es',
				name: opts.name,
				max: opts.max,
				plugin: {
					autocomplete: {
						exclusive: opts.exclusive,
						minLength: opts.minLength,
						highlight: opts.highlight,
						showLoadingHint: true,
						showEmptyHint: true,
						emptyMessage: opts.emptyMessage,

						query: function(keyword) {

							var result = EasySocial.ajax('fields/user/autocomplete/suggest', {
															"search": keyword,
															"id": opts.id
														});
							return result;
						}
					}
				}
			})
			.textboxlist("enable");
	},

	"{suggest} removeItem": function(el, event, menu) {
		
		// When an item is removed, remove it from the exclusion list
		var isExcluded = $.inArray(menu.id.toString(), opts.exclusion) > -1;

		if (isExcluded) {
			opts.exclusion.splice(opts.exclusion.indexOf(menu.id.toString()), 1);
		}
	},

	"{suggest} filterMenu": function(el, event, menu, menuItems, autocomplete, textboxlist) {

		// Get list of items that are already added into the bucket
		var selected = textboxlist.getAddedItems();
		var selected = $.pluck(selected, "id");

		// Add the items into the exclusion
		var ids = selected.concat(opts.exclusion);

		var exclude = [];

		// Convert selected id into string. #1799
		$.each(ids, function(idx, id) {
			exclude.push(id.toString());
		});

		menuItems.each(function(){

			var menuItem = $(this);
			var item = menuItem.data("item");

			var isSelected = $.inArray(item.id.toString(), exclude) > -1;
			menuItem.toggleClass('hidden', isSelected);
			
		});
	}
}});

module.resolve();

});
});
			EasySocial.module('apps/fields/user/avatar/content', function($) {

var module = this;

EasySocial
.require()
.library('image', 'imgareaselect')
.done(function(){

EasySocial.Controller('Field.Avatar', {
	defaultOptions: {
		required: false,
		id: 0,
		group: null,
		origSource: null,
		defaultAvatar: null,
		hasAvatar: null,

		'{field}': '[data-field-avatar]',

		'{gallery}': '[data-field-avatar-gallery]',
		'{galleryList}': '[data-field-avatar-gallery-items]',
		'{galleryItem}': '[data-field-avatar-gallery-item]',

		'{frame}': '[data-field-avatar-frame]',
		'{viewport}': '[data-field-avatar-viewport]',

		'{avatarSource}': '[data-field-avatar-source]',
		'{avatarData}': '[data-field-avatar-data]',
		'{avatarPath}': '[data-field-avatar-path]',
		'{avatarType}': '[data-field-avatar-type]',
		'{avatarName}': '[data-field-avatar-name]',

		'{file}': '[data-field-avatar-file]',
		'{image}': '[data-field-avatar-selected]',

		'{note}': '[data-field-avatar-note]',

		'{actions}': '[data-field-avatar-actions]',

		'{cancel}': '[data-field-avatar-actions-cancel]',
		'{crop}': '[data-field-avatar-actions-crop]',

		'{removeFrame}': '[data-field-avatar-remove]',
		'{remove}': '[data-field-avatar-remove-button]',
		'{revertFrame}': '[data-field-avatar-revert]',
		'{revert}': '[data-field-avatar-revert-button]',

		'{browseButton}': '[data-browse-avatar]'
	}
}, function(self, opts, base) { return {

	init: function() {
		self.state = !!self.options.hasAvatar;
	},

	initErrorOpts: function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	state: true,
	hasAdjustedCropImage: false,

	"{self} onRender": function() {
		self.initErrorOpts();
	},

	toggleLoader: function() {
		isLoading = self.browseButton().hasClass('is-loading');
		self.browseButton().toggleClass('is-loading', !isLoading);
	},

	"{file} change": function(el, event) {

		if($.isEmpty(el.val())) {
			return;
		}

		// Compatibility with input-group
		var label = el.val().replace(/\\/g, '/').replace(/.*\//, '');
		el.parents('.input-group').find(':text').val(label);

		// Set state to false
		self.state = false;

		// Show the loader
		self.toggleLoader();

		// Hide the previous picture
		self.frame().hide();

		// Hide the file upload field
		self.file().hide();

		// Hide the error frame
		self.clearError();

		EasySocial.ajax('fields/' + self.options.group + '/avatar/upload', {
			id: self.options.id,
			files: el
		}, {
			type: "iframe"
		})
		.done(function(raw, uri, path) {

			// Set the name of the image
			self.avatarName().val(raw.name);

			// Set the source of the image
			self.avatarSource().val(uri);

			// Set the path of the image
			self.avatarPath().val(path);

			// Set the type as upload
			self.avatarType().val('upload');

			// Load the imgareaselect for cropping
			self.setLayout(uri);

			// Unset all gallery item
			self.galleryItem().removeClass('active');

			// Hide the remove button
			self.removeFrame().hide();

			// Hide the revert button
			self.revertFrame().hide();

			// Set state to true
			self.state = true;
		})
		.fail(function(msg) {
			self.toggleLoader();

			self.raiseError(msg);

			self.file().show().val('');

			self.frame().show();
		});
	},

	setLayout: function(img) {
		var loader = $.Image.get(img),
			frame = self.frame();

		loader.done(function(el, image) {
			frame.css('background-image', $.cssUrl(img));

			frame.addClass('avatar-frame-crop');

			frame.show();

			self.toggleLoader();

			self.actions().show();

			self.note().show();

			self.viewport().imgAreaSelect({remove: true});

			self.viewport().show();

			var size = $.Image.resizeWithin(
					image.width,
					image.height,
					frame.width(),
					frame.height()
				),
				min = Math.min(size.width, size.height),
				x1  = Math.floor((size.width  - min) / 2),
				y1  = Math.floor((size.height - min) / 2),
				x2  = x1 + min,
				y2  = y1 + min;

			self.viewport()
				.css(size)
				// .css('position', 'absolute')
				.imgAreaSelect({
					handles: true,
					aspectRatio: '1:1',
					parent: frame,
					x1: x1,
					y1: y1,
					x2: x2,
					y2: y2,
					onSelectEnd: function(viewport, selection) {
						var hasSelection = !(selection.width=="0" && selection.height=="0");

						if (hasSelection) {
							var string = JSON.stringify(self.data());

							self.avatarData().val(string);

							// Set to true becuase user did adjusted cropping image
							self.hasAdjustedCropImage = true;
						}
					}
				})
		});
	},

	'{cancel} click': function() {
		self.actions().hide();

		self.note().hide();

		self.frame().hide();

		self.file().show();

		self.file().val('');

		self.file().parents('.input-group').find(':text').val('');

		self.avatarSource().val('');

		self.avatarPath().val('');

		self.avatarData().val('');

		self.avatarType().val('');

		self.viewport()
			.hide()
			.imgAreaSelect({remove: true});

		if(!$.isEmpty(self.options.origSource)) {
			self.frame()
				.css('background-image', $.cssUrl(self.options.origSource))
				.removeClass('avatar-frame-crop')
				.show();
		}

		if(self.options.hasAvatar) {
			self.removeFrame().show();
		}
	},

	data: function() {
		var viewport = self.viewport(),

			width  = viewport.width(),

			height = viewport.height(),

			selection =
				viewport
					.imgAreaSelect({instance: true})
					.getSelection(),

			data = {
				// id    : self.photoId().val(),
				// uid   : self.userId().val(),
				top   : selection.y1 / height,
				left  : selection.x1 / width,
				width : selection.width / width,
				height: selection.height / height
			};

		return data;
	},

	'{gallery} click': function() {
		self.galleryList().toggle();
	},

	'{galleryItem} click': function(el, event) {
		// If this item is not previously selected then only we proceed
		if(!el.hasClass('active')) {


			// Get the id
			var id = el.data('id');

			// Remove all other item selected state
			self.galleryItem().removeClass('active');

			// Set this item as selected
			el.addClass('active');

			// Set state to false
			self.state = false;

			// Show the loader
			self.toggleLoader();

			// Hide the previous picture
			self.frame().hide();

			// Hide the file upload field
			self.file().hide();

			// Clear the file input
			self.file().val('');
			self.file().parents('.input-group').find(':text').val('');

			// Hide the error frame
			self.clearError();

			// Set the type as gallery
			self.avatarType().val('gallery');

			// Set the source id
			self.avatarSource().val(id);

			// Get the avatar source
			EasySocial.ajax('fields/user/avatar/loadDefault', {
				"avatarId": id
			}).done(function(uri) {

				// Set the image preview
				self.frame().css('background-image', 'url(' + uri + ')');

				// Show the image
				self.frame().show();

				// Remove crop class
				self.frame().removeClass('avatar-frame-crop');

				// Hide the loader
				self.toggleLoader();

				// Hide the viewport
				self.viewport().hide();

				// Remove the imgareaselect from viewport
				self.viewport().imgAreaSelect({remove: true});

				// Hide the actions
				self.actions().hide();

				// Hide the note
				self.note().hide();

				// Show the file upload field
				self.file().show();

				// Show the revert button
				self.revertFrame().show();

				// Hide the remove button
				self.removeFrame().hide();

				// Set state to true
				self.state = true;
			});
		}
	},

	'{remove} click': function() {
		self.avatarType().val('remove');

		self.frame().css('background-image', $.cssUrl(self.options.defaultAvatar));

		self.removeFrame().hide();

		if(self.options.hasAvatar) {
			self.revertFrame().show();
		}

		self.state = false;
	},

	'{revert} click': function() {
		self.avatarType().val('');

		self.frame().css('background-image', $.cssUrl(self.options.origSource));

		if(self.options.hasAvatar) {
			self.removeFrame().show();
		}

		self.revertFrame().hide();

		self.galleryItem().removeClass('active');

		self.state = true;
	},

	'{self} onSubmit': function(el, event, register) {
		if(self.options.required) {
			if(!self.state) {

				if (!opts.error) {
					self.initErrorOpts();
				}

				self.raiseError(opts.error.empty);
			}

			register.push(self.state);
		}

		// If the user just uploaded avatar image without adjust any crop image
		// We need to manually capture the current default cropping area from the image
		if (!self.hasAdjustedCropImage) {

			var data = self.data();
			var string = JSON.stringify(data);

			// pass back this data into avatar field hidden input
			self.avatarData().val(string);
		}
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	}
}
});

module.resolve();
});

});
			EasySocial.module('apps/fields/user/avatar/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Avatar.Sample', {
        defaultOptions: {
            '{upload}': '[data-avatar-upload]',

            '{gallery}': '[data-avatar-gallery]',

            '{galleryTitle}': '[data-avatar-gallery-title]',

            '{galleryButton}': '[data-avatar-gallery-button]',

            '{gallerySelection}': '[data-avatar-gallery-selection]'
        }
    }, function(self) {
        return {
            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'upload':
                        self.upload().toggle(value);
                    break;

                    case 'gallery':
                        self.gallery().toggle(value);
                    break;

                    case 'use_gallery_button':
                        self.galleryButton().toggle(value);

                        self.gallerySelection().toggle(!value);

                        self.galleryTitle().toggle(!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/checkbox/content', function($) {

var module = this;

EasySocial.Controller('Field.Checkbox', {
    defaultOptions: {
        required: false,
        "{item}": "[data-field-checkbox-item]",
        "{field}": "[data-field-checkbox]"
    }
}, function(self, opts, base) { return {
    init : function() {
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    validateInput : function() {
        self.clearError();

        if(self.options.required && self.item(':checked').length == 0) {
            self.raiseError();
            return false;
        }

        return true;
    },

    raiseError: function() {
        self.trigger('error', [opts.error.empty]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    "{self} onSubmit": function(el, event, register) {
        register.push(self.validateInput());
        return;
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/checkbox/sample_content', function($) {
    var module  = this;

    EasySocial.Controller('Field.Checkbox.Sample', {
        defaultOptions: {
            '{checkboxes}'	: '[data-checkboxes]',
            '{checkbox}'	: '[data-checkbox]',
            '{sample}'		: '[data-sample-checkboxes] > [data-sample-checkbox]',
            '{checkboxInput}' : '[data-checkbox-input]',
            '{checkboxTitle}' : '[data-checkbox-title]'
        }
    }, function(self) {
        return {
            init: function() {
            },

            '{self} onChoiceTitleChanged': function(el, event, index, data) {

                self.checkboxTitle().eq(index).text(data);
            },

            '{self} onChoiceValueChanged': function(el, event, index, data) {
                self.checkboxInput().eq(index).val(data);
            },

            '{self} onChoiceAdded': function(el, event, index, data) {

				var sample = self.sample().clone();

				sample.removeData('data-sample-checkbox');
				sample.removeAttr('data-sample-checkbox');

				sample.attr('data-checkbox','');
				sample.data('data-checkbox','');

                if(self.checkbox().eq(index).length > 0) {
                    self.checkbox().eq(index).before(sample);
                } else {
                    self.checkboxes().append(sample);
                }
            },

            '{self} onChoiceRemoved': function(el, event, index) {
                self.checkbox().eq(index).remove();
            },

            '{self} onChoiceToggleDefault': function(el, event, index, value) {
                var element = self.checkboxInput().eq(index);

                if(value) {
                    element.prop('checked', true);
                } else {
                    element.prop('checked', false);
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/country/content', function($) {

var module = this;

EasySocial
.require()
.library('textboxlist')
.done(function() {
	
EasySocial.Controller('Field.Country', {
	defaultOptions: {
		fieldname: '',
		required: false,
		id: null,
		min: null,
		max: null,
		selecttype: 'textboxlist',

		'{field}': '[data-field-country]',
		'{inputTextboxlist}': '[data-country-select-textboxlist]',
		'{inputMultilist}': '[data-country-select-multilist]',
		'{inputCheckbox}': '[data-country-select-checkbox]',
		'{inputCheckboxes}': '[data-country-select-checkbox] input',
		'{inputDropdown}': '[data-country-select-dropdown]'
	}
}, function(self, opts, base) { return {
	init: function() {
		opts.max = self.field().data('max');
		opts.min = self.field().data('min');
		opts.selecttype = self.field().data('select-type');

		if (opts.selecttype === 'textboxlist') {
			
			EasySocial.module('field.country/' + self.options.id).done(function(data) {
				self.inputTextboxlist().textboxlist({
					component: 'es',
					name: self.options.fieldname + '[]',
					max: self.options.max < 1 ? null : self.options.max,
					plugin: {
						autocomplete: {
							exclusive: true,
							query: data
						}
					}
				});
			});
		}

		// Initialize error
		var data = self.field().htmlData();
		opts.error = data.error;
	},

	'{inputMultilist} change': function(el, ev) {
		if (self.options.max > 0 && el.val().length > self.options.max) {
			el.val(self.lastValidSelection ? self.lastValidSelection : '');
			return false;
		}

		self.lastValidSelection = el.val();

		self.validateInput();
	},

	'{inputCheckboxes} change': function(el, ev) {
		var count = self.inputCheckboxes(':checked').length;

		if (self.options.max > 0 && count > self.options.max) {
			el.removeAttr('checked');
			return false;
		}

		self.validateInput();
	},

	'{inputDropdown} change': function() {
		self.validateInput();
	},

	'{inputTextboxlist} listChange': function() {
		console.log('list changed');
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var items = null;

		if (self.options.selecttype === 'textboxlist') {
			items = self.inputTextboxlist().controller('textboxlist').getAddedItems();
		}

		if (self.options.selecttype === 'multilist') {
			items = self.inputMultilist().val();
		}

		if (self.options.selecttype === 'checkbox') {
			items = self.inputCheckboxes(':checked');
		}

		if (self.options.selecttype === 'dropdown') {
			var value = self.inputDropdown().val();

			if (!$.isEmpty(value)) {
				items = [value];
			}
		}

		var count = items ? items.length : 0;

		// If it is not required and no selection is made, then we pass this check.
		// If there is selection made, then we have to check against the minimum and maximum count
		if (!self.options.required && count === 0) {
			return true;
		}

		if (self.options.required && count < 1) {
			self.raiseError(opts.error.required);
			return false;
		}

		if (self.options.min > 0 && count < self.options.min) {
			self.raiseError(opts.error.min);
			return false;
		}

		if (self.options.max > 0 && count > self.options.max) {
			self.raiseError(opts.error.max);
			return false;
		}

		return true;
	},

	clearError: function() {
		self.trigger('clear');
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();

});
});			EasySocial.module('apps/fields/user/country/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Country.Sample', {
        defaultOptions: {
            '{inputGeneral}'        : '[data-country-select]',

            '{inputTextboxlist}'    : '[data-country-select-textboxlist]',

            '{inputMultilist}'      : '[data-country-select-multilist]',

            '{inputCheckbox}'       : '[data-country-select-checkbox]',

            '{inputDropdown}'       : '[data-country-select-dropdown]',

            '{maxMessage}'          : '[data-country-max-message]',

            '{maxCount}'            : '[data-country-max-count]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, ev, name, value) {
                switch(name) {
                    case 'select_type':
                        self.inputGeneral().hide();

                        if(value === 'textboxlist') {
                            self.inputTextboxlist().show();
                        }

                        if(value === 'multilist') {
                            self.inputMultilist().show();
                        }

                        if(value === 'checkbox') {
                            self.inputCheckbox().show();
                        }

                        if(value === 'dropdown') {
                            self.inputDropdown().show();
                        }
                        break;

                    case 'multilist_size':
                        self.inputMultilist().attr('size', value);
                        break;

                    case 'show_max_message':
                        self.maxMessage().toggle(!!value);
                        break;

                    case 'max':
                        self.maxCount().text(value);
                        break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/cover/content', function($) {

var module = this;

EasySocial
.require()
.library('image')
.done(function() {

EasySocial.Controller('Field.Cover', {
	defaultOptions: {
		id: 0,
		group: null,
		required: false,
		hasCover: true,
		defaultCover: null,

		ratio: 3,

		'{field}': "[data-field-cover]",
		'{image}': '[data-field-cover-image]',

		'{data}': '[data-field-cover-data]',
		'{position}': '[data-field-cover-position]',
		'{file}': '[data-field-cover-file]',

		'{note}': '[data-field-cover-note]',
		'{error}': '[data-field-cover-error]',

		'{removeButton}': '[data-field-cover-remove-button]',
		'{browseButton}': '[data-browse-cover]',

		'{revertFrame}' : '[data-field-cover-revert]',
		'{revertButton}': '[data-field-cover-revert-button]'
	}
}, function(self, opts, base) { return {
	init : function() {
		self.setFrame();

		self.setLayout();

		self.origCover = self.options.hasCover ? $.uri(self.image().css('backgroundImage')).extract(0) : null;

		self.origPosition = self.options.hasCover ? self.image().css('backgroundPosition') : null;
		
		self.state = !!self.options.hasCover;
	},

	initErrorOpts: function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	state: true,

	"{self} onRender": function() {
		self.initErrorOpts();
	},

	'{self} onShow': function() {
		setTimeout(function() {
			self.setLayout();
		}, 1);
	},

	setFrame: function() {
		var frameWidth = self.image().width(),
			frameHeight = frameWidth / self.options.ratio;

		self.image().css('height', frameHeight);
	},

	'{window} resize': $.debounce(function() {
		self.setFrame();
	}, 250),

	imageLoaders: {},

	toggleLoader: function() {
		isLoading = self.browseButton().hasClass('is-loading');
		self.browseButton().toggleClass('is-loading', !isLoading);
	},

	'{file} change' : function( el , event ) {
		if($.isEmpty(el.val())) {
			return;
		}

		var label = el.val().replace(/\\/g, '/').replace(/.*\//, '');

		el.parents('.input-group').find(':text').val(label);

		// Set state to false
		self.state = false;

		// Show the loader
		self.toggleLoader();

		self.error().hide();

		self.image().hide();

		self.note().hide();

		self.file().hide();

		EasySocial.ajax( 'fields/' + self.options.group + '/cover/upload' , {
			id: self.options.id,
			files: el
		}, {
			type: 'iframe'
		}).done(function(result){

			var resultString = JSON.stringify(result);

			// Set the result in a string format
			self.data().val(resultString);

			var positionString = JSON.stringify({
				x: 0.5,
				y: 0.5
			});

			// Set the position in string format defaulting to 50 50
			self.position().val(positionString);

			// Set the position to 50 50 by default
			self.position().val()

			var url = result.large.uri,
				imageLoaders = self.imageLoaders,
				imageLoader = (imageLoaders[url] || (imageLoaders[url] = $.Image.get(url))).done(function(image) {
					self.setLayout.image = image;

					self.file().show();

					self.image().show();

					self.note().show();

					self.toggleLoader();

					self.revertFrame().hide();

					self.removeButton().show();

					self.setCover(result.large.uri);
				});

			// Set state to true
			self.state = true;

		}).fail(function(msg) {

			self.toggleLoader();

			self.file().show();

			self.error().show().html(msg);
		});
	},

	setLayout: function() {
		var cover = self.image(),
			image = self.setLayout.image;

		if(!image) {
			var url = $.uri(cover.css('backgroundImage')).extract(0);

			if(!url) return;

			var imageLoaders = self.imageLoaders,
				imageLoader =
					(imageLoaders[url] || (imageLoaders[url] = $.Image.get(url)))
						.done(function(image) {

							// Set it as current image
							self.setLayout.image = image;

							// Then set layout again
							self.setLayout();
						});

				return;
		}

		var imageWidth = image.data("width"),
			imageHeight = image.data("height"),
			coverWidth = cover.width(),
			coverHeight = cover.height(),
			size = $.Image.resizeProportionate(
				imageWidth, imageHeight,
				coverWidth, coverHeight,
				"outer"
			);

		self.availableWidth = coverWidth - size.width;
		self.availableHeight = coverHeight - size.height;

		self.setFrame();		
	},

	setCover: function(url, position) {
		position = position || '50% 50%';

		self.image()
			.css({
				backgroundImage: $.cssUrl(url),
				backgroundPosition: position
			});

		self.setLayout();

		self.image().addClass('cover-move');

		self.note().show();
	},

	x: 0.5,
	y: 0.5,

	moveCover: function(dx, dy, image) {

		if (!image) {
			image = self.image();
		}

		var w = self.availableWidth,
			h = self.availableHeight,
			x = (w==0) ? 0 : self.x + ((dx / w) || 0),
			y = (h==0) ? 0 : self.y + ((dy / h) || 0);

		// Always stay within 0 to 1.
		if (x < 0) x = 0; if (x > 1) x = 1;
		if (y < 0) y = 0; if (y > 1) y = 1;

		// Set position on cover
		image.css("backgroundPosition",
			((self.x = x) * 100) + "% " +
			((self.y = y) * 100) + "% "
		);

		var position = {
			x: self.x,
			y: self.y
		}

		self.position().val(JSON.stringify(position));
	},

	'{image} mousedown': function(selection, event) {
		if (event.target === self.image()[0]) {
			event.preventDefault();
		}

		// Initial cover position
		var image = self.image(),
			position = image.css("backgroundPosition").split(" ");
			self.x = parseInt(position[0]) / 100;
			self.y = parseInt(position[1]) / 100;

		// Initial cursor position
		var x = event.pageX,
			y = event.pageY;

		$(document)
			.on("mousemove.movingCover mouseup.movingCover", function(event) {

				self.moveCover(
					(x - (x = event.pageX)) * -1,
					(y - (y = event.pageY)) * -1,
					image
				);
			})
			.on("mouseup.movingCover", function() {

				$(document).off("mousemove.movingCover mouseup.movingCover");
			});
	},

	'{removeButton} click': function(el) {
		var data = self.data().val();

		if($.isEmpty(data)) {
			if(self.options.hasCover) {
				self.setCover(self.options.defaultCover);

				// Mark the data as delete

				self.data().val('delete');

				el.hide();

				self.revertFrame().show();
			}
		} else {
			// Backup the data first
			self.origData = data;
			self.origPosition = self.position().val();

			self.data().val('');
			self.position().val('');
			self.file().val('');
			self.file().parents('.input-group').find(':text').val('');

			if(self.options.hasCover) {
				self.setCover(self.origCover);
			} else {
				self.setCover(self.options.defaultCover);

				// Mark the data as delete
				self.data().val('delete');

				el.hide();
			}
		}

		self.state = false;
	},

	'{revertButton} click': function() {
		self.setCover(self.origCover, self.origPosition);

		self.revertFrame().hide();

		self.removeButton().show();

		self.data().val('');

		self.position().val('');

		self.file().val('');
		self.file().parents('.input-group').find(':text').val('');

		self.state = true;
	},

	'{self} onSubmit': function(el, event, register) {
		
		var data = self.data().val();
		var hasCover = self.options.hasCover;

		// if the value show delete mean it remove that cover before submit
		// need to handle this from the edit switch profile as well
		if (data == 'delete') {
			var data = '';
			var hasCover = false;
		}

		if (self.options.required && !hasCover && $.isEmpty(data)) {
			
			if (!self.state) {

				if (!opts.error) {

					self.initErrorOpts();
				}

				self.raiseError(opts.error.empty);
			}

			register.push(self.state);
		}
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/currency/content', function($) {
var module = this;

EasySocial.Controller('Field.Currency', {
	defaultOptions: {
		required: false,
		'{field}': '[data-field-currency]',
		'{dollarInput}': '[data-currency-dollar]',
		'{centInput}': '[data-currency-cent]'
	}
}, function(self, opts, base) { return {

	init: function() {
		console.log('init');
	},

	'{self} onRender': function() {
		var data = self.field().htmlData();
		opts.error = data.error || {};
	},

	'{dollarInput} keyup': function() {
		self.validateInput();
	},

	'{dollarInput} blur': function() {
		self.validateInput();
	},

	'{centInput} keyup': function() {
		self.validateInput();
	},

	'{centInput} blur': function() {
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var dollar = self.dollarInput().val();
		var cent = self.centInput().val()

		if (self.options.required && ($.isEmpty(dollar) || $.isEmpty(cent))) {
			self.raiseError(opts.error.required);
			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},


	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/datetime/content', function($) {

var module = this;

EasySocial.require()
.library('datetimepicker', 'chosen', 'moment/' + EasySocial.options.momentLang)
.done(function($){

EasySocial.Controller('Field.Datetime', {
	defaultOptions: {
		required: false,
		calendarDateFormat: null,
		yearfrom: null,
		yearto: null,
		date: null,
		lang: null,

		allowTime: false,
		allowTimezone: false,
		ageLimit: null,

		calendarLanguage: 'english',

		'{field}': '[data-field-datetime]',
		'{date}': '[data-field-datetime-select]',
		'{dateValue}': '[data-field-datetime-value]',
		'{timezone}': '[data-field-datetime-timezone]',
		'{form}': '[data-field-datetime-form]',
		'{icon}': '[data-field-datetime-icon]',
		'{clearButton}': '[data-clear]',
	}
}, function(self, opts, base) { return {

	init : function() {
		// self.legacyInit();

		self.options.yearfrom = self.options.yearfrom || 1930;

		// There is an issue with yearto where if I set yearto = 2014, I won't be able to select 2014 dates. This is a bug in datetimepicker. Currently, temporarily, we manually add 1 to the value if there are value set.
		if (!$.isEmpty(self.options.yearto)) {
			self.options.yearto = parseInt(self.options.yearto) + 1;
		} else {
			self.options.yearto = new Date().getFullYear() + 100
		}

		self.date()._datetimepicker({
			component: "es",
			format: self.options.calendarDateFormat,
			minDate: self.options.yearfrom + '-01-01',
			maxDate: self.options.yearto + '-12-31',
			icons: {
				time: 'far fa-clock',
				date: 'fa fa-calendar',
				up: 'fa fa-chevron-up',
				down: 'fa fa-chevron-down'
			},
			sideBySide: false,
			pickTime: self.options.allowTime,
			useCurrent: false,
			language: self.options.calendarLanguage == 'english' ? 'en-gb' : EasySocial.options.momentLang
		});

		// date value should always be in mysql datetime format
		// YYYY-MM-DD HH:MM:SS
		self.options.date = self.dateValue().val();

		// If there is a date value, then we set it into the datetimepicker
		if (!$.isEmpty(self.options.date)) {
			// Datetimepicker is using moment.js, hence here we manually create a moment object to pass in instead of passing in date time string
			// This is because datetimepicker.setDate function passes along the format from self.options.calendarDateFormat to generate the date object, which will render moment.js to generate an invalid dateobject
			// self.options.calendarDateFormat is only for display purposes
			// Raw date object is always in SQL format
			var dateObj = $.moment(self.options.date);

			self.datetimepicker('setDate', dateObj);
			// self.setDateValue(dateObj);
		}

		if (self.options.allowTimezone) {
			self.timezone().chosen({
				search_contains: true
			});
		}
	},

	initErrorData: function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	"{self} onRender": function() {
		self.initErrorData();
	},

	'{icon} click': function() {
		self.datetimepicker('show');
	},

	'{date} dp.change': function(el, ev) {
		self.setDateValue(ev.date.toDate());

		self.form().addClass('has-datetime');

		// Custom hack to ensure that the input box is really blurred
		if (!self.options.allowTime) {
			self.date().blur();
		}

		self.validateCalendar();
	},

	// Alias method to call the datetimepicker instance
	datetimepicker: function(method, value) {
		return self.date().data('DateTimePicker')[method](value);
	},

	setDateValue: function(date) {
		// Convert the date object into sql format and set it into the input
		self.dateValue().val(date.getFullYear() + '-' +
							('00' + (date.getMonth()+1)).slice(-2) + '-' +
							('00' + date.getDate()).slice(-2) + ' ' +
							('00' + date.getHours()).slice(-2) + ':' +
							('00' + date.getMinutes()).slice(-2) + ':' +
							('00' + date.getSeconds()).slice(-2));
	},

	'{date} blur': function() {
		self.validateCalendar();
	},

	validateCalendar: function() {
		self.clearError();

		if(self.options.required && $.isEmpty(self.dateValue().val())) {

			if (!opts.error) {
				self.initErrorData();
			}

			self.raiseError(opts.error.empty);
			return false;
		}

		// Check for age limit
		return self.validateAge()
			.done(function() {
				self.clearError();
			})
			.fail(function(msg) {
				self.raiseError(msg);
			});
	},

	validateAge: function() {
		return EasySocial.ajax('fields/user/birthday/isValid', {
			value: self.dateValue().val(),
			age_limit: opts.ageLimit
		});
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	"{self} onSubmit" : function(el, event, register) {
		register.push(self.validateCalendar());
		return;

	},

	'{clearButton} click': function(el, ev) {
		self.form().removeClass('has-datetime');

		self.datetimepicker('setValue', new $.moment());

		self.date().val('');

		self.dateValue().val('');
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/datetime/display_content', function($) {

var module = this;

EasySocial.require()
.library('popbox', 'chosen')
.done(function($) {

EasySocial.Controller('Field.Datetime.Display', {
    defaultOptions: {
        userid: null,
        date: null,
        timezone: null,
        local: null,

        '{toggle}': '[data-popbox]',
        '{content}': '[data-popbox-content]',
        '{date}': '[data-date]',
        '{timezone}': '[data-timezone]',
        '{loading}': '[data-loading]'
    }
}, function(self, opts, base) { return {
    init: function() {
        self.options.timezone = self.timezone().data('timezone');

        self.options.date = self.date().data('date-utc');

        // Set the selected timezone with the displayed date
        self.datetime(self.options.timezone, self.date().html());

        // Get the local timezone first through client browser
        self.options.local = -new Date().getTimezoneOffset()/60;

        var content = self.content().html(),
            position = self.toggle().data('popbox-position');

        self.toggle().popbox({
            content: content,
            id: 'fd',
            component: 'es',
            type: 'timezone',
            toggle: 'click',
            position: position
        }).attr('data-popbox', '');
    },

    '{toggle} popboxActivate': function(el, event, popbox) {
        $(popbox.tooltip).addController('EasySocial.Controller.Field.Datetime.Display.Timezone', {
            '{parent}': self
        });
    },

    data: {},

    datetime: function(tz, value) {
        // Getter
        if (value === undefined) {
            var dfd = $.Deferred();

            if (self.data[tz] === undefined) {
                self.loading().show();

                EasySocial.ajax('fields/user/datetime/getDatetime', {
                    id: self.options.id,
                    userid: self.options.userid,
                    tz: tz,
                    local: self.options.local,
                    datetime: self.options.date
                }).done(function(datetime) {

                    self.loading().hide();

                    dfd.resolve(self.datetime(tz, datetime));
                });
            } else {
                dfd.resolve(self.data[tz]);
            }

            return dfd;
        }

        // Setter
        self.data[tz] = value;
        return value;
    },

    showDatetime: function(tz, datetime) {
        if (tz === 'local') {
            tz = opts.message.local;
        }

        self.timezone().html(tz);
        self.date().html(datetime);
    }
}});

EasySocial.Controller('Field.Datetime.Display.Timezone', {
    defaultOptions: {
        '{timezones}': '[data-timezone-select]',
        '{reset}': '[data-timezone-reset]',
        '{local}': '[data-timezone-local]'
    }
}, function(self, opts, bae) { return {
    init: function() {
        self.timezones().chosen({
            search_contains: true
        });
    },

    '{timezones} change': function(el, event) {
        var key = el.val();

        self.parent.date().hide();
        self.parent.timezone().hide();

        self.parent.datetime(key).done(function(value) {
            self.parent.showDatetime(key, value);

            self.parent.date().show();
            self.parent.timezone().show();
        });
    },

    '{reset} click': function() {
        self.setTimezone(self.parent.options.timezone);
    },

    '{local} click': function() {
        self.setTimezone('local')
    },

    setTimezone: function(tz) {
        self.timezones()
            .val(tz)
            .trigger('liszt:updated')
            .trigger('change');
    }
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/datetime/dropdown', function($) {

var module = this;

EasySocial.Controller('Field.Datetime.Dropdown', {
	defaultOptions: {
		required: false,
		allowTime: false,
		allowTimezone: false,
		yearfrom: null,
		yearto: null,
		ageLimit: null,

		'{dateValue}': '[data-field-datetime-value]',

		'{year}': '[data-field-datetime-year]',
		'{month}': '[data-field-datetime-month]',
		'{day}': '[data-field-datetime-day]',

		'{hour}': '[data-field-datetime-hour]',
		'{minute}': '[data-field-datetime-minute]',
		'{ampm}': '[data-field-datetime-ampm]',

		'{dayLabel}': '[data-datetime-day-label]'
	}
}, function(self, opts) { return {

	init: function() {
		self.checkDate();
	},

	'{year} change': function(el, ev) {
		self.setValue();
		self.checkDate();

		// trigger month change to get the correct day of the month
		self.month().trigger('change');
	},

	'{month} change': function(el, ev) {
		// If year and month is provided, then we need to find the max day
		var year = self.year().val(),
			month = self.month().val();

		// get the day label
		var dayLabel = self.dayLabel().text();

		if (year !== '' && month !== '') {
			var maxDay = new Date(year, month, 0).getDate();

			// See if there are days originally selected
			var day = self.day().val();

			if (day !== '') {
				// If day value is more than current month maxday, then we use maxday
				day = Math.min(day, maxDay);
			}

			self.day().empty();

			self.day().append('<option value="">' + dayLabel + '</option>');

			for (i = 1; i <= maxDay; i++) {
				$('<option value="' + i + '">' + i + '</option>').appendTo(self.day());
			}

			// Set back the original value
			if (day !== '') {
				self.day().val(day);
			}
		}

		self.setValue();

		self.checkDate();
	},

	'{day} change': function(el, ev) {
		self.setValue();
		self.checkDate();
	},

	'{hour} change': function(el, ev) {
		self.setValue();
	},

	'{minute} change': function(el, ev) {
		self.setValue();
	},

	'{ampm} change': function(el, ev) {
		self.setValue();
	},

	checkDate: function() {

		self.clearError();

		var year = self.year().val();
		var month = self.month().val();
		var day = self.day().val();

		if ((year == '' || month == '' || day == '') && opts.required) {

			self.raiseError();
			return false;
		}

		return self.validate()
			.done(function() {
				self.clearError();
			})
			.fail(function(msg) {
				self.raiseError(msg);
			});
	},

	validate: function() {
		return EasySocial.ajax('fields/user/birthday/isValid', {
			value: self.dateValue().val(),
			age_limit: opts.ageLimit
		});
	},

	setValue: function() {
		var string;

		var year = self.year().val();
		var month = self.month().val();
		var day = self.day().val();

		if (year !== '' && month !== '' && day !== '') {
			string = year + '-' + month + '-' + day;

			if (self.options.allowTime) {
				var hour = self.hour().val(),
					minute = self.minute().val();

				// If there is ampm, then we need to readjust the time a little bit
				if (hour !== '' && self.ampm().length > 0 && self.ampm().val() == 'pm') {
					hour = (parseInt(hour) + 12).toString();

					if (hour === '24') {
						hour = '0';
					}
				}

				if (minute === '') {
					minute = '00';
				}

				string += ' ' + ('00' + hour).slice(-2) + ':' + ('00' + minute).slice(-2) + ':00';
			}

			self.dateValue().val(string);
		}
	},

	"{self} onSubmit": function(element, event, register, mode) {
		register.push(self.checkDate());
	},

	clearError: function() {
		self.trigger('clear');
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/datetime/sample_content', function($) {
    var module = this;

    EasySocial.require().library('ui/datepicker').done(function() {
        EasySocial.Controller('Field.Datetime.Sample', {
            defaultOptions: {
                '{yearPrivacy}'     : '[data-yearprivacy]',

                '{input}'           : '[data-field-datetime-select]',

                '{timezone}'        : '[data-field-datetime-timezone]'
            }
        }, function(self) {
            return {
                init: function() {
                },

                '{self} onConfigChange': function(el, event, name, value) {
                    switch(name) {
                        case 'year_privacy':
                            self.yearPrivacy().toggle(value);
                        break;

                        case 'allow_timezone':
                            self.timezone().toggle(value);
                        break;

                        case 'placeholder':
                            self.input().attr('placeholder', value);
                        break;
                    }
                }
            }
        });

        module.resolve();
    });
});
			EasySocial.module('apps/fields/user/dropdown/content', function($) {
var module = this;

EasySocial.Controller('Field.Dropdown', {
	defaultOptions: {
		required: null,
		"{field}": "[data-field-dropdown]",
		"{item}": "[data-field-dropdown-item]",
		"{option}": "[data-field-dropdown-item] option"
	}
}, function(self, opts, base) { return {

	validateInput : function() {
		self.clearError();

		if(self.options.required && $.isEmpty(self.item().val())) {
			self.raiseError();
			return false;
		}

		return true;
	},

	"{self} onRender": function() {
		var data = self.field().htmlData();
		opts.error = data.error || {};
	},

	raiseError: function() {
		self.trigger('error', [opts.error.empty]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	"{self} onSubmit": function(el, event, register) {
		// If field is not required, skip the checks.

		if(!self.options.required)
		{
			register.push(true);
			return;
		}

		register.push(self.validateInput());

		return;
	},

	'{self} onChoiceAdded': function(el, event, index) {
		if(self.option().eq(index).length > 0) {
			self.option().eq(index).before($('<option></option>'));
		} else {
			self.item().append($('<option></option>'));
		}
	},

	'{self} onChoiceValueChanged': function(el, event, index, value) {
		self.option().eq(index).val(value);
	},

	'{self} onChoiceTitleChanged': function(el, event, index, value) {
		self.option().eq(index).text(value);
	},

	'{self} onChoiceRemoved': function(el, event, index) {
		self.option().eq(index).remove();
	},

	'{self} onChoiceToggleDefault': function(el, event, index, value) {
		self.option().removeAttr('selected');

		if(value) {
			self.option().eq(index).attr('selected', 'selected');
		}
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/email/content', function($) {

var module = this;

EasySocial.Controller('Field.Email', {
    defaultOptions: {
        required: false,
        regex: 0,
        regexFormat: '',

        regexModifier: '',

        "{field}": "[data-field-email]",
        "{input}": "[data-field-email-input]"
    }
}, function(self, opts, base) { return {

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    validateInput: function() {
        var value   = self.input().val();

        if(self.options.required && $.isEmpty(value)) {
            self.raiseError(opts.error.required);
            return false;
        }

        if(!$.isEmpty(value) && self.options.regex) {
            var regex = new RegExp(self.options.regexFormat, self.options.regexModifier);

            if(!regex.test(value)) {
                self.raiseError(opts.error.invalid);
                return false;
            }
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    "{self} onSubmit": function(el, event, register) {

        register.push(self.validateInput());

        return;
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/file/content', function($) {

var module = this;

EasySocial.require()
.library('ui/sortable')
.done(function($) {

EasySocial.Controller('Field.File', {
	defaultOptions: {
		required: false,
		id: null,
		inputName: '',
		maxFile: 0,

		'{field}': '[data-field-file]',
		'{list}': '[data-field-file-list]',
		'{item}': '[data-field-file-item]',
		'{add}': '[data-field-file-add]',

		// file items
		'{dragPlaceholder}': '.data-field-file-item-drag',
		'{moveHandle}': '[data-field-file-move]'

	}
}, function(self, opts, base) { return {
		
	init: function() {

		var data = self.field().htmlData();

		opts.error = data.error || {};
		opts.message = data.message || {};

		opts.maxFile = self.field().data('maxfile');

		self.item().addController('EasySocial.Controller.Field.File.Item', {
			parent: self,
			message: opts.message,
			error: opts.error
		});

		self.initSortable();
	},

	initSortable: function() {
		self.list().sortable({
			items: self.item.selector,
			placeholder: 'data-field-file-item-drag',
			handle: self.moveHandle.selector,
			forcePlaceholderSize: true,
			start: function(event, ui) {
				self.dragPlaceholder().width(ui.item.find('.file-wrap').width());
			}
		})
	},

	'{add} click': function(el, ev) {
		if(self.options.maxFile < 1 || (self.item().length < self.options.maxFile)) {
			var key = self.item().length;

			var item = $('<div class="data-field-file-item" data-field-file-item></div>');

			item.data('key', key);

			item.html(opts.message.working);

			item.addController('EasySocial.Controller.Field.File.Item', {
				parent: self,
				message: opts.message,
				error: opts.error
			});

			self.list().append(item);

			EasySocial.ajax('fields/user/file/getUploadHtml', {
				id: self.options.id,
				key: key
			}).done(function(html) {
				item.html(html);
			});

			if(self.options.maxFile > 1 && self.item().length >= self.options.maxFile) {
				el.hide();
			}
		}
	},

	'{item} uploadDone': function() {
		self.add().click();
	}
}});

EasySocial.Controller('Field.File.Item', {
	defaultOptions: {
		required: false,
		key: null,

		'{upload}' : '[data-field-file-upload]',
		'{progress}' : '[data-field-file-progress]',
		'{delete}' : '[data-field-file-delete]',
		'{clear}' : '[data-field-file-clear]',
		'{id}' : '[data-field-file-id]',
		'{tmp}' : '[data-field-file-tmp]'
	}
}, function(self, opts, base) { return {
	init: function() {
		opts.key = self.element.data('key');
	},

	'{upload} change': function(el, ev) {
		self.element.html(opts.message.working);

		EasySocial.ajax('fields/user/file/upload', {
			id: opts.parent.options.id,
			files: el,
			key: self.options.key
		}, {
			type: 'iframe'
		}).done(function(html) {
			self.element.html(html);

			self.trigger('uploadDone');
		}).fail(function(msg) {
			self.element.html(msg || self.getErrorMsg());
		});
	},

	'{delete} click': function(el, ev) {
		var tmp = self.tmp().val();
		var id = self.id().val();

		self.element.html(opts.message.working);

		EasySocial.ajax('fields/user/file/delete', {
			id: opts.parent.options.id,
			key: self.options.key,
			tmp: tmp,
			fileid: id
		}).done(function(html) {
			self.element.html(html);

			self.trigger('fileDeleted');
		}).fail(function(msg) {
			self.element.html(msg || self.getErrorMsg());
		});
	},

	'{clear} click': function(el, ev) {
		self.element.html(opts.message.working);

		EasySocial.ajax('fields/user/file/getUploadHtml', {
			id: opts.parent.options.id,
			key: self.options.key
		}).done(function(html) {
			self.element.html(html);
		});
	},

	getErrorMsg: function() {
		msg = $('<span class="alert field-file-error">' + opts.error.unknown + '<button class="close" type="button" data-field-file-clear></button></span>');

		return msg;
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/file/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.File', {
        defaultOptions: {
            '{sizeText}': '[data-field-file-size-text]',

            '{size}': '[data-field-file-size]',

            '{add}': '[data-field-file-add]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, ev, name, value) {
                switch(name) {
                    case 'size_limit':
                        self.size().text(value);
                        break;

                    case 'show_size_limit':
                        self.sizeText().toggle(!!value);
                        break;

                    case 'file_limit':
                        self.add().toggle((value < 1 || value > 1));
                        break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/gender/content', function($) {
var module = this;

EasySocial.Controller('Field.Gender', {
    defaultOptions: {
        required: false,
        '{field}': '[data-field-gender]',
        '{selection}': '[data-field-gender-select]'
    }
}, function(self, opts, base) { return {

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    validateInput: function() {
        if(!self.options.required) {
            return true;
        }

        self.clearError();

        var value = self.selection(':checked').val();

        if($.isEmpty(value))
        {
            self.raiseError();
            return false;
        }

        return true;
    },

    raiseError: function() {
        self.trigger('error', [opts.error.required]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, event, register) {
        register.push(self.validateInput());
    },

    '{selection} click': function() {
        self.validateInput();
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_email/content', function($) {

var module = this;

EasySocial.Controller('Field.Joomla_email', {
	defaultOptions: {
		required: true,
		id: null,
		userid: null,
		reconfirm: false,
		event: null,
		registration: null,

		'{field}': '[data-field-joomla_email]',
		'{input}': '[data-field-email-input]',
		'{confirm}': '[data-field-email-reconfirm-input]',
		'{confirmFrame}': '[data-field-email-reconfirm-frame]'
	}
}, function(self, opts, base) { return {
	init: function() {
		self.origEmail = self.input().val();

		// Check for input value
		value = self.input().val();

		// Registration form should always display reconfirm field
		if (opts.reconfirm && !opts.registration && value) {
			self.confirmFrame().hide();
		}
	},

	"{self} onRender": function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	'{input} blur': function(el, ev) {
		var value = self.input().val();

		if (opts.reconfirm && value !== self.origEmail) {
			self.confirmFrame().show();
		}

		if (opts.reconfirm && value === self.origEmail && (opts.event === 'onEdit' || opts.event === 'onAdminEdit')) {
			self.confirmFrame().hide();
		}

		self.validateInput();
	},

	'{confirm} blur': function(el, ev) {
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var value = self.input().val();

		if($.isEmpty(value)) {
			if(!self.options.required) {
				return true;
			}

			self.raiseError(opts.error.required);
			return false;
		}

		if(self.options.reconfirm)
		{
			var reconfirm = self.confirm().val();

			if(value !== self.origEmail && $.isEmpty(reconfirm))
			{
				self.raiseError(opts.error.reconfirmrequired);
				return false;
			}

			if(!$.isEmpty(reconfirm) && value !== reconfirm)
			{
				self.raiseError(opts.error.mismatch);
				return false;
			}
		}

		return self.checkInput()
			.done(function() {
				self.clearError();
			})
			.fail(function(msg) {
				self.raiseError(msg);
			});
	},

	checkInput: function() {
		return EasySocial.ajax('fields/user/joomla_email/isValid', {
			id: self.options.id,
			userid: self.options.userid,
			email: self.input().val()
		});
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onSubmit': function(el, ev, register, mode) {
		if (mode === 'onRegisterMini') {
			return;
		}

		register.push(self.validateInput());
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_email/registermini_content', function($) {

var module = this;

EasySocial.Controller('Field.Joomla_email.Mini', {
    defaultOptions: {
        require: true,
        id: null,

        '{field}': '[data-field-joomla_email]',
        '{input}': '#email',
        '{confirm}' : '[data-field-email-reconfirm-input]'
    }
}, function(self, opts) { return {
    init: function() {
        self.origEmail = self.input().val();

        var data = self.field().htmlData();
        opts.error = data.error || {};
    },

    '{self} onRender': function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    '{input} keyup': function(el) {
        if(el.val().length > 0) {
            self.delayedCheck();
        }
    },

    '{confirm} blur': function(el, ev) {
        self.checkEmail();
    },

    state: false,

    delayedCheck: $.debounce(function() {
        self.checkEmail();
    }, 250),

    checkEmail: function() {

        self.clearError();

        var email = self.input().val();

        if(self.options.required && email.length == 0) {
            self.raiseError(opts.error.required);
            return false;
        }

        if(!$.isEmpty(email) && self.options.regex) {
            var regex = new RegExp(self.options.regexFormat, self.options.regexModifier);

            if(!regex.test(email)) {
                self.raiseError(opts.error.format);
                return false;
            }
        }


        if (opts.reconfirm) {
            var reconfirm = self.confirm().val();

            if (email !== self.origEmail && $.isEmpty(reconfirm)) {
                self.raiseError(opts.error.reconfirmrequired);
                return false;
            }

            if (!$.isEmpty(reconfirm) && email !== reconfirm) {
                self.raiseError(opts.error.mismatch);
                return false;
            }
        }


        if(email.length > 0) {
            var state = $.Deferred();

            self.input().addClass('is-loading');

            var email = self.input().val();

            EasySocial.ajax('fields/user/joomla_email/isValid', {
                id: self.options.id,
                userid: 0,
                email: email
            }).done(function(msg) {

                state.resolve();

            }).fail(function(msg) {
                self.raiseError(msg);

                state.reject();
            }).always(function() {
                self.input().removeClass('is-loading');
            })

            return state;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register, mode) {
        if (mode !== 'onRegisterMini') {
            return;
        }

        if(self.options.required || self.input().val().length > 0) {
            register.push(self.checkEmail());
        }
    },

    setLoaded: function() {
        self.trigger('loaded');
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_email/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_email.Sample', {
        defaultOptions: {
            '{confirmEmail}'        : '[data-field-email-reconfirm-frame]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'reconfirm_email':
                        self.confirmEmail().toggle(value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_fullname/content', function($) {

var module = this;

EasySocial.Controller('Field.Joomla_fullname', {
    defaultOptions: {
        "nameFormat": 1,
        "max": 0,
        "required": true,
        '{field}': '[data-field-joomla_fullname]',
        '{firstName}': '[data-field-jname-first]',
        '{middleName}': '[data-field-jname-middle]',
        '{lastName}': '[data-field-jname-last]',
        '{name}': '[data-field-jname-name]'
    }
}, function(self, opts, base) { return {

    init : function() {
        opts.nameFormat = self.field().data('name-format');
        opts.max = self.field().data('max');

        var data = self.field().htmlData();
        opts.error = data.error || {};
    },

    "{self} onRender": function() {

        var data = self.field().htmlData();
        opts.error = data.error || {};
    },

    validateInput : function() {

        self.clearError();

        if (!opts.required) {
            return true;
        }

        // Name format
        // 1 - first, middle, last
        // 2 - last, middle, first
        // 3 - single name
        // 4 - first, last
        // 5 - last, first

        if (opts.nameFormat == 3) {

            if($.isEmpty(self.name().val())) {
                self.raiseError(opts.error.empty);
                return false;
            }

            return true;
        }

        if ($.isEmpty(self.firstName().val())) {
            self.raiseError(opts.error.empty);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    "{firstName} blur" : function(el, event) {
        self.validateInput();
    },

    "{name} blur": function(el, event) {
        self.validateInput();
    },

    "{self} onError": function(el, event, type, field) {
        self.raiseError();
    },

    "{self} onSubmit" : function(el, event, register) {
        register.push(self.validateInput());

        return;
    }
}});

module.resolve();

});
			EasySocial.module('apps/fields/user/joomla_fullname/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_fullname.Sample', {
        defaultOptions: {
            '{fullnameFormat}'      : '[data-fullname-format]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'format':
                        self.switchFormat(value);
                    break;
                }
            },

            switchFormat: function(value) {
                self.fullnameFormat().hide();

                self.fullnameFormat().eq(value - 1).show();
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_password/content', function($) {

var module = this;

EasySocial.require()
.library('passwordstrength')
.done(function(){

EasySocial.Controller('Field.Joomla_password', {
	defaultOptions: {
		event               : null,
		triggerError        : true,

		required            : false,
		passwordStrength    : false,
		reconfirmPassword   : false,
		requireOriginal     : false,

		min : 4,
		max : 0,

		minInteger: 0,
		minSymbol: 0,
		minUpperCase: 0,

		'{field}': '[data-field-joomla_password]',
		'{original}'    : '[data-field-password-orig]',
		'{input}'       : '[data-field-password-input]',
		'{reconfirm}'   : '[data-field-password-confirm]',
		'{pwResetSubmitButton}' : '[data-password-reset-submit]',
		
		'{warning}'    : '[data-field-password-warning]',
		'{reconfirmNotice}' : '[data-reconfirmPassword-failed]',

		// Password strength
		'{strength}': '[data-password-strength]'
	}
}, function(self, opts, base) { return {
	
	init: function() {
		if (opts.passwordStrength) {
			self.initPasswordStrength();
		}
	},

	"{self} onRender": function() {
		var data = self.field().htmlData();

		opts.error = data.error;
	},

	initPasswordStrength: function() {

		self.input().password_strength({
			container: self.strength.selector,
			minLength: opts.min,
			texts: {
				1: self.strength().data('message-1'),
				2: self.strength().data('message-2'),
				3: self.strength().data('message-3'),
				4: self.strength().data('message-4'),
				5: self.strength().data('message-5')
			},
			onCheck: function(level) {
				if(level <= 1) {
					self.strength()
						.removeClass('t-text--warning')
						.removeClass('t-text--success')
						.addClass('t-text--danger t-fs--sm');
				}

				if(level > 1 && level <= 3) {
					self.strength()
						.removeClass('t-text--danger')
						.removeClass('t-text--success')
						.addClass('t-text--warning t-fs--sm');
				}

				if(level >= 4) {
					self.strength()
						.removeClass('t-text--danger')
						.removeClass('t-text--warning')
						.addClass('t-text--success t-fs--sm');
				}
			}
		})
	},

	'{input} keyup': function() {
		self.validatePassword();
	},

	'{input} blur': function() {
		self.validatePassword();
	},

	'{reconfirm} keyup': function() {
		self.validatePassword();
	},

	'{reconfirm} blur': function() {
		self.validatePassword();
	},

	validatePassword: function() {
		self.clearError();

		var input = self.input().val();
		var reconfirm = self.reconfirm().val();

		if(self.options.event === 'onRegister' && !self.validatePasswordInput() ) {
			return false;
		}

		if(self.options.event === 'onEdit' && !self.validatePasswordEdit()) {
			return false;
		}

		if(self.options.reconfirmPassword && !self.validatePasswordConfirm()) {
			return false;
		}

		return true;
	},

	validatePasswordInput: function() {
		var input = self.input().val();

		if (!opts.error) {
			var data = self.field().htmlData();

			opts.error = data.error;
		}

		if($.isEmpty(input)) {
			self.raiseError(opts.error.empty);
			return false;
		}

		if(self.options.min > 0 && input.length < self.options.min) {
			self.raiseError(opts.error.min);
			return false;
		}

		if(self.options.max > 0 && input.length > self.options.max) {
			self.raiseError(opts.error.max);
			return false;
		}

		if(self.options.minInteger > 0) {
			var test = input.match(/[0-9]/g);
			if (!test || test.length < self.options.minInteger) {
				self.raiseError(opts.error.mininteger);
				return false;
			}
		}

		if(self.options.minSymbol > 0) {
			var test = input.match(/[\W]/g);
			if (!test || test.length < self.options.minSymbol) {
				self.raiseError(opts.error.minsymbols);
				return false;
			}
		}

		if(self.options.minUpperCase > 0) {
			var test = input.match(/[A-Z]/g);
			if (!test || test.length < self.options.minUpperCase) {
				self.raiseError(opts.error.minupper);
				return false;
			}
		}


		return true;
	},

	validatePasswordEdit: function() {
		var orig = self.original().val(),
			input = self.input().val();

		// If both original and input is empty, then we return true as it is not mandatory in edit
		if($.isEmpty(input) && $.isEmpty(orig)) {
			return true;
		}

		// Only original is empty
		if($.isEmpty(orig) && self.options.requireOriginal) {
			self.raiseError(opts.error.emptyoriginal);
			return false;
		}

		// Original is not empty, then we validate the new password
		return self.validatePasswordInput();
	},

	validatePasswordConfirm: function() {
		var input = self.input().val();
		var reconfirm = self.reconfirm().val();

		// Check if either input or reconfirm is not empty
		if (!$.isEmpty(input) || !$.isEmpty(reconfirm)) {
			
			if($.isEmpty(input)) {
				self.raiseError(opts.error.empty);
				return false;
			}

			if($.isEmpty(reconfirm)) {
				self.raiseError(opts.error.emptyconfirm);
				return false;
			}

			if(input !== reconfirm) {
				self.raiseError(opts.error.mismatch);
				return false;
			}
		}

		return true;
	},

	raiseError: function(msg) {
		if (self.options.triggerError) {
			self.trigger('error', [msg]);
		} else {
			self.warning().show();
			self.warning().text(msg);
		}
	},

	clearError: function() {
		if (self.options.triggerError) {
			self.trigger('clear');
		} else {
			self.warning().hide();
			self.warning().text('');
		}
	},

	"{pwResetSubmitButton} click": function() {
		return self.validatePassword();
	},

	"{self} onSubmit": function(el, event, register, mode) {

		if (mode === 'onRegisterMini') {
			return;
		}

		register.push(self.validatePassword());
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/joomla_password/registermini_content', function($) {
    var module = this;

EasySocial.Controller('Field.Joomla_password.Mini', {
    defaultOptions: {
        required: false,
        reconfirmPassword: false,
        min: 4,
        max: 0,

        '{field}': '[data-field-joomla_password]',
        '{input}': '[data-password]',
        '{reconfirm}'   : '[data-field-password-confirm]',
        '{reconfirmNotice}' : '[data-reconfirmPassword-failed]'
    }
}, function(self, opts, base) { return {

    init: function() {

        var data = self.field().htmlData();
        opts.error = data.error || {};
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error;
    },

    '{input} keyup': function() {
        self.checkPassword();
    },

    '{reconfirm} keyup': function() {
        self.validatePassword();
    },

    '{reconfirm} blur': function() {
        self.validatePassword();
    },

    checkPassword: function() {
        self.clearError();

        var value = self.input().val();

        if(self.options.required && value.length == 0) {
            self.raiseError(opts.error.empty);
            return false;
        }

        if(self.options.min > 0 && value.length < self.options.min) {
            self.raiseError(opts.error.min);
            return false;
        }

        if(self.options.max > 0 && value.length > self.options.max) {
            self.raiseError(opts.error.long);
            return false;
        }

        if(self.options.minInteger > 0) {
            var test = value.match(/[0-9]/g);
            if (!test || test.length < self.options.minInteger) {
                self.raiseError(opts.error.min);
                return false;
            }
        }

        if(self.options.minSymbol > 0) {
            var test = value.match(/[\W]/g);
            if (!test || test.length < self.options.minSymbol) {
                self.raiseError(opts.error.minsymbols);
                return false;
            }
        }

        if(self.options.minUpperCase > 0) {
            var test = value.match(/[A-Z]/g);
            if (!test || test.length < self.options.minUpperCase) {
                self.raiseError(opts.error.minupper);
                return false;
            }
        }

        return true;
    },

    validatePassword: function() {
        self.clearError();

        var input = self.input().val();
        var reconfirm = self.reconfirm().val();

        if(self.options.reconfirmPassword && !self.validatePasswordConfirm()) {
            return false;
        }

        return true;
    },

    validatePasswordConfirm: function() {
        var input = self.input().val(),
            reconfirm = self.reconfirm().val();

        // Check if either input or reconfirm is not empty
        if(!$.isEmpty(input) || !$.isEmpty(reconfirm)) {
            if($.isEmpty(input)) {
                self.raiseError(opts.error.empty);
                return false;
            }

            if($.isEmpty(reconfirm)) {
                self.raiseError(opts.error.emptyconfirm);
                return false;
            }

            if(input !== reconfirm) {
                self.raiseError(opts.error.mismatch);
                return false;
            }
        }

        return true;
    },

    '{self} onSubmit': function(el, event, register, mode) {
        if (mode !== 'onRegisterMini') {
            return;
        }

        register.push(self.checkPassword());
    },

    clearError: function() {
        self.trigger('clear');
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    }
}});

module.resolve();
})
			EasySocial.module('apps/fields/user/joomla_password/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_password.Sample', {
        defaultOptions: {
            '{confirmPassword}'     : '[data-password-confirm]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'reconfirm_password':
                        self.confirmPassword().toggle(value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_timezone/content', function($) {

var module = this;

EasySocial
.require()
.library('chosen')
.done(function($) {

EasySocial.Controller('Field.Joomla_timezone', {
	defaultOptions: {
		"required": false,
		'{field}': '[data-field-joomla_timezone]',
		'{input}': '[data-field-joomla_timezone-input]'
	}
}, function(self, opts, base) { return {

	init : function() {
		opts.message = self.element.find('[data-error]').data('error');

		self.input().chosen({
			// width: $('.o-control-input').eq(0).width() + 'px', // #3003
			width: '100%',
			allow_single_deselect: true,
			search_contains: true
		});
	},

	validateInput: function() {
		if(!self.options.required) {
			return true;
		}

		self.clearError();

		var value = self.input().val();

		if(value === 'null' || $.isEmpty(value)) {
			self.raiseError();
			return false;
		}

		return true;
	},

	raiseError: function() {
		self.trigger('error', opts.message);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{input} change': function() {
		self.validateInput();
	},

	"{self} onSubmit": function(el, event, register) {
		register.push(self.validateInput());
	}

}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/joomla_username/content', function($) {

var module = this;

EasySocial.Controller('Field.Joomla_username', {
	defaultOptions: {
		event: null,
		id: null,
		userid: null,

		'{button}': '[data-username-check]',
		'{input}': '[data-username-input]',
		'{available}': '[data-username-available]',
		"{error}": "[data-username-error]",
		"{errorMessage}": "[data-username-error] > [data-message]"
	}
}, function(self, opts, base) { return {
	state: false,

	init: function() {
	},

	'{button} click': function() {
		self.delayedCheck();
	},

	'{input} keyup': function() {
		self.delayedCheck();
	},

	delayedCheck: $.debounce(function() {
		self.checkUsername();
	}, 250),

	checkUsername: function() {
		self.clearError();

		var state = $.Deferred();
		var button = self.button();

		button.addClass('is-loading');

		var username = self.input().val();

		EasySocial.ajax('fields/user/joomla_username/isValid', {
			id: opts.id,
			userid: opts.userid,
			username: username,
			event: opts.event
		}).done(function(msg) {
			
			self.available().removeClass('t-hidden');
			self.error().addClass('t-hidden');
			state.resolve();

		}).fail(function(msg) {

			self.available().addClass('t-hidden');
			self.error().removeClass('t-hidden');
			self.errorMessage().html(msg);

			self.raiseError(msg);

			state.reject();

		}).always(function() {
			button.removeClass('is-loading');
		})

		return state;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onSubmit': function(el, ev, register, mode) {
		if (mode === 'onRegisterMini') {
			return;
		}

		register.push(self.checkUsername());
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_username/registermini_content', function($) {

var module = this;

EasySocial.Controller('Field.Joomla_username.Mini', {
    defaultOptions: {
        id: null,
        required: false,
        '{field}': '[data-field-joomla_username]',
        '{input}': '#joomla_username'
    }
}, function(self, opts, base) { return {

    init: function() {

        var data = self.field().htmlData();
        opts.error = data.error || {};
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    '{input} keyup': function(el) {
        if(el.val().length > 0) {
            self.delayedCheck();
        }
    },

    state: false,

    delayedCheck: $.debounce(function() {
        self.checkUsername();
    }, 250),

    checkUsername: function() {

        var username = self.input().val();

        if(self.options.required && username.length == 0) {
            self.raiseError(opts.error.empty);
            return false;
        }

        if(username.length > 0) {
            var state = $.Deferred();

            self.clearError();

            self.input().addClass('is-loading');

            EasySocial.ajax('fields/user/joomla_username/isValid', {
                id: self.options.id,
                userid: 0,
                username: username
            }).done(function(msg) {
                self.setLoaded();

                state.resolve();

            }).fail(function(msg) {

                self.raiseError(msg);

                state.reject();

            }).always(function() {
                self.input().removeClass('is-loading');
            });

            return state;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register, mode) {
        if (mode !== 'onRegisterMini') {
            return;
        }

        if(self.options.required || self.input().val().length > 0) {
            register.push(self.checkUsername());
        }
    },

    setLoading: function(msg) {
        self.trigger('loading', [msg]);
    },

    setLoaded: function() {
        self.trigger('loaded');
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_username/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_username.Sample', {
        defaultOptions: {
            '{checkUsername}'       : '[data-check-username]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_username':
                        self.checkUsername().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/keycaptcha/content', function($) {
var module = this;

EasySocial.Controller('Field.Keycaptcha', {
    defaultOptions: {
     required: true,
    '{input}': '[data-field-keycaptcha]',
   }
}, function(self, opts, base) { return {

    "{self} onRender": function() {
        var data = self.input().htmlData();

        opts.error = data.error || {};
    },

    validateInput: function() {
        self.clearError();
        var keycaptcha = self.input().val();

        if(keycaptcha.length > 100){
            return true;
        }

        self.raiseError();
        return false;
    },
    
    raiseError: function() {
        self.trigger('error', opts.error.required);
    },

    clearError: function() {
        self.trigger('clear');
    },
    
    '{self} onSubmit': function(el, event, register) {
        register.push(self.validateInput());
    }

}});

module.resolve();

});			EasySocial.module('apps/fields/user/keycaptcha/registermini_content', function($) {
    var module = this;

    EasySocial.require()
        EasySocial.Controller('Field.keycaptcha.Mini', {
            defaultOptions: {
                id: null,

                required: false,

                '{input}': '[data-field-keycaptcha]'
            }
        }, function(self) {
            return {
                init: function() {

                },
                validateInput: function() {

                   self.clearError();

                var state = $.Deferred();

                var keycaptcha = self.input().val();
                var a = keycaptcha.split('|');  

                    if(a[4] == 1){
                     state.resolve();
                      return true;
                    }
                     self.raiseError(msg);
                     state.reject();
                     return state;  
                },

                raiseError: function(msg) {
                    self.trigger('error', [msg]);
                },

                clearError: function() {
                    self.trigger('clear');
                },

                '{self} onSubmit': function(el, ev, register, mode) {
                    if (mode !== 'onRegisterMini') {
                        return;
                    }
                }
            }
        });

        module.resolve();
   
});
			EasySocial.module('apps/fields/user/multidropdown/content', function($) {

var module = this;

EasySocial
.require()
.library('ui/sortable')
.done(function() {

EasySocial.Controller('Field.Multidropdown', {
    defaultOptions: {
    required: false,

    id: null,

    inputName: '',

    max: 0,

    '{field}': '[data-field-multidropdown]',

    '{list}': '[data-field-multidropdown-list]',

    '{item}': '[data-field-multidropdown-item]',

    '{input}': '[data-field-multidropdown-input]',

    '{add}': '[data-field-multidropdown-add]',

    '{delete}': '[data-field-multidropdown-delete]',

    '{move}': '[data-field-multidropdown-move]'
    }
}, function(self, opts, base) { return {

    init: function() {

        opts.message = self.element.find('[data-error]').data('error');
        opts.max = self.field().data('max');

        self.initSortable();
    },

    initSortable: function() {
        self.list().sortable({
            items: self.item.selector,
            handle: self.move.selector
        });
    },

    '{add} click': function(el) {
        if (self.options.max < 1 || self.item().length < self.options.max)
        {
            var item = self.item().eq(0).clone();

            item.find(self.input.selector)
                .attr('value', '')
                .val('');

            self.list().append(item);
        }

        if(self.options.max > 0 && self.item().length >= self.options.max)
        {
            el.hide();
        }
    },

    '{delete} click': function(button, event) {
        var item = button.parents(self.item.selector);

        if (self.item().length > 1) {
            item.remove();
        } else {
            item.find(self.input.selector).val('');
        }

        if (opts.max > 0 && self.item().length < self.options.max) {
            self.add().show();
        }
    },

    '{self} onConfigChange': function(el, ev, name, value) {
        switch (name) {
            case 'add_button_text':
                self.add().text(value);
            break;
        }
    },

    raiseError: function() {
        self.trigger('error', [opts.message]);
    },

    '{self} onSubmit': function(el, ev, register) {
        if (!self.options.required) {
            register.push(true);
            return;
        }

        var state = false;

        $.each(self.input(), function(i, element) {
            if (!$.isEmpty($(element).val())) {
                state = true;

                return false;
            }
        });

        if (!state) {
            self.raiseError();
        }

        register.push(state);
    }
}});

module.resolve();

});
});
			EasySocial.module('apps/fields/user/multilist/content', function($) {

var module = this;

EasySocial.Controller('Field.Multilist', {
	defaultOptions: {
		required        : null,
		multiple        : null,

		"{field}"       : "[data-field-multilist]",

		"{item}"        : "[data-field-multilist-item]",

		"{option}"      : "[data-field-multilist-item] option"
	}
}, function(self, opts, base) { return {

	"{self} onRender": function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	validateInput : function() {
		self.clearError();

		if(self.options.multiple && self.item().children(':selected').length <= 0) {
			self.raiseError();
			return false;
		}

		// The only way to test for an empty value is when the value is empty and it's required.
		if(self.item().children(':selected' ).val() == '') {
			self.raiseError();
			return false;
		}

		return true;
	},

	raiseError: function() {
		self.trigger('error', [opts.error.empty]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	"{self} onSubmit": function(el, event, register) {
		// If field is not required, skip the checks.

		if(!self.options.required)
		{
			register.push(true);
			return;
		}

		register.push(self.validateInput());

		return;
	},

	'{self} onChoiceAdded': function(el, event, index) {
		if(self.option().eq(index).length > 0) {
			self.option().eq(index).before($('<option></option>'));
		} else {
			self.item().append($('<option></option>'));
		}
	},

	'{self} onChoiceValueChanged': function(el, event, index, value) {
		self.option().eq(index).val(value);
	},

	'{self} onChoiceTitleChanged': function(el, event, index, value) {
		self.option().eq(index).text(value);
	},

	'{self} onChoiceRemoved': function(el, event, index) {
		self.option().eq(index).remove();
	},

	'{self} onChoiceToggleDefault': function(el, event, index, value) {
		if(value) {
			self.option().eq(index).attr('selected', 'selected');
		} else {
			self.option().eq(index).removeAttr('selected');
		}
	}
}});

module.resolve();
});			EasySocial.module('apps/fields/user/multitextbox/content', function($) {

var module = this;

EasySocial
.require()
.library('ui/sortable')
.done(function() {

EasySocial.Controller('Field.Multitextbox', {
    defaultOptions: {
        required: false,

        id: null,

        inputName: '',

        max: 0,

        '{field}': '[data-field-multitextbox]',

        '{list}': '[data-field-multitextbox-list]',

        '{item}': '[data-field-multitextbox-item]',

        '{input}': '[data-field-multitextbox-input]',

        '{add}': '[data-field-multitextbox-add]',

        '{delete}': '[data-field-multitextbox-delete]',

        '{move}': '[data-field-multitextbox-move]'
    }
}, function(self, opts, base) { return {
    
    init: function() {
        var data = self.field().htmlData();
        opts.error = data.error || {};

        opts.max = self.field().data('max');
        self.initSortable();
    },

    initSortable: function() {
        self.list().sortable({
            items: self.item.selector,
            handle: self.move.selector
        });
    },

    '{add} click': function(el) {
        
        if (self.options.max < 1 || self.item().length < self.options.max) {
            var item = self.item().eq(0).clone();

            item.find(self.input.selector)
                .attr('value', '')
                .val('');

            self.list().append(item);
        }

        if(self.options.max > 0 && self.item().length >= self.options.max)
        {
            el.hide();
        }
    },

    '{delete} click': function(el) {
        var item = el.parents(self.item.selector);

        if (self.item().length > 1) {
            item.remove();
        } else {
            item.find(self.input.selector).val('');
        }

        if (self.options.max > 0 && self.item().length < self.options.max) {
            self.add().show();
        }
    },

    '{self} onConfigChange': function(el, ev, name, value) {
        switch (name) {
            case 'add_button_text':
                self.add().text(value);
            break;
        }
    },

    raiseError: function() {
        self.trigger('error', [opts.error.required]);
    },

    '{self} onSubmit': function(el, ev, register) {
        if(!self.options.required) {
            register.push(true);
            return;
        }

        var state = false;

        $.each(self.input(), function(i, element) {
            if(!$.isEmpty($(element).val())) {
                state = true;

                return false;
            }
        });

        if (!state) {
            self.raiseError();
        }

        register.push(state);
    }
}
});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/numeric/content', function($) {

var module = this;

EasySocial.Controller('Field.Numeric', {
	defaultOptions: {
		required: false,
		min: 0,
		max: 0,
		'{field}': '[data-field-numeric]',
		'{input}': '[data-field-numeric-input]',
		'{notice}': '[data-check-notice]'
	}
}, function(self, opts, base) { return {
	
	init: function() {
		opts.min = self.input().data('min');
		opts.max = self.input().data('max');
	},

	'{self} onRender': function() {
		var data = self.field().htmlData();
		opts.error = data.error || {};
	},

	'{input} mouseup': function() {
		self.validateInput();
	},

	'{input} keyup': function() {
		self.validateInput();
	},

	'{input} blur': function() {
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var value = self.input().val();

		if (opts.required && $.isEmpty(value)) {
			self.raiseError(opts.error.required);
			return false;
		}

		if (!$.isEmpty(value) && opts.min > 0 && value < opts.min) {
			self.raiseError(opts.error.short);
			return false;
		}

		if (opts.max > 0 && value > opts.max) {
			self.raiseError(opts.error.long);
			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onError': function(el, ev, type) {
		if (type === 'required') {
			self.raiseError(opts.error.required);
		}

		if (type === 'validate') {
			self.raiseError(opts.error.invalid);
		}
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();
});			EasySocial.module('apps/fields/user/password/content', function($) {

var module = this;

EasySocial.Controller('Field.Password', {
    defaultOptions: {
        required: false,

        min: 0,
        max: 0,

        '{field}': '[data-field-password]',

        '{input}': '[data-field-password-input]',

        '{notice}': '[data-check-notice]'
    }
}, function(self, opts, base) { return {
    init: function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
        opts.min = self.field().data('min');
        opts.max = self.field().data('max');
    },

    '{input} keyup': function() {
        self.validateInput();
    },

    '{input} blur': function()
    {
        self.validateInput();
    },

    validateInput: function()
    {
        self.clearError();

        var value = self.input().val();

        if(self.options.required && $.isEmpty(value)) {
            self.raiseError(opts.error.required);
            return false;
        }

        if(!$.isEmpty(value) && self.options.min > 0 && value.length < self.options.min) {
            self.raiseError(opts.error.short);
            return false;
        }

        if(self.options.max > 0 && value.length > self.options.max) {
            self.raiseError(opts.error.long);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onError': function(el, ev, type) {
        if(type === 'required') {
            self.raiseError(opts.error.required);
        }
    },

    '{self} onSubmit': function(el, ev, register) {
        register.push(self.validateInput());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/password/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Password.Sample', {
        defaultOptions: {
            '{input}'           : '[data-input]',

            'min'                   : '',
            'max'                   : ''
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'placeholder':
                        self.input().attr('placeholder', value);
                    break;

                    case 'default':
                        self.input().val(value);
                    break;

                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/permalink/content', function($) {

var module = this;

EasySocial.Controller('Field.Permalink', {
    defaultOptions: {
        required: false,
        max     : 0,
        id      : null,
        userid  : null,
        '{field}': '[data-field-permalink]',
        '{checkButton}': '[data-permalink-check]',
        '{input}': '[data-permalink-input]',
        '{available}': '[data-permalink-available]'
    }
}, function(self, opts, base) { return {
    
    state: false,

    init: function() {
        opts.message = {
            length: base.find('[data-error-length]').data('error-length'),
            required: base.find('[data-error-required]').data('error-required')
        };

        opts.max = self.field().data('max');
    },

    "{checkButton} click" : function() {
        self.delayedCheck();
    },

    "{input} keyup" : function() {
        self.delayedCheck();
    },

    delayedCheck: $.debounce(function() {
        self.checkPermalink();
    }, 250),

    checkPermalink: function() {
        self.clearError();

        var permalink   = self.input().val();

        self.available().hide();

        if(self.options.max > 0 && permalink.length > self.options.max) {
            self.raiseError(opts.message.length);
            return false;
        }

        if(!$.isEmpty(permalink))
        {
            self.checkButton().addClass('is-loading');

            var state = $.Deferred();

            EasySocial.ajax('fields/user/permalink/isValid',
            {
                "id"        : self.options.id,
                "userid"    : self.options.userid,
                "permalink" : permalink
            })
            .done(function(msg)
            {
                self.checkButton().removeClass( 'is-loading' );

                self.available().show();

                state.resolve();
            })
            .fail(function(msg)
            {
                self.raiseError(msg);

                self.checkButton().removeClass('is-loading');

                self.available().hide();

                state.reject();
            });

            return state;
        }

        if(self.options.required && $.isEmpty(permalink))
        {
            self.available().hide();

            self.raiseError(opts.message.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg)
    {
        self.trigger('error', [msg]);
    },

    clearError: function()
    {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register)
    {
        register.push(self.checkPermalink());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/permalink/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Permalink.Sample', {
        defaultOptions: {
            '{checkPermalink}'      : '[data-check-permalink]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_permalink':
                        self.checkPermalink().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/relationship/content', function($) {

var module = this;

EasySocial
.require()
.script('site/friends/suggest')
.done(function($) {

EasySocial.Controller('Field.Relationship', {
	defaultOptions: {
		required: false,
		id: null,
		types: null,
		fieldname: null,
		actor: null,
		target: null,
		userid: null,

		'{type}': '[data-rs-type]',
		'{request}': '[data-rs-request]',

		'{field}': '[data-field-relationship]',
		'{pendingTitle}': '[data-rs-pending-title]',

		// Relations wrapper
		'{relations}': '[data-rs-relations]',

		// Delete a relation
		'{delete}': '[data-rs-delete]',

		// Request form
		'{rejectRequest}': '[data-rs-reject]',
		'{approveRequest}': '[data-rs-approve]'
	}
}, function(self, opts, base) { return {
	init: function() {

		EasySocial.module('field.relationship/' + opts.id).done(function(types) {
			self.options.types = types;
		});

		self.addPlugin('form');
	},

	getRequestId: function() {
		return self.request().data('id');
	},

	getRequestWrapper: function(id) {
		wrapper = $('[data-rs-request][data-id="' + id + '"]');
		return wrapper;
	},

	showTypeSelection: function() {
		// Show the form
		self.type().val(self.type().children(':first').val());
		self.type().removeClass('t-hidden').show();
		self.type().removeAttr('disabled');
	},

	'{self} relationshipDeleted': function() {
		self.showTypeSelection();
	},

	'{delete} click': function(button, event) {
		event.stopPropagation();
		event.preventDefault();

		button.addClass('is-loading');

		EasySocial.ajax('fields/user/relationship/delete', {
			"id": opts.id,
			"userid": opts.userid,
			"relid": self.getRequestId()
		}).done(function(output) {

			button.removeClass('is-loading');

			self.relations().remove();

			// Show the type selection again
			self.showTypeSelection();
		});
	},

	'{approveRequest} click': function(button, event) {
		var id = button.data('id');
		button.addClass('is-loading');

		EasySocial.ajax('fields/user/relationship/approve', {
			"id": opts.id,
			"relid": id,
			"inputName": opts.fieldname
		}).done(function(output) {

			// Remove hidden input
			$('[data-rs-request-hidden]').remove();

			wrapper = self.getRequestWrapper(id);

			button.removeClass('is-loading');
			self.request().not(wrapper).remove();


			wrapper.replaceWith(output);
		});
	},

	'{rejectRequest} click': function(button, event) {
		event.preventDefault();
		event.stopPropagation();

		var id = button.data('id');

		EasySocial.ajax('fields/user/relationship/reject', {
			"id": opts.id,
			"relid": id
		}).done(function() {
			// Hide the request item
			wrapper = self.getRequestWrapper(id);

			wrapper.remove();
			self.trigger('relationshipDeleted');
		});
	}
}});

EasySocial.Controller('Field.Relationship.Form', {
	defaultOptions: {

		'{field}': '[data-field-relationship]',
		'{type}': '[data-rs-type]',

		'{input}': '[data-rs-input]',
		'{target}': '[data-rs-target]',

		'{targetAvatar}': '[data-rs-target-avatar]',
		'{targetName}': '[data-rs-target-name]',
		'{targetDelete}': '[data-rs-form-delete]',
		'{textboxlistDelete}': '[data-textboxlist-itemRemoveButton]',

		target : false
	}
}, function(self, opts, base) { return {
	init: function() {
		self.input().addController(EasySocial.Controller.Friends.Suggest, {
			max: 1,
			name: self.parent.options.fieldname + '[target][]'
		});

        var data = self.field().htmlData();
        if (data && data.error) {
			opts.error = data.error;
        }

        // default this to true so that edit whitout changing the relationship will still pass. #492
		opts.target = true;

	},

    "{self} onRender": function() {
        var data = self.field().htmlData();
        opts.error = data.error;
    },

	'{type} change': function(dropdown, event) {

		var type = dropdown.val();
		var option = dropdown.find(':selected');
		var connection = option.data('connection') ? true : false;
		opts.target = false;

		// If this relationship does not have any connection, skip this
		if (!connection) {
			opts.target = true;

			self.clearError();
			self.input().hide();
			self.target().hide();
			return;
		}

		// Always remove the item when changing a type
		self.input().controller('Textboxlist').clearItems();
		self.target().hide();
		self.input().show();
		self.validateInput(opts.error.target);
	},

	'{input} addItem': function(el, ev, item) {

		// Since the item is html based, we need to extract the data
		var item = $('<div/>').html(item.html);
		var avatar = item.find('[data-suggest-avatar]').attr('src');
		var name = item.find('[data-suggest-title]').val();
		var id = item.find('[data-suggest-id]').val();

		if (avatar) {
			self.targetAvatar().attr('src', avatar);
		}

		if (name) {
			self.targetName().text(name);
		}

		if (id) {
			self.targetDelete().data('id', id);
		}

		self.input().hide();
		self.target().show();

		// Globally set the target is true
		opts.target = true;
		self.clearError();
	},

	'{input} blur' : function(el, ev) {
		self.validateInput(opts.error.target);
	},

	'{targetDelete} click': function(button, event) {
		var id = button.data('id');

		// Remove the selected item
		self.input().controller('Textboxlist').removeItem(id);

		self.type().removeAttr('disabled');
		self.input().show();
		self.target().hide();

		opts.target = false;
		self.validateInput(opts.error.target);
	},

	'{self} onSubmit': function(el, event, register) {

		register.push(self.validateInput(opts.error.target));
	},

	validateInput : function(msg) {

        var isRequired = self.parent.options.required;
        var type = self.type().val();

        var allowed = ['na', 'single', 'widowed', 'separated', 'divorced', 'relationshipnotarget', 'engagednotarget', 'marriednotarget', 'complicatednotarget'];

        if(isRequired && type == 'na') {
			self.raiseError(opts.error.required);
			return false;
        }

        if (!isRequired && ($.inArray(type, allowed) !== -1)) {
			self.clearError();
			return true;
        }

        if (($.inArray(type, allowed) === -1) && !opts.target) {
			self.raiseError(opts.error.target);
			return false;
        }

        // all pass.
		self.clearError();
		return true;
	},

	raiseError: function(msg) {
		if (!msg) {
			msg = opts.error.required;
		}

		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	}
}});

module.resolve();

});
});
			EasySocial.module('apps/fields/user/separator/sample', function($) {
    var module = this;

    EasySocial.Controller( 'Field.Separator.Sample',
    {
        defaultOptions:
        {
            "{items}"   : "[data-separator-type]"
        }
    },
    function( self )
    {
        return {
            "{self} onConfigChange" : function( el , event , name , value )
            {
                if( name == 'type' )
                {
                    var itemToShow  = $( '[data-separator-' + value + ']' );

                    // Hide all separators
                    self.items().hide();

                    // Only show the correct separator
                    itemToShow.show();
                }

            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/terms/content', function($) {

var module = this;

EasySocial.Controller('Field.Terms', {
	defaultOptions: {
		event: null,
		required: false,

		'{textbox}': '[data-field-terms-textbox]',
		'{checkbox}': '[data-field-terms-checkbox]'
	}
}, function(self, opts, base) { return {

	"{self} onRender": function() {
		var data = self.element.htmlData();

		opts.error = data.error || {};
	},

	validateInput: function() {
		self.clearError();

		// We should not prevent admin from hitting errors
		if (opts.event == 'onAdminEdit') {
			return true;
		}

		if (opts.required && !self.checkbox().is(':checked')) {
			self.raiseError(opts.error.required);
			return false;
		}

		return true;
	},

	'{checkbox} change': function() {
		self.validateInput();
	},

	raiseError: function() {
		self.trigger('error', [opts.error.required]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onSubmit': function(el, event, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/textarea/content', function($) {

var module = this;

EasySocial.Controller('Field.Textarea', {
	defaultOptions: {
		required: false,
		min: 0,
		max: 0,
		'{field}': '[data-field-textarea]',
		'{input}': '[data-field-textarea-input]'
	}
}, function(self, opts, base) { return {
	init : function() {
		opts.min = self.field().data('min');
		opts.max = self.field().data('max');
	},

	"{self} onRender": function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	validateInput : function() {
		self.clearError();

		var val = self.input().val();

		if (self.options.required && $.isEmpty(val)) {
			self.raiseError(opts.error.required);
			return false;
		}

		if (!$.isEmpty(val) && self.options.min > 0 && val.length < self.options.min) {
			self.raiseError(opts.error.short);
			return false;
		}

		if (self.options.max > 0 && val.length > self.options.max) {
			self.raiseError(opts.error.long);
			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onSubmit': function(el, event, register) {
		register.push(self.validateInput());
	},

	'{self} onError': function(el, ev, type) {
		if (type === 'required') {
			self.raiseError(opts.error.required);
		}
	},

	'{input} keyup': function() {
		self.validateInput();
	},

	'{self} onConfigChange': function(el, event, name, value) {
		switch(name) {
			case 'default':
				self.input().val(value);
				break;

			case 'placeholder':
				self.input().attr('placeholder', value);
				break;

			case 'readonly':
				if (value) {
					self.input().attr('readonly', 'readonly');
				} else {
					self.input().removeAttr('readonly');
				}
				break;
		}
	}
}});

module.resolve();

});			EasySocial.module('apps/fields/user/textbox/content', function($) {

var module = this;

EasySocial.Controller('Field.Textbox', {
	defaultOptions: {
		required: false,
		min: 0,
		max: 0,
		'{field}': '[data-field-textbox]',
		'{input}': '[data-field-textbox-input]',
		'{notice}': '[data-check-notice]'
	}
}, function(self, opts, base) { return {
	
	init: function() {
		opts.min = self.field().data('min');
		opts.max = self.field().data('max');
	},

	'{self} onRender': function() {
		var data = self.field().htmlData();
		opts.error = data.error || {};
	},

	'{input} keyup': function() {
		self.validateInput();
	},

	'{input} blur': function() {
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var value = self.input().val();

		if (self.options.required && $.isEmpty(value)) {
			self.raiseError(opts.error.required);
			return false;
		}

		if (!$.isEmpty(value) && self.options.min > 0 && value.length < self.options.min) {
			self.raiseError(opts.error.short);
			return false;
		}

		if (self.options.max > 0 && value.length > self.options.max) {
			self.raiseError(opts.error.long);
			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onError': function(el, ev, type) {
		if (type === 'required') {
			self.raiseError(opts.error.required);
		}

		if (type === 'validate') {
			self.raiseError(opts.error.invalid);
		}
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();
});			EasySocial.module('apps/fields/user/textbox/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Textbox.Sample', {
        defaultOptions: {
            '{input}'           : '[data-input]',

            'min'                   : '',
            'max'                   : '',
            'regex_validate'        : false,
            'regex_format'          : '',
            'regex_modifier'        : ''
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'placeholder':
                        self.input().attr('placeholder', value);
                    break;

                    case 'default':
                        self.input().val(value);
                    break;

                    case 'readonly':
                        if(value) {
                            self.input().attr('disabled', 'disabled');
                        } else {
                            self.input().removeAttr('disabled');
                        }
                        break;
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/url/content', function($) {

var module = this;

EasySocial.Controller('Field.Url', {
	defaultOptions: {
		required: false,

		'{field}': '[data-field-url]',
		'{input}': '[data-field-url-input]'
	}
}, function(self, opts, base) { return {

	init: function() {
	},
	
	"{self} onRender": function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	'{input} blur': function() {
		self.validateInput();
	},

	'{input} keyup': function() {
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var value = self.input().val();

		if (self.options.required && $.isEmpty(value)) {
			self.raiseError(opts.error.empty);
			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onError': function(el, event, type, field) {
		self.raiseError(opts.error.empty);
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();

});			EasySocial.module('shared/elements', function($){

var module = this;
var tooltipLoaded = false;

// Initialize yes/no buttons.
$(document).on('click.button.data-bs-api', '[data-bs-toggle-value]', function() {

	var button = $(this);
	var siblings = button.siblings("[data-bs-toggle-value]");
	var parent = button.parents('[data-bs-toggle="radio-buttons"]');

	if (parent.hasClass('disabled')) {
		return;
	}

	// This means that this toggle value belongs to a radio button
	if (parent.length > 0) {

		// Get the current button that's clicked.
		var value = $(this).data('bs-toggle-value');

		button.addClass("active");
		siblings.removeClass("active");

		// Set the value here.
		// Have to manually trigger the change event on the input
		parent.find('input[type=hidden]').val(value).trigger('change');
		return;
	}
});

$(document).on('change.form.toggler', '[data-toggler-checkbox]', function() {
	var checkbox = $(this);
	var checked = checkbox.is(':checked');
	var parent = checkbox.parents('[data-bs-toggler]');

	if (parent.length > 0) {

		var input = parent.find('input[type=hidden]');
		input.val(checked ? 1 : 0).trigger('change');
	}
});

EasySocial.isMobile = function() {
	try {
		document.createEvent('TouchEvent');
		return true;
	} catch(e) {
		return false;
	}
}

// String truncater
// Used when there is a read more of a truncated content.
var selector = '[data-es-truncater] > [data-readmore]';

$(document)
	.on('click.es.strings.truncater', selector, function() {

		var section = $(this).parent();
		var original = section.find('[data-original]');
		var text = section.find('[data-text]');

		// Hide the link
		$(this).addClass('t-hidden');

		// Show the full contents
		text.addClass('t-hidden');
		original.removeClass('t-hidden');
	});

// Tooltips
// detect if mouse is being used or not.
var mouseCount = 0;
window.onmousemove = function() {

	mouseCount++;

	addTooltip();
};

var addTooltip = $.debounce(function(){

    if (!tooltipLoaded && mouseCount > 10) {

		tooltipLoaded = true;
		mouseCount = 0;

		$(document).on('mouseover.tooltip.data-es-api', '[data-es-provide=tooltip]', function() {

			$(this)
				.tooltip({
					delay: {
						show: 200,
						hide: 100
					},
					animation: false,
					template: '<div id="es" class="tooltip tooltip-es"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
					container: 'body'
				})
				.tooltip("show");
		});
    } else {
    	mouseCount = 0;
    }
}, 500);


// TODO: Update to [data-es-provide=tooltip]
if (!EasySocial.isMobile()) {
	$(document).on('mouseover.tooltip.data-es-api', '[data-es-provide=tooltip]', function() {

		$(this)
			.tooltip({
				delay: {
					show: 200,
					hide: 100
				},
				animation: false,
				template: '<div id="es" class="tooltip tooltip-es"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
				container: 'body'
			})
			.tooltip("show");
	});
}

// Popovers
// TODO: Update to [data-es-provide=popover]
$(document).on('mouseover.popover.data-es-api', '[data-es-provide=popover]', function() {
	$(this)
		.popoverES({
			delay: {
				show: 200,
				hide: 100
			},
			animation: false,
			trigger: 'hover',
			container: 'body'
		})
		.popoverES("show");
});


var ly = function(yr) { return (yr%400)?((yr%100)?((yr%4)?false:true):false):true; };

$(document).on("keyup", "[data-date-form] [data-date-day]", function(){

	if (!$.trim($(this).val())) return;

	var year   = parseInt($(this).siblings("[data-date-year]").val()  || $(this).siblings("[data-date-year]").data("dateDefault")),

	    month  = parseInt($(this).siblings("[data-date-month]").val() || $(this).siblings("[data-date-month]").data("dateDefault")),

	    day    = parseInt($(this).val() || $(this).data("dateDefault")),

		maxDay = /1|3|5|7|8|10|12/.test(month) ? 31 : 30;

		if (month==2) maxDay = ly(year) ? 29 : 28;

		if (day < 1) day = 1;

		if (day > maxDay) day = maxDay;

		if ($.isNumeric(day)) {
			$(this).val(day);
		} else {
			$(this).val("");
		}
});

$(document).on("keyup", "[data-date-form] [data-date-year]", function(){

	if (!$.trim($(this).val())) return;

	var year = parseInt($(this).val());
	if (year < 1) year = 1;

	if ($.isNumeric(year)) {
		$(this).val(year);
	} else {
		$(this).val("");
	}
});

module.resolve();

});
			EasySocial.module('shared/fields/base', function($) {

var module = this;

EasySocial.Controller('Field.Base', {
	defaultOptions: {
		regPrefix : 'easysocial/',
		modPrefix : 'field.',
		ctrlPrefix : 'EasySocial.Controller.Field.',
		
		// Field attributes
		"id": null,
		"name": null,
		"element": null,
		"required": false,

		// Default mode
		"mode": 'edit',

		// Container items
		'{field}': '[data-field]',
		'{content}': '[data-content]',
		'{notice}': '[data-check-notice]'
	}
}, function(self, opts, base) { return {
	
	init: function() {

		// Initialize properties of the field
		opts.name = base.data('name');
		opts.element = opts.element || base.data('field-item');
		opts.id = base.data('id');
		opts.required = base.data('required') ? true : false;

		// Start triggering the field apps so that they can start doing their own initialization
		self.triggerFields();

		// Initialize error messages if there are any
		self.initializeErrorMessages();
	},

	initializeErrorMessages: function() {
		var notice = self.notice();
		var text = notice.text().trim();

		if (text.length <= 0) {
			return;
		}

		self.showError(text);
	},

	showError: function(message) {

		var content = self.content();
		
		content
			.find('[data-field-error]')
			.html(message);
	},

	// Trigger the necessary mode here for field to do necessary init
	triggerFields: function() {
		
		var field = self.field();
		var trigger = 'onEdit';

		if (opts.mode == 'registermini') {
			trigger = 'onRegisterMini';
		}

		if (opts.mode == 'register') {
			trigger = 'onRegister';
		}

		if (opts.mode == 'edit') {
			trigger = 'onEdit';
		}

		if (opts.mode == 'adminedit') {
			trigger = 'onAdminEdit';
		}

		if (opts.mode == 'sample') {
			trigger = 'onSample';
		}

		if (opts.mode == 'display') {
			trigger = 'onDisplay';
		}

		// Trigger the field
		field.trigger('onRender');
		field.trigger(trigger);
	},

	// Some base triggers/functions
	'{field} error': function(element, event, state, message) {
		var state = state !== undefined ? state : true;

		if ($.isString(state)) {
			message = state;
			state = true;
		}

		if ($.isBoolean(state)) {
			self.field().toggleClass('has-error', state);
		}

		if (message !== undefined) {
			self.showError(message);
		}
	},

	'{field} clear': function(el, ev) {
		self.field().removeClass('has-error');
		self.field().removeClass('is-loading');

		self.content().popoverES('destroy');
	},

	'{self} show': function() {
		self.field().trigger('onShow');
	},

	'{field} loading': function(el, ev, msg) {
		self.field().addClass('is-loading');

		self.notice().html(msg);
	},

	'{field} loaded': function(el, ev) {
		self.field().removeClass('is-loading');
	}
}});

module.resolve();
});
			EasySocial.module('shared/fields/conditional', function($) {

var module = this;
var isController = $.isController('EasySocial.Controller.Field.Conditional');

if (isController) {
	return;
}

EasySocial.Controller('Field.Conditional', {
	defaultOptions: {
		id: null,
		fieldTargeted: [],
		operator: [],
		conditionValue: [],
		result: []
	}
}, function(self, opts, base) { return {

	init: function() {

		opts.id = base.data('id');
		var isConditional = base.data('isconditional');

		if (isConditional) {
			self.bindTargetedFields();
		}
	},

	bindTargetedFields: function() {
		var conditions = base.data('conditions');

		if (conditions) {
			$.each(conditions, function(key, value) {
				opts.fieldTargeted.push(value.fieldId);
				opts.operator.push(value.operator);
				opts.conditionValue.push(value.value);

				// Properly format the conditon value
				self.formatConditionsValue(key);

				// Bind listen event on targeted field
				self.bindFields(key);
			})
		}
	},

	bindFields: function(key) {

		var field = self.getTargetedField(key);

		if (self.isAutocomplete(key)) {
			self.bindAutocompleteFields(key);
		} else {

			// Listen on change event
			field.on('change', function() {
				self.fieldChanged(key);
			});

			// Listen on keyup event
			field.on('keyup', function() {
				self.fieldChanged(key);
			});

			// Re-check the current field value and determine if we should show or not the field
			field.on('onFieldShow', function() {
				self.fieldChanged(key);
			});

			// Directly trigger the checking during initial page load
			// only if the targeted field is not hidden
			if (!field.hasClass('t-hidden')) {
				self.fieldChanged(key);
			}
		}

		// Hide other field that are dependent on the field that are being hide
		field.on('onFieldHide', function() {
			self.hideSelf(key);
		});
	},

	bindAutocompleteFields: function(key) {

		var field = self.getTargetedField(key);
		var autocomplete = field.find('[data-field-suggest]');
		var accumulativeValue = [];

		// Get stored value
		var fieldName = field.data('name');
		var input = field.find(':input[name="' + fieldName + '[]"]');

		// Assign the stored value
		if (input.length > 0) {
			$.each(input, function(key, item) {
				var value = $(item).val();
				accumulativeValue.push(value);
			});
		}

		autocomplete.on('addItem', function(event, item) {
			accumulativeValue.push(item.value);
			self.fieldChanged(key, accumulativeValue);
		});

		autocomplete.on('removeItem', function(event, item) {
			accumulativeValue.splice($.inArray(item.value, accumulativeValue), 1);
			self.fieldChanged(key, accumulativeValue);
		});

		// Trigger initial page load
		if (!field.hasClass('t-hidden')) {
			self.fieldChanged(key, accumulativeValue);
		}

		// Re-check the current field value and determine if we should show or not the field
		field.on('onFieldShow', function() {
			self.fieldChanged(key, accumulativeValue);
		});
	},

	getRequiredChecking: function() {
		var data = $('[data-conditional-check]').val();

		if (data) {
			return JSON.parse(data);
		}

		return false;
	},

	fieldChanged: function(key, value) {

		// Get the latest value of the field
		if (!value) {
			var value = self.getTargetedFieldValue(key);
		}

		// Check conditions
		opts.result[key] = self.checkCondition(value, key);

		// Get the conditions logic
		var criteria = base.data('conditionsLogic');

		// Hide or show the field depending on the result
		if (opts.result) {
			var trueResult = true;

			$.each(opts.result, function(idx, result) {

				// OR criteria
				if (criteria == 'or') {

					// If there is one true, means everything is true
					if (result == true) {
						trueResult = true;
						return false;
					}
				}

				// AND criteria
				// All must be true in order to pass
				if (result == false) {
					trueResult = false;
				}
			});

			if (trueResult) {
				self.showSelf();
			} else {
				self.hideSelf();
			}
		}
	},

	checkCondition: function(value, key) {
		var condition = opts.conditionValue[key];
		var result = false;

		// format the value for special condition first
		value = self.formatValue(value, key);

		switch (opts.operator[key]) {
			case 'equal':

				if (self.isAutocomplete(key)) {
					$.each(value, function(idx, item) {
						if (item == condition) {
							result = true;
							return true;
						}
					});
				} else if (value == condition) {
					result = true;
				}
			break;

			case 'not equal':

				if (self.isAutocomplete(key)) {
					if (value.length > 0) {
						result = true;
						$.each(value, function(idx, item) {
							if (item == condition) {
								result = false;
								return true;
							}
						});
					}
				} else if (value != condition) {
					result = true;
				}
			break;

			case 'contain':
				if (self.isAutocomplete(key)) {
					$.each(value, function(idx, item) {
						result = new RegExp('\\b' + condition + '\\b', 'i').test(item);
					});
				} else {
					result = new RegExp( '\\b' + condition + '\\b', 'i').test(value);
				}
			break;
		}

		return result;
	},

	getTargetedFieldValue: function(key) {
		var field = self.getTargetedField(key);
		var fieldElement = self.getTargetedFieldElement(key);
		var inputs = field.find(':input');

		var value = [];
		var result = false;

		if (inputs.length > 0) {
			$.each(inputs, function() {
				var input = $(this);
				var type = input.attr('type');

				if (type != 'hidden') {
					switch (type) {
						case 'radio':
							radio = input.is(':checked') ? 1 : 0;

							// Only checked if the radio is selected, means that is the value
							if (radio) {
								value = input.val();
							}

						break;
						case 'checkbox':
							checkbox = input.is(':checked');

							if (checkbox) {
								value.push(input.val());
							}

						break;
						case 'button':
							// since button is not really an input, we need to check the hidden field instead
							var parent = input.parent();
							var inputButton = parent.find('input');

							if (inputButton.attr('type') == 'hidden') {
								value = inputButton.val();
							}
						break;
						default:
							if (input.val()) {
								value = input.val();
							}
						break;
					}
				}
			})
		}

		if ($.isArray(value)) {
			$.each(value, function(key, data) {
				result = result ? result + ' ' + data : data;
			})
		} else {
			result = value;
		}

		return result;
	},

	showSelf: function() {
		base.removeClass('t-hidden');
		base.trigger('onFieldShow');

		// Activate required field
		self.updateRequiredChecking(true);
	},

	hideSelf: function() {
		base.addClass('t-hidden');
		base.trigger('onFieldHide');

		// Disabled required field since the field is not visible on the form
		self.updateRequiredChecking(false);
	},

	updateRequiredChecking: function(operation) {
		// Get current required value
		var data = self.getRequiredChecking();

		if (data) {
			data[opts.id] = operation;
			data = JSON.stringify(data);

			$('[data-conditional-check]').val(data);
		}
	},

	isAutocomplete: function(key) {
		if (self.getTargetedFieldElement(key) == 'autocomplete') {
			return true;
		}

		return false;
	},

	getTargetedField: function(key) {
		var field = $('[data-field-item][data-id="' + opts.fieldTargeted[key] + '"]');

		return field;
	},

	getTargetedFieldElement: function(key) {
		var field = self.getTargetedField(key);
		return field.data('fieldItem');
	},

	formatValue: function(value, key) {

		var fieldElement = self.getTargetedFieldElement(key);

		var defaultGender = ["1", "2", "3"];

		// We check for gender male = 1 and female = 2 value
		if (fieldElement == 'gender' && value && $.inArray(value, defaultGender) >= 0) {
			value = value == "1" ? "male" : value == "3" ? "other" : "female";
		}

		return value;
	},

	formatConditionsValue: function(key) {
		var fieldElement = self.getTargetedFieldElement(key);

		// Properly check for gender value
		if (fieldElement == 'gender') {
			if (opts.conditionValue[key] == "1") {
				opts.conditionValue[key] = 'male';
			}

			if (opts.conditionValue[key] == "2") {
				opts.conditionValue[key] = 'female';
			}

			if (opts.conditionValue[key] == "3") {
				opts.conditionValue[key] = 'other';
			}
		}
	}
}});

module.resolve();
});
			EasySocial.module('shared/fields/validate', function ($) {

var module = this;
var isController = $.isController('EasySocial.Controller.Validator');

if (isController) {
	return;
}

EasySocial.Controller('Validator', {
	defaultOptions: {
		mode: null,
		checks: ['required', 'validate'],

		typeAttr: 'data-check-type',
		formatAttr: 'data-check-format',
		modifierAttr: 'data-check-modifier',
		errorTrigger: 'onError',
		submitTrigger: 'onSubmit',

		fieldSelector: '',

		'{container}': '[data-check]',
		'{notice}': '[data-check-notice]',
		'{required}': '[data-check-required]',
		'{validate}': '[data-check-validate]',
	}
}, function(self, opts) { return {
		// temporary variables
		vars: {},

		// Temporarily stored parents of containers
		parents: {},

		// register of elements returned by fields
		register: [],

		// deferreds return by elements
		deferreds: [],

		// errors return by elements
		errors: [],

		// state of validator
		state: $.Deferred(),

		init: function () {

		},

		reset: function() {
			self.vars = {};
			self.parents = {};

			self.register = [];
			self.deferreds = [];
			self.errors = [];

			self.state = $.Deferred();

			self.container().removeClass('error');
		},

		start: function() {
			self.reset();

			$.each(self.container(), function(i, container) {

				self.vars.container = container = $(container);
				self.parents.container = self.vars.container.parents(opts.fieldSelector);

				// Skip the checking for conditional field that are hidden from the form
				if (self.parents.container.data('isconditional') == "1" && self.parents.container.hasClass('t-hidden')) {
					return true;
				}

				container.trigger(self.options.submitTrigger, [self.register, self.options.mode]);

				$.each(self.getFields(), function(j, field) {
					self.vars.field = field = $(field);

					$.each(self.options.checks, function(i, check) {
						self.vars.check = check;

						self[check + 'Check']();
					});
				});
			});

			$.each(self.register, function(i, result) {
				if($.isDeferred(result)) {
					self.deferreds.push(result);
				} else if($.isPlainObject(result)) {
					$.each(result, function(key, value) {
						if(value === false) {
							self.errors.push(i);
							return true;
						}
					})
				} else {
					if(result === false) {
						self.errors.push(i);
						return true;
					}
				}
			});

			// If have static errors, then reject state
			if(self.errors.length > 0) {
				self.state.reject();
			} else {
				// If no static errors, then check if have deferreds
				if(self.deferreds.length > 0) {
					// This is because $.when accepts n amount of parameters instead of array, so we use .apply to pass in the array
					$.when.apply(null, self.deferreds)
						.done(function() {
							self.state.resolve();
						})
						.fail(function() {
							self.state.reject();
						});
				} else {
					// If no deferreds, then just resolve
					self.state.resolve();
				}
			}

			return self.state;
		},

		getFields: function() {
			return $.merge(self.vars.container.find(self.required.selector), self.vars.container.find(self.validate.selector));
		},

		requiredCheck: function() {
			if(self.vars.field.is(self.required.selector)) {
				var fieldType = self.vars.field.attr(self.options.typeAttr) || self.vars.field.attr('type') || 'text';

				if(fieldType === 'text' && $.trim(self.vars.field.val()) == '' ) {
					self.raiseError();
				}

				if(fieldType === 'checkbox' && self.vars.field.find('input[type="checkbox"]').filter(':checked').length < 1) {
					self.raiseError();
				}
			}
		},

		validateCheck: function() {
			if(self.vars.field.attr(self.options.formatAttr) !== undefined) {

				var value = self.vars.field.val();

				if($.isEmpty(value)) {
					return;
				}

				var format = self.vars.field.attr(self.options.formatAttr) || '';

				var modifier = self.vars.field.attr(self.options.modifierAttr) || '';

				var regex = new RegExp(format, modifier);

				if(!regex.test(value)) {
					self.raiseError();
				}
			}
		},

		raiseError: function () {
			self.vars.container.addClass('has-error');

			self.vars.container.trigger(self.options.errorTrigger, [self.vars.check, self.vars.field]);

			self.register.push(false);
		}
	};
});

// Apply $('xxx').validate
$.fn.validate = function(options) {
	var element = this;

	if (element.length > 0) {
		var controller = this.addController("EasySocial.Controller.Validator", options);

		return controller.start();
	}

	return false;
};

module.resolve();
});
			EasySocial.module('shared/popdown', function($){

var module = this;

$(document)
	.on('click.data.popdown', '[data-popdown-option]', function(event) {
		
		event.preventDefault();

		var option = $(this);
		var optionHtml = option.find('>a').html();
		var tmpl = $(optionHtml).clone();

		var popdown = option.parents('[data-popdown]');
		var value = option.data('popdown-option');
		var active = popdown.find('[data-popdown-active]');
		var input = popdown.find('input[type=hidden]');

		// Set the current option as active
		popdown.find('[data-popdown-option]').removeClass('active');
		option.addClass('active');

		active.html(tmpl);
		input.val(value);
	});



module.resolve();
});
			EasySocial.module("shared/privacy", function($){

var module	= this;

EasySocial.require()
.library("textboxlist")
.done(function($) {

	// Implement privacy button upon clicking on the button
	$(document).on('click.es.privacy',  '[data-es-privacy-form]', function() {

		var button = $(this);
		var controller = "EasySocial.Controller.Privacy.Form";

		// If controller is already implemented on the button, just skip implementation
		if (button.hasController(controller)) {
			return;
		}

		// Run the toggle.
		button.addController(controller).toggle();
	});

	EasySocial.Controller('Privacy.Form', {
		defaultOptions: {
			// The anchor button
			"{button}": "[data-privacy-toggle]",

			"{menu}": "[data-privacy-menu]",
			"{item}": "[data-privacy-menu] > [data-item]",

			// Display
			"{icon}": "[data-privacy-toggle] > [data-privacy-icon]",
			"{label}": "[data-privacy-toggle] > [data-label]",
			"{tooltip}": "[data-original-title]",
			"{key}": "[data-privacy-hidden]"
		}
	}, function(self, opts) { return {

		init: function() {

			// Get the save mode
			opts.mode = self.element.data('mode');

			self.instanceId = $.uid();
			self.addPlugin("custom");
			self.addPlugin("field");
		},

		getData: function(item) {
			var data = $._.pick(item.data(), "uid", "type", "value", "pid", "streamid", "pitemid", "userid");

			data.icon = item.data('privacy-icon');
			data.label = item.find('[data-label]').text();

			return data;
		},


		toggle: function() {

			var isActive = self.element.hasClass("active");
			self[(isActive) ? "deactivate" : "activate"]();
		},

		activate: function() {

			self.element.addClass("active");

			self.trigger("activate", [self]);
			$(window).trigger("activatePrivacy", [self]);

			var windowClick = "click.privacy." + self.instanceId;

			$(document).on(windowClick, function(event){

				var clickedTarget = $(event.target);

				// Don't do anything if we're clicking ourself
				if (clickedTarget.parents().andSelf().filter(self.element).length > 0
					|| clickedTarget.parents('[data-textboxlist-autocomplete]').length > 0
					|| clickedTarget.parents('[data-textboxlist-item]').length > 0 )
				{
					return;
				}

				$(document).off(windowClick);
				self.deactivate();
			});
		},

		deactivate: function() {
			// Remove active class
			self.element.removeClass("active");

			self.trigger("deactivateAllPrivacy", [self]);
			$(window).trigger("deactivatePrivacy", [self]);
		},

		save: function(data) {

			// Set privacy value
			self.key().val(data.value);

			// Update the display
			self.icon().attr("class", data.icon);
			self.label().html(data.label);

			// Trigger save event
			self.trigger("privacySave", [data]);

			// If saving is done via ajax, save now.
			if (opts.mode == "ajax") {
				EasySocial.ajax("site/controllers/privacy/update", {
					uid 	: data.uid,
					utype	: data.type,
					value 	: data.value,
					pid 	: data.pid,
					custom 	: data.custom,
					field	: data.field,
					streamid: data.streamid,
					userid	: data.userid,
					pitemid	: data.pitemid
				}).done(function(tooltips){
					// Update the tooltip for ajax mode
					if (tooltips) {
						self.element.attr('data-original-title', tooltips);
						self.element.tooltip();
					}
				});
			}
		},

		"{self} click" : function(el, event) {

			var target = $(event.target);
			var button = self.button();

			// If the area being clicked is within the toggle button, we should display the options
			if (target.parents().andSelf().filter(button).length > 0) {
				self.toggle();
			}
		},

		"{item} click" : function(item) {

			// Retrieve data from this privacy item
			var data = self.getData(item);

			// Trigger privacy changed event
			self.trigger("privacyChange", [data]);

			if (!data.preventSave) {

				self.save(data);
				self.deactivate();
			}
		},

		"{self} privacyChange": function(el, event, data) {

			// Deactivate other privacy item
			self.item().removeClass("active");
			self.item('[data-value=' + data.value + ']').addClass('active');
		},

		"{window} activatePrivacy": function(el, event, instance) {
			if (instance!==self) {
				self.deactivate();
			}
		}
	}});


	EasySocial.Controller("Privacy.Form.Custom", {
		defaultOptions: {
			"{textField}" : "[data-textfield]",
			"{saveButton}": "[data-save-button]",
			"{cancelButton}": "[data-cancel-button]",
			"{customItem}": "[data-item][data-value=custom]",
			"{customKey}": "[data-privacy-custom-hidden]",
			"{notice}": "[data-privacy-custom-notice]"
		}
	}, function(self) { return {

		init: function() {

			self.textField()
				.textboxlist({
					component: 'es',
					unique: true,
					plugin: {
						autocomplete: {
							exclusive: true,
							minLength: 1,
							cache: false,
							query: function(keyword) {
								var users = self.getIds();
								var ajax = EasySocial.ajax("site/views/privacy/getfriends", {
															"q": keyword,
															"exclude": users
											});

								return ajax;
							}
						}
					}
				});

			self.textboxlist = self.textField().controller("TextboxList");
		},

		getIds: function() {

			var items = self.textField().textboxlist("controller").getAddedItems();

			return $.map(items, function(item, idx) {
				return item.id;
			});
		},

		updateIds: function() {

			// lets update the notice message.
			if (!self.notice().hasClass('t-hidden')) {
				self.notice().addClass('t-hidden');
			}

			var ids = self.getIds();
			self.customKey().val(ids.join(","));
		},

		"{parent} privacyChange": function(el, event, data) {

			var isCustomPrivacy = (data.value=="custom");

			self.element.toggleClass("custom-privacy", isCustomPrivacy);

			// If user no longer selects custom privacy
			if (!isCustomPrivacy) {

				// Clear any existing custom privacy
				self.textField()
					.textboxlist("controller")
					.clearItems();
			} else {

				// Prevent privacy from saving
				data.preventSave = true;
			}
		},

		"{parent} privacySave": function(el, event, data) {
			// for now do nothing.
		},

		"{parent} deactivateAllPrivacy": function(el, event) {
			self.textboxlist.autocomplete.hide();
		},

		"{cancelButton} click" : function(){
			self.element.removeClass("custom-privacy");
			self.textboxlist.autocomplete.hide();
		},

		"{saveButton} click" : function(){

			var parent = self.parent;
			var customItem = self.customItem();
			var data = parent.getData(customItem);
			var value = self.customKey().val().trim();

			if (value == "") {
				self.notice().removeClass('t-hidden');
				return false;
			}

			data.custom = value;

			self.parent.save(data);
			self.parent.deactivate();
		},

		// event listener for adding new name
		"{textField} addItem": function() {
			self.updateIds();
		},

		// event listener for removing name
		"{textField} removeItem": function() {
			self.updateIds();
		}
	}});

	EasySocial.Controller("Privacy.Form.Field", {
		defaultOptions: {
			"{saveButton}": "[data-save-button]",
			"{cancelButton}": "[data-cancel-button]",
			"{fieldItem}": "[data-item][data-value=field]",
			"{fieldKey}": "[data-privacy-field-hidden]",
			"{inputs}": "[data-privacy-field-inputs]",
			"{notice}": "[data-privacy-field-notice]"
		}
	}, function(self) { return {

		init: function() {

		},

		updateIds: function() {

			var ids = self.getIds();
			self.customKey().val(ids.join(","));
		},

		"{parent} privacyChange": function(el, event, data) {

			var isFieldPrivacy = (data.value=="field");

			self.element.toggleClass("field-privacy", isFieldPrivacy);

			// If user no longer selects custom privacy
			if (isFieldPrivacy) {

				// Prevent privacy from saving
				data.preventSave = true;
			}
		},

		"{parent} privacySave": function(el, event, data) {
			// for now do nothing.
		},

		"{parent} deactivateAllPrivacy": function(el, event) {
			// for now do nothing.
		},

		"{cancelButton} click" : function(){

			self.notice().addClass('t-hidden');
			self.element.removeClass("field-privacy");
		},

		"{saveButton} click" : function(){

			var parent = self.parent;
			var fieldItem = self.fieldItem();
			var data = parent.getData(fieldItem);

			var hasValue = false;
			var tmp = [];

			self.inputs().each(function(idx, ele) {
				var select = $(ele);
				var key = select.attr('name');
				var values = select.val();

				if (values) {
					hasValue = true;
					key = key + '|' + values.join(',');
					tmp.push(key);
				}
			});

			if (! hasValue) {
				self.notice().removeClass('t-hidden');
				return false;
			}

			var value = tmp.join(';');
			data.field = value;

			self.parent.save(data);
			self.parent.deactivate();
		}
	}});

	module.resolve();
});

});
			EasySocial.module('shared/responsive', function($){

var module = this;

$(document)
	.on('click.es.sidebar.toggle', '[data-es-sidebar-toggle]', function() {
		// Locate the closest container
		var button = $(this);
		var container = button.siblings('[data-es-container]');

		if (container.length <= 0) {
			return;
		}

		container.toggleClass('sidebar-open');
	});

$(document).on("click.es.sidebar", "[data-sidebar-toggle]", function(){

	// Prefer sidebar from siblings
	var button = $(this);
	var selector = "[data-sidebar]";
	var sidebar = button.siblings(selector);

	// If not find closest sidebar
	if (sidebar.length < 1) {
		sidebar = button.closest(selector);
	}

	// If not find any sidebar
	if (sidebar.length < 1) {
		sidebar = $(selector);
	}

	sidebar
		.toggleClass("sidebar-open")
		.trigger("sidebarToggle");

});


// Simulate the responsive toggle button click.
$(document).on("onEasySocialFilterClick", function(){

	// lets check if this is viewing with mobile app or not. if yes, we
	// do not process further.
	var mobileWrappr = $("[data-es-mobile-wrapper]");
	if (mobileWrappr.length > 0) {
		return;
	}

	var container = $("[data-es-sidebar-toggle]").siblings('[data-es-container]');

	if (container.length <= 0) {
		return;
	}

	if (container.hasClass('sidebar-open')) {
		container.removeClass('sidebar-open');
	}
});



module.resolve();

});
			EasySocial.module('shared/sidebarmenu', function($) {

var module = this;
var isController = $.isController('EasySocial.Controller.Sidebarmenu');

if (isController) {
	return;
}

EasySocial.Controller('Sidebarmenu', {
	defaultOptions: {
		mainmenu: null,
		viewOpenClass: 'dl-subviewopen',
		subViewClass: 'dl-subview',
		animate: true,
		"{subMenuLink}" : "[data-submenu-link]",
		"{subMenuBack}" : "[data-submenu-back]"
	}
}, function(self, opts, base) { return {
	
	init: function() {
	},

	open: function(element) {
		var parent = element.parent('li');
		var submenu = parent.children('ul');

		self.animate('open', submenu).done(function() {

			// Change all of the dl-subviewopen to dl-subview first
			base.find('.dl-subviewopen').addClass(opts.subViewClass).removeClass(opts.viewOpenClass);

			parent.removeClass(opts.subViewClass).addClass(opts.viewOpenClass);
		});
	},

	close: function(submenu) {
		var parent = submenu.parent('li');
		parent.removeClass(opts.viewOpenClass);

		var main = parent.parent('ul');
		main.parent('li').removeClass(opts.subViewClass).addClass(opts.viewOpenClass);

		self.animate('close', submenu, main).done(function() {

			if (main.attr('data-sidebar-menu') !== undefined) {
				main.removeClass(opts.subViewClass);
			}
		});
	},

	animate: function(operation, submenu, main) {

		if (main !== undefined && main.attr('data-sidebar-menu') !== undefined) {
			base.removeClass(opts.subViewClass);
		}

		// Simulate the opposite effect
		if (opts.animate) {
			var dfd1 = $.Deferred(),
				dfd2 = $.Deferred();

			operation1 = operation == 'open' ? 'out' : 'in';
			operation2 = operation == 'open' ? 'in' : 'out';

			var subMenuClone = submenu.clone();

			subMenuClone.find('ul').remove();
			base.after(subMenuClone);
			base.addClass('dl-animate-' + operation1 + '-1');

			// Wait 0.3 second
			setTimeout(function() {
				base.addClass(opts.subViewClass).removeClass('dl-animate-' + operation1 + '-1');

				dfd1.resolve();
			}, 300);

			// Sub menu transition
			subMenuClone.addClass('dl-animate-' + operation2 + '-1');

			if (operation2 == 'in') {
				subMenuClone.css('opacity', '0');
			}

			// Wait 0.3 second
			setTimeout(function() {
				subMenuClone.removeClass('dl-animate-' + operation2 + '-1');
				subMenuClone.remove();

				dfd2.resolve();
			}, 300);

			// Return when the animation is finished
			return $.when(dfd1, dfd2).done(function() {
			}).promise();
		} else {
			var dfd = $.Deferred();

			base.addClass(opts.subViewClass);

			dfd.resolve();

			return dfd;
		}
	},

	"{subMenuLink} click": function(element, event) {
		event.preventDefault();
		event.stopPropagation();

		// Open submenu
		self.open(element);
	},

	"{subMenuBack} click": function(element, event) {
		event.preventDefault();
		event.stopPropagation();

		var parent = element.parent('ul');

		// Close submenu
		self.close(parent);
	},
}});

module.resolve();
});			EasySocial.module( 'uploader/item' , function($){

	var module 	= this;

	EasySocial.require()
	.view( 'site/uploader/preview' )
	.done( function($){

		EasySocial.Controller(
			'Uploader.Item',
			{
				defaults:
				{
					"{uploadItem}" : ".uploadItem",
					"{uploadItemPreview}" : ".uploadItem.preview a.itemLink",

					// Actions
					"{itemLink}"		: '.itemLink',
					"{itemDelete}"		: '.itemDelete',

					view: {

						preview : 'site/uploader/preview'

					}
				}
			},
			function( self ){ return {

				init: function(){

				},

				"{itemDelete} click": function( el ){

					var id 		= $( el ).data( 'id' );

					EasySocial.ajax( 'site:/controllers/uploader/delete' , {
						'id'	: id
					}, function(){

						// Remove the item from the list
						$( el ).parents( 'li.uploadItem' ).remove();
					})
				},

				"{uploadItemPreview} click" : function( el ){

					var uri 	= $( el ).data( 'uri' ),
						title 	= $( el ).data( 'title' );

					$.dialog({
						title: title,
						content: $.Image.get(uri)
					});





					// $.dialog({
					// 	'title'		: title,
					// 	'content'	: content,
					// 	afterShow	: function(){

					// 		$.dialog().update();

					// 	}
					// });
				}

			} }
		);
	});

	module.resolve();
});
			EasySocial.module('uploader/queue', function($){

var module = this;

EasySocial.require()
.done(function($){

	EasySocial.Controller('Uploader.Queue', {
		defaults: {
				"{item}": "[data-uploaderQueue-item]"
			}
		}, function(self) {

			return {
				init: function() {
					self.item().implement(EasySocial.Controller.Uploader.Queue.Item);
				}
			}
		}
	);

	EasySocial.Controller( 'Uploader.Queue.Item', {
		defaultOptions: {
			"{delete}"	: "[data-uploaderQueue-remove]",
			"{progress}": "[data-uploaderQueue-progress]",
			"{progressBar}" : "[data-uploaderQueue-progressBar]",
			"{status}"		: "[data-uploaderQueue-status]",
			"{id}"			: "[data-uploaderQueue-id]"
		}
	}, function(self, opts) { return {
		
		init : function() {

			// Store it as template and remove it
			if (self.uploader.options.temporaryUpload) {
				self.idTemplate = self.id().toHTML();
				self.id().remove();
			}
		},

		"{delete} click": function() {
			self.uploader.removeItem( self.element.attr( 'id' ) );
		},

		"{self} FileUploaded": function(el, event, file, response) {

			if (self.uploader.options.temporaryUpload) {
				// Create a hidden input containing the id
				$.buildHTML(self.idTemplate)
					.val(response.id)
					.appendTo(self.element);
			}

			if (file.status == 5) {
				self.element.removeClass("is-queue").addClass( 'is-done' );
			}
		},

		"{self} UploadProgress": function(el, event, progress) {

			self.status().html(progress.percent + '%');
			self.progressBar().css('width' , progress.percent + '%');
		},

		"{self} FileError": function() {
			self.element.removeClass("is-done is-queue").addClass("is-error");

			self.progress()
				.removeClass("progress-danger progress-success progress-info progress-warning")
				.addClass("progress-danger");

			self.status().html('Error');
		}
	}});

	module.resolve();
});

});
			EasySocial.module('uploader/uploader', function($){

var module = this;

EasySocial.require()
.library('plupload')
.script('uploader/queue')
.done(function() {

EasySocial.Controller('Uploader', {
	defaults: {

		url: $.indexUrl + '?option=com_easysocial&controller=uploader&task=uploadTemporary&format=json&tmpl=component&' + EasySocial.token() + '=1',
		uploaded: [],

		// Allows caller to define their custom query.
		query: "",

		plupload: '',
		dropArea: 'uploaderDragDrop',
		extensionsAllowed: 'jpg,jpeg,png,gif',

		// Determines if we should upload the file first or not
		temporaryUpload: false,

		// Contains a list of files in the queue so others can manipulate this.
		files: [],

		'{uploaderForm}': '[data-uploader-form]',
		'{uploadButton}': '[data-uploader-browse]',
		'{uploadArea}': '.uploadArea',

		// This contains the file list queue.
		'{queue}': '[data-uploaderQueue]',

		// The queue item.
		'{queueItem}': '[data-uploaderQueue-item]',

		// When the queue doesn't have any item, this is the container.
		'{emptyFiles}': '[data-uploader-empty]',

		// This is the file removal link.
		'{removeFile}': '[data-uploaderQueue-remove]',
		'{uploadCounter}': '.uploadCounter',
	}
}, function(self, opts, base) { return {

	init: function(){

		// Implement the uploader queue.
		self.queue().implement(EasySocial.Controller.Uploader.Queue);

		if (opts.temporaryUpload) {
			opts.url = $.indexUrl + '?option=com_easysocial&controller=uploader&task=uploadTemporary&format=json&tmpl=component&' + EasySocial.token() + '=1';
		}

		if (opts.query != '') {
			opts.url = opts.url + '&' + opts.query;
		}

		// Implement the plupload controller on the upload form
		self.uploaderForm().implement('plupload', {
			settings: {
				url: opts.url,
				drop_element: opts.dropArea,
				filters: [{
					title: 'Allowed File Type',
					extensions: opts.extensionsAllowed
				}]
			},
			'{uploader}': '[data-uploader-form]',
			'{uploadButton}': '[data-uploader-browse]'
		}, function() {
			// Get the plupload options
			opts.plupload = this.plupload;
		});
	},


	createFileItem: function(files) {

		$.each(files, function(index, file) {

			if (self.getItem(file)) {
				return;
			}

			// Get the file size.
			file.size = self.formatSize(file.size);

			var queueTemplate = $('[data-uploaderQueue-item-template]');
			var content = queueTemplate.clone();

			content.removeClass('t-hidden');

			content.removeAttr('data-uploaderQueue-item-template');
			content.attr('id', file.id);
			content.find('[data-filename]').text(file.name);
			content.find('[data-filesize]').text(file.size);

			// Implement the queue item controller.
			$(content).implement(EasySocial.Controller.Uploader.Queue.Item, {
				"{uploader}": self
			});

			// Keep a copy of the item in our registry
			self.items[file.id] = content;

			// Add this item into our own queue.
			opts.files.push(file);

			// Hide the "No files" value
			self.emptyFiles().hide();

			// Append the queue item into the queue
			self.queue().append(content);
		});
	},

	/**
	 * Formats the size in bytes into kilobytes.
	 */
	formatSize: function(bytes) {

		// @TODO: Currently this only converts bytes to kilobytes.
		var val = parseInt( bytes / 1024 );

		return val;
	},

	// Remove the item from the list.
	reset: function() {

		// self.queueItem().remove();
		$("[data-uploaderQueue-item].is-done").remove();
	},

	removeItem: function(id) {
		var element = $('#' + id);

		// When an item is removed, we need to send an ajax call to the server to delete this record
		var uploaderId = $(element).find('input[name=upload-id\\[\\]]').val();

		element.remove();

		if (!uploaderId) {
			self.options.plupload.removeFile(self.options.plupload.getFile(id));

			return;
		}

		EasySocial.ajax('site/controllers/uploader/delete' , { "id" : uploaderId })
		.done(function() {
			// Now remove the item from the plupload queue.
			self.options.plupload.removeFile( self.options.plupload.getFile( id ) );
		});

		delete self.items[id];
	},

	startUpload: function() {
		self.upload();
	},

	upload: function() {

		if (self.options.plupload.files.length > 0) {
			self.options.uploading 	= true;
			self.options.plupload.start();
		}
	},

	 hasFiles: function(){
		return self.options.files.length > 0;
	 },

	"{uploaderForm} FilesAdded": function(el, event, uploader, files ) {
		// Add a file to the queue when files are selected.
		self.createFileItem(files);

		// Begin the upload immediately if needed
		if (opts.temporaryUpload) {
			self.startUpload();
		}
	},

	items: {},

	getItem: function(file) {
		var id;

		// By id
		if ($.isString(file)) {
			id = file;
		}

		// By file object
		if (file && file.id) {
			id = file.id;
		}

		return self.items[id];
	},

	"{uploaderForm} UploadProgress" : function(el, event, uploader, file) {
		if (file) {
			self.queueItem('#' + file.id)
				.trigger('UploadProgress', file);
		}

	},

	'{uploaderForm} FileUploaded' : function( el , event, uploader, file , response ){
		self.queueItem('#' + file.id)
			.trigger('FileUploaded', [file , response]);
	},

	"{uploaderForm} UploadComplete" : function(el, event , uploader , files) {
		self.options.uploading 	= false;
	},

	'{uploaderForm} Error': function(el, event, uploader, error) {
		// Clear previous message
		self.clearMessage();

		var obj = { 'message' : error.message , 'type' : 'error' };

		self.setMessage( obj );
	},

	'{uploaderForm} FileError': function(el, event, uploader, file, response) {
		var obj = { 'message' : response.message , 'type' : 'error' };

		self.setMessage(obj);

		self.queueItem( '#' + file.id ).trigger('FileError', [file, response]);
	}
}});

module.resolve();

});


});
			EasySocial.require()
.script(
	'admin/api/tabs',
	'admin/vendors/uniform',
	'admin/grid/grid',
	'shared/responsive',
	'shared/elements',
	'shared/popdown',
	'shared/privacy'
)
.library(
	'dialog',
	'select2'
).done(function($){

	// Once uniform.js is implemented, we want to apply uniform to the elements.
	$(".uniform, input:file[data-uniform], .usergroups :checkbox").uniform();

	$('[data-es-app-side-toogle]').on('click', function() {
		$('[data-es-app]').toggleClass('is-sidebar-close');
	});

	$('[data-sidebar-menu-toggle]').on('click' , function() {
		var parent = $(this).parent('li');
		var child = parent.find('ul');
		var isActive = $(this).parent('li').hasClass('active');

		if (isActive) {
			parent.removeClass( 'active' );
			child.removeClass( 'in' );
		} else {
			parent.addClass( 'active' );
			child.addClass( 'in' );
		}
	});

	$('[data-table-grid-filter]').select2({
		'theme': 'backend',
		'width': 'resolve',
		'minimumResultsForSearch': Infinity
	});

	$('[data-table-grid-filter]').on('select2:open', function() {
		$('body').addClass('has-select2-dropdown');
	});

	$('[data-table-grid-filter]').on('select2:close', function() {
		$('body').removeClass('has-select2-dropdown');
	});

	EasySocial.compareVersion = function(version1, version2) {
		var nRes = 0;
		var parts1 = version1.split('.');
		var parts2 = version2.split('.');
		var nLen = Math.max(parts1.length, parts2.length);

		for (var i = 0; i < nLen; i++) {
			var nP1 = (i < parts1.length) ? parseInt(parts1[i], 10) : 0;
			var nP2 = (i < parts2.length) ? parseInt(parts2[i], 10) : 0;

			if (isNaN(nP1)) { 
				nP1 = 0; 
			}
			
			if (isNaN(nP2)) { 
				nP2 = 0; 
			}

			if (nP1 != nP2) {
				nRes = (nP1 > nP2) ? 1 : -1;
				break;
			}
		}

		return nRes;
	}

	// Implement grid
	var table = $('[data-table-grid]');

	if (table.length > 0) {
		table.implement(EasySocial.Controller.Grid);
	}
});			EasySocial.module('admin/api/tabs', function($) {

var module = this;


// Add active tab state
$(document)
	.on('click.tabs.active', '[data-es-form-tabs] [data-item]', function() {
		var hidden = $('[data-tab-active]');

		if (hidden.length <= 0) {
			return;
		}

		var selected = $(this).data('item');

		hidden.val(selected);

	});


module.resolve();

});
			EasySocial.module('admin/api/toolbar', function($) {

var module = this;


// Toolbar actions
var joomlaToolbar = $('#toolbar');
var actions = $('[data-toolbar-actions]');

if (actions.length > 0) {
	actions.each(function() {
		var buttonGroup = $(this);
		var position = buttonGroup.data('position') || 'append';

		buttonGroup.removeClass('t-hidden');

		if (position == 'append') {
			buttonGroup.appendTo(joomlaToolbar);
		} else {
			buttonGroup.prependTo(joomlaToolbar);
		}

		// Bind all the actions in this button group
		buttonGroup.find('[data-action]').each(function() {
			var element = $(this);
			var action = element.data('action');

			element.on('click', function() {
				Joomla.submitbutton(action);
			});
		});
	});
}

module.resolve();

});
			EasySocial.module('admin/apps/store', function($) {

var module = this;

EasySocial.Controller('Apps.Store', {
	"defaultOptions": {
		"{item}": "[data-app-item]",
		"{install}": "[data-app-install]"
	}
}, function(self, opts, base) { return {

	init: function() {
	},

	getItem: function(element) {
		return element.closest(self.item.selector);
	},

	"{install} click": function(button, event) {
		var item = self.getItem(button);
		var payment = button.data('payment') == 1;
		var external = button.data('app-install') == "external";

		EasySocial.dialog({
			"content": EasySocial.ajax('admin/views/store/confirmation', {
				"id": item.data('id')
			})
		});
	}
}});

module.resolve();

});			EasySocial.module('admin/clusters/users', function($) {

var module = this;

EasySocial.Controller('Clusters.Users', {
	defaultOptions: {
		clusterid: null,
		clustertype: "",

		'{addMember}': '[data-cluster-add-member]',
		'{removeMember}': '[data-cluster-remove-member]',
		'{approveMember}': '[data-cluster-approve-member]',
		'{promoteMember}': '[data-cluster-promote-member]',
		'{demoteMember}': '[data-cluster-demote-member]'
	}
}, function(self, opts) { return {

	'{addMember} click': function(el, ev) {
		var members = {};

		// This is callback from the selected items
		window.addMembers = function(obj) {
			if (obj.state) {
				members[obj.id] = obj;
			} else {
				delete members[obj.id];
			}
		};

		EasySocial.dialog({
			content: EasySocial.ajax('admin/views/' + opts.clustertype + '/addMembers', {"id":opts.clusterid}),
			bindings: {
				'{submitButton} click': function() {

					var form = $('[data-form-add-members]');
					var input = form.find('[data-ids]');
					var ids = [];

					$.each(members, function(i, member) {
						ids.push(member.id);
					});

					input.val(JSON.stringify(ids));

					$('[data-form-add-members]').submit();

				}
			}
		});
	},

	'{removeMember} click': function(el, ev) {
		if(document.adminForm.boxchecked.value == 0) {
			alert(opts.error.empty);
		} else {
			$.Joomla('submitform', ['removeMembers']);
		}
	},

	'{approveMember} click': function(el, ev) {
		if(document.adminForm.boxchecked.value == 0) {
			alert(opts.error.empty);
		} else {
			$.Joomla('submitform', ['publishUser']);
		}
	},

	'{promoteMember} click': function(el, ev) {
		if(document.adminForm.boxchecked.value == 0) {
			alert(opts.error.empty);
		} else {
			$.Joomla('submitform', ['promoteMembers']);
		}
	},

	'{demoteMember} click': function(el, ev) {
		if(document.adminForm.boxchecked.value == 0) {
			alert(opts.error.empty);
		} else {
			$.Joomla('submitform', ['demoteMembers']);
		}
	}
}});

module.resolve();
});
			EasySocial.module('admin/discovery/discovery', function($) {

var module = this;

EasySocial.require()
.script('admin/progress/progress')
.done(function($) {

EasySocial.Controller('Admin.Discovery', {
	"defaultOptions": {
		
		"files": [],
		"namespace": "",
		"progressController": null,

		"{progress}": "[data-progress]",
		"{result}": "[data-discovery-result]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// Implement progress bar
		opts.progressController = self.progress().addController(EasySocial.Controller.Progress);

		$.Joomla('submitbutton', function(task) {

			if (task == 'discover') {
				self.start();
			}

			return;
		});
	},

	start: function() {

		// Reset the logs
		self.reset();

		// Discover the list of files.
		EasySocial.ajax(opts.namespaces.discover, {

		}).done(function(files, message) {

			// Set the files to the properties.
			opts.files = files;

			if (opts.files.length > 0) {

				opts.progressController.begin(opts.files.length);

				self.log(message);

				// Begin to loop through each files.
				self.startIterating();
			
			} else {
				opts.progressController.begin(1);
				opts.progressController.completed('Discover Completed');

				self.log(opts.messages.completed);
			}
		});
	},

	// Resets the scan.
	reset: function() {
		self.result().empty();

		// Reset progress bar.
		self.options.progressController.reset();
	},

	log: function(message) {
		$('<tr>').append( $( '<td>' ).html( message ) ).appendTo(self.result());
	},

	startIterating: function() {
		
		// Get the file from the shelf
		var file = opts.files.shift();

		EasySocial.ajax(opts.namespaces.install, {
			"file": file
		}).done(function(message) {

			opts.progressController.touch('...');
			self.log(message);

			// As long as the files list are not empty yet, we still need to process it.
			if (opts.files.length > 0) {
				self.startIterating();
			} else {
				self.log(opts.messages.completed);
			}
		});
	}
}});

module.resolve();

});

});
			EasySocial.module('admin/events/approveRecurring', function($) {
    var module = this;

    EasySocial.Controller('Events.ApproveRecurring', {
        defaultOptions: {
            postdatas: {},
            schedules: {},
            eventids: [],

            '{progress}': '[data-progress-bar]',

            '{form}': '[data-form]'
        }
    }, function(self) {
        return {
            init: function() {
                // Calculate the total things to do
                var length = 0;

                $.each(self.options.schedules, function(i, s) {
                    length += s.length;
                });

                self.total = length;

                self.startCreate();
            },

            total: 0,
            doneCounter: 0,
            eventCounter: 0,
            createCounter: 0,

            updateProgressBar: function() {
                var percentage = Math.ceil((self.doneCounter / self.total) * 100);

                self.progress().css({
                    width: percentage + '%'
                });
            },

            startCreate: function() {
                if (self.options.eventids[self.eventCounter] === undefined) {
                    return self.completed();
                }

                self.create()
                    .done(function() {
                        self.doneCounter++;

                        self.createCounter++;

                        if (self.options.schedules[self.options.eventids[self.eventCounter]][self.createCounter] === undefined) {
                            self.eventCounter++;
                            self.createCounter = 0;
                        }

                        self.updateProgressBar();

                        self.startCreate();
                    })
                    .fail(function(msg, errors) {
                        console.log(msg, errors);
                    });
            },

            create: function() {
                var eventId = self.options.eventids[self.eventCounter],
                    datetime = self.options.schedules[eventId][self.createCounter],
                    postdata = self.options.postdatas[eventId];

                return EasySocial.ajax('admin/controllers/events/createRecurring', {
                    eventId: eventId,
                    datetime: datetime,
                    postdata: postdata
                });
            },

            completed: function() {
                self.progress().parent().removeClass('progress-info').addClass('progress-success');
                self.form().submit();
            }
        }
    });

    module.resolve();
});
			EasySocial.module('admin/events/events' , function($) {

	var module = this;

	EasySocial
	.require()
	.library('expanding')
	.done(function($)
	{
		EasySocial.Controller(
			'Events.Pending.Item',
			{
				defaultOptions:
				{
					"{approve}" : "[data-pending-approve]",
					"{reject}"	: "[data-pending-reject]"
				}
			},
			function(self) {
				return {
					init: function()
					{
						self.options.id = self.element.data('id');
					},

					"{approve} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax('admin/views/events/approveEvent' , { "ids" : self.options.id })
						});
					},

					"{reject} click" : function()
					{
						EasySocial.dialog(
						{
							content		: EasySocial.ajax('admin/views/events/rejectEvent' , { "ids" : self.options.id })
						});
					}
				}
			});

		module.resolve();
	});

});			EasySocial.module('admin/events/store', function($) {
    var module = this;

    EasySocial.Controller('Events.Update', {
        defaultOptions: {
            postdata: {},
            updateids: [],
            schedule: [],
            eventId: null,
            totalRecurringEvents: 0,
            isNew: 0,

            '{progress}': '[data-progress-bar]',
            '{form}': '[data-form]'
        }
    }, function(self) {
        return {
            init: function() {
                self.startUpdate();
            },

            updateCounter: 0,
            createCounter: 0,
            isNewEvent: 0,

            updateProgressBar: function() {
                var percentage = Math.ceil(((self.updateCounter + self.createCounter) / (self.options.updateids.length + self.options.schedule.length)) * 100);

                self.progress().css({
                    width: percentage + '%'
                });
            },

            startUpdate: function() {
                if (self.options.updateids[self.updateCounter] === undefined) {
                    return self.startCreate();
                }

                self.update(self.options.updateids[self.updateCounter])
                    .done(function() {
                        self.updateCounter++;

                        self.updateProgressBar();

                        self.startUpdate();
                    })
                    .fail(function(msg, errors) {
                        console.log(msg, errors);
                    });
            },

            update: function(id) {

                var isLastRecurringEvent = 0;

                // determine which recurring event process now
                var currentRecurringCounter = self.updateCounter + 1;

                // determine if this recurring proceed the last event
                if (currentRecurringCounter == self.options.updateids.length) {
                    var isLastRecurringEvent = 1;
                }

                self.isNewEvent = self.options.isNew;

                var post = $.extend({}, self.options.postdata, {
                    id: id,
                    applyRecurring: 1,
                    isLastRecurringEvent: isLastRecurringEvent,
                    isNew: self.isNewEvent
                });

                return EasySocial.ajax('admin/controllers/events/store', post);
            },

            startCreate: function() {
                if (self.options.schedule[self.createCounter] === undefined) {
                    return self.completed();
                }

                self.create(self.options.schedule[self.createCounter])
                    .done(function() {
                        self.createCounter++;

                        self.updateProgressBar();

                        self.startCreate();
                    })
                    .fail(function(msg, errors) {
                        console.log(msg, errors);
                    });
            },

            create: function(datetime) {

                var isLastRecurringEvent = 0;

                // determine which recurring event process now
                var currentRecurringCounter = self.createCounter + 1;

                // determine if this recurring proceed the last event
                if (currentRecurringCounter == self.options.totalRecurringEvents) {
                    var isLastRecurringEvent = 1;
                }

                self.isNewEvent = self.options.isNew;

                return EasySocial.ajax('admin/controllers/events/createRecurring', {
                    eventId: self.options.eventId,
                    datetime: datetime,
                    postdata: self.options.postdata,
                    isLastRecurringEvent: isLastRecurringEvent,
                    isNew: self.isNewEvent
                });
            },

            completed: function() {
                self.progress().parent().removeClass('progress-info').addClass('progress-success');
                self.form().submit();
            }
        }
    });

    module.resolve();
});
			EasySocial.module('admin/events/users', function($) {
var module = this;

EasySocial.Controller('Events.Users', {
	defaultOptions: {
		eventid: null,

		'{inviteGuest}': '[data-event-invite-guest]',
		'{removeGuest}': '[data-event-remove-guest]',
		'{approveGuest}': '[data-event-approve-guest]',
		'{promoteGuest}': '[data-event-promote-guest]',
		'{demoteGuest}': '[data-event-demote-guest]'
	}
}, function(self, opts) { return {

	'{inviteGuest} click': function(el, ev) {
		var guests = {};


		window.inviteGuests = function(guest) {
			if (guest.state) {
				guests[guest.id] = guest
			} else {
				delete guests[guest.id];
			}
		};

		EasySocial.dialog({
			content: EasySocial.ajax('admin/views/events/inviteGuests', {"id":opts.eventid}),
			bindings: {
				'{submitButton} click': function() {
					var form = $('[data-form-add-members]');
					var input = form.find('[data-ids]');
					var ids = [];

					$.each(guests, function(i, member) {
						ids.push(member.id);
					});

					input.val(JSON.stringify(ids));

					$('[data-form-add-members]').submit();
				}
			}
		});
	},

	'{removeGuest} click': function(el, ev) {
		if(document.adminForm.boxchecked.value == 0) {
			alert(opts.error.empty);
		} else {
			$.Joomla('submitform', ['removeGuests']);
		}
	},

	'{approveGuest} click': function(el, ev) {
		if(document.adminForm.boxchecked.value == 0) {
			alert(opts.error.empty);
		} else {
			$.Joomla('submitform', ['approveGuests']);
		}
	},

	'{promoteGuest} click': function(el, ev) {
		if(document.adminForm.boxchecked.value == 0) {
			alert(opts.error.empty);
		} else {
			$.Joomla('submitform', ['promoteGuests']);
		}
	},

	'{demoteGuest} click': function(el, ev) {
		if(document.adminForm.boxchecked.value == 0) {
			alert(opts.error.empty);
		} else {
			$.Joomla('submitform', ['demoteGuests']);
		}
	}
}});

module.resolve();
});
			EasySocial.module('admin/grid/grid' , function($) {

var module = this;

EasySocial.require()
.script('admin/grid/sort')
.done(function($) {

EasySocial.Controller('Grid', {
	defaultOptions : {
		"{sortColumns}": "[data-table-grid-sort]",
		"{ordering}": "[data-table-grid-ordering]",
		"{saveorder}": "[data-table-grid-saveorder]",
		"{direction}": "[data-table-grid-direction]",

		"{task}": "[data-table-grid-task]",

		"{searchInput}": "[data-table-grid-search-input]",
		"{search}": "[data-table-grid-search]",
		"{resetSearch}" : "[data-table-grid-search-reset]",

		"{checkAll}": "[data-table-grid-checkall]",
		"{checkboxes}": "input[type=checkbox][data-table-grid-id]",

		"{publishItems}": "[data-table-grid-publishing]",
		"{itemRow}": "tr",
		"{boxChecked}": "[data-table-grid-box-checked]",
		"{filters}": "[data-table-grid-filter]"
	}
}, function(self, opts) { return {

	init : function() {
		// Implement sortable items.
		self.implementSortable();
	},

	"{filters} change" : function() {
		// Always reset the task before submitting.
		self.setTask('');

		self.submitForm();
	},

	"{search} click" : function() {
		self.submitForm();
	},

	"{saveorder} click" : function() {
		self.setTask('saveorder');

		// check all checkbox.
		self.checkAll().click();
		self.submitForm();
	},

	"{resetSearch} click" : function(el, event) {
		self.searchInput().val('');
		self.submitForm();
	},

	submitForm: function() {

		// Allow page to hook into this event
		self.trigger('beforeSubmitForm', [self.task().val()]);

		self.element.submit();
	},

	setTask: function(task) {
		self.task().val( task );
	},

	setOrdering: function(ordering) {
		self.ordering().val( ordering );
	},

	setDirection: function(direction) {
		self.direction().val( direction );
	},

	updateBoxChecked: function() {
		var total = self.checkboxes(':checked').length;
		
		self.boxChecked().val(total);
	},

	toggleSelectRow: function(row) {
		var checkbox = $(row.find('input[name=cid\\[\\]]'));
		var checked = checkbox.prop('checked') == true;

		if (checked) {
			checkbox.prop('checked', false);
			return;
		}

		checkbox.prop('checked', true);
		return;
	},

	selectRow: function(row) {
		var checkbox 	= row.find( 'input[name=cid\\[\\]]' );

		$( checkbox ).prop( 'checked' , true );
	},

	implementSortable: function() {
		self.sortColumns().implement(EasySocial.Controller.Grid.Sort, {
			"{parent}" 	: self
		});
	},

	"{checkboxes} click": function(checkbox, event) {
		event.stopPropagation();
	},

	"{itemRow} click": function(row, event) {
		var checkbox = row.find(self.checkboxes.selector);

		checkbox.prop("checked", !checkbox.is(':checked'))
			.trigger('change');
	},

	"{checkboxes} change": function(checkbox, event) {
		var checked = checkbox.is(':checked');
		var row = checkbox.closest(self.itemRow.selector);

		// Get a list of checked items
		var total = self.checkboxes().is(':checked').length;

		self.updateBoxChecked();

		row.toggleClass('is-checked', checked);
	},

	"{checkAll} change": function(element, event) {

		// Find all checkboxes in the grid.
		self.checkboxes()
			.prop('checked', element.is(':checked'))
			.trigger('change');

		// Update the total number of checkboxes checked.
		var total = element.is(':checked') ? self.checkboxes().length : 0;

		self.updateBoxChecked();
	},

	//
	// Publish buttons
	//
	"{publishItems} click": function(element, event) {
		var row = element.parents(self.itemRow.selector);
		var task = element.data('task');

		self.selectRow(row);
		self.setTask(task);
		self.submitForm();
	}
}});

module.resolve();
});


});
			EasySocial.module( 'admin/grid/ordering' , function($) {

	var module = this;

	EasySocial.Controller('Grid.Ordering', {
		
		defaultOptions: {
			"{moveUp}": "[data-grid-order-up]",
			"{moveDown}": "[data-grid-order-down]",
			row: null
		}
	}, function(self) {
		return {

			init : function() {
				// Get the parent row
				self.options.row = self.element.parents( 'tr' );
			},

			selectRow : function() {
				var checkbox = self.options.row.find('input[name=cid\\[\\]]' );

				// Ensure that the checkbox is checked
				$(checkbox).prop('checked', true);
			},

			"{moveUp} click" : function() {
				self.selectRow();

				$.Joomla('submitform', ['moveUp']);
			},

			"{moveDown} click" : function() {
				self.selectRow();

				$.Joomla('submitform', ['moveDown']);
			}
		}
	});
		
	module.resolve();

});			EasySocial.module( 'admin/grid/sort' , function($) {

	var module = this;

	EasySocial.Controller(
		'Grid.Sort',
		{
			defaultOptions : 
			{
				items 	: "[data-grid-sort-item]"
			}
		},
		function( self )
		{
			return {

				init : function()
				{
				},

				"{self} click": function()
				{
					var direction 	= self.element.data( 'direction' ),
						column 		= self.element.data( 'sort' );

					// Set the ordering
					self.parent.setOrdering( column );

					// Set the direction
					self.parent.setDirection( direction );

					// Remove any task associated to the form.
					self.parent.setTask( '' );
					
					// Submit the form.
					self.parent.submitForm();
				}
			}
		}
	);
		
	module.resolve();

});			EasySocial.module('admin/groups/groups' , function($) {

	var module = this;

	EasySocial
	.require()
	.library('expanding')
	.done(function($) {
		
		EasySocial.Controller('Groups.Pending.Item', {
				defaultOptions: {
					"{approve}": "[data-pending-approve]",
					"{reject}": "[data-pending-reject]"
				}
			}, function(self) { return {
				
				init: function() {
					self.options.id = self.element.data('id');
				},

				"{approve} click": function() {
					EasySocial.dialog({
						content: EasySocial.ajax( 'admin/views/groups/approveGroup' , { "ids" : self.options.id } )
					});
				},

				"{reject} click" : function() {
					EasySocial.dialog({
						content: EasySocial.ajax( 'admin/views/groups/rejectGroup' , { "ids" : self.options.id } )
					});
				}
		}});

		module.resolve();
	});

});			EasySocial.module('admin/header/apps', function($) {

var module = this;

EasySocial.require()
.library('ui/sortable', 'scrollTo')
.done(function($) {

EasySocial.Controller("Header.Apps", {
	defaultOptions: {
		"{appsWrapper}": '[data-apps-wrapper]',
		"{apps}" : '[data-apps]',
		"{appItem}" : '[data-app-item]'
	}
}, function(self, opt, base) { return {

	init : function() {
		self.initAppsSortable();
		self.updateOrdering(self.appItem());
	},

	initAppsSortable: function() {
		self.apps().sortable({
			items: self.appItem.selector,
			cursor: 'move',
			forceHelperSize: true,
			axis : 'y',
			cancel : '.do-not-move',
			start: function(event, ui) {
				ui.helper.addClass('is-new');
			},
			stop: function(event, ui) {
				setTimeout(function() {
					ui.item.removeClass('is-new');
				}, 150);
			},
			update : function(event, ui) {
				self.updateOrdering(self.appItem());
			}
		});
	},

	updateOrdering: function(element) {
		var appOrdering = [];

		$.each(element, function() {
			var item = $(this),
				element = item.data('element'),
				index = item.index();

			// Update the sequence
			item.attr('data-ordering', index);

			appOrdering.push(element);
		});

		appOrdering = JSON.stringify(appOrdering);
		$('[data-app-ordering-value]').val(appOrdering);
	}
}});

module.resolve();
});
});
			EasySocial.module('admin/maintenance/maintenance', function($) {
    var module = this;

    EasySocial.Controller('Maintenance.Execute', {
        defaultOptions: {
            '{row}': '[data-row]'
        }
    }, function(self) {
        return {
            init: function() {
                self.runscript();
            },

            counter: 0,

            success: 0,

            fail: 0,

            runscript: function() {
                var row = self.row().eq(self.counter);

                if (row.length === 0) {
                    return self.completed();
                }

                var key = row.data('key');

                EasySocial.ajax('admin/controllers/maintenance/runscript', {
                    key: key
                }).done(function() {
                    self.setStatus(row, 1);
                    self.success++;
                }).fail(function() {
                    self.setStatus(row, 0);
                    self.fail++;
                }).always(function() {
                    self.counter++;
                    self.runscript();
                });
            },

            completed: function() {
                if (self.fail < 1) {
                    window.location = 'index.php?option=com_easysocial&view=maintenance&success=' + self.success;
                }
            },

            setStatus: function(row, state) {
                var status = row.find('[data-status]'),
                    icon = row.find('[data-icon]'),
                    statuses = ['label-danger', 'label-success', 'label-warning'],
                    icons = ['fa-exclamation-triangle', 'fa-check', 'fa-wrench'];

                for (i = 0; i < 3; i++) {
                    status.toggleClass(statuses[i], state == i);
                    icon.toggleClass(icons[i], state == i);
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module( 'admin/migrators/migrator' , function($) {

	var module = this;

	EasySocial.require()
	.script('admin/progress/progress')
	.done(function($){

		EasySocial.Controller(
			'Migrators.Migrator',
			{
				// A list of selectors we define
				// and expect template makers to follow.
				defaultOptions:
				{
					// Controller Properties.
					component 			: null,

					processState 		: 0,

					// Progress bar controller
					progressController : null,

					mapping 			: null,

					updateconfig 		: 0,


					"{initiateButton}"	: "[data-initiate-migration]",
					"{progressBar}" 	: "[data-progress]",
					"{results}"			: ".scannedResult",
					"{viewLog}"			: ".viewLog",
					"{customFieldsMap}" : "[data-custom-fields-map]",

					"{resultForm}"		: "[data-migration-result]",

					"{startWidget}"		: "[data-start-widget]",
					"{fieldItem}"		: "[data-field-item]",

					"{startMigrationButton}" : "[data-start-migration]",

					"{rows}"			: "[data-row-item]",
					"{selection}"		: "[data-field-item]",

					"{jomsocialBackButton}" : "[data-jomsocial-back-button]"
				}
			},
			function(self){

				return {

					init: function()
					{
						// Initialize progress bar.
						self.initProgressBar();

						// Initialize the logging area.
						self.initLogging();
					},

					showCustomFields: function()
					{
						// Hide the initial section
						self.startWidget().slideUp();

						//Show the custom fields map.
						self.customFieldsMap().slideDown();
					},

					showResultForm: function()
					{
						self.customFieldsMap().slideUp();

						if( self.options.component != 'com_community' )
						{
							self.startWidget().slideUp();
						}

						self.resultForm().slideDown();
					},

					startMigration: function()
					{
						// Disable start button.
						// self.startButton().attr( 'disabled' , 'disabled' );

						self.showResultForm();

						// to prevent user click multiple times.
						if( self.options.processState == 1 )
						{
							return;
						}
						else
						{
							self.options.processState = 1;
						}

						self.reset();


						// Discover the list of files.
						EasySocial.ajax( 'admin/controllers/migrators/check' ,
						{
							'component' : self.options.component
						})
						.done(function( data )
						{

							if( data.isvalid )
							{
								// Begin progress.
								self.options.progressController.begin( data.count );

								// Begin to loop through each files.
								self.startIterating('');
							}
							else
							{
								// Ensure results is always hidden.
								self.results().show();

								// Add logging
								self.addLog( 'Error: ' + data.message );

								// reopen the process state.
								self.options.processState = 0;
							}

						});
					},

					// Resets the scan.
					reset: function()
					{
						// Reset the logs
						self.results().empty();

						// Hide the viewlog button
						self.initLogging();

						// Reset progress bar.
						self.options.progressController.reset();
					},

					initLogging: function()
					{
						// Ensure view log button is always hidden.
						self.viewLog().hide();
					},

					initProgressBar: function()
					{
						// Implement progressbar
						self.progressBar().implement( EasySocial.Controller.Progress );

						// Set this to the options so that we can easily access the controller.
						self.options.progressController	= self.progressBar().controller();
					},

					addLog: function( message )
					{
						$( '<li>' ).html( message )
							.appendTo( self.results() );
					},

					startIterating: function( item )
					{

						if( self.options.mapping == null )
						{
							if( self.selection().length > 0 )
							{
								self.options.mapping = $('#adminForm').serializeArray();
							}
						}

						EasySocial.ajax( 'admin/controllers/migrators/process' ,
						{
							"component"	: self.options.component,
							"item" 		: item,
							"mapping"	: self.options.mapping,
							"updateconfig"	: self.options.updateconfig,
						})
						.always(function( data, updateConfig )
						{

							self.options.updateconfig = updateConfig;

							// As long as the files list are not empty yet, we still need to process it.
							if( data["continue"] )
							{
								// Update once.
								self.options.progressController.touch( 'Discovering...' );

								// Append message to the result list.
								self.addLog( data.message );

								// Run this again.
								self.startIterating( data.item );
							}
							else
							{
								// Update once.
								self.options.progressController.touch( 'Discover Completed' );

								// Append message to the result list.
								self.addLog( data.message );

								// Append completed message to the result list since we know this is the last item.
								self.addLog( 'migration process completed.' );

								// Show view log button.
								self.viewLog().show();

								// Make the scan button work again.
								self.jomsocialBackButton().show();

								// reopen the process state.
								self.options.processState = 0;
							}
						});
					},

					"{fieldItem} change" : function( el )
					{
						var value 	= $( el ).val();

						// Add error class on row
						if( value == '' )
						{
							$( el ).parents( '[data-row-item]' ).removeClass( 'success' ).addClass( 'error' );
						}
						else
						{
							$( el ).parents( '[data-row-item]' ).removeClass( 'error' ).addClass( 'success' );
						}
					},

					"{startMigrationButton} click" : function()
					{
						// If there's error, show dialog and confirm that the user doesn't want to migrate
						// selected fields.
						if( self.selection().length > 0 )
						{
							self.selection().each( function( i, el ) {

								if( $( el ).val() == "" )
								{
									$( el ).parents( '[data-row-item]' ).removeClass( 'success' ).addClass( 'error' );
								}
								else
								{
									$( el ).parents( '[data-row-item]' ).removeClass( 'error' ).addClass( 'success' );
								}
							});
						}

						var hasError = self.rows().hasClass( 'error' );

						if( hasError )
						{
							EasySocial.dialog(
							{
								content 	: EasySocial.ajax( 'admin/views/migrators/confirmMigration' ),
								bindings 	:
								{
									"{submitButton} click" : function()
									{
										self.startMigration();

										EasySocial.dialog().close();
									}
								}
							});
						}
						else
						{
							// do lets this.
							self.startMigration();

						}

					},

					"{initiateButton} click" : function( element )
					{
						self.showCustomFields();
					},

					"{viewLog} click" : function()
					{
						self.results().toggle();
					}
				}

			}
		);

		module.resolve();
	});

});
			EasySocial.module('admin/pages/pages' , function($) {

	var module = this;

	EasySocial
	.require()
	.library('expanding')
	.done(function($)
	{
		EasySocial.Controller(
			'Pages.Pending.Item',
			{
				defaultOptions:
				{
					"{approve}" : "[data-pending-approve]",
					"{reject}"	: "[data-pending-reject]"
				}
			},
			function(self) {
				return {
					init: function()
					{
						self.options.id 	= self.element.data('id');
					},

					"{approve} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax('admin/views/pages/approvePage' , { "ids" : self.options.id })
						});
					},

					"{reject} click" : function()
					{
						EasySocial.dialog(
						{
							content		: EasySocial.ajax('admin/views/pages/rejectPage' , { "ids" : self.options.id })
						});
					}
				}
			});

		module.resolve();
	});

});			EasySocial.module( 'admin/profiles/avatar' , function($){

var module = this;

EasySocial.require()
.script('uploader/uploader')
.done(function() {

EasySocial.Controller('Profiles.Avatar', {
	defaultOptions: {
		token : null,

		// Elements
		"{fileUploader}" : "[data-profile-avatars-uploader]",
		"{startUploadButton}": "[data-profile-avatars-startupload]",
		"{avatarList}": "[data-profile-avatars-list]",
		"{avatarEmpty}": "[data-profile-avatars-empty]",
		"{avatarItem}": "[data-profile-avatars-item]",
		"{messagePlaceholder}": "[data-profile-avatars-message]",
		"{removeFile}": ".removeFile",
		"{clearUploadedItems}": "[data-uploader-clear]"
	}
}, function(self, opts) { return {

	init: function() {
		opts.id = self.element.data('id');

		self.initUploader();
		self.initAvatar();
	},

	initUploader: function() {
		self.fileUploader().implement(EasySocial.Controller.Uploader, {
			url : window.es.rootUrl + '/administrator/index.php?option=com_easysocial&namespace=admin/controllers/profiles/uploadDefaultAvatars&' + window.es.token + '=1&tmpl=component&format=ajax&uid=' + opts.id
		});
	},

	initAvatar: function() {
		self.avatarItem().implement( 'EasySocial.Controller.Profiles.Avatar.Item', {
			"{parent}": self,
			"items": self.avatarItem
		});
	},

	addMessage: function(message) {
		self.clearMessage();
		self.setMessage(message);
	},

	"{removeFile} click" : function(el, event) {
		var id = el.parents('li').attr('id');

		self.fileUploader().controller().removeItem(id);
	},

	"{startUploadButton} click" : function() {
		var controller = self.fileUploader().controller();

		controller.startUpload();
	},

	"{fileUploader} UploadProgress" : function( el , event , file ) {
		// Get the upload progress.
		var progress	= file.percent,
			elementId	= '#' + file.id,
			progressBar	= $( elementId ).find( '.progressBar' );

		// Show the progress bar.
		progressBar.show();

		// Update the width of the progress bar.
		progressBar.find( '.bar' ).css( 'width' , progress + '%' );
	},

	"{fileUploader} FileUploaded" : function( el, event, file, response ) {
		if( response[ 0 ] != undefined )
		{
			var contents 	= response[0].data[ 0 ];

			// Hide empty if any
			self.avatarEmpty().hide();

			// Prepend the item
			self.avatarList().prepend( contents );

			self.clearUploadedItems().show();

			// Apply the controller
			self.initAvatar();
		}
	},

	"{clearUploadedItems} click" : function() {
		var controller 	= self.fileUploader().controller();

		// Reset the queue
		controller.reset();

		// Hide itself since there's no history now.
		self.clearUploadedItems().hide();
	}
}});

EasySocial.Controller('Profiles.Avatar.Item', {
	defaultOptions: {
		id: null,
		"{deleteLink}" : "[data-avatar-delete]",
		"{setDefaultAvatar}" : "[data-avatar-default]"
	}
}, function(self, opts) { return {

	init : function() {
		opts.id = self.element.data('id');
	},

	"{setDefaultAvatar} click" : function(el , event ) {
		EasySocial.ajax('admin/controllers/avatars/setDefault', {
			"id" : opts.id
		})
		.done(function(message) {
			// Remove all default class
			self.parent.avatarItem().removeClass( 'default' );

			// Add a default class to itself
			self.element.addClass('default');

			self.parent.addMessage(message);
		});
	},

	"{deleteLink} click": function() {
		EasySocial.dialog({
			"content": EasySocial.ajax('admin/views/profiles/confirmDeleteAvatar'),
			"bindings": {
				"{deleteButton} click" : function(el, event) {
					$(el).addClass('btn-loading');

					EasySocial.ajax('admin/controllers/avatars/delete', {
						"id" : opts.id
					})
					.done(function(message) {
						self.element.remove();

						if (self.parent.avatarList().children().length == 0) {
							self.parent.avatarEmpty().show();
						}

						self.parent.addMessage(message);

						EasySocial.dialog().close();
					});
				}
			}
		});
	}
}});

module.resolve();

});
});


			EasySocial.module('admin/profiles/form', function($) {

var module = this;

EasySocial.require()
.script('admin/utilities/alias')
.done(function($) {

	EasySocial.Controller('Profiles.Profile', {
		defaultOptions: {
			id: null,

			// Profile avatar
			hasAvatar: false,
			defaultAvatar: null,

			'{profileAvatar}': '[data-profile-avatar]',
			'{profileAvatarImage}': '[data-profile-avatar-image]',
			'{profileAvatarRemoveWrap}': '[data-profile-avatar-remove-wrap]',
			'{profileAvatarRemoveButton}': '[data-profile-avatar-remove-button]',
			'{profileAvatarUpload}': '[data-profile-avatar-upload]'
		}
	}, function(self) {
		
		return {
			init: function() {

				self.element.addController('EasySocial.Controller.Utilities.Alias', {
					"{source}"	: "#title",
					"{target}"	: "#alias"
				});

				self.options.hasAvatar = self.profileAvatar().data('hasavatar');
				self.options.defaultAvatar = self.profileAvatar().data('defaultavatar');
			},

			'{profileAvatarUpload} change': function(el) {
				var value = el.val();

				if(!$.isEmpty(value)) {
					self.profileAvatarRemoveWrap().show();
				} else {
					if(!self.options.hasAvatar) {
						self.profileAvatarRemoveWrap().hide();
					}
				}
			},

			'{profileAvatarRemoveButton} click': function(el) {

				if (!self.options.hasAvatar) {
					self.profileAvatarUpload()
						.val('')
						.trigger('change');

					return;
				}

				EasySocial.dialog({
					content: EasySocial.ajax('admin/views/profiles/confirmRemoveProfileAvatar'),
					bindings: {
						'{deleteButton} click': function() {

							EasySocial.ajax('admin/controllers/profiles/deleteProfileAvatar', {
								id: self.options.id
							}).done(function() {

								self.profileAvatarImage().attr('src', self.options.defaultAvatar);

								self.profileAvatarRemoveWrap().hide();

								self.options.hasAvatar = false;

								EasySocial.dialog().close();
							});
						}
					}
				});
			}
		}
	});

	module.resolve();
});
});
			EasySocial.module('admin/progress/progress', function($) {

var module = this;

EasySocial.Controller('Progress', {
	// A list of selectors we define
	// and expect template makers to follow.
	defaultOptions: {
		// Controller Properties.
		current : 0,
		eachWidth : null,
		total : null,

		// Controller Elements
		"{progressBar}" : ".progress-bar",
		"{progressResult}" : ".progress-result"
	}
}, function(self, opts){ return {

	reset: function() {
		self.options.current 	= 0;
		self.eachWidth 			= null;
		self.total 				= null;

		self.progressBar().css( 'width' , '0%' ).html( '' );
	},

	begin: function(total) {
		// Set the total number of items
		self.options.total 	= total;

		// Set the width of each item.
		self.options.eachWidth	= 100 / total;


		// Only show progress bar when the there's more than 1 item.
		if (total > 0) {
			self.element
				.removeClass('t-hidden');
		}
	},

	touch : function(message) {
		self.options.current 	+= self.options.eachWidth;

		//ensure the progress bar do not exceed 100%
		if( self.options.current > 100 )
		{
			self.options.current = 100;
		}

		self.progressBar().css( 'width' , self.options.current + '%' );
		self.progressResult().html( Math.round( self.options.current ) + '%' );
	},

	completed: function(message) {
		self.options.current 	= 100;

		self.progressBar().css( 'width' , self.options.current + '%' );
		self.progressResult().html( Math.round( self.options.current ) + '%' );
	}
}});

module.resolve();

});
			EasySocial.module('admin/regions/form', function($) {

var module = this;

EasySocial.Controller('Regions.Form', {
	defaultOptions: {
		'{type}': '[data-type]',
		'{parentBase}': '[data-parent-base]',
		'{parentContent}': '[data-parent-content]',
		'{parentUid}': '[data-parent-uid]',
		'{parentType}': '[data-parent-type]'
	}
}, function(self, opts, base) { return {
		init: function() {
			self.element.find('input[type="text"]').prop('disabled', !self.type().val());

			self.element.find('[data-bs-toggle="radio-buttons"]').toggleClass('disabled', !self.type().val());
		},

		'{type} change': function(el) {
			var parentType = el.find(':selected').data('parent');

			self.parentType().val(parentType);

			self.element.find('input[type="text"]').prop('disabled', !el.val());

			self.element.find('[data-bs-toggle="radio-buttons"]').toggleClass('disabled', !el.val());

			if (parentType) {
				self.parentBase().show();

				!self.parentContent().data('loaded') &&
				self.getParents(parentType)
					.done(function(parents) {
						self.parentContent().html(parents);
					});
			} else {
				self.parentBase().hide();
			}
		},

		getParents: $.memoize(function(key) {
			return EasySocial.ajax('admin/controllers/regions/getParents', {
				type: key
			});
		}),

		validate: function() {
			return self.type().val() && self.element.find('input[name="name"]').val() && self.element.find('input[name="code"]').val();
		}
	}
});

module.resolve();
});			EasySocial.module('admin/regions/init', function($) {
    var module = this;

    EasySocial.Controller('Region.Init', {
        defaultOptions: {
            callback: function() {},

            '{startButton}': '[data-start]',
            '{table}': '[data-table]',
            '{tableBody}': '[data-table-body]',
            '{row}': '[data-table-row]'
        }
    }, function(self) {
        return {
            init: function() {
                self.row().addController('EasySocial.Controller.Region.Init.Row');
            },

            '{startButton} click': function(el, ev) {
                el.hide();

                self.table().show();

                self.counter = 0;
                self.progress = $.Deferred()
                    .done(function() {
                        self.options.callback();
                    });

                self.process();
            },

            process: function() {
                var row = self.row().eq(self.counter);

                if (row.length === 0) {
                    return self.progress.resolve();
                }

                row.show();

                EasySocial.ajax('admin/controllers/regions/initialise', {
                    key: row.data('key')
                }).done(function() {
                    row.trigger('updateStatus', [1]);

                    self.counter++;

                    self.process();
                });
            }
        }
    });

    EasySocial.Controller('Region.Init.Row', {
        defaultOptions: {
            '{title}': '[data-row-title]',
            '{status}': '[data-row-status]',
            '{icon}': '[data-row-icon]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            statuses: ['label-danger', 'label-success', 'label-warning'],
            icons: ['fa-exclamation-triangle', 'fa-check', 'fa-wrench'],

            '{self} updateStatus': function(el, ev, state) {
                var status = self.status(),
                    icon = self.icon();

                for (i = 0; i < 3; i++) {
                    status.toggleClass(self.statuses[i], state == i);
                    icon.toggleClass(self.icons[i], state == i);
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module( 'admin/users/form' , function($) {

var module = this;

EasySocial.require()
.script('shared/fields/base', 'shared/fields/conditional')
.done(function($) {

EasySocial.Controller('Users.Form', {
	defaultOptions: {
		userid: null,
		mode: 'adminedit',

		"{selectProfile}": "[data-user-select-profile]",
		"{content}": "[data-user-new-content]",
		"{profileTitle}": "[data-profile-title]",

		"{fieldItem}": "[data-field-item]",

		"{tabnav}": "[data-tabnav]",
		"{tabcontent}": "[data-tabcontent]",

		"{stepnav}": "[data-stepnav]",
		"{stepcontent}": "[data-stepcontent]",

		view: {
			loading : "site/loading/large"
		}
	}
}, function(self, opts) { return {

		init : function() {
			window.selectedProfile 	= self.selectedProfile;

			self.fieldItem().addController('EasySocial.Controller.Field.Base', {
				userid: self.options.userid,
				mode: self.options.mode
			});

			self.fieldItem().addController('EasySocial.Controller.Field.Conditional');
		},

		selectedProfile : function(profileId) {
			EasySocial.dialog().close();

			window.location.href	= 'index.php?option=com_easysocial&view=users&layout=form&profileId=' + profileId;
		},

		"{selectProfile} click" : function() {
			EasySocial.dialog(
			{
				content 	: EasySocial.ajax( 'admin/views/profiles/browse' )
			});
		},

		errorFields: [],

		'{fieldItem} error': function(el, ev) {
			var id = el.data('id');

			if($.inArray(id, self.errorFields) < 0) {
				self.errorFields.push(id);
			}

			var stepid = el.parents(self.stepcontent.selector).data('for');

			self.stepnav().filterBy('for', stepid).trigger('error');

			var tabid = el.parents(self.tabcontent.selector).data('for');

			self.tabnav().filterBy('for', tabid).trigger('error');
		},

		'{fieldItem} clear': function(el, ev) {
			var fieldid = el.data('id');

			self.errorFields = $.without(self.errorFields, fieldid);

			var stepid = el.parents(self.stepcontent.selector).data('for');

			self.stepnav().filterBy('for', stepid).trigger('clear');

			var tabid = el.parents(self.tabcontent.selector).data('for');

			self.tabnav().filterBy('for', tabid).trigger('clear');
		},

		'{stepnav} error': function(el) {
			el.addClass('error');
		},

		'{tabnav} error': function(el) {
			el.addClass('error');
		},

		'{stepnav} clear': function(el) {
			if(self.errorFields.length < 1) {
				el.removeClass('error');
			}
		},

		'{tabnav} clear': function(el) {
			if(self.errorFields.length < 1) {
				el.removeClass('error');
			}
		},

		'{stepnav} click': function(el) {
			var id = el.data('for');

			self.stepcontent().filterBy('for', id).find(self.fieldItem.selector).trigger('show');
		}
	}
});

module.resolve();
});

});
			EasySocial.module('admin/users/privacy' , function($){

	var module 	= this;

	EasySocial.require()
	.library('textboxlist')
	.done(function($){

		EasySocial.Controller(
			'Profile.Privacy',
			{
				defaultOptions:
				{
					userId	: '',

					"{privacyItem}" : "[data-privacy-item]",

					//input form
					"{privacyForm}" : "[data-profile-privacy-form]",

					// global custom fields
					"{defaultFieldInput}" : "[data-default-privacy-field]",
					"{defaultFieldEdit}" : "[data-default-field-edit]"
				}
			},
			function(self) {
				return {

					init : function() {
						self.privacyItem().implement(EasySocial.Controller.Profile.Privacy.Item , {
							"{parent}"	: self
						});
					},

					"{defaultFieldEdit} click" : function() {

						var selected = self.defaultFieldInput().val();
						var controller = self.privacyItem().controller();
						controller.editField(selected, true, self.defaultFieldInput());
					},

				}
			}
		);


		EasySocial.Controller(
			'Profile.Privacy.Item', {
				defaultOptions :
				{
					"{selection}"		: "[data-privacy-select]",
					"{hiddenCustom}" 	: "[data-hidden-custom]",
					"{hiddenField}" 	: "[data-hidden-field]",
					"{customForm}" 		: "[data-privacy-custom-form]",

					"{customTextInput}" : "[data-textfield]",
					"{customItems}"		: "input[]",
					"{customHideBtn}"	: "[data-privacy-custom-hide-button]",
					"{customInputItem}"	: "[data-textboxlist-item]",
					"{customEditBtn}"   : "[data-privacy-custom-edit-button]",

					// used in profile type privacy.
					"{fieldEdit}" : "[data-privacy-field]"
				}
			},
			function(self)
			{
				return {
					init : function()
					{
						if (self.customTextInput().length > 0) {

							self.customTextInput().textboxlist(
								{
									component: 'es',
									unique: true,

									plugin: {
										autocomplete: {
											exclusive: true,
											minLength: 2,
											cache: false,
											query: function(keyword) {

												var users = self.getTaggedUsers();

												var ajax = EasySocial.ajax("site/views/privacy/getfriends",
													{
														q: keyword,
														userid: self.parent.options.userId,
														exclude: users
													});
												return ajax;
											}
										}
									}
								}
							);

							self.textboxlistLib = self.customTextInput().textboxlist("controller");
						}
					},

					getTaggedUsers: function() {
						var users = [];
						var items = self.customInputItem();

						if (items.length > 0) {
							$.each(items, function(idx, element) {
								users.push($(element).data('id'));
							});
						}

						return users;
					},

					// event listener for adding new name
					"{customTextInput} addItem": function(el, event, data) {

						// lets get the exiting ids string
						var ids    = self.hiddenCustom().val();
						var values = '';

						if (ids == '') {
							values = data.id;
						} else {
							var idsArr = ids.split(',');
							idsArr.push(data.id);

							values = idsArr.join(',');
						}

						//now update the customhidden value.
						self.hiddenCustom().val(values);
					},

					// event listener for removing name
					"{customTextInput} removeItem": function(el, event, data) {
						// lets get the exiting ids string
						var ids    = self.hiddenCustom().val();
						var values = '';
						var newIds = [];

						var idsArr = ids.split(',');

						for (var i = 0; i < idsArr.length; i++) {
							if (idsArr[i] != data.id) {
								newIds.push(idsArr[i]);
							}
						}

						if (newIds.length <= 0) {
							values = '';
						} else {
							values = newIds.join(',');
						}

						//now update the customhidden value.
						self.hiddenCustom().val(values);
					},

					"{customEditBtn} click" : function(el) {
						self.customForm().toggle();
					},

					"{selection} change" : function(el) {
						var selected = el.val();

						if (selected == 'custom') {
							self.customForm().show();
							self.customEditBtn().show();
						} else {
							self.customForm().hide();
							self.customEditBtn().hide();
						}

						return;
					},

					"{customHideBtn} click" : function() {
						self.customForm().hide();
						self.customEditBtn().show();

						self.textboxlistLib.autocomplete.hide();

						return;
					},

					"{fieldEdit} click" : function() {

						var selected = self.hiddenField().val();
						self.editField(selected, true, self.hiddenField());

					},

					editField: function(selected, isDefault, input) {

						var selection = [];
						var updated = false;
						var curSelected = [];

						if (isDefault == undefined) {
							isDefault = false;
						}

						if (selected) {
							var curSelected = selected.split(',');
						}

						EasySocial.dialog({
							content : EasySocial.ajax("admin/views/privacy/fields", {
								"selected" : selected,
								"isDefault" : isDefault ? 1 : 0
							}),
							selectors : {
								"{addFieldButton}" : "[data-field-add]",
								"{removeFieldButton}" : "[data-field-remove]",
								"{fieldTemplate}" : "[data-field-template]",
								"{fieldWrapper}" : "[data-field-wrapper]",
								"{fieldSelect}" : "[data-field-item] [data-field-select]",
								"{tmplFieldSelect}" : "[data-field-template] [data-field-select]",
								"{fieldItem}" : "[data-field-item]"
							},
							bindings : {
								"{addFieldButton} click" : function() {
									var template = this.fieldTemplate().clone();

									template.removeAttr('data-field-template')
										.removeClass('t-hidden')
										.attr('data-field-item', '')
										.appendTo(this.fieldWrapper());
								},

								"{removeFieldButton} click" : function(el) {
									// check if we allow to remove or not.
									if (this.fieldItem().length > 1) {

										// var seletecVal = $(el).val();
										var selectVal = $(el).closest('[data-field-item]').find('[data-field-select]').val();

										if ($.inArray(selectVal, curSelected) >= 0) {
											var tmpArr = [];
											$.each(curSelected, function(idx, val) {
												if (val != selectVal) {
													tmpArr.push(val);
												}
											});
											curSelected = tmpArr;
										}

										$(el).closest('[data-field-item]').remove();
									}
								},

								"{fieldSelect} change": function(el) {
									var selectVal = $(el).val();

									$(el).closest('[data-field-item]').find('[data-field-notice]').addClass('t-hidden');

									if ($.inArray(selectVal, curSelected) >= 0) {
										$(el).closest('[data-field-item]').find('[data-field-notice]').removeClass('t-hidden');
										$(el).val('');
									} else {
										curSelected.push(selectVal);
									}
								},

								"{saveButton} click" : function() {
									updated = true;

									var selectInputs = this.fieldSelect();

									$.each(selectInputs, function(idx, ele) {
										var data = $(ele).val();

										if (data != '' && $.inArray(data, selection) == -1) {
											selection.push(data);
										}
									});

									// close the dialog.
									EasySocial.dialog().close();

									var str = '';
									if (selection.length > 0) {
										str = selection.join(',');
										input.val(str);
									}

								}
							}
						});
					}
				}
			});


		module.resolve();
	});

});
			EasySocial.module('admin/users/users', function($) {

var module = this;

EasySocial
.require()
.script('admin/api/toolbar')
.library('expanding')
.done(function($) {

	EasySocial.Controller('Users', {
		defaultOptions: {
			"{item}": "[data-user-item]"
		}
	}, function(self) { return {
		init : function() {
			self.item().implement(EasySocial.Controller.Users.Item);
		}
	}});

	EasySocial.Controller('Users.Item', {
		defaultOptions :  {
			"{insertLink}"	: "[data-user-item-insertLink]"
		}
	}, function(self) { return {
		init : function() {
			self.options.name 	= self.element.data( 'name' );
			self.options.avatar	= self.element.data( 'avatar' );
			self.options.email	= self.element.data( 'email' );
			self.options.id 	= self.element.data( 'id' );
		},

		"{insertLink} click" : function() {
			self.trigger('userSelected', [ self.options.id , self.options.name , self.options.avatar , self.options.email ] );
		}
	}});


	EasySocial.Controller('Users.Pending', {
		defaultOptions : {
			"{item}"	: "[data-pending-item]"
		}
	}, function(self) { return {
		init : function() {
			self.item().implement( EasySocial.Controller.Users.Pending.Item );
		}
	}});


	EasySocial.Controller('Users.Pending.Item', {
		defaultOptions : {
			"{approve}" : "[data-pending-approve]",
			"{reject}"	: "[data-pending-reject]"
		}
	}, function(self) { return {
		init : function() {
			self.options.id = self.element.data('id');
		},

		"{approve} click" : function() {
			EasySocial.dialog(
			{
				content 	: EasySocial.ajax( 'admin/views/users/confirmApprove' , { "id" : self.options.id } ),
				bindings 	:
				{
					"{approveButton} click" : function()
					{
						$( '[data-users-approve-form]' ).submit();
					}
				}
			});
		},

		"{reject} click" : function() {
			EasySocial.dialog({
				content: EasySocial.ajax( 'admin/views/users/confirmReject' , { "id" : self.options.id } )
			});

		}
	}});
	module.resolve();
});

});			EasySocial.module('admin/utilities/alias', function($) {

	var module = this;

	EasySocial.Controller('Utilities.Alias', {
			defaultOptions: {
				// Should be overriden by the caller.
				"{target}"	: "",
				"{source}"	: ""
			}
		},function(self) { 
			return {
				init: function() {
				},

				convertToPermalink: function(title) {
					return title.replace(/\s/g, '-').replace(/[^\w/-]/g, '').toLowerCase();
				},

				"{source} keyup" : function(input, event) {
						
					var permalink = self.convertToPermalink(self.source().val());

					// Update the target when the source is change.
					self.target()
						.val(permalink);
				},

				"{target} keyup" : function(input, event) {

					var permalink = self.convertToPermalink(self.target().val());

					self.target()
						.val(permalink);
				}
			}
		});

	module.resolve();
});
			EasySocial.module('admin/vendors/drag', function($) { 

var module = this; 
var jQuery = $;

/*! 
 * jquery.event.drag - v 2.2
 * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com
 * Open Source MIT License - http://threedubmedia.com/code/license
 */
// Created: 2008-06-04 
// Updated: 2012-05-21
// REQUIRES: jquery 1.7.x

;(function( $ ){

// add the jquery instance method
$.fn.drag = function( str, arg, opts ){
	// figure out the event type
	var type = typeof str == "string" ? str : "",
	// figure out the event handler...
	fn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;
	// fix the event type
	if ( type.indexOf("drag") !== 0 ) 
		type = "drag"+ type;
	// were options passed
	opts = ( str == fn ? arg : opts ) || {};
	// trigger or bind event handler
	return fn ? this.bind( type, opts, fn ) : this.trigger( type );
};

// local refs (increase compression)
var $event = $.event, 
$special = $event.special,
// configure the drag special event 
drag = $special.drag = {
	
	// these are the default settings
	defaults: {
		which: 1, // mouse button pressed to start drag sequence
		distance: 0, // distance dragged before dragstart
		not: ':input', // selector to suppress dragging on target elements
		handle: null, // selector to match handle target elements
		relative: false, // true to use "position", false to use "offset"
		drop: true, // false to suppress drop events, true or selector to allow
		click: false // false to suppress click events after dragend (no proxy)
	},
	
	// the key name for stored drag data
	datakey: "dragdata",
	
	// prevent bubbling for better performance
	noBubble: true,
	
	// count bound related events
	add: function( obj ){ 
		// read the interaction data
		var data = $.data( this, drag.datakey ),
		// read any passed options 
		opts = obj.data || {};
		// count another realted event
		data.related += 1;
		// extend data options bound with this event
		// don't iterate "opts" in case it is a node 
		$.each( drag.defaults, function( key, def ){
			if ( opts[ key ] !== undefined )
				data[ key ] = opts[ key ];
		});
	},
	
	// forget unbound related events
	remove: function(){
		$.data( this, drag.datakey ).related -= 1;
	},
	
	// configure interaction, capture settings
	setup: function(){
		// check for related events
		if ( $.data( this, drag.datakey ) ) 
			return;
		// initialize the drag data with copied defaults
		var data = $.extend({ related:0 }, drag.defaults );
		// store the interaction data
		$.data( this, drag.datakey, data );
		// bind the mousedown event, which starts drag interactions
		$event.add( this, "touchstart mousedown", drag.init, data );
		// prevent image dragging in IE...
		if ( this.attachEvent ) 
			this.attachEvent("ondragstart", drag.dontstart ); 
	},
	
	// destroy configured interaction
	teardown: function(){
		var data = $.data( this, drag.datakey ) || {};
		// check for related events
		if ( data.related ) 
			return;
		// remove the stored data
		$.removeData( this, drag.datakey );
		// remove the mousedown event
		$event.remove( this, "touchstart mousedown", drag.init );
		// enable text selection
		drag.textselect( true ); 
		// un-prevent image dragging in IE...
		if ( this.detachEvent ) 
			this.detachEvent("ondragstart", drag.dontstart ); 
	},
		
	// initialize the interaction
	init: function( event ){ 
		// sorry, only one touch at a time
		if ( drag.touched ) 
			return;
		// the drag/drop interaction data
		var dd = event.data, results;
		// check the which directive
		if ( event.which != 0 && dd.which > 0 && event.which != dd.which ) 
			return; 
		// check for suppressed selector
		if ( $( event.target ).is( dd.not ) ) 
			return;
		// check for handle selector
		if ( dd.handle && !$( event.target ).closest( dd.handle, event.currentTarget ).length ) 
			return;

		drag.touched = event.type == 'touchstart' ? this : null;
		dd.propagates = 1;
		dd.mousedown = this;
		dd.interactions = [ drag.interaction( this, dd ) ];
		dd.target = event.target;
		dd.pageX = event.pageX;
		dd.pageY = event.pageY;
		dd.dragging = null;
		// handle draginit event... 
		results = drag.hijack( event, "draginit", dd );
		// early cancel
		if ( !dd.propagates )
			return;
		// flatten the result set
		results = drag.flatten( results );
		// insert new interaction elements
		if ( results && results.length ){
			dd.interactions = [];
			$.each( results, function(){
				dd.interactions.push( drag.interaction( this, dd ) );
			});
		}
		// remember how many interactions are propagating
		dd.propagates = dd.interactions.length;
		// locate and init the drop targets
		if ( dd.drop !== false && $special.drop ) 
			$special.drop.handler( event, dd );
		// disable text selection
		drag.textselect( false ); 
		// bind additional events...
		if ( drag.touched )
			$event.add( drag.touched, "touchmove touchend", drag.handler, dd );
		else 
			$event.add( document, "mousemove mouseup", drag.handler, dd );
		// helps prevent text selection or scrolling
		if ( !drag.touched || dd.live )
			return false;
	},	
	
	// returns an interaction object
	interaction: function( elem, dd ){
		var offset = $( elem )[ dd.relative ? "position" : "offset" ]() || { top:0, left:0 };
		return {
			drag: elem, 
			callback: new drag.callback(), 
			droppable: [],
			offset: offset
		};
	},
	
	// handle drag-releatd DOM events
	handler: function( event ){ 
		// read the data before hijacking anything
		var dd = event.data;	
		// handle various events
		switch ( event.type ){
			// mousemove, check distance, start dragging
			case !dd.dragging && 'touchmove': 
				event.preventDefault();
			case !dd.dragging && 'mousemove':
				//  drag tolerance, x + y = distance
				if ( Math.pow(  event.pageX-dd.pageX, 2 ) + Math.pow(  event.pageY-dd.pageY, 2 ) < Math.pow( dd.distance, 2 ) ) 
					break; // distance tolerance not reached
				event.target = dd.target; // force target from "mousedown" event (fix distance issue)
				drag.hijack( event, "dragstart", dd ); // trigger "dragstart"
				if ( dd.propagates ) // "dragstart" not rejected
					dd.dragging = true; // activate interaction
			// mousemove, dragging
			case 'touchmove':
				event.preventDefault();
			case 'mousemove':
				if ( dd.dragging ){
					// trigger "drag"		
					drag.hijack( event, "drag", dd );
					if ( dd.propagates ){
						// manage drop events
						if ( dd.drop !== false && $special.drop )
							$special.drop.handler( event, dd ); // "dropstart", "dropend"							
						break; // "drag" not rejected, stop		
					}
					event.type = "mouseup"; // helps "drop" handler behave
				}
			// mouseup, stop dragging
			case 'touchend': 
			case 'mouseup': 
			default:
				if ( drag.touched )
					$event.remove( drag.touched, "touchmove touchend", drag.handler ); // remove touch events
				else 
					$event.remove( document, "mousemove mouseup", drag.handler ); // remove page events	
				if ( dd.dragging ){
					if ( dd.drop !== false && $special.drop )
						$special.drop.handler( event, dd ); // "drop"
					drag.hijack( event, "dragend", dd ); // trigger "dragend"	
				}
				drag.textselect( true ); // enable text selection
				// if suppressing click events...
				if ( dd.click === false && dd.dragging )
					$.data( dd.mousedown, "suppress.click", new Date().getTime() + 5 );
				dd.dragging = drag.touched = false; // deactivate element	
				break;
		}
	},
		
	// re-use event object for custom events
	hijack: function( event, type, dd, x, elem ){
		// not configured
		if ( !dd ) 
			return;
		// remember the original event and type
		var orig = { event:event.originalEvent, type:event.type },
		// is the event drag related or drog related?
		mode = type.indexOf("drop") ? "drag" : "drop",
		// iteration vars
		result, i = x || 0, ia, $elems, callback,
		len = !isNaN( x ) ? x : dd.interactions.length;
		// modify the event type
		event.type = type;
		// remove the original event
		event.originalEvent = null;
		// initialize the results
		dd.results = [];
		// handle each interacted element
		do if ( ia = dd.interactions[ i ] ){
			// validate the interaction
			if ( type !== "dragend" && ia.cancelled )
				continue;
			// set the dragdrop properties on the event object
			callback = drag.properties( event, dd, ia );
			// prepare for more results
			ia.results = [];
			// handle each element
			$( elem || ia[ mode ] || dd.droppable ).each(function( p, subject ){
				// identify drag or drop targets individually
				callback.target = subject;
				// force propagtion of the custom event
				event.isPropagationStopped = function(){ return false; };
				// handle the event	
				result = subject ? $event.dispatch.call( subject, event, callback ) : null;
				// stop the drag interaction for this element
				if ( result === false ){
					if ( mode == "drag" ){
						ia.cancelled = true;
						dd.propagates -= 1;
					}
					if ( type == "drop" ){
						ia[ mode ][p] = null;
					}
				}
				// assign any dropinit elements
				else if ( type == "dropinit" )
					ia.droppable.push( drag.element( result ) || subject );
				// accept a returned proxy element 
				if ( type == "dragstart" )
					ia.proxy = $( drag.element( result ) || ia.drag )[0];
				// remember this result	
				ia.results.push( result );
				// forget the event result, for recycling
				delete event.result;
				// break on cancelled handler
				if ( type !== "dropinit" )
					return result;
			});	
			// flatten the results	
			dd.results[ i ] = drag.flatten( ia.results );	
			// accept a set of valid drop targets
			if ( type == "dropinit" )
				ia.droppable = drag.flatten( ia.droppable );
			// locate drop targets
			if ( type == "dragstart" && !ia.cancelled )
				callback.update(); 
		}
		while ( ++i < len )
		// restore the original event & type
		event.type = orig.type;
		event.originalEvent = orig.event;
		// return all handler results
		return drag.flatten( dd.results );
	},
		
	// extend the callback object with drag/drop properties...
	properties: function( event, dd, ia ){		
		var obj = ia.callback;
		// elements
		obj.drag = ia.drag;
		obj.proxy = ia.proxy || ia.drag;
		// starting mouse position
		obj.startX = dd.pageX;
		obj.startY = dd.pageY;
		// current distance dragged
		obj.deltaX = event.pageX - dd.pageX;
		obj.deltaY = event.pageY - dd.pageY;
		// original element position
		obj.originalX = ia.offset.left;
		obj.originalY = ia.offset.top;
		// adjusted element position
		obj.offsetX = obj.originalX + obj.deltaX; 
		obj.offsetY = obj.originalY + obj.deltaY;
		// assign the drop targets information
		obj.drop = drag.flatten( ( ia.drop || [] ).slice() );
		obj.available = drag.flatten( ( ia.droppable || [] ).slice() );
		return obj;	
	},
	
	// determine is the argument is an element or jquery instance
	element: function( arg ){
		if ( arg && ( arg.jquery || arg.nodeType == 1 ) )
			return arg;
	},
	
	// flatten nested jquery objects and arrays into a single dimension array
	flatten: function( arr ){
		return $.map( arr, function( member ){
			return member && member.jquery ? $.makeArray( member ) : 
				member && member.length ? drag.flatten( member ) : member;
		});
	},
	
	// toggles text selection attributes ON (true) or OFF (false)
	textselect: function( bool ){ 
		$( document )[ bool ? "unbind" : "bind" ]("selectstart", drag.dontstart )
			.css("MozUserSelect", bool ? "" : "none" );
		// .attr("unselectable", bool ? "off" : "on" )
		document.unselectable = bool ? "off" : "on"; 
	},
	
	// suppress "selectstart" and "ondragstart" events
	dontstart: function(){ 
		return false; 
	},
	
	// a callback instance contructor
	callback: function(){}
	
};

// callback methods
drag.callback.prototype = {
	update: function(){
		if ( $special.drop && this.available.length )
			$.each( this.available, function( i ){
				$special.drop.locate( this, i );
			});
	}
};

// patch $.event.$dispatch to allow suppressing clicks
var $dispatch = $event.dispatch;
$event.dispatch = function( event ){
	if ( $.data( this, "suppress."+ event.type ) - new Date().getTime() > 0 ){
		$.removeData( this, "suppress."+ event.type );
		return;
	}
	return $dispatch.apply( this, arguments );
};

// event fix hooks for touch events...
var touchHooks = 
$event.fixHooks.touchstart = 
$event.fixHooks.touchmove = 
$event.fixHooks.touchend =
$event.fixHooks.touchcancel = {
	props: "clientX clientY pageX pageY screenX screenY".split( " " ),
	filter: function( event, orig ) {
		if ( orig ){
			var touched = ( orig.touches && orig.touches[0] )
				|| ( orig.changedTouches && orig.changedTouches[0] )
				|| null; 
			// iOS webkit: touchstart, touchmove, touchend
			if ( touched ) 
				$.each( touchHooks.props, function( i, prop ){
					event[ prop ] = touched[ prop ];
				});
		}
		return event;
	}
};

// share the same special event configuration with related events...
$special.draginit = $special.dragstart = $special.dragend = drag;

})( jQuery );

module.resolve();

});			EasySocial.module('admin/vendors/mousewheel', function($) { 

var module = this; 


/*!
 * jQuery Mousewheel 3.1.12
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }


module.resolve();

});			
EasySocial.module('admin/vendors/raty', function($) {

var jQuery = $;
var module = this;

/*!
 * jQuery Raty FA - A Star Rating Plugin with Font Awesome
 *
 * Licensed under The MIT License
 *
 * @author  : Jacob Overgaard
 * @doc     : http://jacob87.github.io/raty-fa/
 * @version : 0.1.1
 *
 */

;(function($) {

  var methods = {
    init: function(settings) {
      return this.each(function() {
        methods.destroy.call(this);

        this.opt = $.extend(true, {}, $.fn.raty.defaults, settings);

        var that  = $(this),
            inits = ['number', 'readOnly', 'score', 'scoreName'];

        methods._callback.call(this, inits);

        if (this.opt.precision) {
          methods._adjustPrecision.call(this);
        }

        this.opt.number = methods._between(this.opt.number, 0, this.opt.numberMax);

        this.stars = methods._createStars.call(this);
        this.score = methods._createScore.call(this);

        methods._apply.call(this, this.opt.score);

        if (this.opt.cancel) {
          this.cancel = methods._createCancel.call(this);
        }

        if (this.opt.width) {
          that.css('width', this.opt.width);
        }

        if (this.opt.readOnly) {
          methods._lock.call(this);
        } else {
          that.css('cursor', 'pointer');
          methods._binds.call(this);
        }

        methods._target.call(this, this.opt.score);

        that.data({ 'settings': this.opt, 'raty': true });
      });
    }, _adjustPrecision: function() {
      this.opt.targetType = 'score';
      this.opt.half       = true;
    }, _apply: function(score) {
      if (score && score > 0) {
        score = methods._between(score, 0, this.opt.number);
        this.score.val(score);
      }

      methods._fill.call(this, score);

      if (score) {
        methods._roundStars.call(this, score);
      }
    }, _between: function(value, min, max) {
      return Math.min(Math.max(parseFloat(value), min), max);
    }, _binds: function() {
      if (this.cancel) {
        methods._bindCancel.call(this);
      }

      methods._bindClick.call(this);
      methods._bindOut.call(this);
      methods._bindOver.call(this);
    }, _bindCancel: function() {
      methods._bindClickCancel.call(this);
      methods._bindOutCancel.call(this);
      methods._bindOverCancel.call(this);
    }, _bindClick: function() {
      var self = this,
          that = $(self);

      self.stars.on('click.raty', function(evt) {
        self.score.val((self.opt.half || self.opt.precision) ? that.data('score') : $(this).data('score'));

        if (self.opt.click) {
          self.opt.click.call(self, parseFloat(self.score.val()), evt);
        }
      });
    }, _bindClickCancel: function() {
      var self = this;

      self.cancel.on('click.raty', function(evt) {
        self.score.removeAttr('value');

        if (self.opt.click) {
          self.opt.click.call(self, null, evt);
        }
      });
    }, _bindOut: function() {
      var self = this;

      $(this).on('mouseleave.raty', function(evt) {
        var score = parseFloat(self.score.val()) || undefined;

        methods._apply.call(self, score);
        methods._target.call(self, score, evt);

        if (self.opt.mouseout) {
          self.opt.mouseout.call(self, score, evt);
        }
      });
    }, _bindOutCancel: function() {
      var self = this;

      self.cancel.on('mouseleave.raty', function(evt) {
        $(this).attr('class', self.opt.cancelOff);

        if (self.opt.mouseout) {
          self.opt.mouseout.call(self, self.score.val() || null, evt);
        }
      });
    }, _bindOverCancel: function() {
      var self = this;

      self.cancel.on('mouseover.raty', function(evt) {
        $(this).attr('class', self.opt.cancelOn);

        self.stars.attr('class', self.opt.starOff);

        methods._target.call(self, null, evt);

        if (self.opt.mouseover) {
          self.opt.mouseover.call(self, null);
        }
      });
    }, _bindOver: function() {
      var self   = this,
          that   = $(self),
          action = self.opt.half ? 'mousemove.raty' : 'mouseover.raty';

      self.stars.on(action, function(evt) {
        var score = parseInt($(this).data('score'), 10);

        if (self.opt.half) {
          var position = parseFloat((evt.pageX - $(this).offset().left) / (self.opt.size ? self.opt.size : parseInt(that.css('font-size')))),
              plus     = (position > .5) ? 1 : .5;

          score = score - 1 + plus;

          methods._fill.call(self, score);

          if (self.opt.precision) {
            score = score - plus + position;
          }

          methods._roundStars.call(self, score);

          that.data('score', score);
        } else {
          methods._fill.call(self, score);
        }

        methods._target.call(self, score, evt);

        if (self.opt.mouseover) {
          self.opt.mouseover.call(self, score, evt);
        }
      });
    }, _callback: function(options) {
      for (var i in options) {
        if (typeof this.opt[options[i]] === 'function') {
          this.opt[options[i]] = this.opt[options[i]].call(this);
        }
      }
    }, _createCancel: function() {
      var that   = $(this),
          icon   = this.opt.cancelOff,
          cancel = $('<i />', { class: icon, title: this.opt.cancelHint });

      if (this.opt.cancelPlace == 'left') {
        that.prepend('&#160;').prepend(cancel);
      } else {
        that.append('&#160;').append(cancel);
      }

      return cancel;
    }, _createScore: function() {
      return $('<input />', { type: 'hidden', name: this.opt.scoreName }).appendTo(this);
    }, _createStars: function() {
      var that = $(this);

      for (var i = 1; i <= this.opt.number; i++) {
        var title = methods._getHint.call(this, i),
            icon  = (this.opt.score && this.opt.score >= i) ? 'starOn' : 'starOff';

        icon = this.opt[icon];

        $('<i />', { class : icon, title: title, 'data-score': i }).appendTo(this);

        if (this.opt.space) {
          that.append((i < this.opt.number) ? '&#160;' : '');
        }
      }

      return that.children('i');
    }, _error: function(message) {
      $(this).html(message);

      $.error(message);
    }, _fill: function(score) {
      var self  = this,
          hash  = 0;

      for (var i = 1; i <= self.stars.length; i++) {
        var star   = self.stars.eq(i - 1),
            select = self.opt.single ? (i == score) : (i <= score);

        if (self.opt.iconRange && self.opt.iconRange.length > hash) {
          var irange = self.opt.iconRange[hash],
              on     = irange.on  || self.opt.starOn,
              off    = irange.off || self.opt.starOff,
              icon   = select ? on : off;

          if (i <= irange.range) {
            star.attr('class', icon);
          }

          if (i == irange.range) {
            hash++;
          }
        } else {
          var icon = select ? 'starOn' : 'starOff';

          star.attr('class', this.opt[icon]);
        }
      }
    }, _getHint: function(score) {
      var hint = this.opt.hints[score - 1];
      return (hint === '') ? '' : (hint || score);
    }, _lock: function() {
      var score = parseInt(this.score.val(), 10), // TODO: 3.1 >> [['1'], ['2'], ['3', '.1', '.2']]
          hint  = score ? methods._getHint.call(this, score) : this.opt.noRatedMsg;

      $(this).data('readonly', true).css('cursor', '').attr('title', hint);

      this.score.attr('readonly', 'readonly');
      this.stars.attr('title', hint);

      if (this.cancel) {
        this.cancel.hide();
      }
    }, _roundStars: function(score) {
      var rest = (score - Math.floor(score)).toFixed(2);

      if (rest > this.opt.round.down) {
        var icon = 'starOn';                                 // Up:   [x.76 .. x.99]

        if (this.opt.halfShow && rest < this.opt.round.up) { // Half: [x.26 .. x.75]
          icon = 'starHalf';
        } else if (rest < this.opt.round.full) {             // Down: [x.00 .. x.5]
          icon = 'starOff';
        }

        this.stars.eq(Math.ceil(score) - 1).attr('class', this.opt[icon]);
      }                              // Full down: [x.00 .. x.25]
    }, _target: function(score, evt) {
      if (this.opt.target) {
        var target = $(this.opt.target);

        if (target.length === 0) {
          methods._error.call(this, 'Target selector invalid or missing!');
        }

        if (this.opt.targetFormat.indexOf('{score}') < 0) {
          methods._error.call(this, 'Template "{score}" missing!');
        }

        var mouseover = evt && evt.type == 'mouseover';

        if (score === undefined) {
          score = this.opt.targetText;
        } else if (score === null) {
          score = mouseover ? this.opt.cancelHint : this.opt.targetText;
        } else {
          if (this.opt.targetType == 'hint') {
            score = methods._getHint.call(this, Math.ceil(score));
          } else if (this.opt.precision) {
            score = parseFloat(score).toFixed(1);
          }

          if (!mouseover && !this.opt.targetKeep) {
            score = this.opt.targetText;
          }
        }

        if (score) {
          score = this.opt.targetFormat.toString().replace('{score}', score);
        }

        if (target.is(':input')) {
          target.val(score);
        } else {
          target.html(score);
        }
      }
    }, _unlock: function() {
      $(this).data('readonly', false).css('cursor', 'pointer').removeAttr('title');

      this.score.removeAttr('readonly', 'readonly');

      for (var i = 0; i < this.opt.number; i++) {
        this.stars.eq(i).attr('title', methods._getHint.call(this, i + 1));
      }

      if (this.cancel) {
        this.cancel.css('display', '');
      }
    }, cancel: function(click) {
      return this.each(function() {
        if ($(this).data('readonly') !== true) {
          methods[click ? 'click' : 'score'].call(this, null);
          this.score.removeAttr('value');
        }
      });
    }, click: function(score) {
      return $(this).each(function() {
        if ($(this).data('readonly') !== true) {
          methods._apply.call(this, score);

          if (!this.opt.click) {
            methods._error.call(this, 'You must add the "click: function(score, evt) { }" callback.');
          }


          this.opt.click.call(this, score, $.Event('click'));

          methods._target.call(this, score);
        }
      });
    }, destroy: function() {
      return $(this).each(function() {
        var that = $(this),
            raw  = that.data('raw');

        if (raw) {
          that.off('.raty').empty().css({ cursor: raw.style.cursor, width: raw.style.width }).removeData('readonly');
        } else {
          that.data('raw', that.clone()[0]);
        }
      });
    }, getScore: function() {
      var score = [],
          value ;

      $(this).each(function() {
        value = this.score.val();

        score.push(value ? parseFloat(value) : undefined);
      });

      return (score.length > 1) ? score : score[0];
    }, readOnly: function(readonly) {
      return this.each(function() {
        var that = $(this);

        if (that.data('readonly') !== readonly) {
          if (readonly) {
            that.off('.raty').children('i').off('.raty');

            methods._lock.call(this);
          } else {
            methods._binds.call(this);
            methods._unlock.call(this);
          }

          that.data('readonly', readonly);
        }
      });
    }, reload: function() {
      return methods.set.call(this, {});
    }, score: function() {
      return arguments.length ? methods.setScore.apply(this, arguments) : methods.getScore.call(this);
    }, set: function(settings) {
      return this.each(function() {
        var that   = $(this),
            actual = that.data('settings'),
            news   = $.extend({}, actual, settings);

        that.raty(news);
      });
    }, setScore: function(score) {
      return $(this).each(function() {
        if ($(this).data('readonly') !== true) {
          methods._apply.call(this, score);
          methods._target.call(this, score);
        }
      });
    }
  };

  $.fn.raty = function(method) {
    if (methods[method]) {
      return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if (typeof method === 'object' || !method) {
      return methods.init.apply(this, arguments);
    } else {
      $.error('Method ' + method + ' does not exist!');
    }
  };

  $.fn.raty.defaults = {
    cancel        : false,
    cancelHint    : 'Cancel this rating!',
    cancelOff     : 'fa fa-fw fa-minus-square',
    cancelOn      : 'fa fa-fw fa-check-square',
    cancelPlace   : 'left',
    click         : undefined,
    half          : false,
    halfShow      : true,
    hints         : ['bad', 'poor', 'regular', 'good', 'gorgeous'],
    iconRange     : undefined,
    mouseout      : undefined,
    mouseover     : undefined,
    noRatedMsg    : 'Not rated yet!',
    number        : 5,
    numberMax     : 20,
    precision     : false,
    readOnly      : false,
    round         : { down: .25, full: .6, up: .76 },
    score         : undefined,
    scoreName     : 'score',
    single        : false,
    size          : null,
    space         : true,
    starHalf      : 'fa fa-fw fa-star-half-o',
    starOff       : 'fa fa-fw fa-star-o',
    starOn        : 'fa fa-fw fa-star',
    target        : undefined,
    targetFormat  : '{score}',
    targetKeep    : false,
    targetText    : '',
    targetType    : 'hint',
    width         : false
  };

})(jQuery);

module.resolve();

});			EasySocial.module('admin/vendors/resize', function($) { 

var module = this; 

/*!
 * jQuery resize event - v1.1 - 3/14/2010
 * http://benalman.com/projects/jquery-resize-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery resize event
//
// *Version: 1.1, Last updated: 3/14/2010*
// 
// Project Home - http://benalman.com/projects/jquery-resize-plugin/
// GitHub       - http://github.com/cowboy/jquery-resize/
// Source       - http://github.com/cowboy/jquery-resize/raw/master/jquery.ba-resize.js
// (Minified)   - http://github.com/cowboy/jquery-resize/raw/master/jquery.ba-resize.min.js (1.0kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// This working example, complete with fully commented code, illustrates a few
// ways in which this plugin can be used.
// 
// resize event - http://benalman.com/code/projects/jquery-resize/examples/resize/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-resize/unit/
// 
// About: Release History
// 
// 1.1 - (3/14/2010) Fixed a minor bug that was causing the event to trigger
//       immediately after bind in some circumstances. Also changed $.fn.data
//       to $.data to improve performance.
// 1.0 - (2/10/2010) Initial release

  
  // A jQuery object containing all non-window elements to which the resize
  // event is bound.
  var elems = $([]),
    
    // Extend $.resize if it already exists, otherwise create it.
    jq_resize = $.resize = $.extend( $.resize, {} ),
    
    timeout_id,
    
    // Reused strings.
    str_setTimeout = 'setTimeout',
    str_resize = 'resize',
    str_data = str_resize + '-special-event',
    str_delay = 'delay',
    str_throttle = 'throttleWindow';
  
  // Property: jQuery.resize.delay
  // 
  // The numeric interval (in milliseconds) at which the resize event polling
  // loop executes. Defaults to 250.
  
  jq_resize[ str_delay ] = 250;
  
  // Property: jQuery.resize.throttleWindow
  // 
  // Throttle the native window object resize event to fire no more than once
  // every <jQuery.resize.delay> milliseconds. Defaults to true.
  // 
  // Because the window object has its own resize event, it doesn't need to be
  // provided by this plugin, and its execution can be left entirely up to the
  // browser. However, since certain browsers fire the resize event continuously
  // while others do not, enabling this will throttle the window resize event,
  // making event behavior consistent across all elements in all browsers.
  // 
  // While setting this property to false will disable window object resize
  // event throttling, please note that this property must be changed before any
  // window object resize event callbacks are bound.
  
  jq_resize[ str_throttle ] = true;
  
  // Event: resize event
  // 
  // Fired when an element's width or height changes. Because browsers only
  // provide this event for the window element, for other elements a polling
  // loop is initialized, running every <jQuery.resize.delay> milliseconds
  // to see if elements' dimensions have changed. You may bind with either
  // .resize( fn ) or .bind( "resize", fn ), and unbind with .unbind( "resize" ).
  // 
  // Usage:
  // 
  // > jQuery('selector').bind( 'resize', function(e) {
  // >   // element's width or height has changed!
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * The polling loop is not created until at least one callback is actually
  //   bound to the 'resize' event, and this single polling loop is shared
  //   across all elements.
  // 
  // Double firing issue in jQuery 1.3.2:
  // 
  // While this plugin works in jQuery 1.3.2, if an element's event callbacks
  // are manually triggered via .trigger( 'resize' ) or .resize() those
  // callbacks may double-fire, due to limitations in the jQuery 1.3.2 special
  // events system. This is not an issue when using jQuery 1.4+.
  // 
  // > // While this works in jQuery 1.4+
  // > $(elem).css({ width: new_w, height: new_h }).resize();
  // > 
  // > // In jQuery 1.3.2, you need to do this:
  // > var elem = $(elem);
  // > elem.css({ width: new_w, height: new_h });
  // > elem.data( 'resize-special-event', { width: elem.width(), height: elem.height() } );
  // > elem.resize();
      
  $.event.special[ str_resize ] = {
    
    // Called only when the first 'resize' event callback is bound per element.
    setup: function() {
      // Since window has its own native 'resize' event, return false so that
      // jQuery will bind the event using DOM methods. Since only 'window'
      // objects have a .setTimeout method, this should be a sufficient test.
      // Unless, of course, we're throttling the 'resize' event for window.
      if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
      
      var elem = $(this);
      
      // Add this element to the list of internal elements to monitor.
      elems = elems.add( elem );
      
      // Initialize data store on the element.
      $.data( this, str_data, { w: elem.width(), h: elem.height() } );
      
      // If this is the first element added, start the polling loop.
      if ( elems.length === 1 ) {
        loopy();
      }
    },
    
    // Called only when the last 'resize' event callback is unbound per element.
    teardown: function() {
      // Since window has its own native 'resize' event, return false so that
      // jQuery will unbind the event using DOM methods. Since only 'window'
      // objects have a .setTimeout method, this should be a sufficient test.
      // Unless, of course, we're throttling the 'resize' event for window.
      if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
      
      var elem = $(this);
      
      // Remove this element from the list of internal elements to monitor.
      elems = elems.not( elem );
      
      // Remove any data stored on the element.
      elem.removeData( str_data );
      
      // If this is the last element removed, stop the polling loop.
      if ( !elems.length ) {
        clearTimeout( timeout_id );
      }
    },
    
    // Called every time a 'resize' event callback is bound per element (new in
    // jQuery 1.4).
    add: function( handleObj ) {
      // Since window has its own native 'resize' event, return false so that
      // jQuery doesn't modify the event object. Unless, of course, we're
      // throttling the 'resize' event for window.
      if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
      
      var old_handler;
      
      // The new_handler function is executed every time the event is triggered.
      // This is used to update the internal element data store with the width
      // and height when the event is triggered manually, to avoid double-firing
      // of the event callback. See the "Double firing issue in jQuery 1.3.2"
      // comments above for more information.
      
      function new_handler( e, w, h ) {
        var elem = $(this),
          data = $.data( this, str_data );

        // fix related to https://github.com/cowboy/jquery-resize/issues/1
        if (data == null) {
          data = { w: null, h: null };
        }
        
        // If called from the polling loop, w and h will be passed in as
        // arguments. If called manually, via .trigger( 'resize' ) or .resize(),
        // those values will need to be computed.
        data.w = w !== undefined ? w : elem.width();
        data.h = h !== undefined ? h : elem.height();
        
        old_handler.apply( this, arguments );
      };
      
      // This may seem a little complicated, but it normalizes the special event
      // .add method between jQuery 1.4/1.4.1 and 1.4.2+
      if ( $.isFunction( handleObj ) ) {
        // 1.4, 1.4.1
        old_handler = handleObj;
        return new_handler;
      } else {
        // 1.4.2+
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
    
  };
  
  function loopy() {
    
    // Start the polling loop, asynchronously.
    timeout_id = window[ str_setTimeout ](function(){
      
      // Iterate over all elements to which the 'resize' event is bound.
      elems.each(function(){
        var elem = $(this),
          width = elem.width(),
          height = elem.height(),
          data = $.data( this, str_data );
        
        // If element size has changed since the last time, update the element
        // data store and trigger the 'resize' event.
        if ( width !== data.w || height !== data.h ) {
          elem.trigger( str_resize, [ data.w = width, data.h = height ] );
        }
        
      });
      
      // Loop.
      loopy();
      
    }, jq_resize[ str_delay ] );
    
  };
  
module.resolve();

});			EasySocial.module('admin/vendors/uniform', function($) { 

var module = this;

/**
Uniform v1.7.5
Copyright  2009 Josh Pyles / Pixelmatrix Design LLC
http://pixelmatrixdesign.com

Requires jQuery 1.4 or newer

Much thanks to Thomas Reynolds and Buck Wilson for their help and advice on this

Disabling text selection is made possible by Mathias Bynens <http://mathiasbynens.be/>
and his noSelect plugin. <http://github.com/mathiasbynens/noSelect-jQuery-Plugin>

Also, thanks to David Kaneda and Eugene Bond for their contributions to the plugin

License:
MIT License - http://www.opensource.org/licenses/mit-license.php

Enjoy!

*/

(function($) {
  $.uniform = {
    options: {
      selectClass:   'selector',
      radioClass: 'radio',
      checkboxClass: 'checker',
      fileClass: 'uploader',
      filenameClass: 'filename',
      fileBtnClass: 'action',
      fileDefaultText: 'No file selected',
      fileBtnText: 'Choose File',
      checkedClass: 'checked',
      focusClass: 'focus',
      disabledClass: 'disabled',
      buttonClass: 'button',
      activeClass: 'active',
      hoverClass: 'hover',
      useID: true,
      idPrefix: 'uniform',
      resetSelector: false,
      autoHide: true
    },
    elements: []
  };

  if($.browser.msie && $.browser.version < 7){
    $.support.selectOpacity = false;
  }else{
    $.support.selectOpacity = true;
  }

  $.fn.uniform = function(options) {

    options = $.extend($.uniform.options, options);

    var el = this;
    //code for specifying a reset button
    if(options.resetSelector != false){
      $(options.resetSelector).mouseup(function(){
        function resetThis(){
          $.uniform.update(el);
        }
        setTimeout(resetThis, 10);
      });
    }
    
    function doInput(elem){
      $el = $(elem);
      $el.addClass($el.attr("type"));
      storeElement(elem);
    }
    
    function doTextarea(elem){
      $(elem).addClass("uniform");
      storeElement(elem);
    }
    
    function doButton(elem){
      var $el = $(elem);
      
      var divTag = $("<div>"),
          spanTag = $("<span>");
      
      divTag.addClass(options.buttonClass);
      
      if(options.useID && $el.attr("id") != "") divTag.attr("id", options.idPrefix+"-"+$el.attr("id"));
      
      var btnText;
      
      if($el.is("a") || $el.is("button")){
        btnText = $el.text();
      }else if($el.is(":submit") || $el.is(":reset") || $el.is("input[type=button]")){
        btnText = $el.attr("value");
      }
      
      btnText = btnText == "" ? $el.is(":reset") ? "Reset" : "Submit" : btnText;
      
      spanTag.html(btnText);
      
      $el.css("opacity", 0);
      $el.wrap(divTag);
      $el.wrap(spanTag);
      
      //redefine variables
      divTag = $el.closest("div");
      spanTag = $el.closest("span");
      
      if($el.is(":disabled")) divTag.addClass(options.disabledClass);
      
      divTag.bind({
        "mouseenter.uniform": function(){
          divTag.addClass(options.hoverClass);
        },
        "mouseleave.uniform": function(){
          divTag.removeClass(options.hoverClass);
          divTag.removeClass(options.activeClass);
        },
        "mousedown.uniform touchbegin.uniform": function(){
          divTag.addClass(options.activeClass);
        },
        "mouseup.uniform touchend.uniform": function(){
          divTag.removeClass(options.activeClass);
        },
        "click.uniform touchend.uniform": function(e){
          if($(e.target).is("span") || $(e.target).is("div")){    
            if(elem[0].dispatchEvent){
              var ev = document.createEvent('MouseEvents');
              ev.initEvent( 'click', true, true );
              elem[0].dispatchEvent(ev);
            }else{
              elem[0].click();
            }
          }
        }
      });
      
      elem.bind({
        "focus.uniform": function(){
          divTag.addClass(options.focusClass);
        },
        "blur.uniform": function(){
          divTag.removeClass(options.focusClass);
        }
      });
      
      $.uniform.noSelect(divTag);
      storeElement(elem);
      
    }

    function doSelect(elem){
      var $el = $(elem);
      
      var divTag = $('<div />'),
          spanTag = $('<span />');
      
      if(!$el.css("display") == "none" && options.autoHide){
        divTag.hide();
      }

      divTag.addClass(options.selectClass);

      if(options.useID && elem.attr("id") != ""){
        divTag.attr("id", options.idPrefix+"-"+elem.attr("id"));
      }
      
      var selected = elem.find(":selected:first");
      if(selected.length == 0){
        selected = elem.find("option:first");
      }
      spanTag.html(selected.html());
      
      elem.css('opacity', 0);
      elem.wrap(divTag);
      elem.before(spanTag);

      //redefine variables
      divTag = elem.parent("div");
      spanTag = elem.siblings("span");

      elem.bind({
        "change.uniform": function() {
          spanTag.text(elem.find(":selected").html());
          divTag.removeClass(options.activeClass);
        },
        "focus.uniform": function() {
          divTag.addClass(options.focusClass);
        },
        "blur.uniform": function() {
          divTag.removeClass(options.focusClass);
          divTag.removeClass(options.activeClass);
        },
        "mousedown.uniform touchbegin.uniform": function() {
          divTag.addClass(options.activeClass);
        },
        "mouseup.uniform touchend.uniform": function() {
          divTag.removeClass(options.activeClass);
        },
        "click.uniform touchend.uniform": function(){
          divTag.removeClass(options.activeClass);
        },
        "mouseenter.uniform": function() {
          divTag.addClass(options.hoverClass);
        },
        "mouseleave.uniform": function() {
          divTag.removeClass(options.hoverClass);
          divTag.removeClass(options.activeClass);
        },
        "keyup.uniform": function(){
          spanTag.text(elem.find(":selected").html());
        }
      });
      
      //handle disabled state
      if($(elem).prop("disabled")){
        //box is checked by default, check our box
        divTag.addClass(options.disabledClass);
      }
      $.uniform.noSelect(spanTag);
      
      storeElement(elem);

    }

    function doCheckbox(elem){
      var $el = $(elem);
      
      var divTag = $('<div />'),
          spanTag = $('<span />');
      
      if(!$el.css("display") == "none" && options.autoHide){
        divTag.hide();
      }
      
      divTag.addClass(options.checkboxClass);

      //assign the id of the element
      if(options.useID && elem.attr("id") != ""){
        divTag.attr("id", options.idPrefix+"-"+elem.attr("id"));
      }

      //wrap with the proper elements
      $(elem).wrap(divTag);
      $(elem).wrap(spanTag);

      //redefine variables
      spanTag = elem.parent();
      divTag = spanTag.parent();

      //hide normal input and add focus classes
      $(elem)
      .css("opacity", 0)
      .bind({
        "focus.uniform": function(){
          divTag.addClass(options.focusClass);
        },
        "blur.uniform": function(){
          divTag.removeClass(options.focusClass);
        },
        "click.uniform touchend.uniform": function(){
          if(!$(elem).prop("checked")){
            //box was just unchecked, uncheck span
            spanTag.removeClass(options.checkedClass);
          }else{
            //box was just checked, check span.
            spanTag.addClass(options.checkedClass);
          }
        },
        "mousedown.uniform touchbegin.uniform": function() {
          divTag.addClass(options.activeClass);
        },
        "mouseup.uniform touchend.uniform": function() {
          divTag.removeClass(options.activeClass);
        },
        "mouseenter.uniform": function() {
          divTag.addClass(options.hoverClass);
        },
        "mouseleave.uniform": function() {
          divTag.removeClass(options.hoverClass);
          divTag.removeClass(options.activeClass);
        }
      });
      
      //handle defaults
      if($(elem).prop("checked")){
        //box is checked by default, check our box
        spanTag.addClass(options.checkedClass);
      }

      //handle disabled state
      if($(elem).prop("disabled")){
        //box is checked by default, check our box
        divTag.addClass(options.disabledClass);
      }

      storeElement(elem);
    }

    function doRadio(elem){
      var $el = $(elem);
      
      var divTag = $('<div />'),
          spanTag = $('<span />');
          
      if(!$el.css("display") == "none" && options.autoHide){
        divTag.hide();
      }

      divTag.addClass(options.radioClass);

      if(options.useID && elem.attr("id") != ""){
        divTag.attr("id", options.idPrefix+"-"+elem.attr("id"));
      }

      //wrap with the proper elements
      $(elem).wrap(divTag);
      $(elem).wrap(spanTag);

      //redefine variables
      spanTag = elem.parent();
      divTag = spanTag.parent();

      //hide normal input and add focus classes
      $(elem)
      .css("opacity", 0)
      .bind({
        "focus.uniform": function(){
          divTag.addClass(options.focusClass);
        },
        "blur.uniform": function(){
          divTag.removeClass(options.focusClass);
        },
        "click.uniform touchend.uniform": function(){
          if(!$(elem).prop("checked")){
            //box was just unchecked, uncheck span
            spanTag.removeClass(options.checkedClass);
          }else{
            //box was just checked, check span
            var classes = options.radioClass.split(" ")[0];
            $("." + classes + " span." + options.checkedClass + ":has([name='" + $(elem).attr('name') + "'])").removeClass(options.checkedClass);
            spanTag.addClass(options.checkedClass);
          }
        },
        "mousedown.uniform touchend.uniform": function() {
          if(!$(elem).is(":disabled")){
            divTag.addClass(options.activeClass);
          }
        },
        "mouseup.uniform touchbegin.uniform": function() {
          divTag.removeClass(options.activeClass);
        },
        "mouseenter.uniform touchend.uniform": function() {
          divTag.addClass(options.hoverClass);
        },
        "mouseleave.uniform": function() {
          divTag.removeClass(options.hoverClass);
          divTag.removeClass(options.activeClass);
        }
      });

      //handle defaults
      if($(elem).prop("checked")){
        //box is checked by default, check span
        spanTag.addClass(options.checkedClass);
      }
      //handle disabled state
      if($(elem).prop("disabled")){
        //box is checked by default, check our box
        divTag.addClass(options.disabledClass);
      }

      storeElement(elem);

    }

    function doFile(elem){
      //sanitize input
      var $el = $(elem);

      var divTag = $('<div />'),
          filenameTag = $('<span>'+options.fileDefaultText+'</span>'),
          btnTag = $('<span>'+options.fileBtnText+'</span>');
      
      if(!$el.css("display") == "none" && options.autoHide){
        divTag.hide();
      }

      divTag.addClass(options.fileClass);
      filenameTag.addClass(options.filenameClass);
      btnTag.addClass(options.fileBtnClass);

      if(options.useID && $el.attr("id") != ""){
        divTag.attr("id", options.idPrefix+"-"+$el.attr("id"));
      }

      //wrap with the proper elements
      $el.wrap(divTag);
      $el.after(btnTag);
      $el.after(filenameTag);

      //redefine variables
      divTag = $el.closest("div");
      filenameTag = $el.siblings("."+options.filenameClass);
      btnTag = $el.siblings("."+options.fileBtnClass);

      //set the size
      if(!$el.attr("size")){
        var divWidth = divTag.width();
        //$el.css("width", divWidth);
        $el.attr("size", divWidth/10);
      }

      //actions
      var setFilename = function()
      {
        var filename = $el.val();
        if (filename === '')
        {
          filename = options.fileDefaultText;
        }
        else
        {
          filename = filename.split(/[\/\\]+/);
          filename = filename[(filename.length-1)];
        }
        filenameTag.text(filename);
      };

      // Account for input saved across refreshes
      setFilename();

      $el
      .css("opacity", 0)
      .bind({
        "focus.uniform": function(){
          divTag.addClass(options.focusClass);
        },
        "blur.uniform": function(){
          divTag.removeClass(options.focusClass);
        },
        "mousedown.uniform": function() {
          if(!$(elem).is(":disabled")){
            divTag.addClass(options.activeClass);
          }
        },
        "mouseup.uniform": function() {
          divTag.removeClass(options.activeClass);
        },
        "mouseenter.uniform": function() {
          divTag.addClass(options.hoverClass);
        },
        "mouseleave.uniform": function() {
          divTag.removeClass(options.hoverClass);
          divTag.removeClass(options.activeClass);
        }
      });

      // IE7 doesn't fire onChange until blur or second fire.
      if ($.browser.msie){
        // IE considers browser chrome blocking I/O, so it
        // suspends tiemouts until after the file has been selected.
        $el.bind('click.uniform.ie7', function() {
          setTimeout(setFilename, 0);
        });
      }else{
        // All other browsers behave properly
        $el.bind('change.uniform', setFilename);
      }

      //handle defaults
      if($el.prop("disabled")){
        //box is checked by default, check our box
        divTag.addClass(options.disabledClass);
      }
      
      $.uniform.noSelect(filenameTag);
      $.uniform.noSelect(btnTag);
      
      storeElement(elem);

    }
    
    $.uniform.restore = function(elem){
      if(elem == undefined){
        elem = $($.uniform.elements);
      }
      
      $(elem).each(function(){
        if($(this).is(":checkbox")){
          //unwrap from span and div
          $(this).unwrap().unwrap();
        }else if($(this).is("select")){
          //remove sibling span
          $(this).siblings("span").remove();
          //unwrap parent div
          $(this).unwrap();
        }else if($(this).is(":radio")){
          //unwrap from span and div
          $(this).unwrap().unwrap();
        }else if($(this).is(":file")){
          //remove sibling spans
          $(this).siblings("span").remove();
          //unwrap parent div
          $(this).unwrap();
        }else if($(this).is("button, :submit, :reset, a, input[type='button']")){
          //unwrap from span and div
          $(this).unwrap().unwrap();
        }
        
        //unbind events
        $(this).unbind(".uniform");
        
        //reset inline style
        $(this).css("opacity", "1");
        
        //remove item from list of uniformed elements
        var index = $.inArray($(elem), $.uniform.elements);
        $.uniform.elements.splice(index, 1);
      });
    };

    function storeElement(elem){
      //store this element in our global array
      elem = $(elem).get();
      if(elem.length > 1){
        $.each(elem, function(i, val){
          $.uniform.elements.push(val);
        });
      }else{
        $.uniform.elements.push(elem);
      }
    }
    
    //noSelect v1.0
    $.uniform.noSelect = function(elem) {
      function f() {
       return false;
      };
      $(elem).each(function() {
       this.onselectstart = this.ondragstart = f; // Webkit & IE
       $(this)
        .mousedown(f) // Webkit & Opera
        .css({ MozUserSelect: 'none' }); // Firefox
      });
     };

    $.uniform.update = function(elem){
      if(elem == undefined){
        elem = $($.uniform.elements);
      }
      //sanitize input
      elem = $(elem);

      elem.each(function(){
        //do to each item in the selector
        //function to reset all classes
        var $e = $(this);

        if($e.is("select")){
          //element is a select
          var spanTag = $e.siblings("span");
          var divTag = $e.parent("div");

          divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);

          //reset current selected text
          spanTag.html($e.find(":selected").html());

          if($e.is(":disabled")){
            divTag.addClass(options.disabledClass);
          }else{
            divTag.removeClass(options.disabledClass);
          }

        }else if($e.is(":checkbox")){
          //element is a checkbox
          var spanTag = $e.closest("span");
          var divTag = $e.closest("div");

          divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);
          spanTag.removeClass(options.checkedClass);

          if($e.is(":checked")){
            spanTag.addClass(options.checkedClass);
          }
          if($e.is(":disabled")){
            divTag.addClass(options.disabledClass);
          }else{
            divTag.removeClass(options.disabledClass);
          }

        }else if($e.is(":radio")){
          //element is a radio
          var spanTag = $e.closest("span");
          var divTag = $e.closest("div");

          divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);
          spanTag.removeClass(options.checkedClass);

          if($e.is(":checked")){
            spanTag.addClass(options.checkedClass);
          }

          if($e.is(":disabled")){
            divTag.addClass(options.disabledClass);
          }else{
            divTag.removeClass(options.disabledClass);
          }
        }else if($e.is(":file")){
          var divTag = $e.parent("div");
          var filenameTag = $e.siblings(options.filenameClass);
          btnTag = $e.siblings(options.fileBtnClass);

          divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);

          filenameTag.text($e.val());

          if($e.is(":disabled")){
            divTag.addClass(options.disabledClass);
          }else{
            divTag.removeClass(options.disabledClass);
          }
        }else if($e.is(":submit") || $e.is(":reset") || $e.is("button") || $e.is("a") || elem.is("input[type=button]")){
          var divTag = $e.closest("div");
          divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);
          
          if($e.is(":disabled")){
            divTag.addClass(options.disabledClass);
          }else{
            divTag.removeClass(options.disabledClass);
          }
          
        }
        
      });
    };

    return this.each(function() {
      if($.support.selectOpacity){
        var elem = $(this);

        if(elem.is("select")){
          //element is a select
          if(elem.attr("multiple") != true){
            //element is not a multi-select
            if(elem.attr("size") == undefined || elem.attr("size") <= 1){
              doSelect(elem);
            }
          }
        }else if(elem.is(":checkbox")){
          //element is a checkbox
          doCheckbox(elem);
        }else if(elem.is(":radio")){
          //element is a radio
          doRadio(elem);
        }else if(elem.is(":file")){
          //element is a file upload
          doFile(elem);
        }else if(elem.is(":text, :password, input[type='email']")){
          doInput(elem);
        }else if(elem.is("textarea")){
          doTextarea(elem);
        }else if(elem.is("a") || elem.is(":submit") || elem.is(":reset") || elem.is("button") || elem.is("input[type=button]")){
          doButton(elem);
        }
          
      }
    });
  };
})($);

module.resolve();

});			EasySocial.module('admin/workflows/choices', function($) {

var module = this;

EasySocial.Controller('Config.Choices', {
	defaultOptions: {
		'{choiceItems}' : '[data-fields-config-param-choice]',
		unique : 1
	}
}, function(self, opts, base) { return {
	init: function() {
		self.options.unique = self.element.data('unique') !== undefined ? self.element.data('unique') : 1;

		self.choiceItems().implement(EasySocial.Controller.Config.Choices.Choice, {
			controller: {
				'choices': self
			}
		});

		self.initSortable();
	},

	initSortable: function() {
		self.element.sortable({
			items: self.choiceItems.selector,
			placeholder: 'ui-state-highlight',
			cursor: 'move',
			forceHelperSize: true,
			handle: '[data-fields-config-param-choice-drag]',
			stop: function() {
				// Manually remove all the freezing tooltip due to conflict between bootstrap tooltip and jquery sortable
				$('.tooltip-es').remove();

				// Trigger change on parent field
				$('[data-fields-config-param]').trigger('change');
			}
		});
	}
}});

/* Config Choices Choice Controller */
EasySocial.Controller('Config.Choices.Choice', {
	defaultOptions: {
		'{choiceValue}': '[data-fields-config-param-choice-value]',
		'{choiceTitle}': '[data-fields-config-param-choice-title]',
		'{choiceDefault}': '[data-fields-config-param-choice-default]',
		'{addChoice}': '[data-fields-config-param-choice-add]',
		'{removeChoice}': '[data-fields-config-param-choice-remove]',
		'{setDefault}': '[data-fields-config-param-choice-setdefault]',

		'{defaultIcon}': '[data-fields-config-param-choice-defaulticon]'
	}
}, function(self, opts, base) { return {

	init: function() {
	},

	'{addChoice} click' : function() {
		// Clone a new item from current clicked element
		var newItem = self.element.clone();

		// Let's leave the value blank by default.
		var inputElement = newItem.find('input[type="text"]');

		inputElement.attr('value', '');

		inputElement.val('');

		// Set the default as 0 and the icon to unfeatured
		var inputDefault = newItem.find('input[type="hidden"]');

		inputDefault.attr('value', 0);

		inputDefault.val(0);

		// set id = 0
		newItem.attr('data-id', 0);
		newItem.data('id', 0);

		// Implement the controller for this choice
		newItem.implement(EasySocial.Controller.Config.Choices.Choice, {
			controller: {
				'choices': self.choices
			}
		});

		// Append this item
		self.element.after(newItem);
	},

	'{removeChoice} click' : function() {
		// We need to minus one because we're trying to remove ourself also.
		var remaining = self.choices.choiceItems().length - 1;

		// If this is the last item, we wouldn't want to allow the last item to be removed.
		if (remaining >= 1) {
			self.element.remove();

			// Manually remove the tooltip generated on the remove button
			$('.tooltip-es').remove();

			// Trigger event
			$('[data-fields-conditional-param]').trigger('change');
			$('[data-fields-config-param]').trigger('change');
		}
	},

	'{setDefault} click': function() {
		var index = self.element.index(),
			title = self.choiceTitle().val(),
			value = self.choiceValue().val();

		self.choices.choiceItems().trigger( 'toggleDefault', [index] );
	},

	'{self} toggleDefault': function(el, ev, i) {
		var index = self.element.index(),
			value = parseInt(self.choiceDefault().val());

		if (index === i) {
			if(value) {
				self.defaultIcon()
					.removeClass('es-state-featured')
					.addClass('es-state-default');

				self.choiceDefault().val(0);
			} else {
				self.defaultIcon()
					.removeClass('es-state-default')
					.addClass('es-state-featured');

				self.choiceDefault().val(1);
			}
		} else {
			if(self.choices.options.unique) {
				self.defaultIcon()
					.removeClass('es-state-featured')
					.addClass('es-state-default');

				self.choiceDefault().val(0);
			}
		}

		$('[data-fields-config-param]').trigger('change');
	}
}});

module.resolve();
});			EasySocial.module('admin/workflows/form', function($) {

var module = this;

EasySocial.require()
.library('ui/sortable', 'scrollTo')
.script('admin/workflows/choices')
.done(function($) {

EasySocial.Controller('Workflows', {
	defaultOptions: {
		id: null,
		tmpSteps: null,
		tpls: {},
		fieldsValue: {},
		fieldsData: {},
		fieldsChoices: {},
		fieldsConditions: {},
		stepsValue: {},
		stepsHtml: {},
		fieldsConfigValue: {},
		deletedFields: {},
		deletedSteps: {},
		hiddenClass: 't-hidden',

		"{templates}": '[data-workflow-templates]',
		"{content}": "[data-content]",
		"{titleInput}": "[data-input-workflow-title]",
		"{descInput}": "[data-input-workflow-description]",
		"{workflowConfigSave}": "[data-workflow-config-save-button]",

		// Steps
		"{steps}": "[data-steps]",
		"{step}": "[data-step-item]",
		"{newStep}": "[data-step-new]",
		"{stepTitle}": "[data-step-title]",
		"{editStep}": "[data-step-edit]",
		"{deleteStepButton}": "[data-step-delete]",

		// Fields
		"{fields}": "[data-fields]",
		"{field}": "[data-field-item]",
		"{newField}": "[data-field-new]",
		"{moveField}": "[data-field-item-move]",
		"{deleteField}": "[data-field-item-delete]",
		"{editField}": "[data-field-item-edit]",
		"{conditionalField}": "[data-field-item-conditional]",
		"{conditionalParam}" : "[data-fields-conditional-param]",
		"{fieldRequiredSymbol}" : "[data-field-item-required]",

		// Input type to hold fields configuration values
		"{saveFieldsInput}": "[data-fields-saved-value]",

		// Fields Settings
		"{fieldSettings}": "[data-field-settings]",
		"{fieldParam}": "[data-fields-config-param]",

		// Fields Browser
		"{fieldBrowser}": "[data-field-browser]",
		"{fieldBrowserClose}": "[data-field-browser-close]",
		"{fieldsTypeTab}" : "[data-field-type-tab]",
		"{fieldTypeContent}" : "[data-field-type-content]",
		"{fieldBrowserItems}" : "[data-field-browser-items]",
		"{fieldBrowserItem}" : "[data-field-browser-item]",

		// Fields Dialog
		"{dialogFieldSave}": "[data-field-save-button]",
		"{dialogFieldCancel}": "[data-field-cancel-button]",
		"{dialogFieldTab}": "[data-field-tab]",
		"{dialogFieldContent}": "[data-field-content]",
		"{dialogStepSave}": "[data-field-step-save-button]",

		// Error dialog
		"{dialogError}": "[data-dialog-error]",
		"{dialogErrorClose}" : "[data-dialog-error-close]"
	}
}, function(self, opts, base) { return {
	
	init: function() {
		opts.id = self.element.data('id');

		// Initialize all available templates on the page
		this.initTemplates();

		// Need to initialize the drag / drop here
		this.initSortable();

		// Initialize fields default data if this is a new workflow
		this.initDefaultData();

		this.initBindEvent();

		// Duckpunch setMessage
		self._setMessage = self.setMessage;

		self.setMessage = function(message, type, element) {

			if (element == undefined) {
				// Do not set any messages when story is collapsed or is resizing.
				if (base.hasClass("is-resizing")) {
					return;
				}

				// Remove any previous message group first to avoid stacking error messages.
				this.element
					.find('[data-message-group]')
					.remove();

				self._setMessage.apply(this, [message, type]);
			} else {

				var tpl = self.getTemplate('alert');
				var classType = 'o-alert--' + type;
				var container = element.find('[data-message-group]');

				tpl.addClass(classType);

				// Get any message directly from the container
				if (!message) {
					message = container.data('message');
				}

				tpl.find('[data-message]').html(message);

				element.find('[data-message-group]').html(tpl);
			}
		};
	},

	initDefaultData: function() {
		if (!opts.id || opts.id == '') {
			var defaults = JSON.parse(opts.tmpSteps);
			var steps = [];
			var fields = [];

			// Construct steps informations
			$.each(defaults, function(key, step) {

				var stepData = [
					{
						name : "title",
						value: step.title
					},
					{
						name : "description",
						value : step.description
					}
				]

				// Store step
				self.storeSteps(step.id, stepData);

				if (step.fields) {
					$.each(step.fields, function(key, field) {
						var fieldsData = [];

						$.each(field, function(name, value) {
							var input = {
								name: name,
								value : value
							}

							fieldsData.push(input);
						})

						// Store individual field
						self.storeFieldsData(field.id, fieldsData);
					});
				}
			});
		}
	},

	// Fetch all available templates on the page
	initTemplates: function() {
		var templates = self.templates().children();

		$.each(templates, function() {
			var template = $(this);
			var key = template.data('template');
			
			opts.tpls[key] = template.html();
		});
	},

	initSortable: function() {
		this.initStepsSortable();
		this.initFieldsSortable();
	},

	initStepsSortable: function() {

		self.steps().sortable({
			items: self.step.selector,
			cursor: 'move',
			forceHelperSize: true,
			axis : 'x',
			update : function(event, ui) {
				self.updateOrdering(self.step());
			}
		});
	},

	initFieldsSortable: function() {
		self.fields().sortable({
			items: self.field.selector,
			cursor: 'move',
			forceHelperSize: true,
			axis : 'y',
			start: function(event, ui) {
				ui.helper.addClass('is-new');

				// Temporarily removed has-condition class
				if (ui.helper.hasClass('has-condition')) {
					ui.helper.removeClass('has-condition').addClass('has-condition-tmp');
				}
			},
			stop: function(event, ui) {
				setTimeout(function() {
					ui.item.removeClass('is-new');

					if (ui.item.hasClass('has-condition-tmp')) {
						ui.item.removeClass('has-condition-tmp').addClass('has-condition');
					}
				}, 150);
			},
			update : function(event, ui) {
				self.updateOrdering(self.field());
			}
		});
	},

	initBindEvent: function() {
		$(document).on('keyup', function(e) {
			// esc key
			if (e.keyCode == 27) {
				self.closeDialog();
			}
		});
	},

	getTemplate: function(key) {
		var tpl = $(opts.tpls[key]).clone();
		return tpl;
	},

	updateOrdering: function(element) {
		$.each(element, function() {
			var item = $(this);
			var index = item.index();

			// Update the sequence
			item.attr('data-ordering', index);
		});
	},

	changed: false,

	isChanged: function() {
		self.changed = true;
	},

	mandatoryCheck: function() {
		return self.fieldsTypeTab().filter('[id="core"]').hasClass(opts.hiddenClass);
	},

	hasEmptySteps: function() {
		var stepData = self.step();
		var hasEmpty = false;

		$.each(stepData, function(i, step) {
			var step = $(step);
			var stepId = step.data('id');

			if (stepId) {
				if (!self.isStepEmpty(stepId)) {
					return;
				} else {
					hasEmpty = true;
					return false;
				}
			}
		});

		return hasEmpty;
	},

	isStepEmpty: function(stepId) {
		var stepContent = $(self.content.selector + '[data-id="' +  stepId + '"]');
		var fields = stepContent.find(self.field.selector);

		return fields.length > 0 ? false : true;
	},

	validate: function() {

		// Check for mandatory field
		if (!self.mandatoryCheck()) {
			self.showDialogError('mandatory');
			return false;
		}

		// Warn user about empty steps
		if (self.hasEmptySteps()) {
			self.showDialogError('empty-step');
			return false;
		}

		return true;
	},

	save: function() {
		var dfd = $.Deferred();

		// Perform save validation
		if (!self.validate()) {
			dfd.reject();
			return dfd;
		}

		// Perform collection of the input
		var workflowData = self.fetchWorkflowData();

		// Inject the data into the input form
		self.injectSaveData(workflowData);

		// When everything is done, we can mark the deferred object as resolved
		dfd.resolve();

		return dfd;
	},

	getAvailableFields: function() {
		return self.fetchWorkflowData(true, true);
	},

	fetchWorkflowData: function(currentStep, simpleData) {
		var steps = [];
		var stepOrdering = 0;

		// Get all available step
		var stepData = self.step();

		// Determine if we want to retrieve the data for current step only
		if (currentStep) {
			stepData = self.getCurrentStep();
		}

		$.each(stepData, function(i, step) {
			var step = $(step);
			var stepContent = $(self.content.selector + '[data-id="' +  step.data('id') + '"]');
			var stepsData = [];
			var tmpFieldData = [];

			// Get all fields within the step
			var fields = stepContent.find(self.field.selector);

			if (fields.length > 0) {

				var fieldOrdering = 0;

				// Construct the fields data
				$.each(fields, function(i, field) {
					var field = $(field);

					if (simpleData) {
						var fieldData = {
							fieldTitle : field.find('[data-field-item-title]').html(),
							fieldId: field.data('id'),
							fieldElement: field.data('element'),
							appId: field.data('appid'),
						}
					} else {
						var fieldData = {
							fieldTitle : field.find('[data-field-item-title]').html(),
							fieldId: field.data('id'),
							fieldElement: field.data('element'),
							appId: field.data('appid'),
							ordering: fieldOrdering,
							isNew: field.data('isnew'),
							params: opts.fieldsValue[field.data('id')]
						}
					}

					tmpFieldData.push(fieldData);

					fieldOrdering++;
				});

				if (simpleData) {
					var stepsData = {
						stepId: step.data('id'),
						fields: tmpFieldData
					}
				} else {
					var stepsData = {
						stepId: step.data('id'),
						ordering: stepOrdering,
						isNew: step.data('isnew'),
						params: opts.stepsValue[step.data('id')],
						fields: tmpFieldData
					}
				}

				steps.push(stepsData);

				stepOrdering++;
			} else {

				// Remove the step since there are no field within the steps
				if (step.data('id')) {
					if (self.deletedSteps === undefined) {
						self.deletedSteps = [];
					}

					self.deletedSteps.push(step.data('id'));
				}
			}
		});

		var deleted = {
			steps : self.deletedSteps,
			field : self.deletedFields
		}

		var workflowData = {
			"steps" : steps,
			"deleted" : deleted
		}

		return workflowData;
	},

	openWorkflowConfig: function() {
		var config = $(self.getTemplate('workflow-config'));

		// Set title and description
		config.find('[data-workflow-config-title]').val(self.titleInput().val());
		config.find('[data-workflow-config-description]').val(self.descInput().val());

		self.fieldSettings().html(config.wrap('<p/>').parent().html());

		config.unwrap();
	},

	"{workflowConfigSave} click": function(el, event) {
		var parent = el.parents('[data-config-dialog]');

		var title = parent.find('[data-workflow-config-title]').val();
		var description = parent.find('[data-workflow-config-description]').val();

		// Update the value on the input and the page header
		self.titleInput().val(title);
		self.descInput().val(description);

		$('[data-structure-heading]').html(title);
		$('[data-structure-description]').html(description);

		self.closeDialog();
	},

	"{newStep} click": function() {
		self.addStep();
	},

	"{step} click": function(el, event) {
		var id = el.data('id');
		self.switchTab(id);
	},

	showFieldBrowser: function() {
		self.fieldBrowser().removeClass(opts.hiddenClass);

		self.fieldBrowser()
			.find('[data-message-group]')
			.html('');
	},

	// Centralize all the dialogs
	closeDialog: function() {

		// Field browser popup
		self.fieldBrowser().addClass(opts.hiddenClass);

		// Error dialog
		self.dialogError().addClass(opts.hiddenClass);

		// Various dialog form
		self.dialogFieldCancel().trigger('click');
	},

	showDialogError: function(type) {
		var errorDialog = $(self.getTemplate('dialog-error'));
		var dialogMessage = errorDialog.find('[data-error-type="' + type + '"]');

		if (dialogMessage.length > 0) {
			dialogMessage.removeClass(opts.hiddenClass);
		} else {
			errorDialog.find('[data-error-type="default"]').removeClass(opts.hiddenClass)
		}

		self.fieldSettings().html(errorDialog.wrap('<p/>').parent().html());
		errorDialog.unwrap();
	},

	getNewFieldButton: function() {
		var tpl = $('[data-field-new]').first().clone();
		return tpl;
	},

	getField: function(fieldId) {
		var field = $(self.field.selector + '[data-id="' + fieldId + '"]');

		return field;
	},

	updateFieldBrowser: function(appId, action) {
		var hide = true;

		// Get the field
		var field = self.fieldBrowserItem().filter('[data-id="' + appId + '"]');

		// Parent of the field
		var parent = field.parents(self.fieldTypeContent.selector);

		// Exception for standard field
		if (parent.attr('id') == 'standard') {
			return;
		}

		// Hide or show field
		field[action + 'Class'](opts.hiddenClass);

		// Determine if we should hide or show tabs of the fields
		var fields = parent.find(self.fieldBrowserItems.selector).children();
		var fieldTab = self.fieldsTypeTab().filter('[id="' + parent.attr('id') + '"]');

		// No more fields left
		if (fields.not('.' + opts.hiddenClass).length < 1) {

			// Hide tab
			fieldTab.addClass(opts.hiddenClass);

			// Switch to nearest tab
			self.fieldsTypeTab().not('.' + opts.hiddenClass).eq(0).trigger('click');
		} else {

			// Show tab
			fieldTab.removeClass(opts.hiddenClass);
		}
	},

	switchTab: function(id) {
		// Get the step tab
		var tab = self.getStepTab(id);

		// Get the content of the steps
		var steps = self.getStepContent(id);

		self.step().removeClass('is-active');
		tab.addClass('is-active');

		self.content().addClass(opts.hiddenClass);
		steps.removeClass(opts.hiddenClass);
	},

	addStep: function() {
		// Generate unique id
		var uniqueId = $.uid();

		// Insert a new step template
		var template = self.getTemplate('step');

		// set unique id for this steps
		template.attr('data-id', uniqueId);
		
		// Append the template before the new button
		template.insertBefore(self.newStep());

		// Append the editor template on the main content
		var editorTemplate = self.getTemplate('editor');

		// Set unique id
		editorTemplate.attr('data-id', uniqueId);

		// Append the content
		editorTemplate.insertBefore(self.templates());

		// Updata the ordering
		self.updateOrdering(self.step());

		// Show delete steps button
		self.deleteStepButton().removeClass(opts.hiddenClass);

		// Change the page to newly created step
		template.trigger('click');
	},

	addField: function(element, field, wrapper) {

		var newField = false;

		if (field == undefined) {
			// Get field template
			var field = self.getTemplate('field');
			var fieldElement = element.data('fieldElement');

			// Add header class for header field
			if (fieldElement == 'header') {
				field.addClass('es-wf-field--header');
			}

			field.attr('data-id', $.uid());
			field.attr('data-appid', element.data('id'));
			field.attr('data-element', fieldElement)
			field.find('[data-field-item-title]').html(element.data('fieldTitle'));
			field.find('[data-field-item-element]').html(fieldElement.toUpperCase());

			newField = true;
		}

		// Get current steps wrapper
		if (wrapper == undefined) {
			var wrapper = self.getCurrentStep();
		}

		// Get the fields wrapper
		var fieldsWrapper = wrapper.find('[data-fields-wrapper]');

		// Get lists of fields
		var fieldsContent = fieldsWrapper.find('[data-fields]');

		if (fieldsContent.children().length > 0) {
			var clickedNewField = fieldsContent.find(self.currentNewField);
			var action = clickedNewField.data('action');

			clickedNewField[action](field);
		} else {
			self.currentNewField = self.getNewFieldButton().attr('data-action', 'after');

			fieldsContent.append(self.currentNewField);
			fieldsContent.append(field);
			fieldsContent.append(self.getNewFieldButton().attr('data-action', 'before'));
		}

		// Remove empty fields wrapper empty state
		fieldsWrapper.removeClass('is-empty');

		// Update field ordering
		self.updateOrdering(fieldsContent.children());

		// Re-initialize sortable
		self.initFieldsSortable();

		// Update field browser
		if (newField) {

			// self.closeDialog();
			// Tell the user that the field is added to the form
			self.setMessage(false, 'info', self.fieldBrowser());

			self.updateFieldBrowser(element.data('id'), 'add');
		}

		// Scroll to the field
		$.scrollTo(field.offset().top - 250, 200);

		// Add highlight effects of the newly added fields for a few seconds
		field.addClass('is-new');
		setTimeout(function() {
			field.removeClass('is-new');
		}, 1500);
	},

	"{fieldBrowserItem} click": function(element, event) {
		self.addField(element);
	},

	"{fieldBrowser} click": function(element, event) {
		if (event.target == element[0]) {
			event.preventDefault();
			event.stopPropagation();

			self.closeDialog();
		}
	},

	"{dialogError} click": function(element, event) {
		if (event.target == element[0]) {
			event.preventDefault();
			event.stopPropagation();

			self.closeDialog();
		}
	},

	"{dialogErrorClose} click": function(element, event) {
		event.preventDefault();
		event.stopPropagation();

		self.closeDialog();
	},

	"{newField} click": function(element, event) {
		self.currentNewField = element;
		self.showFieldBrowser();
	},

	"{fieldBrowserClose} click": function(el, ev) {
		ev.preventDefault();
		ev.stopPropagation();

		self.closeDialog();
	},

	"{fieldsTypeTab} click": function(el, event) {
		self.fieldsTypeTab().removeClass('active');
		el.addClass('active');

		var id = el.attr('id');
		var content = self.fieldTypeContent();

		content.addClass(opts.hiddenClass);

		content.each(function() {
			if ($(this).attr('id') == id) {
				$(this).removeClass(opts.hiddenClass);
			}
		})
	},

	"{editStep} click": function(el, event) {
		self.fieldSettings().html(self.getTemplate('dialog-loader'));

		var stepId = el.parents(self.content.selector).data('id');

		self.fieldsData = [];

		EasySocial.ajax('admin/views/fields/loadStepConfiguration', {
			"id": stepId
		}).done(function(content, values, params) {

			// Check for previous data
			if (self.stepsHtml) {
				$.each(self.stepsHtml, function(key, data) {
					if (data.stepId == stepId) {
						content = data.html;
						return false;
					}
				});
			}

			self.fieldSettings().html(content);

			// Apply multi choices
			self.fieldSettings().find('[data-fields-config-param-choices]').addController('EasySocial.Controller.Config.Choices');

			// Listen to change event on field editor
			$(self.fieldParam.selector).on('change', function(el) {
				self.paramChanged($(this), params);
			});

			// Listen to keyup event on field editor
			$(self.fieldParam.selector).on('keyup', function(ev, el) {
				self.paramChanged($(this), params);
			});
		});
	},

	"{dialogFieldCancel} click": function(el, event) {
		event.preventDefault();
		event.stopPropagation();

		self.fieldSettings().html('');
	},

	storeFields: function(fieldId, stepId, field) {
		self.storeFieldsData(fieldId, field);
	},

	storeSteps: function(stepId, data) {
		self.storeStepsData(stepId, data);
	},

	deleteFields: function(fieldId, stepId) {

		if (opts.fieldsValue[fieldId]) {
			self.storeFieldsData(fieldId);
		}
	},

	deleteStep: function(stepId) {

		// Get the step
		var step = $(self.step.selector + '[data-id=' + stepId + ']');

		// Get nearest step before we delete it
		if (step.prev().length > 0) {
			var nearestStep = step.prev();
		} else {
			var nearestStep = step.next();
		}

		var content = self.getStepContent(stepId);

		// Update field browser for each deleted fields within the step
		$.each(content.find(self.field.selector), function(i, el) {
			self.updateFieldBrowser($(el).data('appid'), 'remove');
		});

		// Determine if the steps was previously stored in the database
		if (self.deletedSteps === undefined) {
			self.deletedSteps = [];
		}

		// Determine if this field was stored in database previously
		if (step.data('isnew') === false) {
			self.deletedSteps.push(stepId);
		}

		// Remove the content and steps
		content.remove();
		step.remove();

		// Hide delete steps icon if there only one step left in the workflow
		if (self.steps().children(self.step.selector).length < 2) {
			self.deleteStepButton().addClass(opts.hiddenClass);
		}

		// Delete all fields within the step
		delete opts.stepsValue[stepId];

		// Switch to nearest step
		nearestStep.trigger('click');

		self.isChanged();
	},

	storeFieldsData: function(fieldId, field) {
		opts.fieldsValue[fieldId] = field;
	},

	storeStepsData: function(stepId, data) {
		opts.stepsValue[stepId] = data;
	},

	getCurrentStep: function() {
		return self.content().not('.' + opts.hiddenClass);
	},

	getStepTab: function(stepId) {
		return $(self.step.selector + '[data-id="' + stepId + '"]');
	},

	getStepContent: function(stepId) {
		return $('[data-content][data-id=' + stepId + ']');
	},

	injectSaveData: function(data) {

		// Empty the saved data first
		self.saveFieldsInput().val('');

		if (data) {
			data = JSON.stringify(data);
			self.saveFieldsInput().val(data);
		}
	},

	updateFieldTitle: function(fieldId, title) {
		if (!title) {
			return;
		}

		var field = self.getField(fieldId);
		field.find('[data-field-item-title]').html(title);
	},

	updateFieldRequired: function(fieldId, required) {
		var field = self.getField(fieldId);
		var fieldRequired = field.find(self.fieldRequiredSymbol.selector);

		field.attr('data-required', required);

		if (required == "1") {
			fieldRequired.removeClass(opts.hiddenClass);
		} else {
			fieldRequired.addClass(opts.hiddenClass);
		}
	},

	updateConditionsUI: function(fieldId, hasCondition) {
		var field = $(self.field.selector + '[data-id="' + fieldId + '"]');

		// Reset the condition ui
		if (!hasCondition || hasCondition == undefined) {
			field.find('[data-field-item-conditional]').addClass(opts.hiddenClass);
			field.removeClass('has-condition');
			return;
		}

		field.find('[data-field-item-conditional]').removeClass(opts.hiddenClass);
		field.addClass('has-condition');
	},

	updateStepHeader: function(stepId, title, description) {
		if (!title && !description) {
			return;
		}

		// Step bar
		var stepBar = $(self.step.selector + '[data-id="' + stepId + '"]');

		// Step header in content
		var stepHeader = $(self.content.selector + '[data-id="' + stepId + '"]');

		if (title) {
			stepBar.find('[data-step-title]').html(title);
			stepHeader.find('[data-step-title]').html(title);
		}

		if (description) {
			stepHeader.find('[data-step-description]').html(description);
		}
	},

	"{dialogStepSave} click": function(el, event) {
		var parent = el.parents('[data-field-dialog]');
		var stepId = parent.data('id');

		var data = [];
		var newTitle = false;
		var newDesc = false;

		if (self.fieldsData) {
			$.each(self.fieldsData, function(key, stepData) {
				var obj = {
					"name": stepData.name,
					"value": stepData.value
				}

				if (stepData.name == 'title') {
					newTitle = stepData.value;
				}

				if (stepData.name == 'description') {
					newDesc = stepData.value;
				}

				data.push(obj);
			});
		}

		var step = {
			stepId : stepId,
			html : parent.wrap('<p/>').parent().html()
		}

		var tmp = self.stepsHtml;
		self.stepsHtml = [];

		// Temporarily store the html of the field configs
		if (tmp) {
			$.each(tmp, function(key, data) {
				if (data.stepId != stepId) {
					self.stepsHtml.push({
						stepId: data.stepId,
						html: data.html
					});
				}
			});
		}

		// Temporarily store the new data
		self.storeSteps(stepId, data);
		self.stepsHtml.push(step);

		self.updateStepHeader(stepId, newTitle, newDesc);

		self.closeDialog()

		self.isChanged();
	},

	"{dialogFieldSave} click": function(el, event) {
		var parent = el.parents('[data-field-dialog]');
		var fieldId = parent.data('id');
		var appId = parent.data('appid');
		var stepId = self.getCurrentStep().data('id');

		var isConditional = parent.find('[data-field-is-conditional]').is(':checked');

		var tmpData = [];
		var data = [];
		var newTitle = false;

		var newDataName = [];

		// Get required data
		var required = self.getField(fieldId).data('required');

		// Check for changed config
		if (self.fieldsData) {
			$.each(self.fieldsData, function(key, fieldData) {

				var obj = {
					"name": fieldData.name,
					"value": fieldData.value
				}

				if (fieldData.name == 'title') {

					// Only set the value if the title is not empty
					if (fieldData.value) {
						newTitle = fieldData.value;
					} else {
						obj = false;
					}
				}

				// Retrieve new required data
				if (fieldData.name == 'required') {
					required = fieldData.value;
				}

				if (obj) {
					data.push(obj);
					newDataName[fieldData.name] = true;
				}
			});
		}

		var field = {
			fieldId : fieldId,
			html : parent.wrap('<p/>').parent().html()
		}

		// Choices configuration
		if (self.fieldsChoices) {
			var choices = [];

			$.each(self.fieldsChoices, function(key, value) {
				var obj = {
					value: value.value
				}

				choices.push({items: obj});
			});

			data.push({choices : choices});
			newDataName['choices'] = true;
		}

		// Emptied the conditional data directly
		if (!isConditional) {
			self.fieldsConditions = [];

			// Push empty data
			data.push({conditions: false});
		}

		// conditions params
		if (self.fieldsConditions) {
			var conditions = [];

			$.each(self.fieldsConditions, function(key, value) {
				var obj = {
					value: value.value
				}

				data.push({conditions: obj});
				newDataName['conditions'] = true;
			});
		}

		if (opts.fieldsValue[fieldId]) {
			$.each(opts.fieldsValue[fieldId], function(key, value) {
				if (value.name !== undefined && !newDataName[value.name]) {
					data.push({
						name: value.name,
						value: value.value
					})
				}

				if (value.choices && !newDataName['choices']) {
					data.push({
						choices: value.choices
					})
				}

				if (value.conditions && !newDataName['conditions']) {
					data.push({
						conditions: value.conditions
					})
				}
			})
		}

		// Temporarily store the new data
		self.storeFields(fieldId, stepId, data);

		self.updateFieldTitle(fieldId, newTitle);

		self.updateFieldRequired(fieldId, required);

		self.updateConditionsUI(fieldId, isConditional);

		self.closeDialog();

		self.isChanged();
	},

	"{dialogFieldTab} click": function(el, event) {
		var tabId = el.data('id');

		self.dialogFieldTab().removeClass('active');
		el.addClass('active');

		self.dialogFieldContent().addClass(opts.hiddenClass);
		self.dialogFieldContent().filter('[data-id="' + tabId + '"]').removeClass(opts.hiddenClass);
	},

	"{deleteStepButton} click": function(el, event) {

		var content = el.parents(self.content.selector);
		var stepId = content.data('id');

		// Directly delete the step if its empty
		if (self.isStepEmpty(stepId)) {
			self.deleteStep(stepId);
			return true;
		}

		// Display warning dialog
		var warningDialog = self.getTemplate('dialog-delete-step');

		self.fieldSettings().html(warningDialog.wrap('<p/>').parent().html());
		warningDialog.unwrap();
		var confirmDelete = self.fieldSettings().find('[data-dialog-confirm]');

		confirmDelete.on('click', function(event) {
			self.deleteStep(stepId);
			self.closeDialog();
		});
	},

	"{editField} click": function(el, event) {
		var field = el.parents(self.field.selector);
		var appId = field.data('appid');
		var fieldId = field.data('id');

		var previousData = opts.fieldsValue[fieldId];

		// Get available fields for conditional fields
		var availableFields = self.getAvailableFields();

		var appParams = [];

		// Re-initialize the tmp storage
		self.fieldsData = [];
		self.fieldsConditions = [];
		self.fieldsChoices = [];

		self.fieldSettings().html(self.getTemplate('dialog-loader'));

		EasySocial.ajax('admin/views/fields/loadFieldConfiguration', {
			"appId" : appId,
			"fieldId" : fieldId,
			"previousData" : previousData,
			"availableFields" : availableFields
		}).done(function(content, values, params) {

			$.each(params, function(i, property) {
				$.each(property.fields, function(name, field) {

					if (field.subfields) {
						$.each(field.subfields, function(subname, subfield) {
							appParams[name + '_' + subname] = subfield;
						});
					} else {
						appParams[name] = field;
					}
				});
			});

			self.fieldSettings().html(content);

			// Apply multi choices
			self.fieldSettings().find('[data-fields-config-param-choices]').addController('EasySocial.Controller.Config.Choices');

			// Listen to change event on field editor
			$(self.fieldParam.selector).on('change', function(el) {
				self.paramChanged($(this), appParams);
			});

			// Listen to keyup event on field editor
			$(self.fieldParam.selector).on('keyup', function(ev, el) {
				self.paramChanged($(this), appParams);
			});

			// Conditional checkbox
			self.fieldSettings().find('[data-field-is-conditional]').on('change', function(ev, el) {
				self.toggleConditional($(this));
			});

			// Listen to change event in conditional params
			$(self.conditionalParam.selector).on('keyup', function(ev, el) {
				self.conditionalChanged($(this), appParams);
			});

			// Listen to change event in conditional params
			$(self.conditionalParam.selector).on('change', function(ev, el) {
				self.conditionalChanged($(this), appParams);
			});

			// Trigger onChange once to sync the data
			$(self.fieldParam.selector).trigger('change');
		});
	},

	toggleConditional: function(element) {
		var checked = element.is(':checked');
		var conditionalTab = self.fieldSettings().find('[data-field-tab][data-id="conditional-rule"]');
		var conditionalPage = self.fieldSettings().find('[data-field-content][data-id="conditional-rule"]');

		if (checked) {
			conditionalTab.removeClass(opts.hiddenClass);
		} else {
			conditionalTab.addClass(opts.hiddenClass);
			conditionalPage.addClass(opts.hiddenClass);

			// Switch to first tab
			self.fieldSettings().find('[data-field-tab]').first().trigger('click');
		}
	},

	conditionalChanged: function(element) {
		var name = element.data('name');
		var parent = element.parents('[data-field-dialog]');
		var value = self.getConditionsValue(name, parent);

		var obj = {
			"name": name,
			"value": value
		}

		var tmpData = self.fieldsConditions;

		self.fieldsConditions = [];

		// Check for existing data and re-assign it back
		if (tmpData) {
			$.each(tmpData, function(key, value) {

				// Old data exists, skip this since we will overwrite it later
				if (value.name == name) {
					return true;
				} else {
					self.fieldsConditions.push({
						"name": value.name,
						"value": value.value
					});
				}
			});
		}

		// Push new data
		self.fieldsConditions.push(obj);
	},

	paramChanged: function(element, appParams) {
		var name = element.data('name');
		var parent = element.parents('[data-field-dialog]');
		var value = self.getConfigValue(name, appParams, parent);
		var field = appParams[name];

		// Manually convert boolean field into boolean value for toggle to work properly
		if (field.type === 'boolean') {
			value = element.is(':checked') ? "1" : "0";
		}

		if (field.type == 'choices') {
			return self.onChoicesChanged(element, appParams);
		}

		var obj = {
			"name": name,
			"value": value
		}

		var tmpData = self.fieldsData;

		self.fieldsData = [];

		// Check for existing data and re-assign it back
		if (tmpData) {
			$.each(tmpData, function(key, value) {

				// Old data exists, skip this since we will overwrite it later
				if (value.name == name) {
					return true;
				} else {
					self.fieldsData.push({
						"name": value.name,
						"value": value.value
					});
				}
			});
		}

		// Push new data
		self.fieldsData.push(obj);
	},

	getConditionsValue: function(name, parent) {
		var element = parent.find(self.conditionalParam.selector).filterBy('name', name);

		if (element.length === 0) {
			return undefined;
		}

		values = [];

		$.each(element.find('li'), function(i, choice) {
			choice = $(choice);
			var field = choice.find('[data-fields-condition-param-choice-field]'),
				operator = choice.find('[data-fields-condition-param-choice-operator]'),
				value = choice.find('[data-fields-condition-param-choice-value]');

			values.push({
				'id': choice.data('id'),
				'field': field.val(),
				'operator': operator.val(),
				'value': value.val()
			});

			field.attr('value', field.val());
			operator.attr('value', operator.val());
			value.attr('value', value.val());
		});

		return values;
	},

	getConfigValue: function(name, appParams, parent) {
		var field = appParams[name];
		var element = parent.find(self.fieldParam.selector).filterBy('name', name);

		if (element.length === 0) {
			return undefined;
		}

		var values = '';

		// console.log(appParams);

		switch (field.type) {
			
			case 'choices':
				values = [];

				$.each(element.find('li'), function(i, choice) {
					choice = $(choice);

					var titleField = choice.find('[data-fields-config-param-choice-title]'),
						valueField = choice.find('[data-fields-config-param-choice-value]'),
						defaultField = choice.find('[data-fields-config-param-choice-default]');

					values.push({
						'id': choice.data('id'),
						'title': titleField.val(),
						'value': valueField.val(),
						'default': defaultField.val()
					});

					titleField.attr('value', titleField.val());
					valueField.attr('value', valueField.val());
					defaultField.attr('value', defaultField.val());
				});
			break;

			case 'boolean':
				values = element.is(':checked') ? 1 : 0;

				element.attr('value', values);
			break;

			case 'checkbox':
				values = [];
				$.each(field.option, function(k, option) {
					var checkbox = element.filter('[data-fields-config-param-option-' + option.value + ']');

					if(checkbox.length > 0 && checkbox.is(':checked')) {
						values.push(option.value);

						checkbox.attr('checked', 'checked');
					} else {
						checkbox.removeAttr('checked');
					}
				});
			break;

			case 'list':
			case 'select':
			case 'dropdown':
				values = element.length > 0 ? element.val() : field["default"] || '';

				element.find('option').prop('selected', false);

				element.find('option[value="' + values + '"]').prop('selected', true);
			break;

			case 'input':
		case 'text':
			default:
				values = element.length > 0 ? element.val() : field["default"] || '';

				element.attr('value', values);
			break;
		}

		return values;
	},

	onChoicesChanged: function(element, appParams) {
		var name = element.data('name');
		var parent = element.parents('[data-field-dialog]');
		var value = self.getConfigValue(name, appParams, parent);
		var field = appParams[name];

		var obj = {
			"name": name,
			"value": value
		}

		var tmpData = self.fieldsChoices;

		self.fieldsChoices = [];

		// Check for existing data and re-assign it back
		if (tmpData) {
			$.each(tmpData, function(key, value) {

				// Old data exists, skip this since we will overwrite it later
				if (value.name == name) {
					return true;
				} else {
					self.fieldsChoices.push({
						"name": value.name,
						"value": value.value
					});
				}
			});
		}

		// Push new data
		self.fieldsChoices.push(obj);
	},

	"{moveField} click": function(el, event) {
		var field = el.parents(self.field.selector);
		var moveDialog = self.getTemplate('dialog-move-field');

		// Get available steps in this workflow
		var steps = self.step();
		var selectionContainer = moveDialog.find('[data-move-selection]');

		if (steps.length > 1) {
			$.each(steps, function(key, step){
				var id = $(this).data('id');

				if (id) {
					var selectHtml = '<option value="' + id + '">' + $(this).find('[data-step-title]').html() + '</option>';
					selectionContainer.append(selectHtml);
				}
			});

			moveDialog.find('[data-field-available]').removeClass(opts.hiddenClass);
		} else {
			moveDialog.find('[data-field-unavailable]').removeClass(opts.hiddenClass);
		}

		self.fieldSettings().html(moveDialog.wrap('<p/>').parent().html());
		moveDialog.unwrap();
		var confirmMove = self.fieldSettings().find('[data-dialog-move]');

		confirmMove.on('click', function() {
			var container = $(this).parents('[data-dialog-move-field]');
			var stepId = container.find('[data-move-selection]').val()

			// Get steps
			var newStep = self.getStepContent(stepId);

			// Clone the field
			var fieldClone = field.clone();

			// Remove the existing field from current step
			self.removeField(field.data('id'), true);

			self.currentNewField = '[data-field-new][data-action="before"]';

			// Re-add the field to the new step
			self.addField(false, fieldClone, newStep);

			// Switch to step page
			self.getStepTab(stepId).trigger('click');

			self.closeDialog();
		});
	},

	"{deleteField} click": function(el, event) {
		var field = el.parents(self.field.selector);
		var fieldId = field.data('id');

		self.removeField(fieldId);
	},

	removeField: function(fieldId, preserveData) {
		var field = self.getField(fieldId);
		var parent = field.parent();
		var wrapper = parent.parent();

		// Remove the field
		field.remove();

		// Determine if the steps already empty
		// Length set to 2 because there are 2 "add" button left in the wrapper
		if (parent.children().length < 3) {

			// Steps is empty
			wrapper.addClass('is-empty');
			parent.html('');
		} else {

			// There are still some fields left. Let's re-calculate the ordering
			self.updateOrdering(parent.children());
		}

		if (!preserveData || preserveData == undefined) {
			if (self.deletedFields === undefined) {
				self.deletedFields = [];
			}

			// Determine if this field was stored in database previously
			if (field.data('isnew') === false) {
				self.deletedFields.push(fieldId);
			}

			// Delete field from cache if there any
			self.deleteFields(fieldId, self.getCurrentStep().data('id'));

			// Update field browser
			self.updateFieldBrowser(field.data('appid'), 'remove');
		}
	}
}});

module.resolve();
});
});	});
